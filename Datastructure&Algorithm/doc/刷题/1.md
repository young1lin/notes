# 剑指 Offer

## 面试方式

- 电话面试
- 共享桌面面试（大厂经常搞这种，因为可能要你手画一些原理，以及树等）
- 当场面试

# LeetCode 刷题姿势

原文

https://www.youtube.com/watch?v=NdWYxz3izH4

## 刷多少

- 每个类型 10-20
- 总共 200-300 题目

## 如何刷

- 同类型的题目一起刷。
- 第一遍：5 分钟想不出来看答案。
- 第二遍：尝试不看答案完整实现（一道题不要超过 60 分钟）。
- 第三遍：尝试快速实现，如果 15-20 分钟内实现不了，就看答案。

看代码很重要，看至少 3-5 种不同的实现，分析别人的代码，优缺点，为什么速度快/慢。

## 刷题过程中培养的能力

- 扩宽的思路，至少能看出使用什么样的算法。
- 数据规模 -> 时间复杂度推算
- 代码风格。（这个我不说 Spring 源码级别的代码，至少比 MyBatis 源码强）

# TopK 问题、中位数问题

已解决

# 剑指 Offer

## 有序二维数组查找一个数

```java
package me.young1lin.offer;


/**
 * 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每
 * 一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个
 * 二维数组和一个整数，判断数组中是否含有该整数
 * 下面这样
 * -------------------
 * | 1   2   8   9   |
 * | 2   4   9   12  |
 * | 4   7   10  13  |
 * | 6   8   11  15  |
 * |-----------------|
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/1/27 下午11:04
 * @version 1.0
 */
public class TwoDimensionalArray {

   private static final int[][] TWO_DIMENSIONAL_ARRAY = new int[][] {
         {1, 2, 8, 9},
         {2, 4, 9, 12},
         {4, 7, 10, 13},
         {6, 8, 11, 15},
   };


   public static void main(String[] args) {
      int k = 7;
      System.out.println(findExists(k));
   }

   static boolean findExists(int k) {
      // 从右上角开始寻找
      int row = 0;
      int col = TWO_DIMENSIONAL_ARRAY[0].length - 1;
      while (row < TWO_DIMENSIONAL_ARRAY.length && col >= 0) {
         if (TWO_DIMENSIONAL_ARRAY[row][col] == k) {
            return true;
         }
         //当前位置下移，因为下面的元素更大
         else if (TWO_DIMENSIONAL_ARRAY[row][col] < k) {
            row++;
         }
         // 当前位置左移，因为左边的元素更小
         else {
            col--;
         }
      }
      return false;
   }

}
```

## 替换空格

```java
/**
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/1/27 下午11:25
 * @version 1.0
 */
public class ReplaceBlank {

   private static String str = "We are Happy";

   public static void main(String[] args) {
      System.out.println(str.replaceAll("\\s", "%20"));
   }

}
```

 

# 王争的算法

# 找字符串

```java
package me.young1lin.algorithm.search.str;

/**
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/1/27 下午4:27
 * @version 1.0
 */
public class Trie {

   private static final TrieNode ROOT = new TrieNode('/');

   static class TrieNode {

      char data;

      TrieNode[] children = new TrieNode[26];

      boolean isEndingChar = false;

      TrieNode(char data) {
         this.data = data;
      }

   }

   /**
    * only support a-z ASCII.
    * @param text the text of String
    */
   static void insert(char[] text) {
      TrieNode p = ROOT;
      for (char c : text) {
         int index = c - 'a';
         if (p.children[index] == null) {
            TrieNode newNode = new TrieNode(c);
            p.children[index] = newNode;
         }
         p = p.children[index];
      }
      p.isEndingChar = true;
   }

   /**
    *     在Trie树中查找一个字符串
    */
   public static boolean find(char[] pattern) {
      TrieNode p = ROOT;
      for (char c : pattern) {
         int index = c - 'a';
         if (p.children[index] == null) {
            // 不存在pattern
            return false;
         }
         p = p.children[index];
      }
      // 不能完全匹配，只是前缀
      // 找到pattern
      return p.isEndingChar;
   }

   public static void main(String[] args) {
      String[] strArr = {"hello", "hi", "hey", "so", "see", "how", "what"};
      for (String str : strArr) {
         insert(str.toCharArray());
      }
      System.out.println(find("hey".toCharArray()));
   }

}
```

# 剑指 Offer

## 链表

### 从尾到头打印链表

利用栈缓存，其实 Deque 也可以作为链表，然后 poll，offer

```java
/**
 * 从尾到头打印链表
 * 不允许修改链表结构
 * 用栈来实现，LinkedList 就是默认的栈
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/1/28 下午11:40
 * @version 1.0
 */
public class FuckingList {

   static class ListNode {
      int value;
      ListNode next;
   }

   private static ListNode prev = new ListNode();

   static {
      initListNode();
   }

   private static void initListNode() {
      ListNode prev = FuckingList.prev;
      for (int i = 0; i < 50; i++) {
         ListNode tmp = new ListNode();
         prev.value = i;
         prev.next = tmp;
         prev = tmp;
      }
   }

   public static void main(String[] args) {
      ListNode next = prev;
      while (next.next != null) {
         System.out.println(next.value);
         next = next.next;
      }
      System.out.println("=======");
      // 反向打印
      Deque<Integer> stack = new LinkedList<>();
      ListNode next2 = prev;
      while (next2.next != null) {
         stack.push(next2.value);
         next2 = next2.next;
      }
      while (!stack.isEmpty()){
         System.out.println(stack.poll());
      }
   }

}
```

### 二叉树

前序：根左右

中序：左根右

后序：左右根

![二叉树的样例图.png](https://i.loli.net/2021/01/29/IbTnWcdOZj145qK.png)

![二叉树的前序和中序的解析.png](https://i.loli.net/2021/01/29/oi6YKquJvUM1lWA.png)

### 重建二叉树



# 算法 导论

基本的二分法。基本的 Java 语法介绍，直接跳过了。

# 算法

基础语法介绍，基础数据结构介绍。

链表

栈 Stack LIFO 后进先出，压栈 push，弹栈 pop

队列 Queue FIFO 先进先出，enqueue，dequeue

# 自我编写

手写 LinkedList

# 剑指 Offer



# 算法 导论

基本的二分法。基本的 Java 语法介绍，直接跳过了。

```java
public class BinarySearch{
    
    /**
     * 二分搜索的关键是列出所有的可能。
     * 有可能是有序但重复的数组，例如 [1,2,3,4,6,8,8,8,8,10,11]
     * @param data 待搜索数组
     * @param k 要搜索的数字
     */
    public int search(int[] data,int k){
        int low = 0;
        int high = data.length;
    	while(low <= high){
            int mid = (low + high) >> 1;
            if(data[mid] == k ){
                return mid;
            }else if(data[mid] > k){
                high = mid - 1;
            }else if(data[mid] < k){
                low = mid + 1;
            }
        }
        return -1;
    }
    
}
```

# 剑指 Offer

# 问问题的时候

问职业相关的问题，例如电商交易平台的中台这部分是已经开发好了吗？我看上面写维护和开发，是已经有的一个成熟的项目，然后再去做吗？其实我对字节很感兴趣的，只是当初没刷题，虽然我重学过好几次算法，就是不练的话，容易忘记。字节跳动是一家很成功的国际化的公司。在很多方面都有着优秀的底蕴，所以我想问下，贵司有像阿里一样的内部学习的资料库吗？

表现出对该职业和公司的 passion。

# 实现单例

```java
public class Singleton{
	
    // 这里的 volatile 其实可以不用加了，只有低版本的才会有这个指令重排的问题
	private static volatile Singleton INSTANCE;


	private Singleton(){
		if(INSTANCE != null){
			throw new IllegalArgumentException();
		}
	}

	public static Singleton getInstance(){
		if(INSTANCE == null){
			synchronized(Singleton.class){
				if(INSTANCE == null){
					INSTANCE = new Singleton();
				}
			}
		}
		return INSTANCE;
	}

}

```

# 找到重复数字

用 Hash 表，和 LeetCode 第一题有点像。

```java
public class RepeatNum {

   private static final int[] ARR = new int[]{0,1,2,3,2,5,3};

   public static void main(String[] args) {
      Map<Integer,Integer> num = new HashMap<>(ARR.length);
      List<Integer> list = new ArrayList<>();
      for (int i : ARR) {
         if(num.get(i) == null){
            num.put(i,0);
         }else {
            list.add(i);
            num.put(i,num.get(i)+1);
         }
      }
      list.forEach(System.out::println);
   }

}
```

