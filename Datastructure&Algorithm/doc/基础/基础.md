# 树 Tree

树的遍历

前序：根左右

中序：左根右

后序：左右根  

## 完全二叉树

哈夫曼树

## 二叉搜索树 Binary Search Tree

又称有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一颗空树或者具有下列性质的二叉树：

1. **左子树**上所有节点的值均小于它的根节点的值；
2. **右子树**上所有节点的值均大于它的根节点的值;
3. Recusively，左、右子树叶分别为二叉查找树。

![二叉搜索树.png](https://i.loli.net/2021/02/15/oPqSGQ528CdlJA1.png)

### Leetcode 98 题

[验证是否为二叉树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

**Solution 1:：In-order **

中序遍历出来的数组，是个升序数组。时间复杂度为 O(n)

**Solution 2：递归**

时间复杂度为 O(n)，空间复杂度也是 O(n)

```java
package me.young1lin.offer.tree;

import java.util.Deque;
import java.util.LinkedList;

/**
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/2/15 下午4:36
 * @version 1.0
 */
public class BinaryTreeValidate {

   private static class TreeNode {

      int val;

      TreeNode left, right;


      TreeNode() {
      }

      TreeNode(int val) {
         this.val = val;
      }

      TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
      }

   }

   TreeNode generateBinaryTree() {
      TreeNode root = new TreeNode(27);
      root.left = new TreeNode(18);
      root.left.left = new TreeNode(11);
      root.left.right = new TreeNode(20);
      root.right = new TreeNode(35);
      root.right.right = new TreeNode(40);
      root.right.left = new TreeNode(33);
      return root;
   }

   TreeNode generateNonBinaryTree() {
      TreeNode root = new TreeNode(32);
      root.left = new TreeNode(26);
      root.left.left = new TreeNode(19);
      root.right = new TreeNode(47);
      root.right.right = new TreeNode(56);
      root.right.right.right = new TreeNode(27);
      return root;
   }

   public boolean isValidBSTInorder(TreeNode root) {
      Deque<TreeNode> stack = new LinkedList<TreeNode>();
      double inorder = -Double.MAX_VALUE;
      while (!stack.isEmpty() || root != null) {
         while (root != null) {
            stack.push(root);
            root = root.left;
         }
         root = stack.pop();
         // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
         if (root.val <= inorder) {
            return false;
         }
         inorder = root.val;
         root = root.right;
      }
      return true;
   }

   public boolean isValidBSTRecursion(TreeNode root) {
      return isValidBSTRecursion(root, Long.MIN_VALUE, Long.MAX_VALUE);
   }

   public boolean isValidBSTRecursion(TreeNode node, long lower, long upper) {
      if (node == null) {
         return true;
      }
      if (node.val <= lower || node.val >= upper) {
         return false;
      }
      return isValidBSTRecursion(node.left, lower, node.val) && isValidBSTRecursion(node.right, node.val, upper);
   }

   public static void main(String[] args) {
      BinaryTreeValidate validate = new BinaryTreeValidate();
      TreeNode isBinaryTreeRoot = validate.generateBinaryTree();
      TreeNode nonBinaryTreeRoot = validate.generateNonBinaryTree();
      // 中序遍历
      System.out.println(validate.isValidBSTInorder(isBinaryTreeRoot));
      System.out.println(validate.isValidBSTInorder(nonBinaryTreeRoot));
      // 递归
      System.out.println(validate.isValidBSTRecursion(isBinaryTreeRoot));
      System.out.println(validate.isValidBSTRecursion(nonBinaryTreeRoot));
   }

}
```

 Leetcode 235、236 Lowest Common Ancestor 

二叉树/二叉搜索树的最近公共祖先



## 平衡二叉搜索树

## 红黑树

## B+ 树



# 图 Graph

