# 环形缓冲区

环形缓冲区，又称环形队列，是一种定长为 N 的先进先出的数据结构。它在进程间的异步数据传输或记录日志文件时十分有用。当缓冲区为空时，消费者会在数据存入缓冲区钱等待；当缓冲区满时，生产者会等待将数据存入缓冲区。为 RingBuffer 设计一份 API 并用（回环）数组将其实现。 



```java
public class RingBuffer<Item> {
    
    public Item[] a=null;
    
    public int writePos=0;
    
    public int readPos=0;
    
    public boolean flipped=false; //用来标记缓存区域是否已经被完整写入并读取过一轮，默认没有
    
    
    public RingBuffer(int cap){
        this.a=(Item[])new Object[cap];
    }
    
    public void reset(){
        this.writePos=0;
        this.readPos=0;
        this.flipped=false;
    }
    
    public int size(){
        return a.length;
    }
    
    public int available(){  //可读取区域，已经写入但还没有读取的区域
        if(!flipped){  //如果缓冲区还没有完全写入过一轮
            return writePos-readPos;
        }
        return size()-readPos+writePos; //如果已经完整读取过一轮，size()-readPos为负，readPos已经是第二轮的位置，所以加上writePos是第二轮已写入未读取区域
    }

    public int remainingCapacity(){  //剩余还没写入的容量
        if(!flipped){  //如果没有被完整写入过一轮
            return size()-writePos;
        }
        return readPos-writePos; //已经完整读过一轮，这里readPos是第二轮的位置，相当于size()+第一轮的readPos，减去writPos相当于完全没有被写入过的区域加上第二轮已经被读过可以被覆盖写入的区域
    }
    public boolean put(Item x){
        if(!flipped){  //如果没有被完整写入过一轮
            if(writePos==size()){  //一轮缓存已经全部写满
                writePos=0;  //第一轮写满了，写入标签重置到缓冲区开头位置
                flipped=true;  //第一轮已经完全写过了
                if(writePos<readPos){  //缓冲区已经开始被读取了一部分了
                    a[writePos++]=x;  //第一轮的写入缓存已经被读过，可以覆盖写入
                    return true;
                }else{
                    return false; //缓存一轮已满还没被读过，就不写入
                }
            }else{  //缓冲区第一轮还没有写满，可以继续写入
                a[writePos++]=x;
                return true;
            }
        }else{  //已经完整写入过了一轮
            if(writePos<readPos){  //上一轮缓存已经读了一部分
                a[writePos++]=x;   //可以覆盖写入
                return true;
            }else{   //完整写入了一轮但还没有读过，那就不写入
                return false;
            }
        }
    }

    public Item take(){
        if(!flipped){  //没有完整写入过一轮
            if(readPos<writePos){
                return a[readPos++];  //在没有读取完写入部分时可以读取
            }else{
                return null;
            }
        }else{  //已经完整写入过一轮
            if(readPos==size()){  //在之前的缓存中已经读到缓冲区结尾，已经读完了一轮
                readPos=0;   //重置到初始位置开始读取新一轮写入的缓存
                flipped=false;  //对于新一轮写入的缓存来说，确实没有读取过
                if(readPos<writePos){  //没有完全读完写入的部分
                    return a[readPos++];
                }else{
                    return null;
                }
            }else{  //还没有读完之前的缓存，一轮没有读完
                return a[readPos++];  //继续读取原来一轮的缓存
            }
        }
    }

    public static void main(String[] args){
        int capacity=10;
        RingBuffer<String> ringBuffer=new RingBuffer<String>(capacity);
        /*
        * 写入
        * */
        for(int i=0;i<capacity;i++){
            String inputItem=i+"";
            boolean putSuccess=ringBuffer.put(inputItem);
            System.out.println(putSuccess?"插入"+inputItem+"成功":"插入"+inputItem+"失败");
        }
        /*
        * 下一轮写入与读取
        * */
        for(int i=0;i<capacity+1;i++){
            if(i==capacity-1){
                String takeItem=ringBuffer.take();
                System.out.println("取出"+takeItem+"成功");
            }
            if(i==capacity){
                String takeItem=ringBuffer.take();
                System.out.println("取出"+takeItem+"成功");
            }
            String inputItem=i+"";
            boolean putSuccess=ringBuffer.put(inputItem);
            System.out.println(putSuccess?"插入"+inputItem+"成功":"插入"+inputItem+"失败");  //只有在i=9和10的时候才会各读取一次，所以这里的插入大部分都会失败，因为前面写入一轮缓冲区已经满了
        }
	}
}
```

Redis 的 Replica log 就是个环形缓冲区。

https://time.geekbang.org/column/article/272852

![Redis repl_backlog_buffer的使用](https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg)

![Redis增量复制流程](https://static001.geekbang.org/resource/image/20/16/20e233bd30c3dacb0221yy0c77780b16.jpg)

因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。

# 前移编码

从标准输入读取一串字符，使用链表保存这些字符并清楚重复字符。当你读取了一个从未见过的字符时，将它插入表头。当你读取了一个重复的字符时，将它从链表中删去并再次插入表头。将你的程序命名为 MoveToFront：它实现了著名的前移编码策略，这种策略假设近访问过的元素很有可能再次访问，因此可以用于缓存、数据压缩等许多场景。

```java
package me.young1lin.offer.list;


import java.util.HashMap;
import java.util.Map;

/**
 * O(1) 的复杂度实现  get 和 put
 * 原文
 * https://leetcode-cn.com/problems/lru-cache/solution/zui-jin-mian-zi-jie-yi-mian-peng-dao-lia-1t15/
 * @author <a href="mailto:young1lin0108@gmail.com">young1lin</a>
 * @since 2021/2/5 上午6:02
 * @version 1.0
 */
public class LeastRecentlyUsed {

   private final Map<Integer, Node> map;

   private final DoubleLinkedList cache;

   private final int capacity;


   public LeastRecentlyUsed(int capacity) {
      this.map = new HashMap<>();
      this.cache = new DoubleLinkedList();
      this.capacity = capacity;
   }

   void put(int key, int val) {
      Node node = new Node(key, val);
      if (map.containsKey(key)) {
         cache.delete(map.get(key));
      }
      else {
         if (map.size() == capacity) {
            int k = cache.deleteLast();
            map.remove(k);
         }
      }
      cache.addFirst(node);
      map.put(key, node);
   }

   int get(int key) {
      if (!map.containsKey(key)) {
         return -1;
      }
      int val = map.get(key).val;
      put(key, val);
      return val;
   }

}

class DoubleLinkedList {

   Node head;

   Node tail;


   DoubleLinkedList() {
      head = new Node(0, 0);
      tail = new Node(0, 0);
      head.next = tail;
      tail.prev = head;
   }

   void addFirst(Node node) {
      node.next = head.next;
      node.prev = head;
      head.next.prev = node;
      head.next = node;
   }

   int delete(Node n) {
      int key = n.key;
      n.next.prev = n.prev;
      n.prev.next = n.next;

      return key;
   }

   int deleteLast() {
      if (head.next == tail) {
         return -1;
      }
      return delete(tail.prev);
   }

}

class Node {

   int key;

   int val;

   Node prev;

   Node next;


   Node(int key, int val) {
      this.key = key;
      this.val = val;
   }

}
```

LRU 算法 Least Recently Used



# 两个栈实现队列

https://www.cnblogs.com/wanghui9072229/archive/2011/11/22/2259391.html

dequeue 的时候，压 S1 栈，enqueue 的时候，如果 S2 栈不为空，则弹 S2 的栈，为空则“倾倒” S1 栈入 S2 栈。

一个栈往另一个栈倒。