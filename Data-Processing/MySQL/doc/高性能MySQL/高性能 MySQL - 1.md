# 连接

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，改线程只能轮流在某个 CPU 核心或者 CPU 中运行。服务器会负责缓存县城，因此不需要为每一个新建的连接创建或者销毁线程。

> MySQL 5.5 或者更新的版本提供了一个 API，支持线程池插件，可以使用池中少量的线程来服务大量的连接。

shared lock，exclusive lock 排他锁

读锁（read lock）是共享的，或者说是相互不阻塞的。写锁（write lock）是排他的，一个写锁会阻塞其他的写锁和读锁。

锁的粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性。

// 行锁

Row-level lock



隔离性分级别，持久性也是分级别的。

# SHOW PROFILE

默认是禁用的，但可以通过服务变量在会话（连接）级别动态地修改。

这个在 8.x 版本就要被移除了，已经被标记为废弃的了。

```sql
0 row(s) affected, 1 warning(s): 1287 '@@profiling' is deprecated and will be removed in a future release.
```

会先把数据 copy 到临时表。 

## SENDING DATA

这个状态代表的原因非常多，可能是不同的服务器活动，包括在关联时搜索匹配的行记录等，这部分很难说优化节省多少消耗的时间，

# SHOW STATUS

返回了一些计数器，既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器。

# Schema 与数据类型优化

数据类型

1. 更小的通常更好。
   1. 占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。
2. 简单就好
   1. 用整型存 IP
   2. 用简单类型，而非字符串存日期
3. 尽量避免 NULL
   1. 最好指定列卫 NOT NULL，除非真的需要存储 NULL 值。
   2. 查询包含可为 NULL 的列，对 MySQL 来说更难优化，使得索引、索引统计和值比较都更复杂。使用更多的存储空间，在 MySQL 里面也需要特殊处理，当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节。

TIMESTAMP 只使用 DATETIME 的一半存储空间，并且会根据时区变化，具有特殊的自动更新能力，但是 TIMESTAMP 允许的时间范围要小得多。



# 整数

- TINYINT 8
- SMALLINT 16
- MEDIUMINT 24
- INT 32
- BIGINT 64

可选 UNSIGNED 属性，使正数的上限提高一倍。

INT(11) 对大多数应用哲思没有意义的，它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。**对存储和计算来说**，INT(1) 和 INT(20) 是相同的。

# 实数

实数是带有小数部分的数字。

可以用 DECIMAL 存比 BIGINT 还大的整数。

DECIMAL(18,9)

9位.9位

最多 65 个数字

# 字符串类型

## VARCHAR 和 CHAR 类型

怎么存，存储引擎存储 CHAR 或者 VARCHAR 值的方式在内存和磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式。

VARCHAR 需要使用 1 或 2个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2个字节。

如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，不同的存储引擎处理方式是不一样的。InnoDB 需要分裂页来使行可以放进业内。

InnoDB 会把过长的 VARCHAR 存储为 BLOB。

CHAR 是定长的。CHAR 非常适合存储密码的 MD5 值，因为这是个定长的值。

会删除末尾的空格。

## BINARY 和 VARBINARY 

和上面差不多，不过填充不一样，是这个 \0 而不是空格，在检索时也不会去掉填充值。

最好的策略是只是分配真正需要的空间。

## BLOB 和 TEXT 类型

分别采用二进制和字符方式存储。

TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT

TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB

在存储时通常会做特殊处理。

BLOB 是二进制数据，没有排序规则或字符集，TEXT 有。

Using temporary 表示这个查询使用了隐式临时表。

“2008-01-16 22:37:08” 是 ANSI 标准定义的日期和时间表示方法。

TIMESTAMP 只能表示 1970 - 2038

FROM_UNIXTIME 把 Unix 时间戳转换为日期，并提供了 UNIX_TIMESTAMP 把日期转换为 Unix 时间戳。

TIMESTAMP 默认为 NOT NULL。

除了特殊行为之外，通常也应该尽量使用 TIMESTAMP。

# 位数据类型

BIT

在 MySQL 5.0 之前，BIT 是 TINYINT 的同义词。

存一个或多个 true/false 值。

谨慎使用 BIT 类型，最好避免。

SET

一个包装位的应用的例子是保存权限的访问控制列表（ACL）。每个位或者 SET 元素代表一个值，例如 CAN_READ、CAN_WRITE。

# 选择标识符(identifier)

就是 ID。

整数类型



字符串类型

UUID() MD5() SHA1() 产生的字符串，这些函数生成的新值会任意分布在很大的空间内，这回导致 INSERT 以及一些 SELECT 语句变得很慢。

- 因为插入值会随机地写到索引的不同位置，所以使得 INSERT 语句更慢，这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。
- SELECT 语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
- 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存任何一部分特定数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。

如果存 UUID，应当移除 "-" 符号，或者更好的做法是，用 UNHEX() 函数转换 UUID 值为 16 字节的数字，并存储在一个 BINARY(16) 列中。检索时可以通过 HEX() 函数来格式化十六进制格式。

UUID 不如递增的整数好用。
IP 地址用 32 位无符号整数来存，INET_ATON() 、INET_NTOA()

# MySQL schema 设计

- 不要有太多的列

  > MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。

- 不要有太多的关联

  MySQL 限制了每个关联操作最多只能有 61 张表。单个查询最好在 12 个表以内做关联。

- 慎用枚举

- 不要走极端，全部用特殊的值代替 NULL

# 索引

索引在 MySQL 中也叫做键（key），是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

## B-Tree 索引

InnoDB 用的是 B+Tree。

B+Tree 是顺序组织存储的。

可以使用 B-Tree 索引的查询类型。

- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一行并范围匹配另一行
- 只访问索引的查询

索引顺序很重要。

InnoDB 引擎有一个特殊的功能叫做 “自适应哈希索引（adaptive hash index）”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引也具有哈希索引的一些优点。这是个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

## 索引的优点

1. 大大减少了服务器需要扫描的数据量
2. 索引可以啊不过男主服务器避免排序和临时表。
3. 索引可以将随机 I/O 变为顺序 I/O。

分区表，不建议。

## 前缀索引



将 or 语句，拆成 UNION ALL 语句。

在 5.0 或更新的版本中，可以自己使用合并。

![聚簇索引的数据分布.png](https://i.loli.net/2021/07/14/3oIPfT5MyvVXxCL.png)

当表有聚簇索引时，他的数据行实际上存放在索引的叶子页（Leaf page）中。聚簇 表示数据行和相邻的键值紧凑地存在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引，覆盖索引可以模拟多个聚簇索引的情况。

叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中索引列包含的是整数值。

# 前缀索引

ASC 排不了序

