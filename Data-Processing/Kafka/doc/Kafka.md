# 什么是消息系统

消息引擎系统是一组规范，企业利用这组规范再不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。

+ 消息引擎传输的对象是消息；
+ 如何传输消息属于消息引擎设计机制的一部分。

Kafka 采用纯二进制的字节序列。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。

消息引擎系统还要设定具体的传输协议，常见的方法有两种。

+ **点对点模型**：也叫消息队列模型。1 对 1。
+ **发布/订阅模型**：它有一个主题（Topic）的概念，N 对 N 模型。

Kafka 两种都支持。

# 引入 Kafka 的用处

## 削峰填谷

所谓的“削峰填谷”就是指缓冲上下游瞬时突发流量，使其更平滑。特别是对于那种发送能力很强的上游系统，如果没有消息引擎的保护，“脆弱”的下游系统可能会直接被压垮导致全链路服务“雪崩”。但是，一旦有了消息引擎，它能够有效地对抗上游的流量冲击，真正做到将上游的“峰”填满到”谷“中，避免了流量的震荡。

## 解耦

减少了系统间不必要的交互。

# Kafka 专用术语

## Record

Kafka 处理的主要对象。

## Topic

主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。

## Producer

向主题发布消息的客户端应用程序。

## Consumer

订阅这些主题消息的客户端应用程序就被称为消费者。

## Consumer Group

指的是多个消费者实例共同组成一个组来消费一个主题。该组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。消费者组提升了消费者端的吞吐量。

## Broker

一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。

## Replication

备份机制

### Leader Replica

领导者副本，对外提供服务。

### Follower Replica

追随者副本，不对外提供服务，不能与外界进行交互。对 Leader 副本同步有延迟。

## Partition

比如 MongoDB 和 Elasticsearch 中的 Sharding、HBase 中的 Region，其实它们都是相同的原理，只是 Partitioning 是最标准的名称。

生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。

一个有序不变的消息队列，每个主题下可以有多个分区。

## 副本和分区的关系

副本是在分区这个层级定义的，每个分区下可以配置若干个副本，其中只能有一个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息有Offset 的数据来表征。分区的位移总是从 0 开始。

## Rebalance

消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，它们还能彼此协助，假如组内的某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Faild 实例之前负责的分区转移给其他或者消费者。这就是 Rebalance，这个有很多 Bug。

## Consumer Offset

每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上。

