# 一、好代码的定义

写好代码，其实也是遵循架构的原则，简单、合适、可迭代。并且和架构一样，我们总是在可读性和简单的代码中做取舍。

写好代码，合理利用设计模式以及一些强制规定，是比不可以少的。下面的内容会穿插不同的设计模式，让你写出更好的代码。

写好代码，是让你的代码具有可读性、可维护性、可变更性。下面的内容，会将这三部分内容串起来说明。

## 高内聚、低耦合

### 内聚性

下面是维基百科的解释

>  **内聚性**（**Cohesion**）也称为**内聚力**，是一[软件度量](https://zh.wikipedia.org/wiki/軟體度量)，是指机能相关的[程序](https://zh.wikipedia.org/wiki/计算机程序)组合成一[模块](https://zh.wikipedia.org/wiki/軟體模組)的程度[[1\]](https://zh.wikipedia.org/zh-cn/內聚性_(計算機科學)#cite_note-HeSi86-1)，或是各机能凝聚的状态或程度[[2\]](https://zh.wikipedia.org/zh-cn/內聚性_(計算機科學)#cite_note-2)。是[结构化分析](https://zh.wikipedia.org/wiki/結構化分析)的重要概念之一。量测内聚性的方式很多，有些方法是由分析源代码，得到非量化的结果，有些方法则是检查源代码的文本特征，以得到内聚性的量化分数。内聚性是属于[顺序](https://zh.wikipedia.org/wiki/标量类别#序数标量)式的量测量，一般会以“高内聚性”或“低内聚性”来表示。一般会希望程序的模块有高内聚性，因为高内聚性一般和许多理想的软件特性有关，包括[鲁棒性](https://zh.wikipedia.org/wiki/鲁棒性_(计算机科学))、[可靠度](https://zh.wikipedia.org/wiki/可靠度)、[可复用性](https://zh.wikipedia.org/w/index.php?title=可復用性&action=edit&redlink=1)及易懂性（understandability）等特性，而低内聚性一般也代表不易维护、不易测试、不易复用以及难以理解。

### 耦合性

下面是维基百科的解释

>  **耦合性**（Coupling，dependency，或称**耦合力**或**耦合度**）是一种[软件度量](https://zh.wikipedia.org/wiki/軟體度量)，是指一程序中，[模块](https://zh.wikipedia.org/wiki/軟體模組)及模块之间信息或参数依赖的程度。

## 如何实现高内聚、低耦合

更书面化的定义，耦合其实是模块(module）与模块之间联系，内聚是模块内联系。

**通常情况下认为，在 Java 中，一个 Jar 文件就是一个模块**。例如 Spring Boot，利用 spring.factories 以及 @Import  实现了**约定大于配置**，模块化的开发。

我认为，可以更细粒度到类、甚至是方法都可以称之为模块。具体如何解耦以及样例如下：

## 如何解耦

**计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决**。

可分为三类解耦方式

1. 中间层映射
2. 前后节植入
3. 事件流订阅

### 进程内解耦

**中间层映射**的设计理念是当 A 对 B 有依赖时，A 不要直接依赖 B，而是抽象一个中间层，让 A 依赖中间层，再由中间层映射到 B，从而当 B 变成 C 时，不用修改 A，只用调整中间层的映射关系。中间层映射，在应用层表现为面向接口动态绑定，在架构层表现为 Naming 解析动态绑定。

#### 面向接口动态绑定

**解耦第一大法则**。

**面向接口，而非实现编程**。在《UNIX 编程艺术》中是分离原则——策略同机制分离，接口同引擎分离。

![](https://static001.geekbang.org/resource/image/60/da/60b2e194c5505252bb286f2a3d5458da.png)

我的代码示例

**Clean** 接口

```java
package com.dahua.paas.dwu.server.dataclean.clean;

/**
 * 执行数据清洗接口，默认为 {@link com.dahua.paas.dwu.server.dataclean.core.BaseClean} 类型
 *
 * @author 261224
 * @version 1.0
 * @see com.dahua.paas.dwu.server.dataclean.core.BaseClean
 * @see com.dahua.paas.dwu.server.datacollect.service.CollectDataService
 * @since 2021/3/3
 */
public interface Clean {

    /**
     * 数据清洗
     */
    void clean();

}
```

BaseClean 就不贴了，代码中有

**DefaultClean**

```java
package com.dahua.paas.dwu.server.dataclean.clean;

import com.dahua.paas.dwu.api.utils.DateUtils;
import com.dahua.paas.dwu.server.dataclean.core.BaseClean;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

/**
 * 默认的数据清洗类，非 GPS 处理
 *
 * @author 261224
 * @version 1.0
 * @since 2021/3/2
 */
@Component("defaultClean")
@Scope("prototype")
public class DefaultClean<T> extends BaseClean<T> {

    @Override
    public void toTempTable() {
        //获取增量数据
        String maxTime = super.getMaxTime();
        //保证T+1的时间
        String todayTime = DateUtils.getTodayTime();
        getMapper().toTempTable(maxTime, todayTime);
    }

    @Override
    protected void cleanData(long limit0, long limit1) {

    }

    @Override
    protected void standardComparison(long limit0, long limit1) {

    }

    @Override
    protected void governData(long limit0, long limit1) {

    }

    @Override
    protected void customExtension(long limit0, long limit1) {

    }

}
```

**DefaultGpsClean**

```java
package com.dahua.paas.dwu.server.dataclean.clean;

import com.dahua.paas.dwu.api.utils.DateUtils;
import com.dahua.paas.dwu.server.dataclean.core.BaseClean;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

/**
 * 默认的带 GPS 数据清洗类
 *
 * @author 261224
 * @version 1.0
 * @since 2021/3/2
 */
@Component("defaultGpsClean")
@Scope("prototype")
public class DefaultGpsClean extends BaseClean {

    @Override
    public void toTempTable() {
        //获取增量数据
        String maxTime = super.getMaxTime();
        //保证T+1的时间
        String todayTime = DateUtils.getTodayTime();
        getMapper().toTempTable(maxTime, todayTime);
    }

    @Override
    protected void cleanData(long limit0, long limit1) {

    }

    @Override
    protected void standardComparison(long limit0, long limit1) {

    }

    @Override
    protected void governData(long limit0, long limit1) {

    }

    @Override
    protected void customExtension(long limit0, long limit1) {
        super.dealGpsInfo(limit0, limit1);
    }

}
```

**CleanDataService** 

```java
package com.dahua.paas.dwu.server.dataclean.service;

import com.alibaba.fastjson.JSONObject;
import com.dahua.paas.dwu.server.dataclean.clean.Clean;
import com.dahua.paas.dwu.server.dataclean.clean.CleanData;
import com.dahua.paas.dwu.server.dataclean.core.BaseClean;
import com.dahua.paas.dwu.server.utils.IOUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.ApplicationContext;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * DataCleanService to clean data based on {@link BaseClean}
 *
 * @author 261224
 * @since 2021/3/2
 */
@Service
public class CleanDataService implements ApplicationRunner {

    /**
     * 将各个 json 文件以 Resource 的形式注入进来
     */
    private final Resource[] cleanDataJsonResources;

    private final Resource otherResource;

    private final ApplicationContext applicationContext;

    private Map<String, Clean> cleanMap;


    @Autowired
    public CleanDataService(@Value("classpath:clean-data/clean-data-*.json") Resource[] cleanDataJsonResources
            , @Value("classpath:clean-data/other.json") Resource otherResource, ApplicationContext applicationContext) {
        this.cleanDataJsonResources = cleanDataJsonResources;
        this.otherResource = otherResource;
        this.applicationContext = applicationContext;
    }

    @Override
    public void run(ApplicationArguments args) throws Exception {
        cleanMap = new ConcurrentHashMap<>(256);
        for (Resource resource : cleanDataJsonResources) {
            String cleanDataArrStr = IOUtils.toString(resource.getInputStream());
            List<CleanData> list = JSONObject.parseArray(cleanDataArrStr, CleanData.class);
            list.forEach(e -> {
                BaseClean<?> clean = (BaseClean<?>) applicationContext.getBean(e.getCleanClassBeanName());
                clean.setCleanDataParams(e);
                cleanMap.put(e.getName(), clean);
            });
        }
        // 获取其他非继承自 BaseClean 的 Clean 类
        String otherCleanDataArr = IOUtils.toString(otherResource.getInputStream());
        List<CleanData> list = JSONObject.parseArray(otherCleanDataArr, CleanData.class);
        list.forEach(e -> {
            Clean clean = (Clean) applicationContext.getBean(e.getCleanClassBeanName());
            cleanMap.put(e.getName(), clean);
        });
    }

    /**
     * 根据 itemType 名称获取到对应的 Clean 对象
     *
     * @param itemType itemType 名称，在 clean-data/ 下的 json 文件中配置，为 name 属性
     * @return 对应 {@code #itemType} 的 Clean
     */
    public Clean get(String itemType) {
        return cleanMap.get(itemType);
    }

}
```

下面是更为实际的案例。

```java
@GetMapping
public ArrayList<Object> getList(){
    ArrayList<Object> list = aService.getList();
	return list;
}
```

当我需要按照构造器传入的 size 来截取 List，因为我客户端需要根据 pageSize 来获取指定 size 或小于该大小的数据。

```java
@GetMapping
public ArrayList<Object> getList(){
    ArrayList<Object> list = aService.getList();
    SubList subList = list.subList(0,10);
   	return new ArrayList(subList);
}
```

我只是需要个 JSON 数组，我并不需要 ArrayList 的特殊的方法，这样就是**严重耦合**的代码。

这个改成下面的，是不是更好点？

这里有个知识点，你**不需要依赖你不需要的东西**。如果你用不到 ArrayList 的特有的方法，那你就不要用 ArrayList 作为返回对象类型。这也是**封装**的核心思想，不要让别人用你不想让他用的东西。// TODO 更为完善的解释。

```java
@GetMapping
public List<Object> getList(){
    List<Object> list = aService.getList();
    return list.subList(0,10);
}
```

#### 拦截器模式(责任链模式)

职责链模式主要包含以下角色。

1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。


责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。

UML 图如下

![](http://c.biancheng.net/uploads/allimg/181116/3-1Q116135Z11C.gif)

下面是 Spring MVC 的拦截器模式架构图。

![](https://static001.geekbang.org/resource/image/fe/68/febaa9220cb9ad2f0aafd4e5c3c19868.jpg)

具体代码在 **DispatcherServlet#doDispatch** 方法中有体现。源码解析我在 《Effective Java With Spring》的文章中有提到过的。

#### Mediator 中介模式

A 直接调用 B，意味着 A 对 B 产生了强依赖。当然我们可以通过面向接口编程，把这个依赖降低，降低到只依赖接口，不依赖实现。简单说，我们只依赖对事情的处理结果，不依赖于如何实现这个处理结果。

但是这还不够，因为我们还依赖了接口，接口意味着对处理语义的刻画。现实中有些情况，连语义的描述都要发生变化，也就是接口都要发生变化，如何进一步解耦呢？如下图：

![](https://static001.geekbang.org/resource/image/e1/48/e16yyd563e9060c7544973531ab6e048.png)

A 不直接调用 B，而通过中介 Mediator，解耦两步：

- 先由 A 调用 Mediator:  A 持有 Mediator 的引用，执行 Mediator 的方法，即 mediator.publish(e)。
- 再由 Mediator 调用 B:  为了解耦 Mediator 对外界的依赖，我们用面向接口 EventHandler 来实现依赖反转。让 B 来实现 EventHandler，当然如果 B 已经存在，或更有话语权，依然应该遵循依赖反转的原则，只不过 Mediator 模式的推进方可以再实现一个 Adaptor，来帮助既有的 B 适配到 EventHandler。

其实就是发布订阅模式。ThreadPoolExecutor 会让你传一个 BlockingQueue，这就是中介 Mediator。

**这也叫观察者模式（Observe Pattern）**

Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

```java
public interface Subject {
    
  void registerObserver(Observer observer);
    
  void removeObserver(Observer observer);
    
  void notifyObservers(Message message);
    
}

public interface Observer {
    
  void update(Message message);
    
}

public class ConcreteSubject implements Subject {
    
  private List<Observer> observers = new ArrayList<Observer>();

  @Override
  public void registerObserver(Observer observer) {
    observers.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    observers.remove(observer);
  }

  @Override
  public void notifyObservers(Message message) {
    for (Observer observer : observers) {
      observer.update(message);
    }
  }

}

public class ConcreteObserverOne implements Observer {
    
  @Override
  public void update(Message message) {
    // TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverOne is notified.");
  }
    
}

public class ConcreteObserverTwo implements Observer {
    
  @Override
  public void update(Message message) {
    // TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverTwo is notified.");
  }
    
}

public class Demo {
    
  public static void main(String[] args) {
    ConcreteSubject subject = new ConcreteSubject();
    subject.registerObserver(new ConcreteObserverOne());
    subject.registerObserver(new ConcreteObserverTwo());
    subject.notifyObservers(new Message());
  }
    
}
```

观察者模式在 JDK 1.1 中已经引入，具体的是 java.util.EventObject、以及 EventListener，前者是抽象类，后者是标记接口，这是约定俗成的内容。你可以不实现/继承这两个类，但是你要了解。我在项目里面也写了 Spring Boot 的 Listener，以及 事件多播 的介绍。

// TODO 贴出代码

**设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦**。

接下来进行 Spring Boot 的 SpringApplicationRunListener 源码讲解。Spring 中的 @EventListener、EventPublisher 事件实现原理，以及领域驱动设计中的领域事件详解。还有 Java 中，1.1 就提供的默认 EventObject 抽象类，以及 EventListener 接口讲解。

### 进程间解耦

1. Naming 解析动态绑定
2. Proxy 代理模式
3. Broker 消息模式（事件驱动架构）

更多进程间的内容，请看[这里](https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj?from=message)

### 架构方式解耦

#### 分层架构

分层体系结构指的是将**系统的组件分隔到不同的层中，**每一层中的组件应保持内聚性，并且应大致在同一抽象级别； 每一层都应与它下面的各层保持松散耦合。

也就是上层只和下层或者下下层等进行通信，下层不能和上层进行通信。思维源自操作系统，如下图所示。

![操作系统总览.png](https://i.loli.net/2021/01/31/foBZRxFGUY8Nmb2.png)

上图是一个典型的分层架构案例，**上层为用户程序，中间为命令行、指令等，再下面为内核程序，最底层为硬件**。就是因**为有了中间层屏蔽了底层的细节**，所以调用起来更加便捷、清晰。你不会希望写个 APP 然后要写汇编指令 movp movb call 吧？

还有 Spring 中的 HierarchicalBeanFactory 就是典型的分层架构，易扩展，因为设置对应的 ParentFactory 即可 “替换” 掉原来的 BeanFactory 的内容。

在 Web 开发的分层架构，一般为 **表现层**、**业务逻辑层**、**数据持久层**。如下图所示 

![](https://i.loli.net/2020/12/27/NJvGA7x42BjwEaC.png)

在后端代码实际开发中更多情况是贫血模式开发，如下图所示。

![](https://static001.geekbang.org/infoq/84/840700b7e5b88e2103f78e0b2cdd2caa.png)

**什么是贫血领域对象（Anemic Domain Object）**

描述的是一个缺少内在行为的领域对象。即只有 set/get 的 Entity。贫血的领域对象反映了一种自然的过程式的编程风格。

**什么是贫血模型？**

实际代码所有的 Repository，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

**什么是充血模型？**

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

#### DDD （解放繁重的 Service 类）

什么是 DDD （Domain Driven Design）？

领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。

DDD 中包含了，领域、子域、核心域、支撑域、通用域、限界上下文(bounded context)、聚合(aggregate)、聚合根、实体、值对象、领域事件这些概念等。其中对应的名词可以自行搜索了解是何种意思。

**注：只有项目足够大，足够复杂时，才需要 DDD，简单的项目采用贫血模式开发足矣**。杀鸡焉用牛刀？如果项目很复杂，也是可以遵循 DDD 的思想，来重构项目，即使是单体项目。

# 二、那些前人总结的原则

## SOLID 原则

### SRP （Single Responsibility Principle）

>  A class or module should have a single responsibility。

一个类或者模块只负责完成一个职责（或者功能）。

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。

类和方法是否足够符合 SRP，是比较主观的判断，正确的做法应该如下。

我们可以先写一个粗粒度的类（原型代码），满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的**持续重构**。TDD 中，也是包含了持续重构的，只不过是先以错误的测试开始，编写你的代码，再让这个测试变得正确，最后持续重构。在《高效能人士的的七个习惯》中，最后一个习惯是**不断更新，平衡的自我提升原则**，写代码就是个逐步重构，逐步更新的过程。

下面是判断类是否职责单一的一些参考方法。

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
- 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
- 类中大量的方法都是集中操作类中的某几个属性，如果一半的方法都是在操作同一信息，那就可以考虑将这几个属性和对应的方法拆分出来。

### OCP（ Open Closed Principle）

> software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。

软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。

具体代码，参考 DataCleanController#getData 方法。

为了尽量写出扩展性好的代码，我们要时刻具备**扩展意识**、**抽象意识**、**封装意识**。这些“潜意识”可能比任何开发技巧都重要。

最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等。

### LSP（Liskov Substitution Principle）

> Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。

子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

以下是违反里氏替换方式：

- 子类违背父类声明要实现的功能
- 子类违背父类对输入、输出、异常的约定
- 子类违背父类注释中所罗列的任何特殊说明 

多态面向对象编程的一大特性，它是一种代码实现思路。而里氏替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

CleanData 中基本符合里氏替换原则，是实现了父类所定义的原则。

### ISP（Interface Segregation Principle）

> Clients should not be forced to depend upon interfaces that they do not use。

客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

详情请见 **RecordInfoHandler**

如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。

更多详细的内容，见 **AbstractApplicationContext**

### DIP（Dependency Inversion Principle）

>  High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。注意这个层，在英文中有 layer 和 tire，layer 表示进程内的，tire 表示进程间的，详情看并发编程实战网翻译的 N 层架构，以及 Flink 的各个 layer 的图。

**IoC（Inversion of Control）**

控制反转

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

**一般来说，在 Spring 里面，Spring 容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IoC、DI）**。

**DI（Dependency Injection）**

不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。很多设计模式都会这么做，通过构造器注入，无需关心其具体实现。

// TODO 我写个代理模式的标准实现，把我自己实现的简单 Spring 代码贴出来。可以用 Java SPI 机制。

**DIP 和”基于接口而非实现编程“的区别**

“基于接口而非实现编程”与“依赖注入”的联系是二者都是从外部传入依赖对象而不是在内部去 new 一个出来。
区别是“基于接口而非实现编程”强调的是“接口”，强调依赖的对象是接口，而不是具体的实现类；而“依赖注入”不强调这个，类或接口都可以，只要是从外部传入不是在内部 new 出来都可以称为依赖注入。

// TODO 讲解一个具体的设计模式，利用构造器注入，来实现。

### KISS、YANGI、DRY

**KISS**

有三种解释，不只是编程有这个，就连很多人的理财启蒙书籍《富爸爸，穷爸爸》里面也会提到的。

>  Keep It Simple and Stupid.

>  Keep It Short and Simple.

>  Keep It Simple and Straightforward.

翻译：保持简单。

样例 SpringApplication#run 中的 createApplication，以及 ContextLoaderListener#createApplication

**本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则**。

写出满足 KISS 原则代码的几点建议

- 不要使用同事可能不懂的技术来实现代码。比如过度使用正则表达式，还有一些编程语言中过于高级的语法（Java8 的 Lambda 不属于这个范畴）等。
- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 Bug 的概率会更高，维护的成本也比较高。不要过度优化。
- 不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

**YANGI**

> You Ain’t Gonna Need It.

你不会需要它的。

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。

用不到的东西，就不要提前使用。

**DRY**

>  Don’t Repeat Yourself

不要重复你自己

下面是重复的分类：

1. 实现逻辑重复
2. 功能语义重复
3. 代码执行重复

其实 IDE 基本会提示你，是否违背了 DRY 原则，因为很大概率，你写了重复的代码。

具体的代码见 CleanDataFactory，遵循配置大于编码、SOLID 原则、简单工厂模式优化和重构代码。

## 再谈高内聚

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。单一职责原则是实现代码高内聚非常有效的设计原则。

## 再谈松耦合

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。上面所说的依赖注入、接口隔离、基于接口而非实现编程，以及下面的迪米特法则，都是为了实现代码的松耦合。

### 迪米特法则（Law of Demeter）

> Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.

每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。

再看 **DataCleanController** 这个类。

## 更多内容

请自己看看[这个](https://time.geekbang.org/column/intro/250)

# 三、代码书写规范

## 字母大小写区分以及空格

  例如

  - RESTful
  - API
  - Elasticsearch
  - jQuery
  - MyBatis
  - Spring Boot
  - Spring Cloud
  - Spring Cloud Netflix、Spring Cloud Alibaba、Spring Cloud Azure、Spring Cloud Amazon
  - SaaS（Software as a Service）、PaaS（Platform as a Service）、FaaS（Function as a Service）、IaaS（Infrastracture as a Service）、Serverless

  这是证明你确实了解这门技术最基本的方式，以及对代码有最起码的要求。

##  代码书写建议

让别人看代码，像看报纸一样，流畅一些。来自《Clean Code》

## 类属性、方法顺序

  - public 方法早出现，顺序是 public > protected > default > private（可选，最好是同一访问权限的类变量和方法就近原则）。

  - 应用范围比较广的类属性，在注释中标明在哪使用。

  - static 变量和 static 代码块早出现于普通变量。

  - 代码块/方法和变量之间隔两行书写，方法和方法，属性和属性隔一行。

  - 不太复杂的类属性，单行注释即可。

  - 可能并且允许为空的对象，用 @Nullable 标记，同理不允许为空的内容，使用 @NonNull 标记。

  - 构造方法优先于普通方法出现在变量下面。（在编译成 .class 文件，构造器就是 \<init\> 内容，建议是先出现于任何方法）

  - 无参构造方法早出现于有参构造法。

  - 非 static 修饰的变量，不应直接引用。

  - 在不确定对象是否为空的情况下，尽量兜底。

  - final 并且未被 static 修饰的变量，可以不进行检查，通过方法调用，而不是直接使用变量。

- 方法**就近原则**，方法内调用当前类其他方法时，应当在调用下面，越早调用，越早出现。

- 方法内写代码时，一段语义可以适当与另一段语义空一行。

- 方法与类之间留一行空格

  下面是具体的类的介绍。

  **AbstractApplicationContext**
  
  ```java
  public abstract class AbstractApplicationContext extends DefaultResourceLoader
  		implements ConfigurableApplicationContext {
  
      /**
   	 * public 方法早出现（可选，最好是同一访问权限的类变量和方法就近原则）。
   	 * 应用范围比较广的类属性，标明在哪使用。
   	 * Name of the MessageSource bean in the factory.
   	 * If none is supplied, message resolution is delegated to the parent.
   	 * @see MessageSource
   	 */
      public static final String MESSAGE_SOURCE_BEAN_NAME = "messageSource";
  
      // static 变量和 static 代码块早出现于普通变量。
      static {
         ContextClosedEvent.class.getName();
      }
  
      // 代码块/方法和变量之间隔两行书写，方法和方法，属性和属性隔一行。
      // 不太复杂的类属性，单行注释即可。
      /** Logger used by this class. Available to subclasses. */
      protected final Log logger = LogFactory.getLog(getClass());
  
      /** Unique id for this context, if any. */
      private String id = ObjectUtils.identityToString(this);
  
      // 可能并且允许为空的对象，用 @Nullable 标记。
      @Nullable
      private ConfigurableEnvironment environment;
  
  
      // 构造方法优先于普通方法出现在变量下面。
      public AbstractApplicationContext() {
          this.resourcePatternResolver = getResourcePatternResolver();
      }
      
      // 无参构造方法早出现于有参构造法。
      public AbstractApplicationContext(@Nullable ApplicationContext parent) {
  			this();
  			setParent(parent);
  		}
  
      /**
  		 * 非 static 修饰的变量，不应直接引用。
  		 * 在不确定对象是否为空的情况下，尽量兜底
  		 */
      @Override
      public ConfigurableEnvironment getEnvironment() {
          if (this.environment == null) {
              this.environment = createEnvironment();
          }
          return this.environment;
      }
      // final 并且未被 static 修饰的变量，可以不进行检查，通过方法调用，而不是直接使用变量。
      public Collection<ApplicationListener<?>> getApplicationListeners() {
          return this.applicationListeners;
      }
  
      // 方法就近原则，方法内调用当前类其他方法时，应当在调用下面，越早调用，越早出现。
      @Override
      public void refresh() throws BeansException, IllegalStateException {
          synchronized (this.startupShutdownMonitor) {
              // Prepare this context for refreshing.
              prepareRefresh();
              // 省略一大段代码
          }
      }
  
      protected void prepareRefresh() {
          // 方法内写代码时，一段语义可以适当与另一段语义空一行。
          // Switch to active.
          this.startupDate = System.currentTimeMillis();
          this.closed.set(false);
          this.active.set(true);
  
          if (logger.isDebugEnabled()) {
              if (logger.isTraceEnabled()) {
                  logger.trace("Refreshing " + this);
              }
              else {
                  logger.debug("Refreshing " + getDisplayName());
              }
          }
  
          // Initialize any placeholder property sources in the context environment.
          initPropertySources();
          // Validate that all properties marked as required are resolvable:
          // see ConfigurablePropertyResolver#setRequiredProperties
          getEnvironment().validateRequiredProperties();
  
          // Store pre-refresh ApplicationListeners...
          if (this.earlyApplicationListeners == null) {
              this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
          }
          else {
              // Reset local application listeners to pre-refresh state.
              this.applicationListeners.clear();
              this.applicationListeners.addAll(this.earlyApplicationListeners);
          }
  
          // Allow for the collection of early ApplicationEvents,
          // to be published once the multicaster is available...
          this.earlyApplicationEvents = new LinkedHashSet<>();
      }        // 方法与类之间留一行空格
      
  }
  ```

## 将复杂的代码块拆分成多个小的私有方法

具体见各个版本的方法。并且私有方法，尽量不要有注释。注：如果私有方法太多，可以把这些内容独立拆出来，变成一个公共的工具类。

例如 **ClassPathScanningCandidateComponentProvider#findCandidateComponents** 在 3.0 版本，这个方法又臭又长。

  ```java
  /**
   * Scan the class path for candidate components.
   * @param basePackage the package to check for annotated classes
   * @return a corresponding Set of autodetected bean definitions
   */
  public Set<BeanDefinition> findCandidateComponents(String basePackage) {
     if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
     }
     else {
        return scanCandidateComponents(basePackage);
   }
      
  }
  ```

## 注释书写

**Order of Tags**

Include tags in the following order:

- `@author` (classes and interfaces only, **required**)
- `@version` (classes and interfaces only, **required**. See [footnote 1](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#footnote1))
- `@param` (methods and constructors only)
- `@return` (methods only)
- `@exception` (@throws is a synonym added in Javadoc 1.2)
- `@see`
- `@since`
- `@serial` (or @serialField or @serialData)
- `@deprecated` (see [How and When To Deprecate APIs](https://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/deprecation/deprecation.html))

### 类注释

`@author` 你的名字（必选）

`@since` 从什么时候开始的（必选）

`@see` 与当前类相关联的类（不建议太多这个，太多关联类，破坏了类的内聚） `@{code java.io.Serializable}` 解释作用（可选）

`@verison` 建议每改一次文件，更新一下版本。如。1.1 -> 1.2（可选）

`@{link ApplicationContext}` 注释与当前类关联的类、方法、类成员变量（可选）

\<p\> 一段话一个 \<p\>

\<ul\>

\<li>

\<li>

\<li>

\</ul\>

多个 feature 用列表形式展现 （可选）

`#setTransactionSynchronization` #号后面跟上方法名或者类属性。（可选）

下面是一个示例

  **AbstractPlatformTransactionManager**

  ```java
  /**
   * Abstract base class that implements Spring's standard transaction workflow,
   * serving as basis for concrete platform transaction managers like
   * {@link org.springframework.transaction.jta.JtaTransactionManager}.
   *
   * <p>This base class provides the following workflow handling: 列出了提供以下工作流程处理
   * <ul>
   * <li>determines if there is an existing transaction;
   * <li>applies the appropriate propagation behavior;
   * <li>suspends and resumes transactions if necessary;
   * <li>checks the rollback-only flag on commit;
   * <li>applies the appropriate modification on rollback
   * (actual rollback or setting rollback-only);
   * <li>triggers registered synchronization callbacks
   * (if transaction synchronization is active).
   * </ul>
   *
   * <p>Subclasses have to implement specific template methods for specific   一段话以一个 <p> 开头，并段与段之间空一行
   * states of a transaction, e.g.: begin, suspend, resume, commit, rollback.
   * The most important of them are abstract and must be provided by a concrete
   * implementation; for the rest, defaults are provided, so overriding is optional.
   *
   * <p>Transaction synchronization is a generic mechanism for registering callbacks
   * that get invoked at transaction completion time. This is mainly used internally
   * by the data access support classes for JDBC, Hibernate, JPA, etc when running
   * within a JTA transaction: They register resources that are opened within the
   * transaction for closing at transaction completion time, allowing e.g. for reuse
   * of the same Hibernate Session within the transaction. The same mechanism can
   * also be leveraged for custom synchronization needs in an application.
   *
   * <p>The state of this class is serializable, to allow for serializing the
   * transaction strategy along with proxies that carry a transaction interceptor.
   * It is up to subclasses if they wish to make their state to be serializable too.
   * They should implement the {@code java.io.Serializable} marker interface in
   * that case, and potentially a private {@code readObject()} method (according
   * to Java serialization rules) if they need to restore any transient state.
   *
   * @author Juergen Hoeller
   * @since 28.03.2003
   * @see #setTransactionSynchronization 跟上类属性
   * @see TransactionSynchronizationManager 这个类是 Spring 事务同步管理器，也就是物理事务内含有多个逻辑事物时，由此类协调
   * @see org.springframework.transaction.jta.JtaTransactionManager 
   */
  @SuppressWarnings("serial")
  public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable {
    
  }
  ```

### 方法注释

`@author` 你的名字。Spring 中没有，但是实际开发需要知道是谁写的，以便询问意图。（必选）

`@param` 写出这个参数是干什么的，简单描述下。（必选，无参时不填）

`@return` 返回的是什么，简单描述一下（必选，void 的时候不填）

`@throws` 抛出的异常简单描述下。（可选，有异常需要声明的时候需要说明一下）

`@see` 关联的方法、类、类变量（可选）

`@since` 不像 Spring，可以写日期，也可以写版本号，从哪个版本号加的。推荐写日期。（可选）

  这些注解的排序 IDEA 会自动帮你完成，下面的作为参考

  下面是个简单的示例，目的是找出需要注入的候选类。

  **DefaultListbleBeanFactory#findAutowireCandidates**

  ```java
  /**
   * Find bean instances that match the required type.
   * Called during autowiring for the specified bean.
   * @param beanName the name of the bean that is about to be wired
   * @param requiredType the actual type of bean to look for
   * (may be an array component type or collection element type)
   * @param descriptor the descriptor of the dependency to resolve
   * @return a Map of candidate names and candidate instances that match
   * the required type (never {@code null})
   * @throws BeansException in case of errors
   * @see #autowireByType
   * @see #autowireConstructor
   */
  protected Map<String, Object> findAutowireCandidates(
        @Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {
  
  }
  ```

  [更多注释相关内容](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#examples)

  [关于字节码增强](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)

## 其他

###  // TODO

// 这是一行代码

TODO 是一种程序员认为应该做，但由于某些原因目前还没做的工作，它可能是要提醒删除某个不必要的特性，或者要求他人注意某个问题等。

**// 与字符之间有且仅有一个空格**

如果你有未完成的事情，但是又不是这个版本该做的，那你可以编写下面内容。

```java
 // TODO 在 3.2 版本在此类新增一个自动发现类注册的 Feature。
```

###  坏注释

这是 《Clean Code》 中的内容，如果见名不知意，不太理解，可以看对应的章节内容。

不要写下面这些类型的注释：

- 喃喃自语
- 多余的注释
- 误导性注释
- 循规式注释
- 日志式注释
- 废话注释
- 位置标记
- 括号后面的注释
- 注释掉的代码
- HTML 注释
- 非本地信息
- 信息过多
- 不明显的联系

### @SuppressWarning("unchecked")

泛型检查的时候，如果你确定是不需要检查的，可以去在当前方法上写明不需要检查。

### 私有方法

不建议私有方法写注释，并且私有方法应当简短，而非超过 50 行以上。

## 有意义的命名及函数

1. **类名**：使用名词，方法名：动词。（例如 consumer 是名词，consume 是动词，后者用作方法即可）

2. **使用领域名称命名**，例如 JobQueue 一目了然。

3. **函数应该短小**。（每行 120 字符，不要超过 50 行，超过 50 行应将方法按逻辑拆成多个小方法，阿里巴巴 Java 开发规范中是 80 行，我建议是 50 行，这个习惯是当初我在广州时，那里的负责人之前在日企工作，超过 50 行代码的方法，就会被打回来重写。）

4. **函数只做一件事**。单一权责。

5. **每个函数中的语句**，应该都在同一抽象级上。同一抽象级的意思，就是比如我想读取文件并替换掉 ${} 的内容，我应该做如下操作

   1. 读取文件
      1. 用 FileReader，BufferedReader 将文件一行一行读出来。
      2. 用 StringBuilder 累加。
      3. StringBuilder 转换成 String 返回。
   2. 替换内容
      1. 利用正则表达式，循环找到 \${} 内容，如果里面是 \${user.name}，你可以从对应的 Environment 找到这个值。
      2. 如果找不到，抛出异常。
      3. 如果找到了，替换模板内容。
   3. 输出/返回 已经替换过的内容。

   如果你仔细看过 Spring 的代码，都是这么做的，如果没有，可以打断点看看 **AbstractApplicationContext#refresh** 方法。更为通俗得理解，就是把大象装进冰箱需要几步，冰箱打开、把大象塞进去、关上冰箱。冰箱打开具体的实现可以用另一个方法来实现，其他的类似。

6. **函数的参数**：最理想的参数数量是零，其次是一，再次是二，尽量避免三。有足够特殊的理由才能用三个以上参数（阿里巴巴Java开发手册：相同参数类型，相同业务含义，才可以使用 Java 的可变参数，可变参数放在最后，尽量不用可变参数，避免使用 Object）

7. **标识参数**：不建议使用标识参数来判断方法该如何执行，render（Boolean isSuite）代表了该函数在标识为true会这样做，为false会那样做。应该一分为二——renderForSuite()和renderForSingleTest()

8. **参数对象**：如果函数看来需要三个或三个以上参数，就说明其中一些参数应该封装为类进行传入。

   Circle makeCircle(double x ,double y ,double radius);

   Circle makeCircle(Point center ,double radius)

   后者优于前者

9. **函数与参数**：应是一种非常良好的动词 +。名词对形式 write(name)
10. **无副作用**：在执行函数时，应不该造成其他部分的更改。模块化思维
11. **分隔指令与询问**：函数要么做什么事，要么回答什么事。
12. **使用异常代替返回错误代码**，抽离 Try/Catch 代码块。Try/Catch 代码块丑陋不堪，搞乱了代码结构，最好把其中内容单独写成一个函数。

## 格式

1. 垂直格式单个文件代码行数最多在 200 行到 500 行之间（实际开发可以比这多，这是参考，尽量精简代码在单个文件中，并且文件之间代码行数最小与最大值差距不要过大）
2. 向报纸学习（自上而下，内容逐次展开）
3. 适当的换行
4. 方法与方法之间**空一行**
5. 变量与方法之间**空两行**
6. import 与类之间**空一行**。注：这里如果是注释，那么就是和注释空一行。
7. import 系统类和导入包中的类或者自定义类之间**空一行**。IDEA 帮我们做好了
8. 变量声明应尽可能靠近其使用位置。这里说的是方法内，按需使用，按需声明。
9. 实体变量应放在类的顶部声明。参考 AbstractApplicationContext 类。
10. 相关函数应尽量放在一起，一个方法调用了该类中的另一个方法，应尽量放在一块。同上，参考那个类。
11. 概念相关的代码应该放在一起，重载的方法也算。
12. 横向距离。（一行代码不超过 120 个字符，在 IDEA -> settings -> Editor -> Code Style -> Java -> Wrapping and Braces 中设置，默认就是 120）
13. 同一层级的代码应该缩进至同一个层级。

如果你安装了 CheckStyle 插件，或者项目里面引入了 CheckStyle plugin，这个在编译时就能检查你的代码。

建议每次写完代码，按 Ctrl + Alt + L 来格式化你的代码。

## 打印日志

1. 应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式（Facade Pattern）的日志框架，有利于维护和各个类的日志处理方式统一。 

2. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。 logType:日志类型，如 stats/monitor/access 等；logName:日志描述。这种命名的好处： 通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 正例：mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。 

3. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。 说明：

   ```java
   logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 
   ```

   如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象， 会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 

   正例：（条件）建设采用如下方式

   ```java
   if (logger.isDebugEnabled()) {
       logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 
   }
   ```

    正例：（占位符）注意，这里的变量，一般情况下，都是要加上 [ ] 来表示这是个变量，你可以在随便启动一个 Spring Boot 程序，看看对应的日志，是不是基本都是如此。还有中文和英文的书写是不一样的，这里的字母是紧贴符号的，符号后面是需要空一格的。

   ```java
   logger.debug("Processing trade with id: [{}] and symbol: [{}] ", id, symbol);
   ```

4. 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 

5. 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。 正例：

   ```java
   logger.error(各类参数或者对象 toString() + "_" + e.getMessage(), e); 
   ```

6. 谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请 

   **思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？**

7. 可以使用 warn 日志级别来记录用户输入参数错误的情况。如非必要，请不要在此场景打出 error 级别，避免频繁报警。 说明：注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。

8. 尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。

## 如何抛异常

### 通用处理方式

通常情况下，异常该做如下处理。

```java
logger.error("当前层级异常是什么原因引起的写清楚，必要的话，附带上参数 {}", msg, exception);
throw new ConcurrentLevelException(exception);
```

### 优先使用 try with resource

JDK 7 新特性。来自 《Effective Java》中的建议。

### 优先使用系统定义的异常

类越精简，加载类的速度越快，优先使用专家级的定义的异常。如

IndexOfBoundsException

NullPointException

IllegalArgumentException

IllegalStateException

ConcurrentModificationException

UnsupportedOperationException

### 抛出与抽象对应的异常

更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常。

如果在 MyBatis 中，写 resultType 写成不存在的类，会先抛出 ClassNotFoundException，然后层层抛出，到 Spring 创建 Bean 的步骤中。最终由 Servlet 容器捕获，然后停止启动项目。具体内容在下面。

```java
// AbstractAutowireCapableBeanFactory
protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {
    return (new ConstructorResolver(this)).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
// org.springframework.beans.factory.support.ConstructorResolver
// ConstructorResolver.ArgumentsHolder createArgumentArray 方法里面
try {
    Object autowiredArgument = resolveAutowiredArgument(
        methodParam, beanName, autowiredBeanNames, converter, fallback);
    args.rawArguments[paramIndex] = autowiredArgument;
    args.arguments[paramIndex] = autowiredArgument;
    args.preparedArguments[paramIndex] = new AutowiredArgumentMarker();
    args.resolveNecessary = true;
}
catch (BeansException ex) {
    throw new UnsatisfiedDependencyException(
        mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);
}
```

异常链（exception chaining），如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。Spring 就是这样，在创建 Bean 的时候，就是使用的异常链。

实际 Web 开发也是不要将异常捕获，尽量将异常向上抛出，由容器/框架进行捕获/抛出。自定义含 @ExceptionHandler 的类，进行捕获异常。

### 每个方法抛出的所有异常都要建立文档

永远不要声明一个公有方法直接 “throws Exception”。无法让调用者判断该如何解决并捕获该异常。

有个例外，就是 main 方法，它可以被安全地声明抛出 Exception，因为它只通过虚拟机调用。

### 在细节消息中包含失败-捕获信息

```java
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'callEvaluationController' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/api/CallEvaluationController.class]: Unsatisfied dependency expressed through constructor parameter 0;

nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userServiceImpl': Unsatisfied dependency expressed through method 'setUserMapper' parameter 0; 

nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userMapper' defined in file [/IdeaProjects/evaluation/target/classes/cn/luckyray/evaluation/dao/main/UserMapper.class]: Cannot resolve reference to bean 'mainSqlSessionTemplate' while setting bean property 'sqlSessionTemplate'; 

nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'mainSqlSessionTemplate' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Unsatisfied dependency expressed through method 'sqlSessionTemplate' parameter 0;

nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mainSqlSessionFactory' defined in class path resource [cn/luckyray/evaluation/config/DataSourceConfig.class]: Bean instantiation via factory method failed; 

nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is org.springframework.core.NestedIOException: Failed to parse mapping resource: 'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]';

nested exception is org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'file [/IdeaProjects/evaluation/target/classes/mapping/main/UserMapper.xml]'. Cause: org.apache.ibatis.builder.BuilderException: Error resolving class. Cause: org.apache.ibatis.type.TypeException: Could not resolve type alias 'java1.lang.Integer'.  Cause: java.lang.ClassNotFoundException: Cannot find class: java1.lang.Integer
 // 这其实是一行异常信息，我用换行分离出来 
// 层层嵌套，将必要的信息给暴露出来。
```

不要在细节消息中包含密码、密钥以及类似的信息。输出异常消息日志时，或者正常日志时，一定要对敏感信息（用户名密码，用户名等等信息）进行脱敏操作。

### 努力使失败保持原子性

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。使用 JDBC 操作数据库进行增/删/改时，出现失败的情况，应该进行事务回滚。分布式系统中的 GET 操作即使失败，也要保持**幂等**性。

### 不要忽略异常

空的 catch 块会使异常达不到应有的目的。

**如果**选择忽略异常，catch 块中应该包含一条注释，说明情况，并将异常变量命名成 ignored

 ```java
try{

}catch(TimeoutException | ExecutionException ignored){
    // 这是一条注释
}
 ```

在 Spring 中，试图加载各个规范的类时，可能会类不存在，例如 @Inject，那么它不会抛出异常。

// TODO 贴出 Spring 的对应注入的注解 BeanPostProcessor 的源码。

# 四、重构，改善代码的既有设计

**小步快跑，逐步重构**。

先写出原型代码，在对其进行重构。编写代码时，应该将此类或此方法需要实现的 features 一一列出，一开始不需要考虑非常多，你先把这些功能实现了，再去说实现一个高内聚，低耦合的内容。

重构不是重写，不是大规模全部推翻前人的代码，而是做修补，使得代码更易读，更符合 SOLID 原则。

## 重构 if

### 条件过多的情况

如

```java
if(recordId == null || recordId == ""){
    // 执行方法
}
```

使用工具类

```java
if(StringUtils.isEmpty(recordId)){
    // 执行方法
}
```

或者

```java
if(recordIdIsEmpty()){
    // 执行代码
}
```

当判断条件十分多的时候，建议使用后者。

再看一个案例

**Original**

```java
package me.young1lin.specification;

/**
 * 重构前的标记接口
 *
 * @author 261224
 * @version 1.0
 * @since 2021/3/10
 */
public interface Original {

    /**
     * 重构之前的代码
     *
     * @author 261224
     * @since 1.0
     */
    void beforeRefactor();

}
```

**Refactoring**

```java
package me.young1lin.specification;

/**
 * 重构后的标记接口
 *
 * @author 261224
 * @version 1.0
 * @since 2021/3/10
 */
public interface Refactoring {

    /**
     * 重构之后的代码
     *
     * @author 261224
     * @since 1.0
     */
    void afterRefactor();

}
```

**RefactoringIf**

```java
package me.young1lin.specification;

import java.util.logging.Logger;

/**
 * @author 261224
 * @version 1.0
 * @since 2021/3/10
 */
public class RefactoringIf implements Original, Refactoring {

    private final Logger logger = Logger.getLogger(getClass().getName());

    private final double quantity;

    private final Date date;


    public RefactoringIf(Date date, double quantity) {
        this.quantity = quantity;
        this.date = date;
    }

    @Override
    public void beforeRefactor() {
        double charge;
        if (!date.isBefore(Plan.summerStart) && !date.isAfter(Plan.summerEnd)) {
            charge = quantity * Plan.summerRate;
        } else {
            charge = quantity * Plan.regularRate + Plan.regularServiceCharge;
        }
        logger.fine("charge is " + charge);
    }

    @Override
    public void afterRefactor() {
        double charge;
        // 普通重构
        if (summer()) {
            charge = summerCharge();
        } else {
            charge = regularCharge();
        }
        logger.fine("charge is " + charge);
        // 精进重构
        charge = summer() ? summerCharge() : regularCharge();
    }

    private boolean summer() {
        return !date.isBefore(Plan.summerStart) && !date.isAfter(Plan.summerEnd);
    }

    private double summerCharge() {
        return quantity * Plan.summerRate;
    }

    private double regularCharge() {
        return quantity * Plan.regularRate + Plan.regularServiceCharge;
    }

}

/**
 * 仅为演示使用
 *
 * @author 261124
 * @version 1.0
 * @since 2021/3/10
 */
class Date {

    /**
     * 是否在当前日期之前，仅作演示使用
     *
     * @param date 日期
     * @return 是否在此之前的布尔值
     * @author 261224
     * @see RefactoringIf#beforeRefactor()
     * @since 1.0
     */
    boolean isBefore(Date date) {
        return true;
    }

    /**
     * 是否在当前日期之后，仅作演示使用
     *
     * @param date 日期
     * @return 是否在此之前的布尔值
     * @author 261224
     * @see RefactoringIf#beforeRefactor()
     * @since 1.0
     */
    boolean isAfter(Date date) {
        return true;
    }

}

/**
 * @author 261224
 * @version 1.0
 * @see RefactoringIf
 * @since 2021/3/10
 */
class Plan {

    static Date summerStart;

    static Date summerEnd;

    static double summerRate = 5.1;

    static double regularRate = 6.0;

    static double regularServiceCharge = 20;
    
    
    Plan() {
    }

}
```

## 重构 switch

数据集市层代码，将原来的 switch 关键字给重构了，一般是简单厂模式 + 策略模式实现，来重构。类似的案例，在很多框(kuàng)架，中间件远源码中都有。

例如 MyBatis 的解析的成 String、Integer 这些类型的时候，Spring 的 TypeConverter。具体的源码，我会打断点讲解。

更具体的案例，在我一个库里面，极客时间的家庭作业中有的。

// TODO 将【配置】作业内容复制上来。

# 五、讲一个 Entity 方面的小技巧

## 为什么 id 不是连续自增的

可以认为是 getAutoIncrement 

事务回滚并不会回滚这个，因为多个事务操作的时候，会引起不必要的锁的开销。

为什么自增主键不是连续自增的，更为详细的[内容](https://time.geekbang.org/column/article/80531)

## MyBatis 默认会调用字段的 get 方法？

MyBatis 会调用默认字段的 getXXXX 方法，在插入的时候，这个是 Entity 的规范，它默认你有对应的方法。

具体哪一行代码，我也忘了。我现场打断点，直接用代码讲解在哪，堆栈信息是什么。

debug 的 drop frame 和 debug 信息就是函数调用栈的内容，每个方法就是一个栈帧，也就是 frame，drop frame 就是丢弃当前方法，跳转到上一个方法。

方法调用栈，顾名思义就是方法的调用的栈。方法将会采用先进后出的思想（栈的思想）来实现方法层层嵌套调用。这也就解释了，为什么一个线程都只有一个方法调用栈，并且只能同步执行。看过 《深入理解 Java 虚拟机》的话，前面就会说 JVM 的一些整体的结构。

## 为什么这么写？Spring 对应的参考在哪？

**AbstractApplicationContext#getEnvironment**

```java
@Override
public ConfigurableEnvironment getEnvironment() {
   if (this.environment == null) {
      this.environment = createEnvironment();
   }
   return this.environment;
}
```

# 六、总结

这里做个小总结，以便你能快速优化你的代码。

1. 代码遵循就近原则，看看能不能像看报纸一样，看你写的代码。
2. 遇到 IDEA 黄线提示，按照它的提示来改，也可以下载 Alibaba 的插件来检查你的代码（SonarLint 也可以）。
3. 按照格式写好 Java Doc。
4. 善用 StringUtils、CollectionUtils、MapUtils、Objects 等工具类，让你的代码更可读。我们有时候需要在可读性(readable)和
5. 记住那些空一行，空两行的建议，并执行下去。
6. 代码最好不要超过 50 行，除非有足够的理由，尽量拆分多个方法，尽量见名知意。

# 参考

以下参考的内容，除了 《阿里巴巴 Java 开发规范手册》都值得好好读一读。

>[细数软件架构中的解耦](https://www.infoq.cn/article/8hlh2qEWP1Y00qumdMQj?from=message)

> [领域驱动设计在爱奇艺打赏业务的实践](https://xie.infoq.cn/article/f7a9d800552aab218c0d2c075)


>[《设计模式之美》](https://time.geekbang.org/column/article/160985)

> [责任链模式（职责链模式）详解](http://c.biancheng.net/view/1383.html)

> 《重构：改善既有代码的设计》

> 《Clean Code》

> 《Clean Architecture》

>《实现领域驱动设计》

> 《Effective Java》

> 《UNIX 编程艺术》

> 《阿里巴巴 Java 开发规范手册》