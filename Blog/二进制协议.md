基于WebSocket Binary Frame 设计。

```plaintext
0               1               2               3               4               5               6               7               8               9
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|         code (4 bytes)         | header length (4 bytes) |                               header (variable length)                             |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| L |  body type (2 bytes)  |     body length (4 bytes)     |                            body (variable length)                                |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| ... Continued body segments ...                                                                                                                 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
```
字段描述
• code (4 bytes): 4 字节，用于标识消息的类型或用途。
• header length (4 bytes): 4 字节，用于指示头部的长度。
• header (variable length): 可变长度的头部内容，根据 header length 字段确定长度。
• L (1 byte): 1 字节，标识是否是最后一个 body。0 表示不是最后一个，1 表示是最后一个。
• body type (2 bytes): 2 字节，用于指示 body 的数据格式或类别。0 表示 message，1 表示 audio。
• body length (4 bytes): 4 字节，用于指示 body 的长度。
• body (variable length): 可变长度的实际数据内容，根据 body length 字段确定长度。

# Java
## 数据转ByteBuffer 代码

```java
package com.galaxyeye.expert.websocket.response;

import com.alibaba.fastjson.JSON;
import lombok.Getter;
import lombok.Setter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.galaxyeye.expert.websocket.response.ByteBufferBuilder.BodyTypeEnum.AUDIO;
import static com.galaxyeye.expert.websocket.response.ByteBufferBuilder.BodyTypeEnum.MESSAGE;

public class ByteBufferBuilder {

    @Getter
    public enum BodyTypeEnum {

        MESSAGE((short) 0),

        AUDIO((short) 1);

        private final short bodyType;

        BodyTypeEnum(short bodyType) {
            this.bodyType = bodyType;
        }

    }

    private static final String SEQ_HEADER = "seq";

    @Setter
    private int code;

    private final Map<String, List<Object>> customHeaders = new HashMap<>();

    private final List<BodyPart> bodyParts = new ArrayList<>();

    public ByteBufferBuilder(int code) {
        this.code = code;
    }

    public ByteBufferBuilder header(String headerName, List<Object> headerValue) {
        customHeaders.put(headerName.toLowerCase(), headerValue);
        return this;
    }

    public ByteBufferBuilder seq(String seq) {
        return header(SEQ_HEADER, Collections.singletonList(seq));
    }

    public ByteBufferBuilder message(byte[] bodyContent) {
        return addBody(MESSAGE, bodyContent);
    }

    public ByteBufferBuilder audio(byte[] bodyContent) {
        return addBody(AUDIO, bodyContent);
    }

    public ByteBufferBuilder addBody(BodyTypeEnum bodyType, byte[] bodyContent) {
        bodyParts.add(new BodyPart(bodyType.getBodyType(), bodyContent));
        return this;
    }

    public ByteBuffer build() {
        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            // 写入 code 值
            outputStream.write(ByteBuffer.allocate(Integer.BYTES).putInt(code).array());

            // 构建 Header JSON map
            String headerJson = JSON.toJSONString(customHeaders);
            byte[] headerBytes = headerJson.getBytes(StandardCharsets.UTF_8);
            int headerLength = headerBytes.length;

            // 写入 header 长度
            outputStream.write(ByteBuffer.allocate(4).putInt(headerLength).array());
            // 写入 header 内容
            outputStream.write(headerBytes);

            // 写入 Body 内容
            for (int i = 0; i < bodyParts.size(); i++) {
                BodyPart bodyPart = bodyParts.get(i);
                byte isLastBody = (byte) ((i == bodyParts.size() - 1) ? 1 : 0);
                // 写入是否是最后一个 body
                outputStream.write(isLastBody);
                // 写入 body 类型
                outputStream.write(ByteBuffer.allocate(Short.BYTES).putShort(bodyPart.getBodyType()).array());
                // 写入 body 长度
                outputStream.write(ByteBuffer.allocate(Integer.BYTES).putInt(bodyPart.getBodyContent().length).array());
                // 写入 body 内容
                outputStream.write(bodyPart.getBodyContent());
            }

            byte[] packet = outputStream.toByteArray();
            return ByteBuffer.wrap(packet);
        } catch (IOException e) {
            throw new RuntimeException("Error building byte buffer", e);
        }
    }

    public static class BodyPart {

        private final short bodyType;

        private final byte[] bodyContent;

        public BodyPart(short bodyType, byte[] bodyContent) {
            this.bodyType = bodyType;
            this.bodyContent = bodyContent;
        }

        public short getBodyType() {
            return bodyType;
        }

        public byte[] getBodyContent() {
            return bodyContent;
        }
    }

}
```

## 转换代码

```java
    @SuppressWarnings("unchecked")
    public static WebSocketBinaryResponse parse(ByteBuffer byteBuffer) {
        WebSocketBinaryResponse response = new WebSocketBinaryResponse();
        try {
            // 读取 code 值（4 字节）
            int code = byteBuffer.getInt();
            response.setCode(code);

            // 读取 header 长度
            int headerLength = byteBuffer.getInt();
            byte[] headerBytes = new byte[headerLength];
            byteBuffer.get(headerBytes);
            String headerJson = new String(headerBytes, StandardCharsets.UTF_8);
            Map<String, List<?>> headerMap = JSON.parseObject(headerJson, Map.class);
            response.setHeaders(headerMap);

            // 读取 Body 内容
            List<BodyPart> bodyParts = new ArrayList<>();
            while (byteBuffer.hasRemaining()) {
                byte isLastBody = byteBuffer.get();
                short bodyType = byteBuffer.getShort();
                int bodyLength = byteBuffer.getInt();
                byte[] bodyContent = new byte[bodyLength];
                byteBuffer.get(bodyContent);
                bodyParts.add(new BodyPart(bodyType, bodyContent));
                if (isLastBody == 1) {
                    break;
                }
            }

            for (BodyPart bodyPart : bodyParts) {
                if (bodyPart.getBodyType() == MESSAGE.getBodyType()) {
                    response.setMessageBytes(bodyPart.getBodyContent());
                } else if (bodyPart.getBodyType() == AUDIO.getBodyType()) {
                    response.setAudioBytes(bodyPart.getBodyContent());
                }
            }

            return response;
        } catch (Exception e) {
            throw new RuntimeException("Error parsing byte buffer", e);
        }
    }
```

# JavaScript
## 转换代码
```javascript
class WebSocketBinaryResponse {
  constructor() {
    this.code = null;
    this.headers = {};
    this.messageBytes = null;
    this.audioBytes = null;
  }

  setCode(code) {
    this.code = code;
  }

  setHeaders(headers) {
    this.headers = headers;
  }

  setMessageBytes(messageBytes) {
    this.messageBytes = messageBytes;
  }

  setAudioBytes(audioBytes) {
    this.audioBytes = audioBytes;
  }
}

/**
 * ArrayBuffer 转成 response 对象
 */
function parseArrayBuffer(arrayBuffer) {
  const response = new WebSocketBinaryResponse();
  const dataView = new DataView(arrayBuffer);
  let offset = 0;

  try {
    // 读取 code 值（4 字节）
    const code = dataView.getInt32(offset);
    response.setCode(code);
    offset += 4;

    // 读取 header 长度
    const headerLength = dataView.getInt32(offset);
    offset += 4;

    const headerBytes = new Uint8Array(arrayBuffer, offset, headerLength);
    const headerJson = new TextDecoder("utf-8").decode(headerBytes);
    const headerMap = JSON.parse(headerJson);
    response.setHeaders(headerMap);
    offset += headerLength;

    // 读取 Body 内容
    const bodyParts = [];
    while (offset < arrayBuffer.byteLength) {
      const isLastBody = dataView.getUint8(offset);
      offset += 1;
      const bodyType = dataView.getUint16(offset);
      offset += 2;
      const bodyLength = dataView.getInt32(offset);
      offset += 4;
      const bodyContent = new Uint8Array(arrayBuffer, offset, bodyLength);
      offset += bodyLength;
      bodyParts.push({ bodyType, bodyContent });
      if (isLastBody === 1) {
        break;
      }
    }

    for (const bodyPart of bodyParts) {
      if (bodyPart.bodyType === 0) {
        response.setMessageBytes(bodyPart.bodyContent);
      } else if (bodyPart.bodyType === 1) {
        response.setAudioBytes(bodyPart.bodyContent);
      }
    }

    return response;
  } catch (e) {
    throw new Error("Error parsing ArrayBuffer: " + e.message);
  }
}

/**
 * Blob 需要转成 ArrayBuffer
 */
function blobToArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = function (event) {
      resolve(event.target.result);
    };
    reader.onerror = function (error) {
      reject(error);
    };
    reader.readAsArrayBuffer(blob);
  });
}
```