# 微服务架构中的测试策略

## 测试

测试用例是用于特定目标的一组测试输入、执行条件和预期结果，例如执行特定的程序路径火验证是否符合特定条件。——来自维基百科

自动化测试通常包括四个阶段

1. 设置环境
2. 执行测试
3. 验证结果
4. 清理环境

测试套件是一组测试类的集合，测试由测试运行器（test runner）执行。

### 使用模拟和桩进行测试

测试替身（Test double）来消除被测系统的依赖性。

![测试替身.png](https://i.loli.net/2021/05/17/9pUZHFwgid2JxR6.png)

两种类型的测试替身：桩（stub）和模拟（mock）。术语桩和模拟通常可以互相使用，尽管它们的行为略有不同。桩事一个测试替身，它代替依赖项被测系统发送调用的返回值。模拟也是测试替身，用来验证被测系统事否正确调用了依赖项。此外，模拟通常也扮演桩的角色，向被测系统发送调用的返回值。

四种不同类型的测试：

- 单元测试：测试服务的一小部分，例如类。
- 集成测试：验证服务是否可以与基础设施服务（如数据库）或其他应用程序服务进行交互。
- 组件测试：单个服务的验收测试。
- 端到端测试：整个应用程序的验收测试。

![测试金字塔.png](https://i.loli.net/2021/05/17/dFwAgNBcfWuViXl.png)

## 消费者驱动的契约测试

验证服务是否满足它的消费者的期望。

验证服务的客户端是否可以与服务通信。

Spring Cloud Contract

## 单元测试

单元测试是测试金字塔的最低级别。它们是面向技术的测试，目标是协助开发。单元测试验证单元（服务很小的一部分）是否正常工作。单元通常是一个类，因此单元测试的目标是验证这个类的行为是否符合预期。

有两种类型的单元测试

- 独立型单元测试：使用针对类的依赖性的模拟对象隔离测试类。
- 协作型单元测试：测试一个类及其依赖项。

![image.png](https://i.loli.net/2021/05/18/GqRUYNIOPQETXZF.png)

关于指对象测试等一些测试，我就不写了。

# 集成测试

跳过

# 组件测试

## 使用 Gherkin 测试

given 是先决条件

when 是发生的动作或事件

Then/and 是预期的结果

```java
 public class StepDefinition {
     
     @Given("A valid consumer")
     public void useConsumer(){
         
     }
     
     @Given("using a(.?) (.*) credit card")
     public void useCreditCard(String ignore, String creditCard){
         
     }
     
     @When("I place an order for Chicken Vindaloo at Ajanta")
     public void palceOrder(){
         
     }
     
     @Then("the order should be (.*)")
     public void theOrderShouldBe(String desiredOrderState){
         
     }
     
     @And("an (.*) event should be published")
     public void verifyEventPublished(String exceptedEventClass){
         
     }
     
 }
```

# 开发面向生产环境的微服务应用

1. 安全性
2. 服务可配置性
3. 可观测性

使用 JWT

1. 不透明令牌。例如 UUID，它们会降低性能和可用性，并增加延迟。这种令牌的接收方必须对安全服务发起同步 RPC 调用，以验证令牌并检索用户信息。
2. 透明令牌。消除对安全服务调用的方法是，使用包含有关用户信息的透明令牌。 JSON Web Token。 JWT 是在访问双方之间安全地穿日信息（例如用户身份和角色）的标准方式。JWT 的内容包含一个 JSON 对象，其中有用户的信息。例如其身份和角色，以及其他数据，如到期日期等。

没有切实可行的方法来撤销落入恶意第三方售中的某个 JWT 令牌，解决方法是发布具有较短到期时间的 JWT，这可以限制恶意方。但是，短期的 JWT 的一个缺点是应用程序必须以某种方式不断重新发布 JWT 以保持会话活动。幸运的是， OAuth2.0 安全标准旨在解决的众多问题之一。

## OAuth2.0

书上解释其实一般，但比[云冲印](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)简单

// TODO 等我看完《OAuth2 实战》再详细写一篇文章。

# 外部化配置

在运行时向服务提供配置属性值，例如数据访问凭据和网络位置。

1. **推送模型**：部署基础设施通过类似操作系统黄精变量或配置文件，将配置属性传递给服务实例。
2. **拉取模型**：服务实例从配置服务器读取它所需要的配置属性。

## 推送模型

推送模型依赖于部署环境和服务的协作。部署环境在创建服务实例时提供配置属性。

Spring Boot 多数据来源

1. 命令行参数
2. SPRING_APPLICATION_JSON
3. JVM 系统属性
4. 操作系统环境变量
5. 当前目录中的配置文件。

推送模型是一种有效且广泛使用的配置服务的机制，它的一个限制是重新配置正在运行的服务可能很难，甚至不可能。

![基于推送的外部化配置.png](https://i.loli.net/2021/05/20/pPeGn5ucfWkZEl1.png)

## 拉取模型

在拉取模型中，服务实例从配置服务器读取其配置属性。

有多种方法可以实现配置服务器，包括：

- 版本控制系统，如 Git
- SQL 和 NoSQL 数据库
- 专用配置服务器，例如 Spring Cloud config Server， Hashicorp Vault（用于存储敏感数据，如访问凭据）和 AWS Parameter Store

![基于拉取的外部化配置.png](https://i.loli.net/2021/05/20/sfjK5OlqBTzIDHb.png)

# 可观测的服务

- 健康检查 API
- 日志聚合
- 分布式跟踪
- 异常跟踪
- 应用程序指标
- 审核日志记录

使用 Spring Boot Actuaor

使用日志聚合 ELK

使用 Zipkin、SkyWalking 也行、Spring Cloud Sleuth 也行。

使用异常跟中，如 HoneyBadger，好像 SkyWalking 也行的。

使用审计日志。使用AOP或者事件溯源。

# 微服务基底

问题

- 外部化配置
- 健康检查
- 应用程序指标
- 服务发现
- 断路器
- 分布式追踪

Spring Boot Actuator 是微服务的基础，当然这个也可以自己撸一个，不难。定时任务罢了

## 服务网格（Service Mesh）

服务网格

把所有进出服务的网络流量通过一个网络层进行路由，这个网络层负责解决包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量陆游等具有共性的需求。

服务网格是网络基础设施，它调和（mediate）服务与其他服务和外部应用程序之间的通信。

Istio

Linkerd

Conduit

# 流水线式部署

![不同年代部署.png](https://i.loli.net/2021/05/20/uiyfNnLTv2jroxe.png)

## 将服务部署为虚拟机

好处

- 虚拟机镜像封装了技术栈。
- 隔离的服务实例。
- 使用成熟的云计算基础设施。

缺点

- 资源利用效率较低。
- 部署速度相对较慢
- 系统管理的额外开销。

## 将服务部署为容器

![将服务部署为容器.png](https://i.loli.net/2021/05/20/mQlRYLB3v1gu8e9.png)

每个服务实例都是一个容器。

> 将作为容器镜像打包的服务部署到生产环境中。每个服务实例都是一个容器。

创建容器时，可以指定它的 CPU 和内存资源，以及依赖于容器实现的 I/O 资源等。容器运行时强制执行这些限制，并防止容器占用其机器的资源。使用 Docker 编排框架（如 Kubernetes）时，指定容器的资源尤为重要。这是因为编排框架使用容器请求的资源来选择运行容器的底层机器，从而确保机器不会过载。

Dockerfile

```dockerfile
FROM openjdk:8u171-jre-alpine
RUN apk --no-cache add curl
CMD java ${JAVA_OPTS} -jar ftgo-restaurant-service.jar
HEALTHCHECK --start-period=30s --interval=5s CMD curl http://localhost:8080/actuator/health || exit 1
```

二选一

不上传至自己的仓库的
```shell 
docker build -t young1lin/evaluation .

docker run -d --name evaluation -p 8888:8888 young1lin/evaluation
```
上传至自己仓库的
```shell 
docker build -t young1lin/evaluation .

docker tag evaluation young1lin/evaluation:1.0.1.RELEASE

docker push young1lin/evaluation:1.0.1:RELEASE

docker run -d --name evaluation -p 8888:8888 young1lin/evaluation
# 或者
docker run -e "server.port=8080" -d --name evaluation-1 -p 8080:8080 young1lin/evaluation
```

**推荐学习，并使用 Docker Compose**。

更多关于 Docker Compose 的内容，在对应的书籍都有。

## 使用 Kubernetes 部署

Kubernetes 是一个 Docker 编排框架，是 Docker 之上的一个软件层，它将一组计算机硬件资源转变为用于运行服务的单一资源池。它努力保持每个服务所需的实例数量，并确保它们一直在线，即使无副实例或机器崩溃也是如此。容器的灵活性与 Kubernetes 的复杂性相结合是部署服务的一种强有力的方式。

## 什么是 Kubernetes

Kubernetes 是一个 Docker 编排框架。Docker 编排框架将运行 Docker 的一组计算机视为资源池。你只需要告诉 Docker 编排框架运行你的服务的 N 个实例，它就会自动把其余的事情搞定。

有三个主要功能：

- 资源管理：将一组计算机视为由 CPU、内存和存储卷构成的资源池，将计算机集群视为一台计算机。
- 调度：选择要运行容器的机器。默认情况下，调度考虑容器的资源需要和每个节点的可用资源。它还可以实现在同一节点上部署具有亲和性（affinity）的容器，或确保特定的几个容器分散部署在不同的节点之上（反亲和性，anti-affinity）
- 服务管理：实现命名和版本化服务的概念，这个概念可以直接映射到微服务架构中的具体服务。编排框架确保始终运行所需数量的正常实例。它实现请求的负载均衡。编排框架也可以执行服务的滚动升级，并允许你会滚到旧版本。

![Docker 编排框架.png](https://i.loli.net/2021/05/23/7LYV9lMqswbdotf.png)

## Kubenetes 的架构

Kubernetes 在一组机器上运行。下图显示了 Kubernetes 集群的架构。Kubernetes 集群中的计算机角色分为主节点和普通节点（也称为节点）集群通常只有很少的几个主节点（可能只有一个）和很多普通节点。主节点负责管理集群。Kubernetes 的普通节点称为 “工作节点”，它会运行一个或多个 Pod。Pod 是 Kubernetes 的部署单元，由一组容器组成。

- API 服务器：用于部署和管理服务的 REST API，例如，可被 kubectl 命令行使用。
- Etcd：存储集群数据键值的 NoSQL 数据库。
- 调度器：选择要运行的 Pod 的节点。
- 控制器管理器：运行控制器，确保集群状态与预期状态匹配。例如，一种被称为复制（replication）控制器的控制通过启动和终止实例来确保运行所需数量的服务实例。

![Kubernetes 的架构.png](https://i.loli.net/2021/05/23/rjxoUPZYId6RSzF.png)

Kubenetes 集群由管理集群的主节点和运行服务的普通节点组成。开发人员和部署流水线通过 API 服务器与 Kubernetes 交互，API 服务器与主节点上运行的其他集群管理软件一起运行。应用程序容器在节点上运行，每个节点运行一个 Kubelet （它管理应用程序容器），以及一个 Kube-proxy （它将应用程序请求路由到 Pod），可以直接使用代理，也可以通过配置 Linux 内核中内置的 iptable 路由规则间接地完成路由工作。

普通节点运行多个组件，包括以下内容：

- Kubelet ： 创建和管理节点上运行的 Pod。
- Kube-proxy：管理网络，包括跨 Pod 的负载均衡。
- Pods：应用程序服务。

## Kubernetes 的关键概念

- Pod：Pod 的 Kubernetes 的基本部署单元。它由一个或多个共享 IP 地址和存储卷的容器组成。服务实例的 pod 通常由单个容器组成，例如运行 JVM 的容器。但在某些情况下，Pod 包含一个或多个实现支持功能的边车（sidecar）容器。例如，Nginx 服务器可以有一个边车容器，定期执行 git pull 以下载最新版本的网站。Pod 的生命周期很短，因为 Pod 的容器或它运行的节点可能会崩溃。
- Deployment：Pod 的声明规范。Deployment 是一个控制器，可确保始终运行所需数量的 Pod 实例（服务实例）。它通过滚动升级和会滚来支持版本控制。每个服务都是 Kubernetes 的一个 Deployment。
- Servcie：向应用程序服务的客户端提供的一个静态/稳定的网络地址。它是基础设施提供的服务发现一种形式。每个 Service 具有一个 IP 地址和一个可解析位该 IP 地址的 DNS 名称，并跨一个或多个 Pod 对 TCP 和 UDP 流量进行负载均衡处理。IP 地址和 DNS 名称只能在 Kubernetes 内部访问。也可以配置可从集群外部访问的服务。
- ConfigMap：名称与值对的命名集合，用于定义一个或多个应用程序服务的外部化配置。Pod 容器的定义可以饮用 ConfigMap 来定义容器的环境变量。它还可以使用 ConfigMap 在容器内创建配置文件。可以使用 Secret 来存储敏感信息（如密码），它也是 ConfigMap 的一种形式。

## 在 Kubernetes 上部署 Restaurant Service

定义一个部署（Deployment）对象。最简单的方法是编写 YAML 文件。

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
  metadata:
    name: ftgo-restaurant-service
  spec:
    # Pod 副本的数量
    replicas: 2
      template:
        metadata:
          labels:
            app: ftgo-restaurant-service
        spec:
          containers:
            - name: ftgo-restaurant-service
              image: msapatterns/ftgo-restaurant-service:lastes
              imagePullPolicy: Always
              ports:
                - containerPort: 8080
                  nanme: httpport
                env:
                  - name: JAVA_OPTS
                    value: "-Dsun.net.inetaddr.ttl=30"
                  - name: SPRING_DATASOURCE_URL
                    value: jdbc:mysql://ftgo-mysql/eventuate
                  - name: SPRING_DATASOURCE_USERNAME
                    valueFrom:
                      secretKeyRef:
                        name: ftgo-db-secret
                        key: username
                  - name: SPRING_DATASOURCE_PASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: ftgo-db-secret
                        key: password
                  - name: SPRING_DATASOURCE_DRIVER_CLASS_NAME
                    value: com.mysql.jdbc.Driver
                  - name: EVENTUATELOCAL_KAFKA_BOOTSTRAP_SERVERS
                    value: ftgo-kafka:9092
                  - name: EVENTUATELOCAL_KAFKA_ZOOKEEPER_CONNECTION_STRING
                    value: ftgo-zookeeper:2181
                livenessProbe:
                  httpGet:
                    path: /actuator/health
                    port: 8080
                  initialDelySeconds: 60
                  periodSeconds: 20
                readinessProbe:
                  httpGet:
                    path: /actuator/health
                    port: 8080
                  initialDelaySeconds: 60
                  periodSeconds: 20
```

接下来是部署 Service（这里的服务发现组件），K8s 自带的。

部署 API Gateway。大同小异，同上。

# 零停机部署

- 构建新的容器镜像，变更版本
- 编辑服务部署的 YAML 文件，以便它引用新镜像。
- 使用 kubectl apply -f 命令更新部署。

K8s 将对 Pod 进行滚动升级。

```shell
kubectl rollout undo deployment ftgo-restaurant-service
```

Istio 服务网格概述

不记了。

# 微服务重构策略

逐步重构，拆分为服务。

![逐步重构单体应用.png](https://i.loli.net/2021/05/23/HQ64M8JblwTKkjq.png)



- API Gateway：将对新功能的请求路由到新服务，并将遗留请求路由到单体。

- 集成胶水代码：将服务与单体结合。它使服务能够访问单体所拥有的数据，并能够带哦用单体实现的功能。

其他部分略过。

## 实现防腐层

想象一下，你正在将一项新功能实现为一个新服务。因为不受单体代码库的限制，因此可以使用现代开发技术（比如 DDD）并开发一个全新的领域模型。此外由于 FTGO 单体的领域定义不明确且有些过时，你可能会以不同的方式对概念进行建模。因此，服务的领域模型将具有不同的类名、字段名和字段值。例如 Delayed Delivery Service 又一个 Delivery 实体，其职责范围比较窄，而 FTGO 单体有一个职责过多的 Order 实体。由于两个领域模型不同，因此必须实现 DDD 称为防腐层（Anti-Corruption Layer，ACL）的服务，以便让服务与单体进行通信。

**腐层**

一个软件层，用于在两个不同的领域模型之间进行转换，防止一个模型的概念污染另一个模型。

防腐层的目标是防止传统的单体领域模型污染服务的领域模型。它是在不同领域模型之间进行转换的一层代码。

**anti** 

```
a person who is opposed to something or someone
Examples
They went on an anti-war demonstration last weekend.
There are anti-discrimination laws nowadays to prevent that kind of thing from happening.
He wanted to abolish slavery and introduced the first anti-slavery bill to Parliament.
Our school has a very good anti-bullying strategy.
The hunt was stopped by a group of anti-hunting protesters.
还有个例子
Anti—General
反一般，拒绝平凡，也是一个国内 DJ 的名字
```



后面部分，没了。书籍有误。

书上示例代码工程

https://github.com/microservices-patterns/ftgo-application
