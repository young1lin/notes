# 第三章 微服务架构中的进程间的通信

## 微服务架构中的进程间通信概述

### 交互方式

有多种客户端和服务的交互方式。

**一对一**：每个客户端请求由一个服务实例来处理。

**一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

**同步模式**：客户端请求需要服务端实时响应，客户端等待响应式可能导致堵塞。

**异步模式**：客户端请求不会阻塞进程，服务端的响应可是非实时的。

|          |           一对一           |           一对多            |
| :------: | :------------------------: | :-------------------------: |
| 同步模式 |         请求/响应          |             无              |
| 异步模式 | 异步请求/响应<br/>单向通知 | 发布/订阅<br/>发布/异步响应 |

### 定义 API

使用某种借口定义语言（IDL）

### API 演化

**语义化的版本控制**

看这个 http://semver.org

要求版本号由三部分组成：

MAJOR.MINOR.PATCH

- MAJOR：当你对 API 进行不兼容的更改时。
- MINOR：当你对 API 进行向后兼容的增强时。
- PATCH：当你进行向后兼容的错误修复时。

不就是开发的 1.0.0 SNAPSHOT -> 1.0.0 REALEASE

可以在 REST 的 URL 中加上 MAJOR 版本号。这个在对接的时候，用过。/test/v1 -> /test/v2

这个其实在西安那和阿里对接的时候，他们是把版本号放到末尾的。

**如果你使用的是基于 HTTP 的进程间人通信机制，例如 REST，则一种方法是在 URL 中嵌入主要版本号。例如 /v1/... 为前缀，而版本 2 路径以 /v2/... 为前缀**。

另一种选择是使用 HTTP 的内容协商机制，并在 MIME 类型中包含版本号。

GET /orders/xyz HTTP/1.1

Accept: application/vnd.example.resource+json; version=1

此请求告诉 Order Service ，它的客户端需要来自版本 1.x 的响应。

### 消息的格式

进程间通信的本质是交换信息。

消息的格式可以分为两大类：文本和二进制。

1. 文本

JSON、XML。

优点：可读性高，自描述。

缺点：消息往往过度冗长，特别是 XML。解析文本引入额外开销，尤其是消息较大。

2. 二进制

- Protocol Buffers
- Avro

Protocol Buffers 使用 tagged fields，Avro 消费者在解析消息前需要知道它的格式。

## 基于同步远程过程调用模式的通信

RPI

