# 第三章 微服务架构中的进程间的通信

## 微服务架构中的进程间通信概述

### 交互方式

有多种客户端和服务的交互方式。

**一对一**：每个客户端请求由一个服务实例来处理。

**一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

**同步模式**：客户端请求需要服务端实时响应，客户端等待响应式可能导致堵塞。

**异步模式**：客户端请求不会阻塞进程，服务端的响应可是非实时的。

|          |           一对一           |           一对多            |
| :------: | :------------------------: | :-------------------------: |
| 同步模式 |         请求/响应          |             无              |
| 异步模式 | 异步请求/响应<br/>单向通知 | 发布/订阅<br/>发布/异步响应 |

### 定义 API

使用某种借口定义语言（IDL）

### API 演化

**语义化的版本控制**

看这个 http://semver.org

要求版本号由三部分组成：

MAJOR.MINOR.PATCH

- MAJOR：当你对 API 进行不兼容的更改时。
- MINOR：当你对 API 进行向后兼容的增强时。
- PATCH：当你进行向后兼容的错误修复时。

不就是开发的 1.0.0 SNAPSHOT -> 1.0.0 REALEASE

可以在 REST 的 URL 中加上 MAJOR 版本号。这个在对接的时候，用过。/test/v1 -> /test/v2

这个其实在西安那和阿里对接的时候，他们是把版本号放到末尾的。

**如果你使用的是基于 HTTP 的进程间人通信机制，例如 REST，则一种方法是在 URL 中嵌入主要版本号。例如 /v1/... 为前缀，而版本 2 路径以 /v2/... 为前缀**。

另一种选择是使用 HTTP 的内容协商机制，并在 MIME 类型中包含版本号。

GET /orders/xyz HTTP/1.1

Accept: application/vnd.example.resource+json; version=1

此请求告诉 Order Service ，它的客户端需要来自版本 1.x 的响应。

### 消息的格式

进程间通信的本质是交换信息。

消息的格式可以分为两大类：文本和二进制。

1. 文本

JSON、XML。

优点：可读性高，自描述。

缺点：消息往往过度冗长，特别是 XML。解析文本引入额外开销，尤其是消息较大。

2. 二进制

- Protocol Buffers
- Avro

Protocol Buffers 使用 tagged fields，Avro 消费者在解析消息前需要知道它的格式。

## 基于同步远程过程调用模式的通信

当使用基于远程过程调用（RPI）的进程间通信机制时，客户端向服务发送请求，服务处理该请求并发回响应。有些客户端可能会处在堵塞状态并等待响应，而其他客户端可能会有一个响应式的非阻塞架构。但与使用消息机制时不同，客户端假定响应讲及时到达。
![远程过程调用.png](https://i.loli.net/2021/04/04/IBDgEV3bfmuW5vX.png)

客户端的业务逻辑调用由 RPI 代理适配器类实现的接口。RPI 代理类向服务发出请求。RPI 服务器适配器类通过调用服务的业务逻辑来处理请求。

### 使用 REST

REST 提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。

REST 使用 HTTP 动词来操作资源，使用 URL 引用这些资源。

REST 成熟度模型

- Level 0 ：Level 0 层级服务的客户端只是向服务端发起 HTTP POST 请求，进行服务调用。每个请求都指明了需要执行的操作、这个操作针对的目标（例如，业务对象）和必要的参数。
- Level 1：Level 1 层级的服务引入了资源的概念。要执行对资源的操作，客户端需要发出制定要执行的操作和任何参数的 POST 请求。
- Level 2 ：Level 2 层级的服务使用 HTTP 动词来执行操作。如 GET 表示获取、POST 表示创建、PUT 表示更新。请求查询和主体（如果有的话）制定操作的参数。这让服务能够借助 Web 基础设施服务，例如通过 CDN 来缓存 GET 请求。
- Level 3: Level 3 层级的服务基于 HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是在由 GET 请求返回的资源信息中包含链接，这些链接能够执行该资源允许的操作。

GraphQL 和 Netflix Falcor 解决 REST  的不足。

优点：

- 简单。
- 易用易测试。
- 直接支持请求/响应方式的通信。
- HTTP 对防火墙友好。
- 不需要中间代理，简化了系统架构。

缺点：

- 只支持请求/响应方式的通信。
- 可能导致可用性降低。
- 客户端必须知道服务实例的位置。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到 HTTP 动词。

### 使用 gRPC

基于二进制消息的协议。使用 Protocol Buffer 编译器生成客户端的桩（stub，也称为存根）和服务端骨架（skeleton）。客户端和服务端使用 HTTP/2 以 Protocol Buffer 格式交换二进制消息。

gRPC API 由一个或多个服务和请求/响应消息定义组成。除了支持简单的请求/响应 RPC 之外，gRPC 还支持流式 RPC。

优点：

- 设计具有复杂更新操作的 API 非常简单。
- 具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和消息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种编程语言编写的服务端之间的互操作性。

缺点：

- 繁琐
- 旧式防火墙可能不支持 HTTP/2.

## 使用断路器模式处理局部故障

模式：断路器（相当于保险丝）

这是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用。

解决同步调用无限期阻塞，等待响应的问题。

1. 必须让远程过程调用代理有正确处理无响应服务的能力。
2. 需要决定如何从失败的远程服务中恢复。

**开发可靠的远程过程调用代理**

- 网络超时
- 限制客户端向服务器发出请求的数量：限流。
- 断路器模式：断路器。

  调用超时次数，设置阈值，尝试恢复。

熔断机制实现的另外一个关键是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。

熔断的目的是应对依赖的外部系统故障的情况。

相当于本系统的“保险丝”，如果一直调用外部系统失败或者超时，响应非常慢，就需要熔断机制。只要是需要调用那个系统的请求，全部错误返回。

可以设置一定时间后，再重试这个另一个系统的接口，尝试恢复。

**从服务失效故障中恢复**

Hystrix 之类的库只是解决方案的一部分。可以将错误返回给移动客户端。

## 使用服务发现

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。

1. 自注册
2. 客户端发现

**应用层服务发现模式**

![服务注册表.png](https://i.loli.net/2021/04/07/Y3QG8LCWTN5V4Ja.png)

要有心跳机制保证服务其注册过期。

也可以使用 K8s 来实现服务注册等机制，不过这个只能用于部署在 Kubernetes 平台之上的部分服务。

**平台层服务发现模式**

K8s 自带了服务注册表和服务发现机制。

和上面的图类似，只不过大部分内容交给平台来做了。

1. 第三方注册模式。
2. 服务端发现模式。

