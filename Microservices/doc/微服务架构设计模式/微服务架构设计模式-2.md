# 第三章 微服务架构中的进程间的通信

## 微服务架构中的进程间通信概述

### 交互方式

有多种客户端和服务的交互方式。

**一对一**：每个客户端请求由一个服务实例来处理。

**一对多**：每个客户端请求由多个服务实例来处理。

交互方式的第二个维度关注的是同步和异步。

**同步模式**：客户端请求需要服务端实时响应，客户端等待响应式可能导致堵塞。

**异步模式**：客户端请求不会阻塞进程，服务端的响应可是非实时的。

|          |           一对一           |           一对多            |
| :------: | :------------------------: | :-------------------------: |
| 同步模式 |         请求/响应          |             无              |
| 异步模式 | 异步请求/响应<br/>单向通知 | 发布/订阅<br/>发布/异步响应 |

### 定义 API

使用某种借口定义语言（IDL）

### API 演化

**语义化的版本控制**

看这个 http://semver.org

要求版本号由三部分组成：

MAJOR.MINOR.PATCH

- MAJOR：当你对 API 进行不兼容的更改时。
- MINOR：当你对 API 进行向后兼容的增强时。
- PATCH：当你进行向后兼容的错误修复时。

不就是开发的 1.0.0 SNAPSHOT -> 1.0.0 REALEASE

可以在 REST 的 URL 中加上 MAJOR 版本号。这个在对接的时候，用过。/test/v1 -> /test/v2

这个其实在西安那和阿里对接的时候，他们是把版本号放到末尾的。

**如果你使用的是基于 HTTP 的进程间人通信机制，例如 REST，则一种方法是在 URL 中嵌入主要版本号。例如 /v1/... 为前缀，而版本 2 路径以 /v2/... 为前缀**。

另一种选择是使用 HTTP 的内容协商机制，并在 MIME 类型中包含版本号。

GET /orders/xyz HTTP/1.1

Accept: application/vnd.example.resource+json; version=1

此请求告诉 Order Service ，它的客户端需要来自版本 1.x 的响应。

### 消息的格式

进程间通信的本质是交换信息。

消息的格式可以分为两大类：文本和二进制。

1. 文本

JSON、XML。

优点：可读性高，自描述。

缺点：消息往往过度冗长，特别是 XML。解析文本引入额外开销，尤其是消息较大。

2. 二进制

- Protocol Buffers
- Avro

Protocol Buffers 使用 tagged fields，Avro 消费者在解析消息前需要知道它的格式。

## 基于同步远程过程调用模式的通信

当使用基于远程过程调用（RPI）的进程间通信机制时，客户端向服务发送请求，服务处理该请求并发回响应。有些客户端可能会处在堵塞状态并等待响应，而其他客户端可能会有一个响应式的非阻塞架构。但与使用消息机制时不同，客户端假定响应讲及时到达。
![远程过程调用.png](https://i.loli.net/2021/04/04/IBDgEV3bfmuW5vX.png)

客户端的业务逻辑调用由 RPI 代理适配器类实现的接口。RPI 代理类向服务发出请求。RPI 服务器适配器类通过调用服务的业务逻辑来处理请求。

### 使用 REST

REST 提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。

REST 使用 HTTP 动词来操作资源，使用 URL 引用这些资源。

REST 成熟度模型

- Level 0 ：Level 0 层级服务的客户端只是向服务端发起 HTTP POST 请求，进行服务调用。每个请求都指明了需要执行的操作、这个操作针对的目标（例如，业务对象）和必要的参数。
- Level 1：Level 1 层级的服务引入了资源的概念。要执行对资源的操作，客户端需要发出制定要执行的操作和任何参数的 POST 请求。
- Level 2 ：Level 2 层级的服务使用 HTTP 动词来执行操作。如 GET 表示获取、POST 表示创建、PUT 表示更新。请求查询和主体（如果有的话）制定操作的参数。这让服务能够借助 Web 基础设施服务，例如通过 CDN 来缓存 GET 请求。
- Level 3: Level 3 层级的服务基于 HATEOAS（Hypertext As The Engine Of Application State）原则设计，基本思想是在由 GET 请求返回的资源信息中包含链接，这些链接能够执行该资源允许的操作。

GraphQL 和 Netflix Falcor 解决 REST  的不足。

优点：

- 简单。
- 易用易测试。
- 直接支持请求/响应方式的通信。
- HTTP 对防火墙友好。
- 不需要中间代理，简化了系统架构。

缺点：

- 只支持请求/响应方式的通信。
- 可能导致可用性降低。
- 客户端必须知道服务实例的位置。
- 在单个请求中获取多个资源具有挑战性。
- 有时很难将多个更新操作映射到 HTTP 动词。

### 使用 gRPC

基于二进制消息的协议。使用 Protocol Buffer 编译器生成客户端的桩（stub，也称为存根）和服务端骨架（skeleton）。客户端和服务端使用 HTTP/2 以 Protocol Buffer 格式交换二进制消息。

gRPC API 由一个或多个服务和请求/响应消息定义组成。除了支持简单的请求/响应 RPC 之外，gRPC 还支持流式 RPC。

优点：

- 设计具有复杂更新操作的 API 非常简单。
- 具有高效、紧凑的进程间通信机制，尤其是在交换大量消息时。
- 支持在远程过程调用和消息传递过程中使用双向流式消息方式。
- 它实现了客户端和用各种编程语言编写的服务端之间的互操作性。

缺点：

- 繁琐
- 旧式防火墙可能不支持 HTTP/2.

## 使用断路器模式处理局部故障

模式：断路器（相当于保险丝）

这是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用。

解决同步调用无限期阻塞，等待响应的问题。

1. 必须让远程过程调用代理有正确处理无响应服务的能力。
2. 需要决定如何从失败的远程服务中恢复。

**开发可靠的远程过程调用代理**

- 网络超时
- 限制客户端向服务器发出请求的数量：限流。
- 断路器模式：断路器。

  调用超时次数，设置阈值，尝试恢复。

熔断机制实现的另外一个关键是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1 秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。实践中一般都是先根据分析确定阈值，然后上线观察效果，再进行调优。

熔断的目的是应对依赖的外部系统故障的情况。

相当于本系统的“保险丝”，如果一直调用外部系统失败或者超时，响应非常慢，就需要熔断机制。只要是需要调用那个系统的请求，全部错误返回。

可以设置一定时间后，再重试这个另一个系统的接口，尝试恢复。

**从服务失效故障中恢复**

Hystrix 之类的库只是解决方案的一部分。可以将错误返回给移动客户端。

## 使用服务发现

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。

1. 自注册
2. 客户端发现

**应用层服务发现模式**

![服务注册表.png](https://i.loli.net/2021/04/07/Y3QG8LCWTN5V4Ja.png)

要有心跳机制保证服务其注册过期。

也可以使用 K8s 来实现服务注册等机制，不过这个只能用于部署在 Kubernetes 平台之上的部分服务。

**平台层服务发现模式**

K8s 自带了服务注册表和服务发现机制。

和上面的图类似，只不过大部分内容交给平台来做了。

1. 第三方注册模式。
2. 服务端发现模式。DNS 解析，搞大数据这块的，一定要把对应的 zk 的服务改成域名，然后本地 /etc/hosts 文件配置对应的 ip 才行。

## 基于异步消息模式的通信

消息机制

有代理和无代理

问题

1. 保持消息的顺序
2. 检测和丢弃重复消息
3. 事务型消息

### 什么是消息传递

消息通过消息通道（channel）进行交换。发送方将消息写入通道

，接收方从通道读取消息。

**关于消息**

消息由消息头部和消息主体组成。标题是名称与值对的集合，描述正在发送的数据的元数据。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息。消息正文是以文本或二进制格式发送的数据。

包含以下几种类型

- 文档：仅包含数据的通用消息
- 命令：一条等同于 RPC 请求的消息。它指定要调用的操作及其参数。
- 事件：表示发送方这一端发生了重要的事件。事件通常是领域事件

**关于消息通道**

当两种类型的消息通道

1. 点对点
2. 发布-订阅

![消息通道.png](https://i.loli.net/2021/04/07/i2u8qJeBfd3HXlb.png)

### 使用消息机制实现交互方式

**实现请求/响应和异步请求/响应**

![请求_响应.png](https://i.loli.net/2021/04/07/tEVog9bdqKQkOes.png)

**实现单向通知**

这个正常的 MQ 都行。点对点

**实现发布订阅**

Kafka 是 Producer 和 Consumer Group，单个消费者就是点对点了。

**实现发布/异步响应**

每个消息头都带上消息 id。

### 为基于消息机制的服务 API 创建 API 规范

使用 JSON、XML 或 Protobuf 之类的标准来描述消息的格式。需要自己编写对应文档。

### 使用消息代理

**无代理**

ZeroMQ（http://zeromq.org）是一种流行的无代理消息技术。既是规范，

优点

- 低流量、低延迟。
- 消除了消息代理可能成为性能瓶颈或淡点故障的可能性。
- 具有较低的操作复杂性。

缺点

- 服务需要了解彼此的位置，因此必须使用服务发现机制。
- 会导致可用性降低，发送消息时，双方必须同时在线。
- 在实现例如确保消息能够成功投递这些复杂功能时的挑战性更大。

**基于代理的消息**

选择消息代理时，需要考虑以下各种因素：

- 支持的编程语言
- 支持的消息标准
- 消息排序
- 投递保证
- 持久性
- 耐久性
- 延迟
- 竞争性（并发）接收方

我选 Confluent Kafka

选择消息代理的好处和弊端

优点

- 松耦合
- 消息缓存
- 灵活的通信：点对点，发布/订阅
- 明确的进程间通信

缺点

- 潜在的性能瓶颈
- 潜在的单点故障
- 额外的操作复杂性

### 处理并发和消息顺序

保证消息只被处理一次，并且有序。

Kafka 使用 Key 的哈希来指定发送到哪个 partition 上，我觉得其实就是粘性 session 那种，这样就保证某一类的消息都是只被处理一次，且有序的。

### 处理重复消息

- 至少一次
- 最多一次
- 精准一次

Kafka 都有实现。精准一次，就是加字段，以空间换时间的思维，来保证投递消息是实现了精准一次语义的。

**编写幂等消息处理器**

幂等（idempotent）其实是一个数学与计算机学的概念，常见于抽象代数中。

**跟踪消息并丢弃重复消息**

给每个消息一个 messageId，建立一个事务，里面有两个操作。

1. 插入消息 Id 表，如果重复，就执行事务回滚，如果插入成功，执行下一步操作。
2. 执行业务逻辑的插入数据操作。

其实可以用一句 SQL 来弄。ON DUPLICATE KEY UPDATE，当然，这会导致更新。并且在大量数据同时操作的情况下，需要降低 MySQL 的一个事务隔离级别，不然容易被间隙锁搞崩了。

### 事务型消息

Kafka 事务。

**使用数据库表作为消息队列**

这个是可行的，就是 TPS 不要太高的那种业务才行。

然后通过轮询来查表。

**使用事务日志拖尾模式发布事件**

就是利用 Binlog 那种来搞，下面有几种实际参考实现来做

- Debezium（想 Kafka 发布数据库更改）
- LinkedIn Databus（针对 Oracle 的）
- DynamoDB streams（仅针对 Amazon 的这个数据库）
- Eventuate Tram（支持 MySQL binlog，Postgres WAL 或轮询来读取）

## 消息相关的类库和框架

作者开源的 Eventuate 位 Saga 量身订做的。

两个重要机制

- 事务性消息
- 重复消息检测

  

**如果你想最大化一个系统的可用性，就应该设法最小化系统的同步操作量。**

![异步交互.png](https://i.loli.net/2021/04/11/KzoYvJCOcN97pj6.png)

**复制数据**

在请求处理缓解中减少同步请求的另外一种方法，就是进行数据复制。

![数据复制.png](https://i.loli.net/2021/04/11/IHYLJuBhUQkSRED.png)