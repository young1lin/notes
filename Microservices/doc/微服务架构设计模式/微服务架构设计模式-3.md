# Saga

一种消息驱动的本地事务序列。

Saga 只满足 ACD，隔离性不要了。

1. 协同式（choreography）
2. 编排式（orchestration）

因为每个服务都有自己的私有数据库，所以要一种机制来保障多数据环境下的数据一致性。

事务补偿机制。

## 分布式事务的挑战

分布式事务管理的事实标准是 X/Open Distributed Transaction Processing (DTP) Model (X/Open XA)。XA 采用了两段提交(two phase commit, 2PC) 来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。应用程序的整个技术栈都要满足 XA 标准。

NoSQL 不支持 XA 标准，RabbitMQ 和 Apache Kafka 也不支持分布式事务。这就要用 Saga 了。

## 使用 Saga 模式维护数据一致性

Saga 是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。一个 Saga 表示需要更新多个服务中数据的一个系统操作。Saga 由一连串本地事务组成。

下面是使用 Saga 来 Create Order。

![Saga Create Order.png](https://i.loli.net/2021/04/12/JvMuRko8f53SL7x.png)这个 Saga 包含了以下鸡哥本地事务

1. Order Service ： 创建一个处于 APPROVAL_PENDING 状态的 Order。
2. Consumer Service ：验证当前订单中的消费者可以下单。
3. Kitchen Service： 验证订单内容，并创建一个后厨工单 Ticket，状态为 CRAETE_PENGIND。
4. Accounting Service： 对消费者提供的信用卡作授权操作。
5. Kitchen serivce：把后厨工单 Ticket 的状态为 AWAITING_ACCEPTANCE。
6. Order Service ： 把 Order 的状态改为 APPROVED。

**Saga 使用补偿事务来回滚所做出的改变**

如果第四步错了，就要明确撤销前三个步骤做的更改。所以必须变成所谓的补偿事务。

做了多少更改，就要做多少补偿。

# Saga 的协调模式

1. 协同式：把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换时间的方式来进行沟通。
2. 编排式：把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。 Saga 编排器发出命令式消息给各个 Saga 参与方，指示这些参与方服务完成具体操作（本地事务）。

## 协同式 Saga

使用协同时，没有一个中央协调器会告诉参与方该做什么。相反，Saga 参与方订阅彼此的事件并做出相应的响应。为了展示基于协同的 Saga 如何运作。

实现协同式的 Create Order Saga

1. Order Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Service 消费 OrderCreated 事件，验证消费者是否可以下订单，并发布 ConsumerVerified 事件。
3. Kitchen Service 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PRNDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreted 事件并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Accounting Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡收费，并发布 CreaditaCardAuthorized 事件。
6. Kitchen Service 消费 CreditCardAuthorized 事件并将 Ticket 的状态更改为 AWAITING_ACCEPTANCE。
7. ORder Service 接受 CreditCardAuthorized 事件，将 Order 的状态更改为 APPROVED，并发布 OrderApproved 事件。



![协同式实现 Create Order Saga.png](https://i.loli.net/2021/04/13/DdBLmskyVIhYn2e.png)

下面是无法授权的案例，及事件顺序。