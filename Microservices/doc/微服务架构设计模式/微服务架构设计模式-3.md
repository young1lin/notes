# Saga

一种消息驱动的本地事务序列。

Saga 只满足 ACD，隔离性满足不了。

1. 协同式（choreography）
2. 编排式（orchestration）

因为每个服务都有自己的私有数据库，所以要一种机制来保障多数据环境下的数据一致性。

事务补偿机制。

## 分布式事务的挑战

分布式事务管理的事实标准是 X/Open Distributed Transaction Processing (DTP) Model (X/Open XA)。XA 采用了两段提交(two phase commit, 2PC) 来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。应用程序的整个技术栈都要满足 XA 标准。

NoSQL 不支持 XA 标准，RabbitMQ 和 Apache Kafka 也不支持分布式事务。这就要用 Saga 了。

## 使用 Saga 模式维护数据一致性

Saga 是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。一个 Saga 表示需要更新多个服务中数据的一个系统操作。Saga 由一连串本地事务组成。

下面是使用 Saga 来 Create Order。

![Saga Create Order.png](https://i.loli.net/2021/04/12/JvMuRko8f53SL7x.png)这个 Saga 包含了以下鸡哥本地事务

1. Order Service ： 创建一个处于 APPROVAL_PENDING 状态的 Order。
2. Consumer Service ：验证当前订单中的消费者可以下单。
3. Kitchen Service： 验证订单内容，并创建一个后厨工单 Ticket，状态为 CRAETE_PENGIND。
4. Accounting Service： 对消费者提供的信用卡作授权操作。
5. Kitchen serivce：把后厨工单 Ticket 的状态为 AWAITING_ACCEPTANCE。
6. Order Service ： 把 Order 的状态改为 APPROVED。

**Saga 使用补偿事务来回滚所做出的改变**

如果第四步错了，就要明确撤销前三个步骤做的更改。所以必须变成所谓的补偿事务。

做了多少更改，就要做多少补偿。

# Saga 的协调模式

1. 协同式：把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换时间的方式来进行沟通。
2. 编排式：把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。 Saga 编排器发出命令式消息给各个 Saga 参与方，指示这些参与方服务完成具体操作（本地事务）。

## 协同式 Saga

使用协同时，没有一个中央协调器会告诉参与方该做什么。相反，Saga 参与方订阅彼此的事件并做出相应的响应。为了展示基于协同的 Saga 如何运作。

实现协同式的 Create Order Saga

1. Order Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Service 消费 OrderCreated 事件，验证消费者是否可以下订单，并发布 ConsumerVerified 事件。
3. Kitchen Service 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PRNDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreted 事件并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Accounting Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡收费，并发布 CreaditaCardAuthorized 事件。
6. Kitchen Service 消费 CreditCardAuthorized 事件并将 Ticket 的状态更改为 AWAITING_ACCEPTANCE。
7. ORder Service 接受 CreditCardAuthorized 事件，将 Order 的状态更改为 APPROVED，并发布 OrderApproved 事件。



![协同式实现 Create Order Saga.png](https://i.loli.net/2021/04/13/DdBLmskyVIhYn2e.png)

下面是无法授权的案例，及事件顺序。

1. Orders Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Servie 消费 OrderCreated 事件，验证消费者是否可以下单，并发布 ConsumerVerified 事件。
3. Kitchen Serivce 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PENDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreated 事件，并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Account Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡扣款（失败了），并发布 CreaditCardAuthorizationFailed 事件。
6. Kitchen Service 消费 CreditCardAuthorizationFailed 事件，然后把后厨工单 Ticket 的状态更改为 REJECTED。
7. Order Service 消费 CreditCardAuthorizationFailed 事件，并将 Order 的状态更改为 REJECTED。

图就不画了，和上面类似。

协同式 Saga 

好处

1. **简单**
2. **松耦合**

弊端

**更难理解**

**服务之间的循环依赖关系**：Saga 参与方订阅彼此的事件，这通常会导致循环以来关系。

**紧密耦合的风险**

## 编排式 Saga

定义一个编排器类。Saga 编排器使用命令/异步响应方式与 Saga 的参与方通信。

### 实现编排式的 Create Order Saga

下面是流程

1. Saga 编排器向 Consumer Service 发送 Verify Consumer 命令。
2. Consumer Service 回复 Consumer Verified 消息。
3. Saga 编排器向 kitchen Service 发送 Create Ticket 命令。
4. Kitchen Service 回复 Ticket Created 消息。
5. Saga 编排器向 Accounting Service 发送 Authorize Card 消息。
6. Accounting Service 使用 Card Authorized 消息回复。
7. Saga 编排器向 Kitchen Service 发送 Approve Ticket 命令。
8. Saga 编排器向 Order Service 发送 Approve Order 命令。

![编排式实现 Create Order Saga.png](https://i.loli.net/2021/04/14/ENMWA6lqPhQXerL.png)

**把 Saga 编排器视为一个状态机**

状态机式建模 Saga 编排器的一个好办法。状态机由一组状态和一组由事件触发的状态之间转换组成。每个转换都可以有一个动作，对 Saga 来说动作就是某个参与方的调用。状态之间的转换由 Saga 参与方执行的本地事务完成触发。

下面是 Create Order Saga 的状态机模型。包含

- Verifying Consumer ：初始状态。当处于此状态时，该 Saga 正在等待 Consumer Service 验证消费者是否可以下订单。
- Creating Ticket ： 该 Saga 正在等待对 Create Ticket 命令的回复。
- Authorizing Card：等待 Accounting Service 授权消费者的信用卡。
- Order Approved ：最终状态，表示该 Saga 已成功完成。
- Order Rejected ：最终状态，表示 Order 被其中一个参与方拒绝。

![Create Order Saga 的状态机模型.png](https://i.loli.net/2021/04/14/omwD8Ft7rl59xnc.png)

### 使用 Saga 的优点

1. 更简单的依赖关系
2. 较少的耦合
3. 改善关注点隔离，简化业务逻辑

缺点就是

在编排器中存在过多业务逻辑的风险。

# 解决隔离问题

ACD

Atomic：Saga实现确保执行所有事务或撤销所有更改。

Consistency：服务内的参照完整性（referential integrity）由本地数据库处理。服务之间的参照完整性由服务处理。

Durability：由本地数据库处理。

但是隔离性没有。

## 缺乏隔离性导致的问题

- 丢失更新
- 脏读
- 模糊或不可重复读

## 隔离的对策

- 语义锁：应用程序级的锁
- 交换式更新：把更新操作设计成可以按任何顺序执行
- 悲观视图：重新排序 Saga 的步骤，以最大限度地降低业务风险。
- 重读值：通过重写数据来防止脏写，以在覆盖数据之前验证它是否保持不变。
- 版本文件：将更新记录下来，以便可以对它们重新排序。
- 业务风险评级：使用每个请求的业务风险来动态选择并发机制。

Saga 可包含三种类型事务

1. 可补偿性事务：可以使用补偿事务回滚的事务。
2. 关键性事务：Saga 执行过程的关键点。如果关键性事务成功，则 Saga 将一直运行到完成。关键性事务不见得是一个可补偿性事务，或者可重复性事务。但是它们可以是最后一个可补偿的事务或第一个可重复的事务。
3. 可重复性事务：在关键性事务之后的事务，保证成功。

### 语义锁

就是分布式锁呗。锁就是 Order 的 state 或者 Order id。仅且仅能一个程序处理它。

Redission，Zookeeper 之类的。

### 交换式更新

将更新操作设计为可交换的。如果可以按任何顺序执行，操作就是可交换的（commutative）。

### 悲观视图（Pessimistic View）

重新排序 Saga 的步骤，以最大限度地降低由于脏读而导致的业务风险。

### 重读值

乐观锁。

### 版本文件

给业务一个版本号，类似 CAS 解决 ABA 问题那样。还有实现 Kafka 事务的实现那样。

### 业务风险评级

不同业务使用不同策略。

书上讲 Saga 的使用。没用过，不太懂。

# 微服务架构中的业务逻辑设计

## 使用领域模型模式设计业务逻辑

除非是编写一个非常简单的应用程序，否则应该地址编写面向过程代码的诱惑，使用领域模型模式，并进行面向对象的设计。

![聚合 _1_.png](https://i.loli.net/2021/04/25/rlqhbgZBDsPY5ew.png)

识别聚合是关键

## 聚合的规则

1. 只引用聚合根。
2. 聚合间的引用必须使用主键。
3. 在一个事务中，只能创建或更新一个聚合。

## 聚合的颗粒度

聚合不是一成不变的，可以适当调整边界。

![更大的聚合 _1_.png](https://i.loli.net/2021/04/25/gX8FEs4KldNDCYT.png)

# 发布领域事件

事件（Event）这个单词的定义

1. 发生的事情
2. 一件值得注意的事情。
3. 社交场合或活动。
4. 不良或有害的医疗事故，心脏病发作或其他心脏事件。

在领域驱动设计的上下文中，领域事件是聚合发生的事情。它由领域模型中的一个类表示。事件通常代表状态的变化。

## e什么是领域事件

命名领域事件时，往往选择动词的过去分词。

OrderCreated

领域事件通常还具有元数据，例如事件 ID 和时间戳。

### 识别领域事件

当 X 发生时做 Y 之类的语言。

事件风暴。

事件风暴时一种以事件为中心的研讨会，用于理解复杂的领域。

三步骤

1. 头脑风暴：请求领域专家集体讨论领域事件。领域事件由橙色便笺表示，这些便笺在白板上按照事件轴顺序摆放。
2. 识别事件触发器：如
   1. 用户操作，表示为使用蓝色便笺的命令。
   2. 外部系统，由紫色便笺表示
   3. 另一个领域事件
   4. 时间的流逝。
3. 识别聚合：聚合由黄色便笺表示。

### 生成和发布领域事件

从概念上讲，领域事件由聚合负责发布。

可以在聚合内生成对象，然后 Service 层发布生成的事件，也可以搞一个 AbstractAggregateRoot#registerDomainEvent();

