# Saga

一种消息驱动的本地事务序列。

Saga 只满足 ACD，隔离性满足不了。

1. 协同式（choreography）
2. 编排式（orchestration）

因为每个服务都有自己的私有数据库，所以要一种机制来保障多数据环境下的数据一致性。

事务补偿机制。

## 分布式事务的挑战

分布式事务管理的事实标准是 X/Open Distributed Transaction Processing (DTP) Model (X/Open XA)。XA 采用了两段提交(two phase commit, 2PC) 来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。应用程序的整个技术栈都要满足 XA 标准。

### 两段提交

协调者（Coordinator）// TODO 详细解释这些

### 三段提交

超时机制

NoSQL 不支持 XA 标准，RabbitMQ 和 Apache Kafka 也不支持分布式事务。这就要用 Saga 了。

## 使用 Saga 模式维护数据一致性

Saga 是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。一个 Saga 表示需要更新多个服务中数据的一个系统操作。Saga 由一连串本地事务组成。

下面是使用 Saga 来 Create Order。

![Saga Create Order.png](https://i.loli.net/2021/04/12/JvMuRko8f53SL7x.png)这个 Saga 包含了以下几个本地事务

1. Order Service ： 创建一个处于 APPROVAL_PENDING 状态的 Order。
2. Consumer Service ：验证当前订单中的消费者可以下单。
3. Kitchen Service： 验证订单内容，并创建一个后厨工单 Ticket，状态为 CRAETE_PENGIND。
4. Accounting Service： 对消费者提供的信用卡作授权操作。
5. Kitchen serivce：把后厨工单 Ticket 的状态为 AWAITING_ACCEPTANCE。
6. Order Service ： 把 Order 的状态改为 APPROVED。

**Saga 使用补偿事务来回滚所做出的改变**

如果第四步错了，就要明确撤销前三个步骤做的更改。所以必须变成所谓的补偿事务。

做了多少更改，就要做多少补偿。

# Saga 的协调模式

1. 协同式：把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换时间的方式来进行沟通。
2. 编排式：把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。 Saga 编排器发出命令式消息给各个 Saga 参与方，指示这些参与方服务完成具体操作（本地事务）。

## 协同式 Saga

使用协同时，没有一个中央协调器会告诉参与方该做什么。相反，Saga 参与方订阅彼此的事件并做出相应的响应。为了展示基于协同的 Saga 如何运作。

实现协同式的 Create Order Saga

1. Order Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Service 消费 OrderCreated 事件，验证消费者是否可以下订单，并发布 ConsumerVerified 事件。
3. Kitchen Service 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PRNDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreted 事件并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Accounting Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡收费，并发布 CreaditaCardAuthorized 事件。
6. Kitchen Service 消费 CreditCardAuthorized 事件并将 Ticket 的状态更改为 AWAITING_ACCEPTANCE。
7. ORder Service 接受 CreditCardAuthorized 事件，将 Order 的状态更改为 APPROVED，并发布 OrderApproved 事件。



![协同式实现 Create Order Saga.png](https://i.loli.net/2021/04/13/DdBLmskyVIhYn2e.png)

下面是无法授权的案例，及事件顺序。

1. Orders Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Servie 消费 OrderCreated 事件，验证消费者是否可以下单，并发布 ConsumerVerified 事件。
3. Kitchen Serivce 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PENDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreated 事件，并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Account Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡扣款（失败了），并发布 CreaditCardAuthorizationFailed 事件。
6. Kitchen Service 消费 CreditCardAuthorizationFailed 事件，然后把后厨工单 Ticket 的状态更改为 REJECTED。
7. Order Service 消费 CreditCardAuthorizationFailed 事件，并将 Order 的状态更改为 REJECTED。

图就不画了，和上面类似。

协同式 Saga 

好处

1. **简单**
2. **松耦合**

弊端

**更难理解**

**服务之间的循环依赖关系**：Saga 参与方订阅彼此的事件，这通常会导致循环以来关系。

**紧密耦合的风险**

## 编排式 Saga

定义一个编排器类。Saga 编排器使用命令/异步响应方式与 Saga 的参与方通信。

### 实现编排式的 Create Order Saga

下面是流程

1. Saga 编排器向 Consumer Service 发送 Verify Consumer 命令。
2. Consumer Service 回复 Consumer Verified 消息。
3. Saga 编排器向 kitchen Service 发送 Create Ticket 命令。
4. Kitchen Service 回复 Ticket Created 消息。
5. Saga 编排器向 Accounting Service 发送 Authorize Card 消息。
6. Accounting Service 使用 Card Authorized 消息回复。
7. Saga 编排器向 Kitchen Service 发送 Approve Ticket 命令。
8. Saga 编排器向 Order Service 发送 Approve Order 命令。

![编排式实现 Create Order Saga.png](https://i.loli.net/2021/04/14/ENMWA6lqPhQXerL.png)

**把 Saga 编排器视为一个状态机**

状态机式建模 Saga 编排器的一个好办法。状态机由一组状态和一组由事件触发的状态之间转换组成。每个转换都可以有一个动作，对 Saga 来说动作就是某个参与方的调用。状态之间的转换由 Saga 参与方执行的本地事务完成触发。

下面是 Create Order Saga 的状态机模型。包含

- Verifying Consumer ：初始状态。当处于此状态时，该 Saga 正在等待 Consumer Service 验证消费者是否可以下订单。
- Creating Ticket ： 该 Saga 正在等待对 Create Ticket 命令的回复。
- Authorizing Card：等待 Accounting Service 授权消费者的信用卡。
- Order Approved ：最终状态，表示该 Saga 已成功完成。
- Order Rejected ：最终状态，表示 Order 被其中一个参与方拒绝。

![Create Order Saga 的状态机模型.png](https://i.loli.net/2021/04/14/omwD8Ft7rl59xnc.png)

### 使用 Saga 的优点

1. 更简单的依赖关系
2. 较少的耦合
3. 改善关注点隔离，简化业务逻辑

缺点就是

在编排器中存在过多业务逻辑的风险。

# 解决隔离问题

ACD

Atomic：Saga实现确保执行所有事务或撤销所有更改。

Consistency：服务内的参照完整性（referential integrity）由本地数据库处理。服务之间的参照完整性由服务处理。

Durability：由本地数据库处理。

但是隔离性没有。

## 缺乏隔离性导致的问题

- 丢失更新
- 脏读
- 模糊或不可重复读

## 隔离的对策

- 语义锁：应用程序级的锁
- 交换式更新：把更新操作设计成可以按任何顺序执行
- 悲观视图：重新排序 Saga 的步骤，以最大限度地降低业务风险。
- 重读值：通过重写数据来防止脏写，以在覆盖数据之前验证它是否保持不变。
- 版本文件：将更新记录下来，以便可以对它们重新排序。
- 业务风险评级：使用每个请求的业务风险来动态选择并发机制。

Saga 可包含三种类型事务

1. 可补偿性事务：可以使用补偿事务回滚的事务。
2. 关键性事务：Saga 执行过程的关键点。如果关键性事务成功，则 Saga 将一直运行到完成。关键性事务不见得是一个可补偿性事务，或者可重复性事务。但是它们可以是最后一个可补偿的事务或第一个可重复的事务。
3. 可重复性事务：在关键性事务之后的事务，保证成功。

### 语义锁

就是分布式锁呗。锁就是 Order 的 state 或者 Order id。仅且仅能一个程序处理它。

Redission，Zookeeper 之类的。

### 交换式更新

将更新操作设计为可交换的。如果可以按任何顺序执行，操作就是可交换的（commutative）。

### 悲观视图（Pessimistic View）

重新排序 Saga 的步骤，以最大限度地降低由于脏读而导致的业务风险。

### 重读值

乐观锁。

### 版本文件

给业务一个版本号，类似 CAS 解决 ABA 问题那样。还有实现 Kafka 事务的实现那样。

### 业务风险评级

不同业务使用不同策略。

书上讲 Saga 的使用。没用过，不太懂。

# 微服务架构中的业务逻辑设计

## 使用领域模型模式设计业务逻辑

除非是编写一个非常简单的应用程序，否则应该地址编写面向过程代码的诱惑，使用领域模型模式，并进行面向对象的设计。

![聚合 _1_.png](https://i.loli.net/2021/04/25/rlqhbgZBDsPY5ew.png)

识别聚合是关键

## 聚合的规则

1. 只引用聚合根。
2. 聚合间的引用必须使用主键。
3. 在一个事务中，只能创建或更新一个聚合。

## 聚合的颗粒度

聚合不是一成不变的，可以适当调整边界。

![更大的聚合 _1_.png](https://i.loli.net/2021/04/25/gX8FEs4KldNDCYT.png)

# 发布领域事件

事件（Event）这个单词的定义

1. 发生的事情
2. 一件值得注意的事情。
3. 社交场合或活动。
4. 不良或有害的医疗事故，心脏病发作或其他心脏事件。

在领域驱动设计的上下文中，领域事件是聚合发生的事情。它由领域模型中的一个类表示。事件通常代表状态的变化。

## 什么是领域事件

命名领域事件时，往往选择动词的过去分词。

OrderCreated

领域事件通常还具有元数据，例如事件 ID 和时间戳。

### 识别领域事件

当 X 发生时做 Y 之类的语言。

事件风暴。

事件风暴时一种以事件为中心的研讨会，用于理解复杂的领域。

三步骤

1. 头脑风暴：请求领域专家集体讨论领域事件。领域事件由橙色便笺表示，这些便笺在白板上按照事件轴顺序摆放。
2. 识别事件触发器：如
   1. 用户操作，表示为使用蓝色便笺的命令。
   2. 外部系统，由紫色便笺表示
   3. 另一个领域事件
   4. 时间的流逝。
3. 识别聚合：聚合由黄色便笺表示。

### 生成和发布领域事件

从概念上讲，领域事件由聚合负责发布。

可以在聚合内生成对象，然后 Service 层发布生成的事件，也可以搞一个 AbstractAggregateRoot#registerDomainEvent();

**方法一 Service 层发布事件**

**Ticket** 聚合

```java
public class Ticket{
    
    public List<DomainEvent> accept(ZonedDateTime readyBy){
        //...
        this.acceptTime = ZonedDateTime.now();
        this.readyBy = readyBy;
        return singletonList(new TicketAcceptedEvent(readyBy));
    }
    
}
```

**KitchenService**

```java
public class KitchenService{
    
    @Autowired
    private TicketRepository ticketRepository;
    
    @Autowired
    private DomainEventPublisher domainEventPublisher;
    
    public void accept(Long ticketId, ZoneDateTime readyBy){
        Ticket ticket = 
            ticketRepository.findById(ticketId)
            	.orElseThrow(() -> new TicketNotFoundException(ticketId));
        List<DomainEvent> events = ticket.accpet(readyBy);
        domainEventPublisher.publish(Ticket.class, orderId, events);
    }
    
}
```

**方法二 聚合基类发布**

Ticket

```java
public class Ticket extends AbstractAggregateRoot{
    
    public void accept(ZonedDateTime readyBy){
        //...
        this.acceptTime = ZonedDateTime.now();
        this.readyBy = readyBy;
        registerDomainEvent(new TicketAcceptedEvent(readyBy));
    }
    
}
```

## Kitchen Service 的业务逻辑

![Kitchen Service 的设计.png](https://i.loli.net/2021/04/28/ZzJQ4Hvfr5BitIm.png)

KitchenService 服务有三个入站适配器

-  REST API：餐馆工作人员通过他们的用户界面调用这些 REST API。它调用 KitchenService 来创建和更新 Ticket。
- KitchenService CommandHandler：由 Saga 调用的基于异步请求/响应的 API。它调用 KitchenService 来创建和更新 Ticket。
- KitchenServiceEventConsumer：订阅 Resturant Service 发布的事件。它调用 KitchenService 来创建和更新 Restaurant 聚合。

该服务还有两个出站适配器：

- DB Adapter：实现 TicketRepository 和 RestaurantRepository 接口并访问数据库。（书上这里有个作，应该是多打了一个字）
- DomainEventPublishingAdapter：实现 DomainEventPublisher 接口并发布 Ticket 领域事件。

### Ticket 聚合

下面的都是部分代码

```java
@Entity(table = "tickets")
public class Ticket{
    
    @Id
    private Long id;
    
    private TicketState state,=;
    
    private Long restaurantId;
    
    @ElmentCollection
    @CoolectionTable(name = "ticket line items")
    
    private List<TicketLineItem> lineItems;
    
    private ZonedDateTime readyBy;
    
    private ZonedDateTime acceptTime;

    private ZonedDateTime preparingTime;

	private ZonedDateTime pickedUpTime;

    private ZonedDateTime readyForPickupTime;

    //...

}
```

### Ticket 聚合的行为

- accept()： 餐馆已接受订单。
- preparing()：餐馆已开始准备订单，这意味着订单无法再更改或取消。
- readyForPickup()：订单可以派送。

```java
public class Ticket{
    
    public static ResultWithAggregateEvents<Ticket, TicketDomainEvent> 
        create(Long id, TicketDetails details){
        return new ResultWithAggregateEvents<>(new Ticket(id, details),
                                               new TicketCreateEvent(id, details));
    }
    
    public List<TicketPreparationStartedEvent> preparing(){
        switch(state){
            case ACCEPTED:
                this.state = TicketState.PREPARING;
                this.preparingTime = ZonedDateTime.now();
                return singletonList(new TicketPreparationStartedEvent());
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
    public List<TicketDomainEvent> cancel(){
        switch(state){
            case CREATED:
            case ACCEPTED:
                this.state = TicketState.CANCELLED;
                return singletonList(new TicketCancelled());
            case READY_FOR_PICKUP:
                throw new TicketCannotBeCancelledException();
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
}
```

### KitchenService 的领域服务

```java
public class KitchenService{
    
    @Autowired
    private TicketRepository ticketRepository;
    
    @Autowired
    private TicketDomainEventPublisher domainEventPublisher;
    
    public void accept(long ticketId, ZonedDateTime readyBy){
        Ticket ticket = 
            ticketRepository.findById(ticketId)
            .orElseThrow(() -> new TicketNotFoundException(ticketId));
        List<TicketDomainEvent> events = ticket.accept(readyBy);
        domainEventPublisher.publish(ticket, events);
    }
    
}
```

- orderId：要接受订单的 ID。
- readyBy：订单可被派送的预计时间。

### KitchenServiceCommandHandler 类

负责处理 OrderService 实现的各种 Saga 发送的命令式消息。此类每个命令定义一个处理程序方法，该方法调用 KitchenService 来创建或更新 Ticket。

```java
public class KitchenServiceCommandHandler{
    
    @Autowired
    private KitchenService kitchenService;
    
    public CommandHandlers commandHandlers(){
        return CommandHandlerBuilder
            .fromChannel("orderService")
            .onMessage(CreateTicket.class, this::createTicket)
            .onMessage(ConfrimCreateTicket.class, this::confirmCreateTicket)
            .onMessage(CancelCreateTicket.class, this::cancelCreateTicket)
            .build();
    }
    
    private Message createTicket(CommandMessage<CreateTicket> cm){
        CreateTicket command = cm.getCommand();
        long restaurantId = command.getRestaurantId();
        Long ticketId = command.getOrderId();
        TicketDetails ticketDetails = command.getTicketDetails();
        try{
            Ticket ticket =
                kitchenService.createTicket(restaurantId, ticketId, ticketDetails);
            CreateTicketReply reply = new CreateTicketReply(ticket.getId());
            return withSuccess(reply);
        }catch(RestaurantDetailsVerificationException e){
            return withFailure();
        }
    }
    
    private Message confirmCreateTicket(CommandMessage<ConfirmCreateTicket> cm){
        Long ticketId = cm.getCommand().getTicketdId();
        kitchenService.confirmCreateTicket(ticketId);
        return withSuccess();
    }
    
    //...
    
}
```

## Order Service 的业务逻辑

Order Service 提供了用于创建、更新和取消订单的 API。 Order 聚合是 Order Service 的核心聚合。但服务中也包括了 Restaurant 的聚合，这是 Restaurant Service 用哟的部分数据的复制品。它使 Order Service 能够验证 Order 的订单项并为其定价。

又一个用于管理订单的 REST API。它通过多个消息通道与其他服务交换消息和事件。

![image.png](https://i.loli.net/2021/04/30/5BE21u4meArQWFz.png)

## Order 聚合

![Order 聚合 UML 类图.png](https://i.loli.net/2021/04/30/Mz6STCuqsQkWofB.png)

聚合内包含了许多值对象。

值对象——通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。简单来说，值对象本质上就是一个集。**在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计**。

其实这里就是为什么 MongoDB 为什么更适合 DDD 了，因为值对象是没有 ID 的，要么全部更新，要么不更新。

```java
@Entity
@Table(name = "order")
@Accesss(AccessType.FIELD)
public class Order{
    
    @Id
    @GeneratedValue
    private Long id;
    
    /**
     * 乐观锁
     */
    @Version
    private Long version;
    
    private OrderState state;
    
    private Long consumerId;
    
    private Long restaurantId;
    
    @Embedded
    private OrderLineItems orderLineItems;
    
    @Embedded
    private DeliveryInfomation deliveryInfomation;
    
    @Embedded
    private PaymentInfomation paymentInfomation;
    
    @Embedded
    private Money orderMinimum;
    
}
```

这个类映射到 ORDER 表，id 是主键。@Embedded 注解映射到 ORDER 表，并存储到 ORDERS 表对应的列。orderLineItems 字段是包含订单行项的嵌入式对象。Order 聚合包含的不仅仅是字段，还实现了业务逻辑，后者可以由状态机描述。

### Order 聚合状态机

![Order 聚合状态机的一部分.png](https://i.loli.net/2021/05/06/uawZnTU9EVj8vfe.png)

### Order 聚合的方法

```java
public class Order{
    
    // ... 省略部分代码
    
    public static ResultWithDomainEvents<Order, OrderDomainEvent> 
        createOrder(long consumerId, Restaurant restaurant, List<OderLineItem> orderLineItems){
        Order order = new Order(consumerId, restaurant.getId(), OrderLineItems);
        List<OrderDomainEvent> events = singletonList(new OderCreatedEvent(
        new OrderDetails(consumerId, restaurant.getId(), orderLineItems, order.getOrderTotal()),
        restaurant.getName()));
        return new ResultWithDomainEvents<>(order, events);
    }
    
    public Order(OrderDetails orderDetails){
        this.orderLineItems = new OrderLineItems(orderDetails.getLineItems());
        this.orderMinium = orderDetails.getOrderMinimum();
        this.state = APPROCAL_PENDING;
    }
    
    public List<DomainEvent> noteApproved(){
        switch(state){
            case APPROVAL_PENDING:
                this.state = APPROVED;
                return singletonList(new OrderAuthorized());
            // ... 省略其他状态
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
    public List<DomainEvent> noteRejected(){
        switch(state){
            case APPROVAL_PENDING:
            	this.state = REJECTED;
                return singletonList(new OrderRejected());
            // ...
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }

}
```

### OrderService 类

```java
@Transactional
public class OrderService{
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RestaurantRepository restaurantRepository;
    
    @Autorwired
    private SagaManager<CreateOrderSagaState, CreateOrderSagaState>
        createOrderSagaManager;
    
    @Autorwired
    private SagaManger<ReviseOrderSagaState, ReviseOrderSagaData>
        reviseOrderSagaManagement;
    
    @Autorwired
    private OrderDomainEventPublisher orderAggredateEventPublisher;
    
    
    public Order createOrder(OrderDetails orderDetails){
        Restaurant restaurant = restaurantRepository.findById(restaurantId)
            .orElseThrow(() -> new RestaurantNotFoundException(restaurantId));
        List<OrderLineItem> orderLineItems = 
            makeOrderLineItems(lineItems, restaurant);
        ResultWithDomainEvents<Order, OrderDomainEvent> orderAndEvents = 
            Order.createOrder(consumerId, restaurant, orderLineItems);
        Order order = orderAndEvents.result;
        orderRepository.save(order);
        orderAggredateEventPublisher.publish(order, orderAndEvents.events);
        OrderDetails orderDetails = 
            new OrderDetails(consumerId, restaurantId, orderLineItems, order.getOrderTotal());
        CreateOrderSagaState data = new CreateOrderSagaState(order.getId(), orderDetails);
        createorderSagaManger.create(data, Order.class, order.getId());
        return order;
    }
    
    // 书上这里代码有问题，多嵌套了一层
    public Order reviseOrder(Long orderId, Long expectedVersion, OrderRevision orderRevision){
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
        ReviseOrderSagaData sagaData = 
            new ReviseOrderSagaData(order.getConsumerId(), orderId, null, orderRevision);
        reviseOrderSagaManager.create(sagaData);
        return order;
    }
    
}
```

# 使用事件溯源开发业务逻辑

 ## 概述

事件溯源是构建业务逻辑和持久化聚合的另一种选择。它将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化。应用程序通过重放（replaying）事件来重新创建聚合的当前状态。

需要 CQRS 模式来配合查询事件存储库。

使用日志拖尾技术来可靠地发布事件。可以利用 MySQL binlog 来发到 Kafka，再去消费。

使用快照提升性能。幂等方式的消息处理。



使用消息 ID 作为幂等性键值，确保消息只被处理一次。

# 在微服务中实现查询

1. API 组合模式：简单。
2. 命令查询职责隔离（CQRS）模式：比上面的更强大，但更复杂。维护了一个或多个视图数据库，唯一目的是支持查询。

# CQRS 模式

MySQL 同步到-> Elasticsearch，然后 Es 查询。

使用事件来维护多个服务复制数据的只读视图，借此来实现对来自多个服务的数据的查询。

CQRS 式这种架构的概括。它维护了一个或多个视图数据库，而不仅仅是文本搜索数据库，进而实现一个或多个应用程序的查询。

通过事件来发布信息。

C U D 一个库，R 一个库。

CQRS 有数据延迟，一个解决方案是命令端和查询端API为客户端提供版本信息，能够判断查询端是否过时。客户端可以轮到查询端的是图，直到它是最新的。version 字段。

## 设计 CQRS 视图

![CQRS 试图模块的设计.png](https://i.loli.net/2021/05/13/QnxyEUY7mi4tIs9.png)

在开发视图模块时，必须做一些设计决策：

- 必须选择合适的底层数据库，并设计数据库结构。
- 在设计数据访问模块时，必须解决各种问题，包括确保更新是幂等的，并且能够处理并发更新。
- 在现有应用程序中实现新视图或更改现有应用程序的模式时，必须实现一种机制，以便有效地构建或重建视图。
- 你必须决定如何设计视图的客户端，以应对前面描述的复制延迟。

DynamoDb 不会啊

# 外部 API 模式

## API Gateway 模式

实现一个服务，该服务是外部 API 客户端进入基于微服务应用程序的入口点。

类似 Facade （外观/门面）模式。

实现边缘功能。含：

- 身份验证
- 访问授权
- 速率限制
- 缓存
- 指标收集
- 请求日志

不同设备由不同 API Gateway 团队维护。简单讲了下 Zuul

Spring Cloud Zuul 使用讲解。

使用 GraphQL

# 微服务架构中的测试策略

## 测试

测试用例是用于特定目标的一组测试输入、执行条件和预期结果，例如执行特定的程序路径火验证是否符合特定条件。——来自维基百科

自动化测试通常包括四个阶段

1. 设置环境
2. 执行测试
3. 验证结果
4. 清理环境

测试套件是一组测试类的集合，测试由测试运行器（test runner）执行。

### 使用模拟和桩进行测试

测试替身（Test double）来消除被测系统的依赖性。

![测试替身.png](https://i.loli.net/2021/05/17/9pUZHFwgid2JxR6.png)

两种类型的测试替身：桩（stub）和模拟（mock）。术语桩和模拟通常可以互相使用，尽管它们的行为略有不同。桩事一个测试替身，它代替依赖项被测系统发送调用的返回值。模拟也是测试替身，用来验证被测系统事否正确调用了依赖项。此外，模拟通常也扮演桩的角色，向被测系统发送调用的返回值。

四种不同类型的测试：

- 单元测试：测试服务的一小部分，例如类。
- 集成测试：验证服务是否可以与基础设施服务（如数据库）或其他应用程序服务进行交互。
- 组件测试：单个服务的验收测试。
- 端到端测试：整个应用程序的验收测试。

![测试金字塔.png](https://i.loli.net/2021/05/17/dFwAgNBcfWuViXl.png)

## 消费者驱动的契约测试

验证服务是否满足它的消费者的期望。

验证服务的客户端是否可以与服务通信。

Spring Cloud Contract

## 单元测试

单元测试是测试金字塔的最低级别。它们是面向技术的测试，目标是协助开发。单元测试验证单元（服务很小的一部分）是否正常工作。单元通常是一个类，因此单元测试的目标是验证这个类的行为是否符合预期。

有两种类型的单元测试

- 独立型单元测试：使用针对类的依赖性的模拟对象隔离测试类。
- 协作型单元测试：测试一个类及其依赖项。

![image.png](https://i.loli.net/2021/05/18/GqRUYNIOPQETXZF.png)

关于指对象测试等一些测试，我就不写了。

# 集成测试

跳过

# 组件测试

## 使用 Gherkin 测试

given 是先决条件

when 是发生的动作或事件

Then/and 是预期的结果

```java
 public class StepDefinition {
     
     @Given("A valid consumer")
     public void useConsumer(){
         
     }
     
     @Given("using a(.?) (.*) credit card")
     public void useCreditCard(String ignore, String creditCard){
         
     }
     
     @When("I place an order for Chicken Vindaloo at Ajanta")
     public void palceOrder(){
         
     }
     
     @Then("the order should be (.*)")
     public void theOrderShouldBe(String desiredOrderState){
         
     }
     
     @And("an (.*) event should be published")
     public void verifyEventPublished(String exceptedEventClass){
         
     }
     
 }
```

# 开发面向生产环境的微服务应用

1. 安全性
2. 服务可配置性
3. 可观测性

使用 JWT

1. 不透明令牌。例如 UUID，它们会降低性能和可用性，并增加延迟。这种令牌的接收方必须对安全服务发起同步 RPC 调用，以验证令牌并检索用户信息。
2. 透明令牌。消除对安全服务调用的方法是，使用包含有关用户信息的透明令牌。 JSON Web Token。 JWT 是在访问双方之间安全地穿日信息（例如用户身份和角色）的标准方式。JWT 的内容包含一个 JSON 对象，其中有用户的信息。例如其身份和角色，以及其他数据，如到期日期等。

没有切实可行的方法来撤销落入恶意第三方售中的某个 JWT 令牌，解决方法是发布具有较短到期时间的 JWT，这可以限制恶意方。但是，短期的 JWT 的一个缺点是应用程序必须以某种方式不断重新发布 JWT 以保持会话活动。幸运的是， OAuth2.0 安全标准旨在解决的众多问题之一。

## OAuth2.0

书上解释其实一般，但比[云冲印](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)简单

等我看完《OAuth2 实战》再详细写一篇文章。

# 外部化配置

在运行时向服务提供配置属性值，例如数据访问凭据和网络位置。

1. **推送模型**：部署基础设施通过类似操作系统黄精变量或配置文件，将配置属性传递给服务实例。
2. **拉取模型**：服务实例从配置服务器读取它所需要的配置属性。

## 推送模型

推送模型依赖于部署环境和服务的协作。部署环境在创建服务实例时提供配置属性。

Spring Boot 多数据来源

1. 命令行参数
2. SPRING_APPLICATION_JSON
3. JVM 系统属性
4. 操作系统环境变量
5. 当前目录中的配置文件。

推送模型是一种有效且广泛使用的配置服务的机制，它的一个限制是重新配置正在运行的服务可能很难，甚至不可能。

![基于推送的外部化配置.png](https://i.loli.net/2021/05/20/pPeGn5ucfWkZEl1.png)

## 拉取模型

在拉取模型中，服务实例从配置服务器读取其配置属性。

有多种方法可以实现配置服务器，包括：

- 版本控制系统，如 Git
- SQL 和 NoSQL 数据库
- 专用配置服务器，例如 Spring Cloud config Server， Hashicorp Vault（用于存储敏感数据，如访问凭据）和 AWS Parameter Store

![基于拉取的外部化配置.png](https://i.loli.net/2021/05/20/sfjK5OlqBTzIDHb.png)

# 可观测的服务

- 健康检查 API
- 日志聚合
- 分布式跟踪
- 异常跟踪
- 应用程序指标
- 审核日志记录

使用 Spring Boot Actuaor

使用日志聚合 ELK

使用 Zipkin、SkyWalking 也行、Spring Cloud Sleuth 也行。

使用异常跟中，如 HoneyBadger，好像 SkyWalking 也行的。

使用审计日志。使用AOP或者事件溯源。

# 微服务基底

问题

- 外部化配置
- 健康检查
- 应用程序指标
- 服务发现
- 断路器
- 分布式追踪

## 服务网格（Service Mesh）

服务网格

把所有进出服务的网络流量通过一个网络层进行路由，这个网络层负责解决包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量陆游等具有共性的需求。

服务网格是网络基础设施，它调和（mediate）服务与其他服务和外部应用程序之间的通信。

Istio

Linkerd

Conduit

# 流水线式部署

![不同年代部署.png](https://i.loli.net/2021/05/20/uiyfNnLTv2jroxe.png)

## 将服务部署为虚拟机

好处

- 虚拟机镜像封装了技术栈。
- 隔离的服务实例。
- 使用成熟的云计算基础设施。

缺点

- 资源利用效率较低。
- 部署速度相对较慢
- 系统管理的额外开销。

## 将服务部署为容器

![将服务部署为容器.png](https://i.loli.net/2021/05/20/mQlRYLB3v1gu8e9.png)

每个服务实例都是一个容器。

> 将作为容器镜像打包的服务部署到生产环境中。每个服务实例都是一个容器。

创建容器时，可以指定它的 CPU 和内存资源，以及依赖于容器实现的 I/O 资源等。容器运行时强制执行这些限制，并防止容器占用其机器的资源。使用 Docker 编排框架（如 Kubernetes）时，指定容器的资源尤为重要。这是因为编排框架使用容器请求的资源来选择运行容器的底层机器，从而确保机器不会过载。

Dockerfile

```dockerfile
FROM openjdk:8u171-jre-alpine
RUN apk --no-cache add curl
CMD java ${JAVA_OPTS} -jar ftgo-restaurant-service.jar
HEALTHCHECK --start-period=30s --interval=5s CMD curl http://localhost:8080/actuator/health || exit 1
```

二选一

不上传至自己的仓库的
```shell 
docker build -t young1lin/evaluation .

docker run -d --name evaluation -p 8888:8888 young1lin/evaluation
```
上传至自己仓库的
```shell 
docker build -t young1lin/evaluation .

docker tag evaluation young1lin/evaluation:1.0.1.RELEASE

docker push young1lin/evaluation:1.0.1:RELEASE

docker run -d --name evaluation -p 8888:8888 young1lin/evaluation
# 或者
docker run -e "server.port=8080" -d --name evaluation-1 -p 8080:8080 young1lin/evaluation
```

使用 Docker Compose

## 使用 Kubernetes 部署

