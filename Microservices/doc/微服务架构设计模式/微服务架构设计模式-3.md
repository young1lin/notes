# Saga

一种消息驱动的本地事务序列。

Saga 只满足 ACD，隔离性满足不了。

1. 协同式（choreography）
2. 编排式（orchestration）

因为每个服务都有自己的私有数据库，所以要一种机制来保障多数据环境下的数据一致性。

事务补偿机制。

## 分布式事务的挑战

分布式事务管理的事实标准是 X/Open Distributed Transaction Processing (DTP) Model (X/Open XA)。XA 采用了两段提交(two phase commit, 2PC) 来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。应用程序的整个技术栈都要满足 XA 标准。

NoSQL 不支持 XA 标准，RabbitMQ 和 Apache Kafka 也不支持分布式事务。这就要用 Saga 了。

## 使用 Saga 模式维护数据一致性

Saga 是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。一个 Saga 表示需要更新多个服务中数据的一个系统操作。Saga 由一连串本地事务组成。

下面是使用 Saga 来 Create Order。

![Saga Create Order.png](https://i.loli.net/2021/04/12/JvMuRko8f53SL7x.png)这个 Saga 包含了以下鸡哥本地事务

1. Order Service ： 创建一个处于 APPROVAL_PENDING 状态的 Order。
2. Consumer Service ：验证当前订单中的消费者可以下单。
3. Kitchen Service： 验证订单内容，并创建一个后厨工单 Ticket，状态为 CRAETE_PENGIND。
4. Accounting Service： 对消费者提供的信用卡作授权操作。
5. Kitchen serivce：把后厨工单 Ticket 的状态为 AWAITING_ACCEPTANCE。
6. Order Service ： 把 Order 的状态改为 APPROVED。

**Saga 使用补偿事务来回滚所做出的改变**

如果第四步错了，就要明确撤销前三个步骤做的更改。所以必须变成所谓的补偿事务。

做了多少更改，就要做多少补偿。

# Saga 的协调模式

1. 协同式：把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换时间的方式来进行沟通。
2. 编排式：把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。 Saga 编排器发出命令式消息给各个 Saga 参与方，指示这些参与方服务完成具体操作（本地事务）。

## 协同式 Saga

使用协同时，没有一个中央协调器会告诉参与方该做什么。相反，Saga 参与方订阅彼此的事件并做出相应的响应。为了展示基于协同的 Saga 如何运作。

实现协同式的 Create Order Saga

1. Order Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Service 消费 OrderCreated 事件，验证消费者是否可以下订单，并发布 ConsumerVerified 事件。
3. Kitchen Service 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PRNDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreted 事件并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Accounting Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡收费，并发布 CreaditaCardAuthorized 事件。
6. Kitchen Service 消费 CreditCardAuthorized 事件并将 Ticket 的状态更改为 AWAITING_ACCEPTANCE。
7. ORder Service 接受 CreditCardAuthorized 事件，将 Order 的状态更改为 APPROVED，并发布 OrderApproved 事件。



![协同式实现 Create Order Saga.png](https://i.loli.net/2021/04/13/DdBLmskyVIhYn2e.png)

下面是无法授权的案例，及事件顺序。

1. Orders Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Servie 消费 OrderCreated 事件，验证消费者是否可以下单，并发布 ConsumerVerified 事件。
3. Kitchen Serivce 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PENDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreated 事件，并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Account Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡扣款（失败了），并发布 CreaditCardAuthorizationFailed 事件。
6. Kitchen Service 消费 CreditCardAuthorizationFailed 事件，然后把后厨工单 Ticket 的状态更改为 REJECTED。
7. Order Service 消费 CreditCardAuthorizationFailed 事件，并将 Order 的状态更改为 REJECTED。

图就不画了，和上面类似。

协同式 Saga 

好处

1. **简单**
2. **松耦合**

弊端

**更难理解**

**服务之间的循环依赖关系**：Saga 参与方订阅彼此的事件，这通常会导致循环以来关系。

**紧密耦合的风险**

## 编排式 Saga

定义一个编排器类。Saga 编排器使用命令/异步响应方式与 Saga 的参与方通信。

### 实现编排式的 Create Order Saga

下面是流程

1. Saga 编排器向 Consumer Service 发送 Verify Consumer 命令。
2. Consumer Service 回复 Consumer Verified 消息。
3. Saga 编排器向 kitchen Service 发送 Create Ticket 命令。
4. Kitchen Service 回复 Ticket Created 消息。
5. Saga 编排器向 Accounting Service 发送 Authorize Card 消息。
6. Accounting Service 使用 Card Authorized 消息回复。
7. Saga 编排器向 Kitchen Service 发送 Approve Ticket 命令。
8. Saga 编排器向 Order Service 发送 Approve Order 命令。

![编排式实现 Create Order Saga.png](https://i.loli.net/2021/04/14/ENMWA6lqPhQXerL.png)

**把 Saga 编排器视为一个状态机**

状态机式建模 Saga 编排器的一个好办法。状态机由一组状态和一组由事件触发的状态之间转换组成。每个转换都可以有一个动作，对 Saga 来说动作就是某个参与方的调用。状态之间的转换由 Saga 参与方执行的本地事务完成触发。

下面是 Create Order Saga 的状态机模型。包含

- Verifying Consumer ：初始状态。当处于此状态时，该 Saga 正在等待 Consumer Service 验证消费者是否可以下订单。
- Creating Ticket ： 该 Saga 正在等待对 Create Ticket 命令的回复。
- Authorizing Card：等待 Accounting Service 授权消费者的信用卡。
- Order Approved ：最终状态，表示该 Saga 已成功完成。
- Order Rejected ：最终状态，表示 Order 被其中一个参与方拒绝。

![Create Order Saga 的状态机模型.png](https://i.loli.net/2021/04/14/omwD8Ft7rl59xnc.png)

### 使用 Saga 的优点

1. 更简单的依赖关系
2. 较少的耦合
3. 改善关注点隔离，简化业务逻辑

缺点就是

在编排器中存在过多业务逻辑的风险。

# 解决隔离问题

ACD

Atomic：Saga实现确保执行所有事务或撤销所有更改。

Consistency：服务内的参照完整性（referential integrity）由本地数据库处理。服务之间的参照完整性由服务处理。

Durability：由本地数据库处理。

但是隔离性没有。

## 缺乏隔离性导致的问题

- 丢失更新
- 脏读
- 模糊或不可重复读

## 隔离的对策

- 语义锁：应用程序级的锁
- 交换式更新：把更新操作设计成可以按任何顺序执行
- 悲观视图：重新排序 Saga 的步骤，以最大限度地降低业务风险。
- 重读值：通过重写数据来防止脏写，以在覆盖数据之前验证它是否保持不变。
- 版本文件：将更新记录下来，以便可以对它们重新排序。
- 业务风险评级：使用每个请求的业务风险来动态选择并发机制。

Saga 可包含三种类型事务

1. 可补偿性事务：可以使用补偿事务回滚的事务。
2. 关键性事务：Saga 执行过程的关键点。如果关键性事务成功，则 Saga 将一直运行到完成。关键性事务不见得是一个可补偿性事务，或者可重复性事务。但是它们可以是最后一个可补偿的事务或第一个可重复的事务。
3. 可重复性事务：在关键性事务之后的事务，保证成功。

### 语义锁

就是分布式锁呗。锁就是 Order 的 state 或者 Order id。仅且仅能一个程序处理它。

Redission，Zookeeper 之类的。

### 交换式更新

将更新操作设计为可交换的。如果可以按任何顺序执行，操作就是可交换的（commutative）。

### 悲观视图（Pessimistic View）

重新排序 Saga 的步骤，以最大限度地降低由于脏读而导致的业务风险。

### 重读值

乐观锁。

### 版本文件

给业务一个版本号，类似 CAS 解决 ABA 问题那样。还有实现 Kafka 事务的实现那样。

### 业务风险评级

不同业务使用不同策略。

书上讲 Saga 的使用。没用过，不太懂。

# 微服务架构中的业务逻辑设计

## 使用领域模型模式设计业务逻辑

除非是编写一个非常简单的应用程序，否则应该地址编写面向过程代码的诱惑，使用领域模型模式，并进行面向对象的设计。

![聚合 _1_.png](https://i.loli.net/2021/04/25/rlqhbgZBDsPY5ew.png)

识别聚合是关键

## 聚合的规则

1. 只引用聚合根。
2. 聚合间的引用必须使用主键。
3. 在一个事务中，只能创建或更新一个聚合。

## 聚合的颗粒度

聚合不是一成不变的，可以适当调整边界。

![更大的聚合 _1_.png](https://i.loli.net/2021/04/25/gX8FEs4KldNDCYT.png)

# 发布领域事件

事件（Event）这个单词的定义

1. 发生的事情
2. 一件值得注意的事情。
3. 社交场合或活动。
4. 不良或有害的医疗事故，心脏病发作或其他心脏事件。

在领域驱动设计的上下文中，领域事件是聚合发生的事情。它由领域模型中的一个类表示。事件通常代表状态的变化。

## 什么是领域事件

命名领域事件时，往往选择动词的过去分词。

OrderCreated

领域事件通常还具有元数据，例如事件 ID 和时间戳。

### 识别领域事件

当 X 发生时做 Y 之类的语言。

事件风暴。

事件风暴时一种以事件为中心的研讨会，用于理解复杂的领域。

三步骤

1. 头脑风暴：请求领域专家集体讨论领域事件。领域事件由橙色便笺表示，这些便笺在白板上按照事件轴顺序摆放。
2. 识别事件触发器：如
   1. 用户操作，表示为使用蓝色便笺的命令。
   2. 外部系统，由紫色便笺表示
   3. 另一个领域事件
   4. 时间的流逝。
3. 识别聚合：聚合由黄色便笺表示。

### 生成和发布领域事件

从概念上讲，领域事件由聚合负责发布。

可以在聚合内生成对象，然后 Service 层发布生成的事件，也可以搞一个 AbstractAggregateRoot#registerDomainEvent();

**方法一 Service 层发布事件**

**Ticket** 聚合

```java
public class Ticket{
    
    public List<DomainEvent> accept(ZonedDateTime readyBy){
        //...
        this.acceptTime = ZonedDateTime.now();
        this.readyBy = readyBy;
        return singletonList(new TicketAcceptedEvent(readyBy));
    }
    
}
```

**KitchenService**

```java
public class KitchenService{
    
    @Autowired
    private TicketRepository ticketRepository;
    
    @Autowired
    private DomainEventPublisher domainEventPublisher;
    
    public void accept(Long ticketId, ZoneDateTime readyBy){
        Ticket ticket = 
            ticketRepository.findById(ticketId)
            	.orElseThrow(() -> new TicketNotFoundException(ticketId));
        List<DomainEvent> events = ticket.accpet(readyBy);
        domainEventPublisher.publish(Ticket.class, orderId, events);
    }
    
}
```

**方法二 聚合基类发布**

Ticket

```java
public class Ticket extends AbstractAggregateRoot{
    
    public void accept(ZonedDateTime readyBy){
        //...
        this.acceptTime = ZonedDateTime.now();
        this.readyBy = readyBy;
        registerDomainEvent(new TicketAcceptedEvent(readyBy));
    }
    
}
```

## Kitchen Service 的业务逻辑

![Kitchen Service 的设计.png](https://i.loli.net/2021/04/28/ZzJQ4Hvfr5BitIm.png)

KitchenService 服务有三个入站适配器

-  REST API：餐馆工作人员通过他们的用户界面调用这些 REST API。它调用 KitchenService 来创建和更新 Ticket。
- KitchenService CommandHandler：由 Saga 调用的基于异步请求/响应的 API。它调用 KitchenService 来创建和更新 Ticket。
- KitchenServiceEventConsumer：订阅 Resturant Service 发布的事件。它调用 KitchenService 来创建和更新 Restaurant 聚合。

该服务还有两个出站适配器：

- DB Adapter：实现 TicketRepository 和 RestaurantRepository 接口并访问数据库。（书上这里有个作，应该是多打了一个字）
- DomainEventPublishingAdapter：实现 DomainEventPublisher 接口并发布 Ticket 领域事件。

### Ticket 聚合

下面的都是部分代码

```java
@Entity(table = "tickets")
public class Ticket{
    
    @Id
    private Long id;
    
    private TicketState state,=;
    
    private Long restaurantId;
    
    @ElmentCollection
    @CoolectionTable(name = "ticket line items")
    
    private List<TicketLineItem> lineItems;
    
    private ZonedDateTime readyBy;
    
    private ZonedDateTime acceptTime;

    private ZonedDateTime preparingTime;

	private ZonedDateTime pickedUpTime;

    private ZonedDateTime readyForPickupTime;

    //...

}
```

### Ticket 聚合的行为

- accept()： 餐馆已接受订单。
- preparing()：餐馆已开始准备订单，这意味着订单无法再更改或取消。
- readyForPickup()：订单可以派送。

```java
public class Ticket{
    
    public static ResultWithAggregateEvents<Ticket, TicketDomainEvent> 
        create(Long id, TicketDetails details){
        return new ResultWithAggregateEvents<>(new Ticket(id, details),
                                               new TicketCreateEvent(id, details));
    }
    
    public List<TicketPreparationStartedEvent> preparing(){
        switch(state){
            case ACCEPTED:
                this.state = TicketState.PREPARING;
                this.preparingTime = ZonedDateTime.now();
                return singletonList(new TicketPreparationStartedEvent());
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
    public List<TicketDomainEvent> cancel(){
        switch(state){
            case CREATED:
            case ACCEPTED:
                this.state = TicketState.CANCELLED;
                return singletonList(new TicketCancelled());
            case READY_FOR_PICKUP:
                throw new TicketCannotBeCancelledException();
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
}
```

### KitchenService 的领域服务

```java
public class KitchenService{
    
    @Autowired
    private TicketRepository ticketRepository;
    
    @Autowired
    private TicketDomainEventPublisher domainEventPublisher;
    
    public void accept(long ticketId, ZonedDateTime readyBy){
        Ticket ticket = 
            ticketRepository.findById(ticketId)
            .orElseThrow(() -> new TicketNotFoundException(ticketId));
        List<TicketDomainEvent> events = ticket.accept(readyBy);
        domainEventPublisher.publish(ticket, events);
    }
    
}
```

- orderId：要接受订单的 ID。
- readyBy：订单可被派送的预计时间。

### KitchenServiceCommandHandler 类

负责处理 OrderService 实现的各种 Saga 发送的命令式消息。此类每个命令定义一个处理程序方法，该方法调用 KitchenService 来创建或更新 Ticket。

```java
public class KitchenServiceCommandHandler{
    
    @Autowired
    private KitchenService kitchenService;
    
    public CommandHandlers commandHandlers(){
        return CommandHandlerBuilder
            .fromChannel("orderService")
            .onMessage(CreateTicket.class, this::createTicket)
            .onMessage(ConfrimCreateTicket.class, this::confirmCreateTicket)
            .onMessage(CancelCreateTicket.class, this::cancelCreateTicket)
            .build();
    }
    
    private Message createTicket(CommandMessage<CreateTicket> cm){
        CreateTicket command = cm.getCommand();
        long restaurantId = command.getRestaurantId();
        Long ticketId = command.getOrderId();
        TicketDetails ticketDetails = command.getTicketDetails();
        try{
            Ticket ticket =
                kitchenService.createTicket(restaurantId, ticketId, ticketDetails);
            CreateTicketReply reply = new CreateTicketReply(ticket.getId());
            return withSuccess(reply);
        }catch(RestaurantDetailsVerificationException e){
            return withFailure();
        }
    }
    
    private Message confirmCreateTicket(CommandMessage<ConfirmCreateTicket> cm){
        Long ticketId = cm.getCommand().getTicketdId();
        kitchenService.confirmCreateTicket(ticketId);
        return withSuccess();
    }
    
    //...
    
}
```

## Order Service 的业务逻辑

Order Service 提供了用于创建、更新和取消订单的 API。 Order 聚合是 Order Service 的核心聚合。但服务中也包括了 Restaurant 的聚合，这是 Restaurant Service 用哟的部分数据的复制品。它使 Order Service 能够验证 Order 的订单项并为其定价。

又一个用于管理订单的 REST API。它通过多个消息通道与其他服务交换消息和事件。

![image.png](https://i.loli.net/2021/04/30/5BE21u4meArQWFz.png)

## Order 聚合

![Order 聚合 UML 类图.png](https://i.loli.net/2021/04/30/Mz6STCuqsQkWofB.png)

聚合内包含了许多值对象。

值对象——通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。在 DDD 中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。简单来说，值对象本质上就是一个集。**在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计**。

其实这里就是为什么 MongoDB 为什么更适合 DDD 了，因为值对象是没有 ID 的，要么全部更新，要么不更新。

```java
@Entity
@Table(name = "order")
@Accesss(AccessType.FIELD)
public class Order{
    
    @Id
    @GeneratedValue
    private Long id;
    
    /**
     * 乐观锁
     */
    @Version
    private Long version;
    
    private OrderState state;
    
    private Long consumerId;
    
    private Long restaurantId;
    
    @Embedded
    private OrderLineItems orderLineItems;
    
    @Embedded
    private DeliveryInfomation deliveryInfomation;
    
    @Embedded
    private PaymentInfomation paymentInfomation;
    
    @Embedded
    private Money orderMinimum;
    
}
```

这个类映射到 ORDER 表，id 是主键。@Embedded 注解映射到 ORDER 表，并存储到 ORDERS 表对应的列。orderLineItems 字段是包含订单行项的嵌入式对象。Order 聚合包含的不仅仅是字段，还实现了业务逻辑，后者可以由状态机描述。

### Order 聚合状态机

![Order 聚合状态机的一部分.png](https://i.loli.net/2021/05/06/uawZnTU9EVj8vfe.png)

### Order 聚合的方法

```java
public class Order{
    
    // ... 省略部分代码
    
    public static ResultWithDomainEvents<Order, OrderDomainEvent> 
        createOrder(long consumerId, Restaurant restaurant, List<OderLineItem> orderLineItems){
        Order order = new Order(consumerId, restaurant.getId(), OrderLineItems);
        List<OrderDomainEvent> events = singletonList(new OderCreatedEvent(
        new OrderDetails(consumerId, restaurant.getId(), orderLineItems, order.getOrderTotal()),
        restaurant.getName()));
        return new ResultWithDomainEvents<>(order, events);
    }
    
    public Order(OrderDetails orderDetails){
        this.orderLineItems = new OrderLineItems(orderDetails.getLineItems());
        this.orderMinium = orderDetails.getOrderMinimum();
        this.state = APPROCAL_PENDING;
    }
    
    public List<DomainEvent> noteApproved(){
        switch(state){
            case APPROVAL_PENDING:
                this.state = APPROVED;
                return singletonList(new OrderAuthorized());
            // ... 省略其他状态
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
    
    public List<DomainEvent> noteRejected(){
        switch(state){
            case APPROVAL_PENDING:
            	this.state = REJECTED;
                return singletonList(new OrderRejected());
            // ...
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }

}
```

### OrderService 类

```java
@Transactional
public class OrderService{
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RestaurantRepository restaurantRepository;
    
    @Autorwired
    private SagaManager<CreateOrderSagaState, CreateOrderSagaState>
        createOrderSagaManager;
    
    @Autorwired
    private SagaManger<ReviseOrderSagaState, ReviseOrderSagaData>
        reviseOrderSagaManagement;
    
    @Autorwired
    private OrderDomainEventPublisher orderAggredateEventPublisher;
    
    public Order createOrder(OrderDetails orderDetails){
        Restaurant restaurant = restaurantRepository.findById(restaurantId)
            .orElseThrow(() -> new RestaurantNotFoundException(restaurantId));
        List<OrderLineItem> orderLineItems = 
            makeOrderLineItems(lineItems, restaurant);
        ResultWithDomainEvents<Order, OrderDomainEvent> orderAndEvents = 
            Order.createOrder(consumerId, restaurant, orderLineItems);
        Order order = orderAndEvents.result;
        orderRepository.save(order);
        orderAggredateEventPublisher.publish(order, orderAndEvents.events);
        OrderDetails orderDetails = 
            new OrderDetails(consumerId, restaurantId, orderLineItems, order.getOrderTotal());
        CreateOrderSagaState data = new CreateOrderSagaState(order.getId(), orderDetails);
        createorderSagaManger.create(data, Order.class, order.getId());
        return order;
    }
    
    // 书上这里代码有问题，多嵌套了一层
    public Order reviseOrder(Long orderId, Long expectedVersion, OrderRevision orderRevision){
        Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
        ReviseOrderSagaData sagaData = 
            new ReviseOrderSagaData(order.getConsumerId(), orderId, null, orderRevision);
        reviseOrderSagaManager.create(sagaData);
        return order;
    }
    
}
```

# 使用事件溯源开发业务逻辑

 ## 概述

事件溯源是构建业务逻辑和持久化聚合的另一种选择。它将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化。应用程序通过重放（replaying）事件来重新创建聚合的当前状态。

需要 CQRS 模式来配合查询事件存储库。

使用日志拖尾技术来可靠地发布事件。可以利用 MySQL binlog 来发到 Kafka，再去消费。

使用快照提升性能。幂等方式的消息处理。



使用消息 ID 作为幂等性键值，确保消息只被处理一次。

# 在微服务中实现查询

1. API 组合模式：简单。
2. 命令查询职责隔离（CQRS）模式：比上面的更强大，但更复杂。维护了一个或多个视图数据库，唯一目的是支持查询。

# CQRS 模式

MySQL 同步到-> Elasticsearch，然后 Es 查询。

使用事件来维护多个服务复制数据的只读视图，借此来实现对来自多个服务的数据的查询。

CQRS 式这种架构的概括。它维护了一个或多个视图数据库，而不仅仅是文本搜索数据库，进而实现一个或多个应用程序的查询。

通过事件来发布信息。

C U D 一个库，R 一个库。

CQRS 有数据延迟，一个解决方案是命令端和查询端API为客户端提供版本信息，能够判断查询端是否过时。客户端可以轮到查询端的是图，直到它是最新的。version 字段。

## 设计 CQRS 视图

![CQRS 试图模块的设计.png](https://i.loli.net/2021/05/13/QnxyEUY7mi4tIs9.png)

在开发视图模块时，必须做一些设计决策：

- 必须选择合适的底层数据库，并设计数据库结构。
- 在设计数据访问模块时，必须解决各种问题，包括确保更新是幂等的，并且能够处理并发更新。
- 在现有应用程序中实现新视图或更改现有应用程序的模式时，必须实现一种机制，以便有效地构建或重建视图。
- 你必须决定如何设计视图的客户端，以应对前面描述的复制延迟。

DynamoDb 不会啊

# 外部 API 模式

## API Gateway 模式

实现一个服务，该服务是外部 API 客户端进入基于微服务应用程序的入口点。

类似 Facade （外观/门面）模式。

实现边缘功能。含：

- 身份验证
- 访问授权
- 速率限制
- 缓存
- 指标收集
- 请求日志

不同设备由不同 API Gateway 团队维护。简单讲了下 Zuul

Spring Cloud Zuul 使用讲解。

使用 GraphQL

