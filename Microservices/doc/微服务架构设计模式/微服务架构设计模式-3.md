# Saga

一种消息驱动的本地事务序列。

Saga 只满足 ACD，隔离性不要了。

1. 协同式（choreography）
2. 编排式（orchestration）

因为每个服务都有自己的私有数据库，所以要一种机制来保障多数据环境下的数据一致性。

事务补偿机制。

## 分布式事务的挑战

分布式事务管理的事实标准是 X/Open Distributed Transaction Processing (DTP) Model (X/Open XA)。XA 采用了两段提交(two phase commit, 2PC) 来保证事务中的所有参与方同时完成提交，或者在失败时同时回滚。应用程序的整个技术栈都要满足 XA 标准。

NoSQL 不支持 XA 标准，RabbitMQ 和 Apache Kafka 也不支持分布式事务。这就要用 Saga 了。

## 使用 Saga 模式维护数据一致性

Saga 是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。一个 Saga 表示需要更新多个服务中数据的一个系统操作。Saga 由一连串本地事务组成。

下面是使用 Saga 来 Create Order。

![Saga Create Order.png](https://i.loli.net/2021/04/12/JvMuRko8f53SL7x.png)这个 Saga 包含了以下鸡哥本地事务

1. Order Service ： 创建一个处于 APPROVAL_PENDING 状态的 Order。
2. Consumer Service ：验证当前订单中的消费者可以下单。
3. Kitchen Service： 验证订单内容，并创建一个后厨工单 Ticket，状态为 CRAETE_PENGIND。
4. Accounting Service： 对消费者提供的信用卡作授权操作。
5. Kitchen serivce：把后厨工单 Ticket 的状态为 AWAITING_ACCEPTANCE。
6. Order Service ： 把 Order 的状态改为 APPROVED。

**Saga 使用补偿事务来回滚所做出的改变**

如果第四步错了，就要明确撤销前三个步骤做的更改。所以必须变成所谓的补偿事务。

做了多少更改，就要做多少补偿。

# Saga 的协调模式

1. 协同式：把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换时间的方式来进行沟通。
2. 编排式：把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。 Saga 编排器发出命令式消息给各个 Saga 参与方，指示这些参与方服务完成具体操作（本地事务）。

## 协同式 Saga

使用协同时，没有一个中央协调器会告诉参与方该做什么。相反，Saga 参与方订阅彼此的事件并做出相应的响应。为了展示基于协同的 Saga 如何运作。

实现协同式的 Create Order Saga

1. Order Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Service 消费 OrderCreated 事件，验证消费者是否可以下订单，并发布 ConsumerVerified 事件。
3. Kitchen Service 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PRNDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreted 事件并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Accounting Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡收费，并发布 CreaditaCardAuthorized 事件。
6. Kitchen Service 消费 CreditCardAuthorized 事件并将 Ticket 的状态更改为 AWAITING_ACCEPTANCE。
7. ORder Service 接受 CreditCardAuthorized 事件，将 Order 的状态更改为 APPROVED，并发布 OrderApproved 事件。



![协同式实现 Create Order Saga.png](https://i.loli.net/2021/04/13/DdBLmskyVIhYn2e.png)

下面是无法授权的案例，及事件顺序。

1. Orders Service 创建一个处于 APPROVAL_PENDING 状态的 Order 并发布 OrderCreated 事件。
2. Consumer Servie 消费 OrderCreated 事件，验证消费者是否可以下单，并发布 ConsumerVerified 事件。
3. Kitchen Serivce 消费 OrderCreated 事件，验证 Order，创建一个处于 CREATE_PENDING 状态的后厨工单 Ticket，并发布 TicketCreated 事件。
4. Accounting Service 消费 OrderCreated 事件，并创建一个处于 PENDING 状态的 CreditCard Authorization。
5. Account Service 消费 TicketCreated 和 ConsumerVerified 事件，向消费者的信用卡扣款（失败了），并发布 CreaditCardAuthorizationFailed 事件。
6. Kitchen Service 消费 CreditCardAuthorizationFailed 事件，然后把后厨工单 Ticket 的状态更改为 REJECTED。
7. Order Service 消费 CreditCardAuthorizationFailed 事件，并将 Order 的状态更改为 REJECTED。

图就不画了，和上面类似。

协同式 Saga 

好处

1. **简单**
2. **松耦合**

弊端

**更难理解**

**服务之间的循环依赖关系**：Saga 参与方订阅彼此的事件，这通常会导致循环以来关系。

**紧密耦合的风险**

## 编排式 Saga

定义一个编排器类。Saga 编排器使用命令/异步响应方式与 Saga 的参与方通信。

### 实现编排式的 Create Order Saga

下面是流程

1. Saga 编排器向 Consumer Service 发送 Verify Consumer 命令。
2. Consumer Service 回复 Consumer Verified 消息。
3. Saga 编排器向 kitchen Service 发送 Create Ticket 命令。
4. Kitchen Service 回复 Ticket Created 消息。
5. Saga 编排器向 Accounting Service 发送 Authorize Card 消息。
6. Accounting Service 使用 Card Authorized 消息回复。
7. Saga 编排器向 Kitchen Service 发送 Approve Ticket 命令。
8. Saga 编排器向 Order Service 发送 Approve Order 命令。

![编排式实现 Create Order Saga.png](https://i.loli.net/2021/04/14/ENMWA6lqPhQXerL.png)

**把 Saga 编排器视为一个状态机**

状态机式建模 Saga 编排器的一个好办法。状态机由一组状态和一组由事件触发的状态之间转换组成。每个转换都可以有一个动作，对 Saga 来说动作就是某个参与方的调用。状态之间的转换由 Saga 参与方执行的本地事务完成触发。

下面是 Create Order Saga 的状态机模型。包含

- Verifying Consumer ：初始状态。当处于此状态时，该 Saga 正在等待 Consumer Service 验证消费者是否可以下订单。
- Creating Ticket ： 该 Saga 正在等待对 Create Ticket 命令的回复。
- Authorizing Card：等待 Accounting Service 授权消费者的信用卡。
- Order Approved ：最终状态，表示该 Saga 已成功完成。
- Order Rejected ：最终状态，表示 Order 被其中一个参与方拒绝。

![Create Order Saga 的状态机模型.png](https://i.loli.net/2021/04/14/omwD8Ft7rl59xnc.png)

### 使用 Saga 的优点

1. 更简单的依赖关系
2. 较少的耦合
3. 改善关注点隔离，简化业务逻辑

缺点就是

在编排器中存在过多业务逻辑的风险。

# 解决隔离问题

ACD

Atomic：Saga实现确保执行所有事务或撤销所有更改。

Consistency：服务内的参照完整性（referential integrity）由本地数据库处理。服务之间的参照完整性由服务处理。

Durability：由本地数据库处理。

但是隔离性没有。

## 缺乏隔离性导致的问题

- 丢失更新
- 脏读
- 模糊或不可重复读



