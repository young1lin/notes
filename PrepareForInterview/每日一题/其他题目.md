# 其他题目

Owner: lin young

- **[2682. 找出转圈游戏输家](https://leetcode.cn/problems/find-the-losers-of-the-circular-game/)**
    
    `n` 个朋友在玩游戏。这些朋友坐成一个圈，按 **顺时针方向** 从 `1` 到 `n` 编号。从第 `i` 个朋友的位置开始顺时针移动 `1` 步会到达第 `(i + 1)` 个朋友的位置（`1 <= i < n`），而从第 `n` 个朋友的位置开始顺时针移动 `1` 步会回到第 `1` 个朋友的位置。
    
    游戏规则如下：
    
    第 `1` 个朋友接球。
    
    - 接着，第 `1` 个朋友将球传给距离他顺时针方向 `k` 步的朋友。
    - 然后，接球的朋友应该把球传给距离他顺时针方向 `2 * k` 步的朋友。
    - 接着，接球的朋友应该把球传给距离他顺时针方向 `3 * k` 步的朋友，以此类推。
    
    换句话说，在第 `i` 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 `i * k` 步的朋友。
    
    当某个朋友第 2 次接到球时，游戏结束。
    
    在整场游戏中没有接到过球的朋友是 **输家** 。
    
    给你参与游戏的朋友数量 `n` 和一个整数 `k` ，请按升序排列返回包含所有输家编号的数组 `answer` 作为答案。
    
    **示例 1：**
    
    ```
    输入：n = 5, k = 2
    输出：[4,5]
    解释：以下为游戏进行情况：
    1）第 1 个朋友接球，第1 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。
    2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。
    3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。
    4）第 3 个朋友接到两次球，游戏结束。
    
    ```
    
    **示例 2：**
    
    ```
    输入：n = 4, k = 4
    输出：[2,3,4]
    解释：以下为游戏进行情况：
    1）第 1 个朋友接球，第1 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 1 个朋友。
    2）第 1 个朋友接到两次球，游戏结束。
    ```
    
    ```java
    class Solution {
    
        public int[] circularGameLosers(int n, int k) {
            Map<Integer, Boolean> alreadyRecive = new HashMap<>(n);
            int currentNum = 1;
            int steps = 1;
            while (alreadyRecive.get(currentNum) == null) {
                alreadyRecive.put(currentNum, Boolean.TRUE);
                currentNum += steps * k;
                steps++;
                while (currentNum > n) {
                    currentNum = currentNum - n;
                }
            }
            ArrayList<Integer> result = new ArrayList<>();
            for (int i = 1; i <= n; i++) {
                if (alreadyRecive.get(i) == null) {
                    result.add(i);
                }
            }
            int[] resultArr = new int[result.size()];
            for (int i = 0; i < result.size(); i++) {
                resultArr[i] = result.get(i);
            }
            return resultArr;
        }
    
    }
    ```
    
- **[2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)**
    
    给你两个字符串 `start` 和 `target` ，长度均为 `n` 。每个字符串 **仅** 由字符 `'L'`、`'R'` 和 `'_'` 组成，其中：
    
    - 字符 `'L'` 和 `'R'` 表示片段，其中片段 `'L'` 只有在其左侧直接存在一个 **空位** 时才能向 **左** 移动，而片段 `'R'` 只有在其右侧直接存在一个 **空位** 时才能向 **右** 移动。
    - 字符 `'_'` 表示可以被 **任意** `'L'` 或 `'R'` 片段占据的空位。
    
    如果在移动字符串 `start` 中的片段任意次之后可以得到字符串 `target` ，返回 `true` ；否则，返回 `false` 。
    
    **示例 1：**
    
    ```
    输入：start = "_L__R__R_", target = "L______RR"
    输出：true
    解释：可以从字符串 start 获得 target ，需要进行下面的移动：
    - 将第一个片段向左移动一步，字符串现在变为 "L___R__R_" 。
    - 将最后一个片段向右移动一步，字符串现在变为 "L___R___R" 。
    - 将第二个片段向右移动散步，字符串现在变为 "L______RR" 。
    可以从字符串 start 得到 target ，所以返回 true 。
    
    ```
    
    **示例 2：**
    
    ```
    输入：start = "R_L_", target = "__LR"
    输出：false
    解释：字符串 start 中的 'R' 片段可以向右移动一步得到 "_RL_" 。
    但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。
    
    ```
    
    **示例 3：**
    
    ```
    输入：start = "_R", target = "R_"
    输出：false
    解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。
    ```
    
    **提示：**
    
    - `n == start.length == target.length`
    - `1 <= n <= 105`
    - `start` 和 `target` 由字符 `'L'`、`'R'` 和 `'_'` 组成
    
    ```java
    class Solution {
    
        public boolean canChange(String start, String target) {
            int sIndex = 0;
            int tIndex = 0;
            char[] sCharArr = start.toCharArray();
            char[] tCharArr = target.toCharArray();
            int len = sCharArr.length;
            while (sIndex < len && tIndex < len) {
                while (sIndex < len && sCharArr[sIndex] == '_') {
                    sIndex++;
                }
                while(tIndex < len && tCharArr[tIndex] == '_') {
                    tIndex++;
                }
                if (sIndex < len && tIndex < len) {
                    if (sCharArr[sIndex] != tCharArr[tIndex]) {
                        return false;
                    }
                    if((sCharArr[sIndex] == 'L' && sIndex < tIndex) || (sCharArr[sIndex] == 'R' && sIndex > tIndex)) {
                        return false;
                    }
                    sIndex++;
                    tIndex++;
                }
            }
            while (sIndex < len) {
                if (sCharArr[sIndex] != '_') {
                    return false;
                }
                sIndex++;
            }
            while (tIndex < len) {
                if (tCharArr[tIndex] != '_') {
                    return false;
                }
                tIndex++;
            }
            return true;        
        }
    
    }
    ```
    
- **[321. 拼接最大数](https://leetcode.cn/problems/create-maximum-number/)**
    
    给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。
    
    求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。
    
    **说明:** 请尽可能地优化你算法的时间和空间复杂度。
    
    **示例 1:**
    
    ```
    输入:
    nums1 =[3, 4, 6, 5]
    nums2 =[9, 1, 2, 5, 8, 3]
    k =5输出:[9, 8, 6, 5, 3]
    ```
    
    **示例 2:**
    
    ```
    输入:
    nums1 =[6, 7]
    nums2 =[6, 0, 4]
    k =5输出:[6, 7, 6, 0, 4]
    ```
    
    **示例 3:**
    
    ```
    输入:
    nums1 =[3, 9]
    nums2 =[8, 9]
    k =3输出:[9, 8, 9]
    ```
    
    ```java
    class Solution {
        public int[] maxNumber(int[] nums1, int[] nums2, int k) {
            int m = nums1.length, n = nums2.length;
            int[] maxSubsequence = new int[k];
            int start = Math.max(0, k - n), end = Math.min(k, m);
            for (int i = start; i <= end; i++) {
                int[] subsequence1 = maxSubsequence(nums1, i);
                int[] subsequence2 = maxSubsequence(nums2, k - i);
                int[] curMaxSubsequence = merge(subsequence1, subsequence2);
                if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {
                    System.arraycopy(curMaxSubsequence, 0, maxSubsequence, 0, k);
                }
            }
            return maxSubsequence;
        }
    
        public int[] maxSubsequence(int[] nums, int k) {
            int length = nums.length;
            int[] stack = new int[k];
            int top = -1;
            int remain = length - k;
            for (int i = 0; i < length; i++) {
                int num = nums[i];
                while (top >= 0 && stack[top] < num && remain > 0) {
                    top--;
                    remain--;
                }
                if (top < k - 1) {
                    stack[++top] = num;
                } else {
                    remain--;
                }
            }
            return stack;
        }
    
        public int[] merge(int[] subsequence1, int[] subsequence2) {
            int x = subsequence1.length, y = subsequence2.length;
            if (x == 0) {
                return subsequence2;
            }
            if (y == 0) {
                return subsequence1;
            }
            int mergeLength = x + y;
            int[] merged = new int[mergeLength];
            int index1 = 0, index2 = 0;
            for (int i = 0; i < mergeLength; i++) {
                if (compare(subsequence1, index1, subsequence2, index2) > 0) {
                    merged[i] = subsequence1[index1++];
                } else {
                    merged[i] = subsequence2[index2++];
                }
            }
            return merged;
        }
    
        public int compare(int[] subsequence1, int index1, int[] subsequence2, int index2) {
            int x = subsequence1.length, y = subsequence2.length;
            while (index1 < x && index2 < y) {
                int difference = subsequence1[index1] - subsequence2[index2];
                if (difference != 0) {
                    return difference;
                }
                index1++;
                index2++;
            }
            return (x - index1) - (y - index2);
        }
    }
    ```
    
- **[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)**
    
    请你为 [最不经常使用（LFU）](https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95)缓存算法设计并实现数据结构。
    
    实现 `LFUCache` 类：
    
    - `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
    - `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `1` 。
    - `void put(int key, int value)` - 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最近最久未使用** 的键。
    
    为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。
    
    当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。
    
    函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。
    
    **示例：**
    
    ```
    输入：
    ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
    [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
    输出：
    [null, null, null, 1, null, -1, 3, null, -1, 3, 4]
    
    解释：
    // cnt(x) = 键 x 的使用计数
    // cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
    LFUCache lfu = new LFUCache(2);
    lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
    lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
    lfu.get(1);      // 返回 1
                     // cache=[1,2], cnt(2)=1, cnt(1)=2
    lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                     // cache=[3,1], cnt(3)=1, cnt(1)=2
    lfu.get(2);      // 返回 -1（未找到）
    lfu.get(3);      // 返回 3
                     // cache=[3,1], cnt(3)=2, cnt(1)=2
    lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                     // cache=[4,3], cnt(4)=1, cnt(3)=2
    lfu.get(1);      // 返回 -1（未找到）
    lfu.get(3);      // 返回 3
                     // cache=[3,4], cnt(4)=1, cnt(3)=3
    lfu.get(4);      // 返回 4
                     // cache=[3,4], cnt(4)=2, cnt(3)=3
    ```
    
    **提示：**
    
    - `1 <= capacity <= 104`
    - `0 <= key <= 105`
    - `0 <= value <= 109`
    - 最多调用 `2 * 105` 次 `get` 和 `put` 方法
    
    ```java
    class LFUCache {
        int minfreq, capacity;
        Map<Integer, Node> keyTable;
        Map<Integer, DoublyLinkedList> freqTable;
    
        public LFUCache(int capacity) {
            this.minfreq = 0;
            this.capacity = capacity;
            keyTable = new HashMap<Integer, Node>();
            freqTable = new HashMap<Integer, DoublyLinkedList>();
        }
        
        public int get(int key) {
            if (capacity == 0) {
                return -1;
            }
            if (!keyTable.containsKey(key)) {
                return -1;
            }
            Node node = keyTable.get(key);
            int val = node.val, freq = node.freq;
            freqTable.get(freq).remove(node);
            // 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq
            if (freqTable.get(freq).size == 0) {
                freqTable.remove(freq);
                if (minfreq == freq) {
                    minfreq += 1;
                }
            }
            // 插入到 freq + 1 中
            DoublyLinkedList list = freqTable.getOrDefault(freq + 1, new DoublyLinkedList());
            list.addFirst(new Node(key, val, freq + 1));
            freqTable.put(freq + 1, list);
            keyTable.put(key, freqTable.get(freq + 1).getHead());
            return val;
        }
        
        public void put(int key, int value) {
            if (capacity == 0) {
                return;
            }
            if (!keyTable.containsKey(key)) {
                // 缓存已满，需要进行删除操作
                if (keyTable.size() == capacity) {
                    // 通过 minFreq 拿到 freqTable[minFreq] 链表的末尾节点
                    Node node = freqTable.get(minfreq).getTail();
                    keyTable.remove(node.key);
                    freqTable.get(minfreq).remove(node);
                    if (freqTable.get(minfreq).size == 0) {
                        freqTable.remove(minfreq);
                    }
                }
                DoublyLinkedList list = freqTable.getOrDefault(1, new DoublyLinkedList());
                list.addFirst(new Node(key, value, 1));
                freqTable.put(1, list);
                keyTable.put(key, freqTable.get(1).getHead());
                minfreq = 1;
            } else {
                // 与 get 操作基本一致，除了需要更新缓存的值
                Node node = keyTable.get(key);
                int freq = node.freq;
                freqTable.get(freq).remove(node);
                if (freqTable.get(freq).size == 0) {
                    freqTable.remove(freq);
                    if (minfreq == freq) {
                        minfreq += 1;
                    }
                }
                DoublyLinkedList list = freqTable.getOrDefault(freq + 1, new DoublyLinkedList());
                list.addFirst(new Node(key, value, freq + 1));
                freqTable.put(freq + 1, list);
                keyTable.put(key, freqTable.get(freq + 1).getHead());
            }
        }
    }
    
    class Node {
        int key, val, freq;
        Node prev, next;
    
        Node() {
            this(-1, -1, 0);
        }
    
        Node(int key, int val, int freq) {
            this.key = key;
            this.val = val;
            this.freq = freq;
        }
    }
    
    class DoublyLinkedList {
        Node dummyHead, dummyTail;
        int size;
    
        DoublyLinkedList() {
            dummyHead = new Node();
            dummyTail = new Node();
            dummyHead.next = dummyTail;
            dummyTail.prev = dummyHead;
            size = 0;
        }
    
        public void addFirst(Node node) {
            Node prevHead = dummyHead.next;
            node.prev = dummyHead;
            dummyHead.next = node;
            node.next = prevHead;
            prevHead.prev = node;
            size++;
        }
    
        public void remove(Node node) {
            Node prev = node.prev, next = node.next;
            prev.next = next;
            next.prev = prev;
            size--;
        }
    
        public Node getHead() {
            return dummyHead.next;
        }
    
        public Node getTail() {
            return dummyTail.prev;
        }
    }
    ```