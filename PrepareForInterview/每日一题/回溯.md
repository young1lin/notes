# 回溯

Owner: lin young

- ****[1681. 最小不兼容性](https://leetcode.cn/problems/minimum-incompatibility/)（待细品）求组和的，这题应该算回溯里的**
    
    ```java
    class Solution {
        int result = Integer.MAX_VALUE;
        public int minimumIncompatibility(int[] nums, int k) {
            
            Arrays.sort(nums);
            Bucket[] buckets = new Bucket[k];
            for (int i = 0; i < k; ++i)
                buckets[i] = new Bucket();
            int bucketSize = nums.length / k;
            dfs(nums, 0, 0, buckets, bucketSize);
            return result == Integer.MAX_VALUE ? -1 : result;
        }
        
        private void dfs (int[] nums, int index, int sum, Bucket[] buckets, int bucketSize){
            
            if (index == nums.length){
                result = sum;
                return;
            }
            int num = nums[index];
            int currentSize = bucketSize;
            
            for (Bucket bucket : buckets){
                if (bucket.size == currentSize || bucket.max == num)
                    continue;
                    
                currentSize = bucket.size;
                int delta = currentSize == 0? 0: num - bucket.max;           
                if (sum + delta >= result)
                    return;
                    
                int prevMax = bucket.max;    
                bucket.max = num;
                bucket.size++; 
    
                dfs(nums, index + 1, sum + delta, buckets, bucketSize);
                
                bucket.size--;
                bucket.max = prevMax;
            }
        }
    
        class Bucket {
            int size = 0;
            int max = 0;
            Bucket(){}
        }    
    }
    ```
    
- ****[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)****
    
    给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
    
    示例 1：
    
    输入：n = 3
    输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
    示例 2：
    
    输入：n = 1
    输出：[[1]]
    
    提示：
    
    1 <= n <= 8
    
    ```mathematica
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
    
        public List<TreeNode> generateTrees(int n) {
            return generateTrees(1, n);
        }
       
        private List<TreeNode> generateTrees(int start, int end) {
            List<TreeNode> allTrees = new LinkedList<TreeNode>();
            if (start > end) {
                allTrees.add(null);
                return allTrees;
            }
    
            // 枚举可行根节点
            for (int i = start; i <= end; i++) {
                // 获得所有可行的左子树集合
                List<TreeNode> leftTrees = generateTrees(start, i - 1);
    
                // 获得所有可行的右子树集合
                List<TreeNode> rightTrees = generateTrees(i + 1, end);
    
                // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
                for (TreeNode left : leftTrees) {
                    for (TreeNode right : rightTrees) {
                        TreeNode currTree = new TreeNode(i);
                        currTree.left = left;
                        currTree.right = right;
                        allTrees.add(currTree);
                    }
                }
            }
            return allTrees;
        }
    
    }
    ```
    
- **[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)**
    
    给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
    
    **叶子节点** 是指没有子节点的节点。
    
    **示例 1：**
    
    ![https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)
    
    ```
    输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
    输出：[[5,4,11,2],[5,8,4,5]]
    
    ```
    
    **示例 2：**
    
    ![https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)
    
    ```
    输入：root = [1,2,3], targetSum = 5
    输出：[]
    
    ```
    
    **示例 3：**
    
    ```
    输入：root = [1,2], targetSum = 0
    输出：[]
    
    ```
    
    **提示：**
    
    - 树中节点总数在范围 `[0, 5000]` 内
    - `1000 <= Node.val <= 1000`
    - `1000 <= targetSum <= 1000`
    
    ```java
    **/**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
        
        private List<List<Integer>> result = new ArrayList<>();
    
        private int targetSum;
    
        public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
            if (root == null) {
                return result;
            }
            this.targetSum = targetSum;
            LinkedList<Integer> path = new LinkedList<>();
            backtrack(root, 0, path);
            return result;
        }
    
        private void backtrack(TreeNode root, int currentSum, LinkedList<Integer> path) {
            if (root == null) {
                return;
            }
            path.add(root.val);
            currentSum += root.val;
            if (root.left == null && root.right == null && currentSum == targetSum) {
                result.add(new LinkedList<>(path));
            }
            backtrack(root.left, currentSum, path);
            backtrack(root.right, currentSum, path);
            path.removeLast();
        }
    
    }**
    ```
    
- **[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)**
    
    ```java
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
    
        private List<List<Integer>> allPath = new LinkedList<>();
    
        public int sumNumbers(TreeNode root) {
            sum(root, new LinkedList<>());
            return trans(allPath);
        }
    
        private void sum(TreeNode root, LinkedList<Integer> path) {
            if (root == null) {
                return;
            }
            int val = root.val;
            path.add(val);
            if (isLeafNode(root)) {
                allPath.add(new ArrayList<>(path));
            }
            sum(root.left, path);
            sum(root.right, path);
            path.removeLast();
        }
    
        private boolean isLeafNode(TreeNode root) {
            return root.left == null && root.right == null;
        }
    
        private int trans(List<List<Integer>> allPath) {
            int result = 0;
            for (List<Integer> path : allPath) {
                int size = path.size();
                for (int i = 0; i < path.size(); i++) {
                    size--;
                    int val = path.get(i);
                    result += Math.pow(10, size) * val;
                }
            }
            return result;
        }
    
    }
    class Solution1 {
        public int sumNumbers(TreeNode root) {
            return dfs(root, 0);
        }
    
        public int dfs(TreeNode root, int prevSum) {
            if (root == null) {
                return 0;
            }
            int sum = prevSum * 10 + root.val;
            if (root.left == null && root.right == null) {
                return sum;
            } else {
                return dfs(root.left, sum) + dfs(root.right, sum);
            }
        }
    }
    ```