# 递归

Owner: lin young

- ****[递枕头](https://leetcode.cn/problems/pass-the-pillow/)****
    
    n 个人站成一排，按从 1 到 n 编号。
    
    最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。
    
    例如，当枕头到达第 n 个人时，TA 会将枕头传递给第 n - 1 个人，然后传递给第 n - 2 个人，依此类推。
    给你两个正整数 n 和 time ，返回 time 秒后拿着枕头的人的编号。
    
    示例 1：
    
    输入：n = 4, time = 5
    输出：2
    解释：队伍中枕头的传递情况为：1 -> 2 -> 3 -> 4 -> 3 -> 2 。
    5 秒后，枕头传递到第 2 个人手中。
    示例 2：
    
    输入：n = 3, time = 2
    输出：3
    解释：队伍中枕头的传递情况为：1 -> 2 -> 3 。
    2 秒后，枕头传递到第 3 个人手中。
    
    ```java
    class Solution {
    
        public int passThePillow(int n, int time) {
            int rounds = time/(n-1); // how many rounds have we passed back and forth
            int k = time % (n-1); // index starting from left or right at the last round
            return rounds % 2 == 0 ? k+1 : n - k;
        }
    
    }
    ```
    
- [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)（1）
    
    给你一个二叉树的根节点 root ， 检查它是否轴对称。
    
    示例 1：
    
    输入：root = [1,2,2,3,4,4,3]
    输出：true
    示例 2：
    
    输入：root = [1,2,2,null,3,null,3]
    输出：false
    
    提示：
    
    树中节点数目在范围 [1, 1000] 内
    -100 <= Node.val <= 100
    
    进阶：你可以运用递归和迭代两种方法解决这个问题吗？
    
    ```java
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
    
        public boolean isSymmetric(TreeNode root) {
            if (root == null) {
                return true;
            }
            return isSymmetric(root.left, root.right);
        }
    
        public boolean isSymmetric(TreeNode left, TreeNode right) {
            if (left == null && right == null) {
                return true;
            }
            if (left != null && right != null && left.val == right.val) {
                return isSymmetric(left.right, right.left) && isSymmetric(right.right, left.left);
            }
            return false;
        }
        
    }
    ```
    
- ****[数组归约运算](https://leetcode.cn/problems/array-reduce-transformation/)****（1）
    
    请你编写一个函数，它的参数为一个整数数组 nums 、一个计算函数 fn 和初始值 init 。返回一个数组 归约后 的值。
    
    你可以定义一个数组 归约后 的值，然后应用以下操作： val = fn(init, nums[0]) ， val = fn(val, nums[1]) ， val = fn(val, nums[2]) ，... 直到数组中的每个元素都被处理完毕。返回 val 的最终值。
    
    如果数组的长度为 0，它应该返回 init 的值。
    
    请你在不使用内置数组方法的 Array.reduce 前提下解决这个问题。
    
    ```
    示例 1：
    
    输入：
    nums = [1,2,3,4]
    fn = function sum(accum, curr) { return accum + curr; }
    init = 0
    输出：10
    解释：
    初始值为 init=0 。
    (0) + nums[0] = 1
    (1) + nums[1] = 3
    (3) + nums[2] = 6
    (6) + nums[3] = 10
    Val 最终值为 10。
    示例 2：
    
    输入：
    nums = [1,2,3,4]
    fn = function sum(accum, curr) { return accum + curr * curr; }
    init = 100
    输出：130
    解释：
    初始值为 init=0 。
    (100) + nums[0]^2 = 101
    (101) + nums[1]^2 = 105
    (105) + nums[2]^2 = 114
    (114) + nums[3]^2 = 130
    Val 最终值为 130。
    示例3:
    
    输入：
    nums = []
    fn = function sum(accum, curr) { return 0; }
    init = 25
    输出：25
    解释：这是一个空数组，所以返回 init 。
    
    提示：
    
    0 <= nums.length <= 1000
    0 <= nums[i] <= 1000
    0 <= init <= 1000
    ```
    
- ****[递归乘法](https://leetcode.cn/problems/recursive-mulitply-lcci/)****（2）
    
    递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
    
    示例1:
    
    输入：A = 1, B = 10
    输出：10
    示例2:
    
    输入：A = 3, B = 4
    输出：12
    提示:
    
    保证乘法范围不会溢出
    
    ```
    class Solution {
    
        public int multiply(int A, int B) {
            if (B == 1) {
                return A;
            } 
            return A + multiply(A, B - 1);
        }
    
    }
    ```
    
- ****[传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/)（这不是简单题，使用动态规划、或者 DFS 才能解开）**（3）
    
    小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
    
    有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
    每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
    每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
    给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
    
    示例 1：
    
    输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
    
    输出：3
    
    解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。
    
    示例 2：
    
    输入：n = 3, relation = [[0,2],[2,1]], k = 2
    
    输出：0
    
    解释：信息不能从小 A 处经过 2 轮传递到编号 2
    
    限制：
    
    2 <= n <= 10
    1 <= k <= 5
    1 <= relation.length <= 90, 且 relation[i].length == 2
    0 <= relation[i][0],relation[i][1] < n 且 relation[i][0] != relation[i][1]
    
    ```java
    class Solution {
    
        int ways, n, k;
        List<List<Integer>> edges;
    
        public int numWays(int n, int[][] relation, int k) {
            ways = 0;
            this.n = n;
            this.k = k;
            edges = new ArrayList<List<Integer>>(n);
            for (int i = 0; i < n; i++) {
                edges.add(new LinkedList<>());
            }
    
            for (int[] arr : relation) {
                edges.get(arr[0]).add(arr[1]);
            }
            dfs(0, 0);
            return ways;
        }
    
        public void dfs(int index, int steps) {
            if (steps == k) {
                if (index == n - 1) {
                    ways++;
                }
                return;
            }
            List<Integer> list = edges.get(index);
            for (int nextIndex : list) {
                dfs(nextIndex, steps + 1);
            }
        }
    
    }
    ```
    
- ****[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)****（2）
    
    给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
    
    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。
    返回 nums 构建的 最大二叉树 。
    
    ![https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)
    
    ```
    示例 1：
    
    输入：nums = [3,2,1,6,0,5]
    输出：[6,3,5,null,2,0,null,null,1]
    解释：递归调用如下所示：
    
    - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
        - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
            - 空数组，无子节点。
            - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
                - 空数组，无子节点。
                - 只有一个元素，所以子节点是一个值为 1 的节点。
        - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
            - 只有一个元素，所以子节点是一个值为 0 的节点。
            - 空数组，无子节点。
            示例 2：
    
    输入：nums = [3,2,1]
    输出：[3,null,2,null,1]
    
    提示：
    
    1 <= nums.length <= 1000
    0 <= nums[i] <= 1000
    nums 中的所有整数 互不相同
    ```
    
    ![https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)
    
    ```java
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
    
        public TreeNode constructMaximumBinaryTree(int[] nums) {
            return findMaxTreeNode(nums, 0, nums.length - 1);
        }
    
        private TreeNode findMaxTreeNode(int[] nums, int left, int right) {
            if (left > right) {
                return null;
            }
            int maxVlueIndex = left; 
            for (int i = left + 1; i <= right ; i++) {
                if (nums[maxVlueIndex] < nums[i]) {
                    maxVlueIndex = i;
                }
            }
    
            TreeNode root = new TreeNode(nums[maxVlueIndex]);
            root.left = findMaxTreeNode(nums, left, maxVlueIndex - 1);
            root.right= findMaxTreeNode(nums, maxVlueIndex + 1, right);
            return root;
        }
    
    }
    
    ```
    
    - 单调栈解决
        
        方法二：单调栈
        思路与算法
        
        我们可以将题目中构造树的过程等价转换为下面的构造过程：
        
        初始时，我们只有一个根节点，其中存储了整个数组；
        
        在每一步操作中，我们可以「任选」一个存储了超过一个数的节点，找出其中的最大值并存储在该节点。最大值左侧的数组部分下放到该节点的左子节点，右侧的数组部分下放到该节点的右子节点；
        
        如果所有的节点都恰好存储了一个数，那么构造结束。
        
        由于最终构造出的是一棵树，因此无需按照题目的要求「递归」地进行构造，而是每次可以「任选」一个节点进行构造。这里可以类比一棵树的「深度优先搜索」和「广度优先搜索」，二者都可以起到遍历整棵树的效果。
        
        既然可以任意进行选择，那么我们不妨每次选择数组中最大值最大的那个节点进行构造。这样一来，我们就可以保证按照数组中元素降序排序的顺序依次构造每个节点。因此：
        
        当我们选择的节点中数组的最大值为
        nums
        [
        �
        ]
        nums[i] 时，所有大于
        nums
        [
        �
        ]
        nums[i] 的元素已经被构造过（即被单独放入某一个节点中），所有小于
        nums
        [
        �
        ]
        nums[i] 的元素还没有被构造过。
        
        这就说明：
        
        在最终构造出的树上，以
        nums
        [
        �
        ]
        nums[i] 为根节点的子树，在原数组中对应的区间，左边界为
        nums
        [
        �
        ]
        nums[i] 左侧第一个比它大的元素所在的位置，右边界为
        nums
        [
        �
        ]
        nums[i] 右侧第一个比它大的元素所在的位置。左右边界均为开边界。
        
        如果某一侧边界不存在，则那一侧边界为数组的边界。如果两侧边界均不存在，说明其为最大值，即根节点。
        
        并且：
        
        nums
        [
        �
        ]
        nums[i] 的父结点是两个边界中较小的那个元素对应的节点。
        
        因此，我们的任务变为：找出每一个元素左侧和右侧第一个比它大的元素所在的位置。这就是一个经典的单调栈问题了，可以参考 503. 下一个更大元素 II。如果左侧的元素较小，那么该元素就是左侧元素的右子节点；如果右侧的元素较小，那么该元素就是右侧元素的左子节点。
        
        代码
        
        C++JavaC#Python3CJavaScriptGolang
        
        class Solution {
        public TreeNode constructMaximumBinaryTree(int[] nums) {
        int n = nums.length;
        Deque<Integer> stack = new ArrayDeque<Integer>();
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(left, -1);
        Arrays.fill(right, -1);
        TreeNode[] tree = new TreeNode[n];
        for (int i = 0; i < n; ++i) {
        tree[i] = new TreeNode(nums[i]);
        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
        right[stack.pop()] = i;
        }
        if (!stack.isEmpty()) {
        left[i] = stack.peek();
        }
        stack.push(i);
        }
        
        ```
            TreeNode root = null;
            for (int i = 0; i < n; ++i) {
                if (left[i] == -1 && right[i] == -1) {
                    root = tree[i];
                } else if (right[i] == -1 || (left[i] != -1 && nums[left[i]] < nums[right[i]])) {
                    tree[left[i]].right = tree[i];
                } else {
                    tree[right[i]].left = tree[i];
                }
            }
            return root;
        }
        
        ```
        
        }
        我们还可以把最后构造树的过程放进单调栈求解的步骤中，省去用来存储左右边界的数组。下面的代码理解起来较为困难，同一个节点的左右子树会被多次赋值，读者可以仔细品味其妙处所在。
        
        C++JavaC#Python3CJavaScriptGolang
        
        class Solution {
        public TreeNode constructMaximumBinaryTree(int[] nums) {
        int n = nums.length;
        List<Integer> stack = new ArrayList<Integer>();
        TreeNode[] tree = new TreeNode[n];
        for (int i = 0; i < n; ++i) {
        tree[i] = new TreeNode(nums[i]);
        while (!stack.isEmpty() && nums[i] > nums[stack.get(stack.size() - 1)]) {
        tree[i].left = tree[stack.get(stack.size() - 1)];
        stack.remove(stack.size() - 1);
        }
        if (!stack.isEmpty()) {
        tree[stack.get(stack.size() - 1)].right = tree[i];
        }
        stack.add(i);
        }
        return tree[stack.get(0)];
        }
        }
        复杂度分析
        
        时间复杂度：
        �
        (
        �
        )
        O(n)，其中
        �
        n 是数组
        nums
        nums 的长度。单调栈求解左右边界和构造树均需要
        �
        (
        �
        )
        O(n) 的时间。
        
        空间复杂度：
        �
        (
        �
        )
        O(n)，即为单调栈和数组
        tree
        tree 需要使用的空间。
        
- ****[636. 函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/)（这是栈的题目，递归我真想不出来怎么解）**（3）
    
    有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。
    
    函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。
    
    给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 "{function_id}:{"start" | "end"}:{timestamp}" 进行格式化的字符串。例如，"0:start:3" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 "1:end:2" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。
    
    函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。
    
    以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。
    
    示例 1：
    
    ![https://assets.leetcode.com/uploads/2019/04/05/diag1b.png](https://assets.leetcode.com/uploads/2019/04/05/diag1b.png)
    
    ```java
    输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]
    输出：[3,4]
    解释：
    函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。
    函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。
    函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。
    所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。
    示例 2：
    
    输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]
    输出：[8]
    解释：
    函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
    函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
    函数 0（初始调用）恢复执行，并立刻再次调用它自身。
    函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。
    函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。
    所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。
    示例 3：
    
    输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:6","1:end:6","0:end:7"]
    输出：[7,1]
    解释：
    函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。
    函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。
    函数 0（初始调用）恢复执行，并立刻调用函数 1 。
    函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。
    函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。
    所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。
    示例 4：
    
    输入：n = 2, logs = ["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]
    输出：[8,1]
    示例 5：
    
    输入：n = 1, logs = ["0:start:0","0:end:0"]
    输出：[1]
    ```
    
    ```java
    class Solution {
        
        public int[] exclusiveTime(int n, List<String> logs) {
            int[] result = new int[n];
            LinkedList<int[]> stack = new LinkedList<>();
            for (String log : logs) {
                Integer idx = Integer.parseInt(log.substring(0, log.indexOf(":")));
                String operate = log.substring(log.indexOf(":") + 1, log.lastIndexOf(":"));
                Integer timestamp = Integer.parseInt(log.substring(log.lastIndexOf(":") + 1));
                if ("start".equals(operate)) {
                    if (!stack.isEmpty()) {
                        result[stack.peek()[0]] += timestamp - stack.peek()[1]; 
                    }
                    stack.push(new int[]{idx, timestamp});
                }
                else {
                    int[] tmp = stack.pop();
                    result[tmp[0]] += timestamp - tmp[1] + 1;
                    if (!stack.isEmpty()) {
                        stack.peek()[1] = timestamp + 1;
                    }
                }
            }
            return result;
        }
    
    }
    ```
    
- ****[填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)（BFS，层序遍历）还是不怎么会，需要反复练习类似题目**（3）
    
    给定一个二叉树：
    
    struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next;
    }
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。
    
    初始状态下，所有 next 指针都被设置为 NULL 。
    
    示例 1：
    
    ![https://assets.leetcode.com/uploads/2019/02/15/117_sample.png](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)
    
    ```
    输入：root = [1,2,3,4,5,null,7]
    输出：[1,#,2,3,#,4,5,7,#]
    解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
    ```
    
    示例 2：
    
    ```
    
    输入：root = []
    输出：[]
    ```
    
    提示：
    
    树中的节点数在范围 [0, 6000] 内
    -100 <= Node.val <= 100
    进阶：
    
    你只能使用常量级额外空间。
    使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。
    
    ```java
    /*
    // Definition for a Node.
    class Node {
        public int val;
        public Node left;
        public Node right;
        public Node next;
    
        public Node() {}
        
        public Node(int _val) {
            val = _val;
        }
    
        public Node(int _val, Node _left, Node _right, Node _next) {
            val = _val;
            left = _left;
            right = _right;
            next = _next;
        }
    };
    */
    
    class Solution {
    
        private List<List<Integer>> binaryLevelTreeList = new ArrayList<>(); 
    
        public Node connect(Node root) {
            if (root == null || (root.left == null && root.right == null)) {
                return root;
            }
            Node next = getNext(root.next);
            if(root.left != null && root.right != null){
                root.left.next = root.right;
                root.right.next = next;
            } 
            if(root.left != null && root.right == null)
                root.left.next = next;
            if(root.left == null && root.right != null)
                root.right.next = next;
            
            connect(root.right);
            connect(root.left);
    
            return root;
        }
    
        private Node getNext(Node root) {
            if (root == null) {
                return null;
            }
            if (root.left != null) {
                return root.left;
            }
            if (root.right != null) {
                return root.right;
            } 
            return getNext(root.next);
       }
    
    }
    ```
    
- ****[87. 扰乱字符串](https://leetcode.cn/problems/scramble-string/)（DFS）**（4）
    
    使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
    如果字符串的长度为 1 ，算法停止
    如果字符串的长度 > 1 ，执行下述步骤：
    在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
    随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
    在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
    给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
    
    示例 1：
    
    输入：s1 = "great", s2 = "rgeat"
    输出：true
    解释：s1 上可能发生的一种情形是：
    "great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串
    "gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
    "gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
    "g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
    "r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
    "r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
    算法终止，结果字符串和 s2 相同，都是 "rgeat"
    这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
    示例 2：
    
    输入：s1 = "abcde", s2 = "caebd"
    输出：false
    示例 3：
    
    输入：s1 = "a", s2 = "a"
    输出：true
    
    提示：
    
    s1.length == s2.length
    1 <= s1.length <= 30
    s1 和 s2 由小写英文字母组成
    
    ```java
    class Solution {
        // 记忆化搜索存储状态的数组
        // -1 表示 false，1 表示 true，0 表示未计算
        int[][][] memo;
        String s1, s2;
    
        public boolean isScramble(String s1, String s2) {
            int length = s1.length();
            this.s1 = s1;
            this.s2 = s2;
            memo = new int[length][length][length + 1];
            return dfs(0, 0 , length);
        }
    
        // 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐
        public boolean dfs(int i1, int i2, int length) {
            if (memo[i1][i2][length] != 0) {
                return memo[i1][i2][length] == 1;
            }
    
            // 比较两个字符串是否相等
        // 判断两个子串是否相等
            if (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) {
                memo[i1][i2][length] = 1;
                return true;
            }
    
            // 判断是否存在字符 c 在两个子串中出现的次数不同
            if (!checkIfSimilar(i1, i2, length)) {
                memo[i1][i2][length] = -1;
                return false;
            }
            
            // 枚举分割位置
            for (int i = 1; i < length; ++i) {
                // 不交换的情况
                if (dfs(i1, i2, i) && dfs(i1 + i, i2 + i, length - i)) {
                    memo[i1][i2][length] = 1;
                    return true;
                }
                // 交换的情况
                if (dfs(i1, i2 + length - i, i) && dfs(i1 + i, i2, length - i)) {
                    memo[i1][i2][length] = 1;
                    return true;
                }
            }
            memo[i1][i2][length] = -1;
            return false;
        }
    
        public boolean checkIfSimilar(int i1, int i2, int length) {
            Map<Character, Integer> freq = new HashMap<Character, Integer>();
            for (int i = i1; i < i1 + length; ++i) {
                char c = s1.charAt(i);
                freq.put(c, freq.getOrDefault(c, 0) + 1);
            }
            for (int i = i2; i < i2 + length; ++i) {
                char c = s2.charAt(i);
                freq.put(c, freq.getOrDefault(c, 0) - 1);
            }
            for (Map.Entry<Character, Integer> entry : freq.entrySet()) {
                int value = entry.getValue();
                if (value != 0) {
                    return false;
                }
            }
            return true;
        }
    }
    ```
    
- ****[998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/)（树的遍历）**（5）
    
    最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。
    
    给你最大树的根节点 root 和一个整数 val 。
    
    就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root = Construct(a)）递归地构建的：
    
    如果 a 为空，返回 null 。
    否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。
    root 的左子树将被构建为 Construct([a[0], a[1], ..., a[i - 1]]) 。
    root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]) 。
    返回 root 。
    请注意，题目没有直接给出 a ，只是给出一个根节点 root = Construct(a) 。
    
    假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。
    
    返回 Construct(b) 。
    
    示例 1：
    
    输入：root = [4,1,3,null,null,2], val = 5
    输出：[5,4,null,1,3,null,null,2]
    解释：a = [1,4,2,3], b = [1,4,2,3,5]
    示例 2：
    
    输入：root = [5,2,4,null,1], val = 3
    输出：[5,2,4,null,1,null,3]
    解释：a = [2,1,5,4], b = [2,1,5,4,3]
    示例 3：
    
    输入：root = [5,2,3,null,1], val = 4
    输出：[5,2,4,null,1,3]
    解释：a = [2,1,5,3], b = [2,1,5,3,4]
    
    提示：
    
    树中节点数目在范围 [1, 100] 内
    1 <= Node.val <= 100
    树中的所有值 互不相同
    1 <= val <= 100
    
    ```java
    /**
     * 如果给定的值大于 root 的值，那么就设定该值的节点为 root 的父节点，
     * 如果给定的值小于该树的当前节点，且大于右子节点，那么就拆掉当前节点，将此节点塞入其中
     * 如果到底了还没有大于该值的节点，那么就插入该树的最右边节点
     */
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode() {}
     *     TreeNode(int val) { this.val = val; }
     *     TreeNode(int val, TreeNode left, TreeNode right) {
     *         this.val = val;
     *         this.left = left;
     *         this.right = right;
     *     }
     * }
     */
    class Solution {
    
        public TreeNode insertIntoMaxTree(TreeNode root, int val) {
            TreeNode parent = null;
            TreeNode cur = root;
            while (cur != null) {
                if (val > cur.val) {
                    if (parent == null) {
                        return new TreeNode(val, root, null);
                    }
                    TreeNode node = new TreeNode(val, cur, null);
                    parent.right = node;
                    return root;
                }
                else {
                    parent = cur;
                    cur = cur.right;
                }
            }
            parent.right = new TreeNode(val);
            return root;
        }
    
    }
    ```
    
- ****[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)****`中序遍历二叉搜索树等于遍历有序数组`（4）
    
    给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
    
    如果树中有不止一个众数，可以按 任意顺序 返回。
    
    假定 BST 满足如下定义：
    
    结点左子树中所含节点的值 小于等于 当前节点的值
    结点右子树中所含节点的值 大于等于 当前节点的值
    左子树和右子树都是二叉搜索树
    
    示例 1：
    
    输入：root = [1,null,2,2]
    输出：[2]
    示例 2：
    
    输入：root = [0]
    输出：[0]
    
    提示：
    
    树中节点的数目在范围 [1, 104] 内
    -105 <= Node.val <= 105
    
    ```java
    class Solution {
        List<Integer> answer = new ArrayList<Integer>();
        int base, count, maxCount;
    
        public int[] findMode(TreeNode root) {
            dfs(root);
            int[] mode = new int[answer.size()];
            for (int i = 0; i < answer.size(); ++i) {
                mode[i] = answer.get(i);
            }
            return mode;
        }
    
        public void dfs(TreeNode o) {
            if (o == null) {
                return;
            }
            dfs(o.left);
            update(o.val);
            dfs(o.right);
        }
    
        public void update(int x) {
            if (x == base) {
                ++count;
            } else {
                count = 1;
                base = x;
            }
            if (count == maxCount) {
                answer.add(base);
            }
            if (count > maxCount) {
                maxCount = count;
                answer.clear();
                answer.add(base);
            }
        }
    }
    ```