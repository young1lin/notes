# 贪心

Owner: lin young

求解问题类型

最小相交子区间

- 看电影
- **[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)**
- **[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)**

```jsx
# 初始化数据
data = initialize() 

result = [] # 结果集合

while 数据未处理完:
  
  # 1. 选择贪心策略
  选择一个符合策略的元素

  # 2. 更新数据
  更新数据

  # 3. 添加结果
  将选择的元素添加到结果集

return 结果
```

- **[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)（这题也是双指针的题目，每次求最优解）**
    
    给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
    
    找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
    
    返回容器可以储存的最大水量。
    
    **说明：**你不能倾斜容器。
    
    **示例 1：**
    
    ![https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)
    
    ```
    输入：[1,8,6,2,5,4,8,3,7]
    输出：49
    解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
    ```
    
    **示例 2：**
    
    ```
    输入：height = [1,1]
    输出：1
    
    ```
    
    **提示：**
    
    - `n == height.length`
    - `2 <= n <= 105`
    - `0 <= height[i] <= 104`
    
    ```java
    class Solution {
    
        public int maxArea(int[] height) {
            int left = 0;
            int right = height.length - 1;
            int maxCapcity = 0;
            while (left < right) {
                int m = right - left;
                int n = Math.min(height[left], height[right]);
                maxCapcity = Math.max(maxCapcity, m * n);
                if (height[left] < height[right]) {
                    left++;
                }
                else {
                    right--;
                }
            }
            return maxCapcity;
        }
    
    }
    ```
    
- **[849. 到最近的人的最大距离](https://leetcode.cn/problems/maximize-distance-to-closest-person/)**
    
    给你一个数组 `seats` 表示一排座位，其中 `seats[i] = 1` 代表有人坐在第 `i` 个座位上，`seats[i] = 0` 代表座位 `i` 上是空的（**下标从 0 开始**）。
    
    至少有一个空座位，且至少有一人已经坐在座位上。
    
    亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。
    
    返回他到离他最近的人的最大距离。
    
    **示例 1：**
    
    ![https://assets.leetcode.com/uploads/2020/09/10/distance.jpg](https://assets.leetcode.com/uploads/2020/09/10/distance.jpg)
    
    ```
    输入：seats = [1,0,0,0,1,0,1]
    输出：2
    解释：
    如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
    如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
    因此，他到离他最近的人的最大距离是 2 。
    
    ```
    
    **示例 2：**
    
    ```
    输入：seats = [1,0,0,0]
    输出：3
    解释：
    如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
    这是可能的最大距离，所以答案是 3 。
    
    ```
    
    **示例 3：**
    
    ```
    输入：seats = [0,1]
    输出：1
    
    ```
    
    ```java
    class Solution {
    
        public int maxDistToClosest(int[] seats) {
            int left = 0;
            int len = seats.length;
            int maxLen = 0; 
            while (left < len && seats[left] == 0) {
                left++;
            }
            maxLen = Math.max(maxLen, left);
            while (left < len) {
                int right = left + 1;
                while (right < len && seats[right] == 0) {
                    right++;
                }
                if (right == len) {
                    maxLen = Math.max(maxLen, right - left - 1);
                }
                else {
                    maxLen = Math.max(maxLen, (right - left) / 2);
                }
                left = right;
            }
            return maxLen;
        }
    
    }
    ```
    
- **[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)**
    
    给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
    
    每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
    
    - `0 <= j <= nums[i]`
    - `i + j < n`
    
    返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
    
    **示例 1:**
    
    ```
    输入: nums = [2,3,1,1,4]
    输出: 2
    解释: 跳到最后一个位置的最小跳跃数是2。
         从下标为 0 跳到下标为 1 的位置，跳1 步，然后跳3 步到达数组的最后一个位置。
    
    ```
    
    **示例 2:**
    
    ```
    输入: nums = [2,3,0,1,4]
    输出: 2
    
    ```
    
    **提示:**
    
    - `1 <= nums.length <= 104`
    - `0 <= nums[i] <= 1000`
    - 题目保证可以到达 `nums[n-1]`
    
    ```java
    class Solution {
    
        public int jump(int[] nums) {
            int len = nums.length;
            int end = 0;
            int maxPosition = 0;
            int steps = 0;
            for (int i = 0; i < len - 1; i++) {
                maxPosition = Math.max(maxPosition, i + nums[i]);
                if (i == end) {
                    end = maxPosition;
                    steps++;
                }
            }
            return steps;
        }
    
    }
    ```
    
- **[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)   （[题解](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/476791/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/)十分重要）**
    
    给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
    
    在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
    
    返回 *你能获得的 **最大** 利润* 。
    
    **示例 1：**
    
    ```
    输入：prices = [7,1,5,3,6,4]
    输出：7
    解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
         随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
         总利润为 4 + 3 = 7 。
    ```
    
    **示例 2：**
    
    ```
    输入：prices = [1,2,3,4,5]
    输出：4
    解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
         总利润为 4 。
    ```
    
    **示例 3：**
    
    ```
    输入：prices = [7,6,4,3,1]
    输出：0
    解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
    ```
    
    **提示：**
    
    - `1 <= prices.length <= 3 * 104`
    - `0 <= prices[i] <= 104`
    
    ```java
    class Solution {
    
        public int maxProfit(int[] prices) {
            int ans = 0;
            int n = prices.length;
            for (int i = 1; i < n; ++i) {
                ans += Math.max(0, prices[i] - prices[i - 1]);
            }
            return ans;
        }
    
    }
    ```
    
- **[134. 加油站](https://leetcode.cn/problems/gas-station/)（[题解](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/476791/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/)十分重要）**
    
    在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` **升。
    
    你有一辆油箱容量无限的的汽车，从第 **`i` **个加油站开往第 **`i+1` **个加油站需要消耗汽油 `cost[i]` **升。你从其中的一个加油站出发，开始时油箱为空。
    
    给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
    
    **示例 1:**
    
    ```
    输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
    输出: 3
    解释:
    从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
    开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
    开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
    开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
    开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
    开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
    因此，3 可为起始索引。
    ```
    
    **示例 2:**
    
    ```
    输入: gas = [2,3,4], cost = [3,4,3]
    输出: -1
    解释:
    你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
    我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
    开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
    开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
    你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
    因此，无论怎样，你都不可能绕环路行驶一周。
    ```
    
    **提示:**
    
    - `gas.length == n`
    - `cost.length == n`
    - `1 <= n <= 105`
    - `0 <= gas[i], cost[i] <= 104`
    
    ```java
    class Solution {
    
        public int canCompleteCircuit(int[] gas, int[] cost) {
            int n = gas.length;
            int i = 0;
            while (i < n) {
                int sumOfGas = 0;
                int sumOfCost = 0;
                int cnt = 0;
                while (cnt < n) {
                    int j = (i + cnt) % n;
                    sumOfGas += gas[j];
                    sumOfCost += cost[j];
                    if (sumOfCost > sumOfGas) {
                        break;
                    }
                    cnt++;
                }
                if (cnt == n) {
                    return i;
                }
                else {
                    i = i + cnt + 1;
                }
            }
            return -1;
        }
    
    }
    ```
    
- **[316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)( [1](https://leetcode.cn/problems/remove-duplicate-letters/solutions/) )**
    
    给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。
    
    **示例 1：**
    
    ```
    输入：s = "bcabc"输出："abc"
    ```
    
    **示例 2：**
    
    ```
    输入：s = "cbacdcbc"输出："acdb"
    ```
    
    **提示：**
    
    - `1 <= s.length <= 104`
    - `s` 由小写英文字母组成
    
    ```java
    class Solution {
    
        public String removeDuplicateLetters(String s) {
            boolean[] vis = new boolean[26];
            int[] num = new int[26];
            char[] sArr = s.toCharArray();
            for (int i = 0; i < s.length(); i++) {
                num[sArr[i] - 'a']++; 
            }
    
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < s.length(); i++) {
                if (!vis[sArr[i] - 'a']) {
                    while (sb.length() > 0 && sb.charAt(sb.length() - 1) > sArr[i]) {
                        if (num[sb.charAt(sb.length() - 1) - 'a'] > 0) {
                            vis[sb.charAt(sb.length() - 1) - 'a'] = false;
                            sb.deleteCharAt(sb.length() - 1);
                        }
                        else {
                            break;
                        }
                    }
                    vis[sArr[i] - 'a'] = true;
                    sb.append(sArr[i]);
                }
                num[sArr[i] - 'a'] -= 1;
            }
            return sb.toString();
        }
    
    }
    ```
    
- **[135. 分发糖果](https://leetcode.cn/problems/candy/)（从左到右遍历，从右到左遍历）**
    
    `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
    
    你需要按照以下要求，给这些孩子分发糖果：
    
    - 每个孩子至少分配到 `1` 个糖果。
    - 相邻两个孩子评分更高的孩子会获得更多的糖果。
    
    请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。
    
    **示例 1：**
    
    ```
    输入：ratings = [1,0,2]
    输出：5
    解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
    
    ```
    
    **示例 2：**
    
    ```
    输入：ratings = [1,2,2]
    输出：4
    解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
         第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
    ```
    
    **提示：**
    
    - `n == ratings.length`
    - `1 <= n <= 2 * 104`
    - `0 <= ratings[i] <= 2 * 104`
    
    ```java
    class Solution {
    
        public int candy(int[] ratings) {
            // 一个从左遍历，一个从右遍历
            int len = ratings.length;
            int[] left = new int[len];
            for (int i = 0; i < len; i++) {
                if (i > 0 && ratings[i] > ratings[i - 1]) {
                    left[i] = left[i - 1] + 1;
                }
                else {
                    left[i] = 1;
                }
            } 
            int right = 0; 
            int ret = 0;
            for (int i = len - 1; i >= 0; i--) {
                if (i < len - 1 && ratings[i] > ratings[i + 1]) {
                    right++;
                }
                else {
                    right = 1;
                }
                ret += Math.max(left[i], right);
            }
            return ret;
        }
    
    }
    ```
    
- **[179. 最大数](https://leetcode.cn/problems/largest-number/)（看不懂为什么这么写）**
    
    给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。
    
    **注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。
    
    **示例 1：**
    
    ```
    输入：nums = [10,2]输出："210"
    ```
    
    **示例 2：**
    
    ```
    输入：nums = [3,30,34,5,9]输出："9534330"
    ```
    
    **提示：**
    
    - `1 <= nums.length <= 100`
    - `0 <= nums[i] <= 109`
    
    ```java
    class Solution {
    
        public String largestNumber(int[] nums) {
            StringBuilder sb = new StringBuilder();
            Arrays.stream(nums)
                .boxed()
                .sorted((x, y) -> {
                    long shiftX = 10, shiftY = 10;
                    while (shiftX <= y) {
                        shiftX *= 10;
                    }
                    while (shiftY <= x) {
                        shiftY *= 10;
                    }
                    return Long.signum((shiftY * y + x) - (shiftX * x + y));
                })
                .forEach(sb::append);
            return sb.charAt(0) == '0' ? "0" : sb.toString();
        }
    
    }
    ```
    
- **[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)**
    
    如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
    
    - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
    - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
    
    **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
    
    给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。
    
    **示例 1：**
    
    ```
    输入：nums = [1,7,4,9,2,5]
    输出：6
    解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
    
    ```
    
    **示例 2：**
    
    ```
    输入：nums = [1,17,5,10,13,15,10,5,16,8]
    输出：7
    解释：这个序列包含几个长度为 7 摆动序列。
    其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
    
    ```
    
    **示例 3：**
    
    ```
    输入：nums = [1,2,3,4,5,6,7,8,9]
    输出：2
    
    ```
    
    **提示：**
    
    - `1 <= nums.length <= 1000`
    - `0 <= nums[i] <= 1000`
    
    **进阶：**你能否用 `O(n)` **时间复杂度完成此题?
    
    ```java
    class Solution {
    
        public int wiggleMaxLength(int[] nums) {
            int n = nums.length;
            if (n < 2) {
                return n;
            }
            int[] up = new int[n];
            int[] down = new int[n];
            up[0] = down[0] = 1;
            for (int i = 1; i < n; i++) {
                if (nums[i] > nums[i - 1]) {
                    up[i] = Math.max(up[i - 1], down[i - 1] + 1);
                    down[i] = down[i - 1];
                }
                else if (nums[i] < nums[i - 1]) {
                    up[i] = up[i - 1];
                    down[i] = Math.max(up[i - 1] + 1, down[i - 1]);
                }
                else {
                    up[i] = up[i - 1];
                    down[i] = down[i - 1];
                }
            }
            return Math.max(up[n - 1], down[n - 1]);
        }
    
    }
    ```
    
- **[397. 整数替换](https://leetcode.cn/problems/integer-replacement/)**
    
    给定一个正整数 `n` ，你可以做如下操作：
    
    1. 如果 `n` **是偶数，则用 `n / 2`替换 `n` **。
    2. 如果 `n` **是奇数，则可以用 `n + 1`或`n - 1`替换 `n` 。
    
    返回 `n` **变为 `1` 所需的 *最小替换次数* 。
    
    **示例 1：**
    
    ```
    输入：n = 8
    输出：3
    解释：8 -> 4 -> 2 -> 1
    
    ```
    
    **示例 2：**
    
    ```
    输入：n = 7
    输出：4
    解释：7 -> 8 -> 4 -> 2 -> 1
    或 7 -> 6 -> 3 -> 2 -> 1
    
    ```
    
    **示例 3：**
    
    ```
    输入：n = 4
    输出：2
    
    ```
    
    **提示：**
    
    - `1 <= n <= 231 - 1`
    
    ```java
    class Solution {
    
        public int integerReplacement(int n) {
            int ans = 0;
            while (n != 1) {
                if (n % 2 == 0) {
                    ++ans;
                    n /=  2;
                }
                else if (n % 4 == 1) {
                    ans += 2;
                    n /= 2;
                }
                else {
                    if (n == 3) {
                        ans += 2;
                        n = 1;
                    }
                    else {
                        ans += 2;
                        n = n / 2 + 1;
                    }
                }
            }
            return ans;
        }
    
    }
    ```
    
- **[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)(贪心加单调栈)**
    
    给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` **位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
    
    **示例 1 ：**
    
    ```
    输入：num = "1432219", k = 3
    输出："1219"
    解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
    
    ```
    
    **示例 2 ：**
    
    ```
    输入：num = "10200", k = 1
    输出："200"
    解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
    
    ```
    
    **示例 3 ：**
    
    ```
    输入：num = "10", k = 2
    输出："0"
    解释：从原数字移除所有的数字，剩余为空就是 0 。
    
    ```
    
    **提示：**
    
    - `1 <= k <= num.length <= 105`
    - `num` 仅由若干位数字（0 - 9）组成
    - 除了 **0** 本身之外，`num` 不含任何前导零
    
    ```java
    **class Solution {
    
        public String removeKdigits(String num, int k) {
            Deque<Character> stack = new LinkedList<>();
            int length = num.length();
            for (int i = 0; i < length; i++) {
                char digit = num.charAt(i);
                while (!stack.isEmpty() && k > 0 && stack.peekLast() > digit) {
                    stack.pollLast();
                    k--;
                }
                stack.offerLast(digit);
            }
    
            for (int i = 0; i < k; i++) {
                stack.pollLast();
            }
            StringBuilder sb = new StringBuilder(length - k);
            boolean leadingZero = true;
            while (!stack.isEmpty()) {
                char digit = stack.pollFirst();
                if (leadingZero && digit == '0') {
                    continue;
                }
                leadingZero = false;
                sb.append(digit);
            }
            return sb.length() == 0 ? "0": sb.toString();
        }
    
    }**
    ```
    
- **[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)**
    
    假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
    
    请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
    
    **示例 1：**
    
    ```
    输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
    输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
    解释：
    编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
    编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
    编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
    编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
    编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
    
    ```
    
    **示例 2：**
    
    ```
    输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
    输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
    
    ```
    
    **提示：**
    
    - `1 <= people.length <= 2000`
    - `0 <= hi <= 106`
    - `0 <= ki < people.length`
    - 题目数据确保队列可以被重建
    
    ```java
    class Solution {
    
        public int[][] reconstructQueue(int[][] people) {
            Arrays.sort(people, (person1, person2) -> {
                if (person1[0] != person2[0]) {
                    return person1[0] - person2[0];
                }
                else {
                    return person2[1] - person1[1];
                }
            });
            int n = people.length;
            int[][] result = new int[n][];
            for (int[] person : people) {
                int spaces = person[1] + 1;
                for (int i = 0; i < n; i++) {
                    if (result[i] == null) {
                        --spaces;
                        if (spaces == 0) {
                            result[i] = person;
                            break;
                        }
                    }
                }
            }
            return result;
        }
    
    }
    ```
    
- **[330. 按要求补齐数组](https://leetcode.cn/problems/patching-array/)（纯数学题）**
    
    给定一个已排序的正整数数组 `nums` *，*和一个正整数 `n` *。*从 `[1, n]` 区间内选取任意个数字补充到 nums 中，使得 `[1, n]` 区间内的任何数字都可以用 nums 中某几个数字的和来表示。
    
    请返回 *满足上述要求的最少需要补充的数字个数* 。
    
    **示例 1:**
    
    ```
    输入:nums =[1,3], n =6输出:1
    解释:
    根据 nums 里现有的组合[1], [3], [1,3]，可以得出1, 3, 4。
    现在如果我们将2 添加到 nums 中， 组合变为:[1], [2], [3], [1,3], [2,3], [1,2,3]。
    其和可以表示数字1, 2, 3, 4, 5, 6，能够覆盖[1, 6] 区间里所有的数。
    所以我们最少需要添加一个数字。
    ```
    
    **示例 2:**
    
    ```
    输入:nums =[1,5,10], n =20输出: 2
    解释:我们需要添加[2,4]。
    
    ```
    
    **示例 3:**
    
    ```
    输入:nums =[1,2,2], n =5输出: 0
    
    ```
    
    **提示：**
    
    - `1 <= nums.length <= 1000`
    - `1 <= nums[i] <= 104`
    - `nums` 按 **升序排列**
    - `1 <= n <= 231 - 1`
    
    ```java
    class Solution {
    
        public int minPatches(int[] nums, int n) {
            int patches = 0;
            long x = 1;
            int length = nums.length;
            int index = 0;
            while (x <= n) {
                if (index < length && nums[index] <= x) {
                    x += nums[index];
                    index++;
                }
                else {
                    x *= 2;
                    patches++;
                }
            }
            return patches;
        }
    
    }
    ```
    
- **[420. 强密码检验器](https://leetcode.cn/problems/strong-password-checker/)（数学题）**
    
    满足以下条件的密码被认为是强密码：
    
    - 由至少 `6` 个，至多 `20` 个字符组成。
    - 包含至少 **一个小写** 字母，至少 **一个大写** 字母，和至少 **一个数字** 。
    - 不包含连续三个重复字符 (比如 `"B***aaa***bb0"` 是弱密码, 但是 `"B***aa***b***a***0"` 是强密码)。
    
    给你一个字符串 `password` ，返回 *将 `password` 修改到满足强密码条件需要的最少修改步数。如果 `password` 已经是强密码，则返回 `0` 。*
    
    在一步修改操作中，你可以：
    
    - 插入一个字符到 `password` ，
    - 从 `password` 中删除一个字符，或
    - 用另一个字符来替换 `password` 中的某个字符。
    
    **示例 1：**
    
    ```
    输入：password = "a"
    输出：5
    
    ```
    
    **示例 2：**
    
    ```
    输入：password = "aA1"
    输出：3
    
    ```
    
    **示例 3：**
    
    ```
    输入：password = "1337C0d3"
    输出：0
    
    ```
    
    **提示：**
    
    - `1 <= password.length <= 50`
    - `password` 由字母、数字、点 `'.'` 或者感叹号 `'!'` 组成
    
    ```java
    class Solution {
        public int strongPasswordChecker(String password) {
            int n = password.length();
            int hasLower = 0, hasUpper = 0, hasDigit = 0;
            for (int i = 0; i < n; ++i) {
                char ch = password.charAt(i);
                if (Character.isLowerCase(ch)) {
                    hasLower = 1;
                } else if (Character.isUpperCase(ch)) {
                    hasUpper = 1;
                } else if (Character.isDigit(ch)) {
                    hasDigit = 1;
                }
            }
            int categories = hasLower + hasUpper + hasDigit;
    
            if (n < 6) {
                return Math.max(6 - n, 3 - categories);
            } else if (n <= 20) {
                int replace = 0;
                int cnt = 0;
                char cur = '#';
    
                for (int i = 0; i < n; ++i) {
                    char ch = password.charAt(i);
                    if (ch == cur) {
                        ++cnt;
                    } else {
                        replace += cnt / 3;
                        cnt = 1;
                        cur = ch;
                    }
                }
                replace += cnt / 3;
                return Math.max(replace, 3 - categories);
            } else {
                // 替换次数和删除次数
                int replace = 0, remove = n - 20;
                // k mod 3 = 1 的组数，即删除 2 个字符可以减少 1 次替换操作
                int rm2 = 0;
                int cnt = 0;
                char cur = '#';
    
                for (int i = 0; i < n; ++i) {
                    char ch = password.charAt(i);
                    if (ch == cur) {
                        ++cnt;
                    } else {
                        if (remove > 0 && cnt >= 3) {
                            if (cnt % 3 == 0) {
                                // 如果是 k % 3 = 0 的组，那么优先删除 1 个字符，减少 1 次替换操作
                                --remove;
                                --replace;
                            } else if (cnt % 3 == 1) {
                                // 如果是 k % 3 = 1 的组，那么存下来备用
                                ++rm2;
                            }
                            // k % 3 = 2 的组无需显式考虑
                        }
                        replace += cnt / 3;
                        cnt = 1;
                        cur = ch;
                    }
                }
                if (remove > 0 && cnt >= 3) {
                    if (cnt % 3 == 0) {
                        --remove;
                        --replace;
                    } else if (cnt % 3 == 1) {
                        ++rm2;
                    }
                }
                replace += cnt / 3;
    
                // 使用 k % 3 = 1 的组的数量，由剩余的替换次数、组数和剩余的删除次数共同决定
                int use2 = Math.min(Math.min(replace, rm2), remove / 2);
                replace -= use2;
                remove -= use2 * 2;
                // 由于每有一次替换次数就一定有 3 个连续相同的字符（k / 3 决定），因此这里可以直接计算出使用 k % 3 = 2 的组的数量
                int use3 = Math.min(replace, remove / 3);
                replace -= use3;
                remove -= use3 * 3;
                return (n - 20) + Math.max(replace, 3 - categories);
            }
        }
    }
    ```
    
- **[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)（看电影的题目）**
    
    给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
    
    **示例 1:**
    
    ```
    输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
    输出: 1
    解释: 移除 [1,3] 后，剩下的区间没有重叠。
    
    ```
    
    **示例 2:**
    
    ```
    输入: intervals = [ [1,2], [1,2], [1,2] ]
    输出: 2
    解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
    
    ```
    
    **示例 3:**
    
    ```
    输入: intervals = [ [1,2], [2,3] ]
    输出: 0
    解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
    
    ```
    
    **提示:**
    
    - `1 <= intervals.length <= 105`
    - `intervals[i].length == 2`
    - `5 * 104 <= starti < endi <= 5 * 104`
    
    ```java
    class Solution {
        public int eraseOverlapIntervals(int[][] intervals) {
            if (intervals.length == 0) {
                return 0;
            }
            
            Arrays.sort(intervals, Comparator.comparingInt(interval -> interval[1]));
    
            int n = intervals.length;
            int right = intervals[0][1];
            int ans = 1;
            for (int i = 1; i < n; i++) {
                if (intervals[i][0] >= right) {
                    ans++;
                    right = intervals[i][1];
                }
            }
            return n - ans;
        }
    }
    ```
    
- **[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)**
    
    有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
    
    一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
    
    给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。
    
    **示例 1：**
    
    ```
    输入：points = [[10,16],[2,8],[1,6],[7,12]]
    输出：2
    解释：气球可以用2支箭来爆破:
    -在x = 6处射出箭，击破气球[2,8]和[1,6]。
    -在x = 11处发射箭，击破气球[10,16]和[7,12]。
    ```
    
    **示例 2：**
    
    ```
    输入：points = [[1,2],[3,4],[5,6],[7,8]]
    输出：4
    解释：每个气球需要射出一支箭，总共需要4支箭。
    ```
    
    **示例 3：**
    
    ```
    输入：points = [[1,2],[2,3],[3,4],[4,5]]
    输出：2
    解释：气球可以用2支箭来爆破:
    - 在x = 2处发射箭，击破气球[1,2]和[2,3]。
    - 在x = 4处射出箭，击破气球[3,4]和[4,5]。
    ```
    
    **提示:**
    
    - `1 <= points.length <= 105`
    - `points[i].length == 2`
    - `231 <= xstart < xend <= 231 - 1`
    
    ```java
    class Solution {
    
        public int findMinArrowShots(int[][] points) {
            // 根据左边最小区间来区别
            Arrays.sort(points, new Comparator<int[]>() {
                public int compare(int[] point1, int[] point2) {
                    if (point1[1] > point2[1]) {
                        return 1;
                    } else if (point1[1] < point2[1]) {
                        return -1;
                    } else {
                        return 0;
                    }
                }
            });
            int pos = points[0][1];
            int ans = 1;
            for (int[] ballon : points) {
                if (ballon[0] > pos) {
                    pos = ballon[1];
                    ans++;
                }
            }
            return ans;
        }
    
    }
    ```
    
- **[502. IPO](https://leetcode.cn/problems/ipo/)**
    
    假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。
    
    给你 `n` 个项目。对于每个项目 `i` ****，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。
    
    最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
    
    总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。
    
    答案保证在 32 位有符号整数范围内。
    
    **示例 1：**
    
    ```
    输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
    输出：4
    解释：
    由于你的初始资本为 0，你仅可以从 0 号项目开始。
    在完成后，你将获得 1 的利润，你的总资本将变为 1。
    此时你可以选择开始 1 号或 2 号项目。
    由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
    因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
    
    ```
    
    **示例 2：**
    
    ```
    输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
    输出：6
    
    ```
    
    **提示：**
    
    - `1 <= k <= 105`
    - `0 <= w <= 109`
    - `n == profits.length`
    - `n == capital.length`
    - `1 <= n <= 105`
    - `0 <= profits[i] <= 104`
    - `0 <= capital[i] <= 109`
    
    ```java
    class Solution {
    
        public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
            int n = profits.length;
            int curr = 0;
            int[][] arr = new int[n][2];
    
            for (int i = 0; i < n; i++) {
                arr[i][0] = capital[i];
                arr[i][1] = profits[i];
            }
    
            Arrays.sort(arr, (a, b) -> a[0] - b[0]);
    
            PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);
            for (int i = 0; i < k; i++) {
                while (curr < n && arr[curr][0] <= w) {
                    pq.add(arr[curr][1]);
                    curr++;
                }
                if (!pq.isEmpty()) {
                    w += pq.poll();
                }
                else {
                    break;
                }
            }
            return w;
        }
    
    }
    ```
    
- **[1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)**
    
    给你一个数组 `events`，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。
    
    你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 。注意，一天只能参加一个会议。
    
    请你返回你可以参加的 **最大** 会议数目。
    
    **示例 1：**
    
    ![https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png)
    
    ```
    输入：events = [[1,2],[2,3],[3,4]]
    输出：3
    解释：你可以参加所有的三个会议。
    安排会议的一种方案如上图。
    第 1 天参加第一个会议。
    第 2 天参加第二个会议。
    第 3 天参加第三个会议。
    
    ```
    
    **示例 2：**
    
    ```
    输入：events= [[1,2],[2,3],[3,4],[1,2]]
    输出：4
    ```
    
    ```java
    class Solution {
    
        public int maxEvents(int[][] events) {
            Arrays.sort(events, (e1, e2) -> {
               if (e1[0] != e2[0]) {
                   return e1[0] - e2[0]; 
               }
               return e1[1] - e2[1];
            });
            int n = events.length;
            // 小顶堆：用于高效的维护最小的 endDay
            PriorityQueue<Integer> pq = new PriorityQueue<>();
            int res = 0;
            int currDay = 1;
            int i = 0;
            while (i < n || !pq.isEmpty()) {
                // 将所有开始时间等于 currDay 的会议的结束时间放到小顶堆
                while (i < n && events[i][0] == currDay) {
                    pq.add(events[i][1]);
                    i++;
                }
    
                // 将已经结束的会议弹出堆中，即堆顶的结束时间小于 currDay 的
                while (!pq.isEmpty() && pq.peek() < currDay) {
                    pq.remove();
                }
    
                // 贪心的选择结束时间最小的会议参加
                if (!pq.isEmpty()) {
                    // 参加的会议，就从堆中删除
                    pq.remove();
                    res++;
                }
    
                // 当前的天往前走一天，开始看下下一天能不能参加会议
                currDay++;
            }
    
            return res;
        }
    
    }
    ```
    
- **[517. 超级洗衣机](https://leetcode.cn/problems/super-washing-machines/)**
    
    假设有 `n` ****台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。
    
    在每一步操作中，你可以选择任意 `m` (`1 <= m <= n`) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。
    
    给定一个整数数组 `machines` 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 **最少的操作步数** 。如果不能使每台洗衣机中衣物的数量相等，则返回 `-1` 。
    
    **示例 1：**
    
    ```
    输入：machines = [1,0,5]
    输出：3
    解释：
    第一步:    1     0 <-- 5    =>    1     1     4
    第二步:    1 <-- 1 <-- 4    =>    2     1     3
    第三步:    2     1 <-- 3    =>    2     2     2
    
    ```
    
    **示例 2：**
    
    ```
    输入：machines = [0,3,0]
    输出：2
    解释：
    第一步:    0 <-- 3     0    =>    1     2     0
    第二步:    1     2 --> 0    =>    1     1     1
    
    ```
    
    **示例 3：**
    
    ```
    输入：machines = [0,2,0]
    输出：-1
    解释：
    不可能让所有三个洗衣机同时剩下相同数量的衣物。
    
    ```
    
    **提示：**
    
    - `n == machines.length`
    - `1 <= n <= 104`
    - `0 <= machines[i] <= 105`
    
    ```java
    class Solution {
    
        public int findMinMoves(int[] machines) {
            int n = machines.length;
            int summary = 0;
            for (int clothesNum : machines) {
                summary += clothesNum;
            }
            if (summary % n != 0) {
                return -1;
            }
            int avg = summary / n;
            int ans = 0;
            int sum = 0;
            for (int num : machines) {
                num -= avg;
                sum += num;
                ans = Math.max(ans, Math.max(Math.abs(sum), num));
            }
            return ans;
        }
    
    }
    ```