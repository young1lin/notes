# 二分查找

符合条件

1. 连续的
2. 排序过的内容
3. 查找某个元素

- ****[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)（此题也算二分查找）（3）**
    
    给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
    
    整数 a 比整数 b 更接近 x 需要满足：
    
    |a - x| < |b - x| 或者 |a - x| == |b - x| 且 a < b
    
    示例 1：
    
    输入：arr = [1,2,3,4,5], k = 4, x = 3 输出：[1,2,3,4] 示例 2：
    
    输入：arr = [1,2,3,4,5], k = 4, x = -1 输出：[1,2,3,4]
    
    提示：
    
    1 <= k <= arr.length 1 <= arr.length <= 104 arr 按 升序 排列 -104 <= arr[i], x <= 104
    
    先利用二分查找法找到最靠近 X 的右边元素的下标
    
    左边就从 right-1 开始
    
    ```java
    class Solution {
    
        public List<Integer> findClosestElements(int[] arr, int k, int x) {
            // 先利用二分查找找到最靠近 x 的右边的下标
            int right = binarySearch(arr, x);
            int left = right - 1;
            while (k-- > 0) {
                if (left < 0) {
                    right++;                
                }
                else if (right >= arr.length) {
                    left--;
                }
                else if (x - arr[left] <= arr[right] - x) {
                    left--;
                }
                else {
                    right++;
                }
            }
            List<Integer> result = new ArrayList<>();
            for (int i = left + 1; i < right; i++) {
                result.add(arr[i]);
            }
            return result;
        }
    
        private int binarySearch(int[] arr, int x) {
            int low = 0;
            int high = arr.length;
            while (low < high) {
                // 防止求 mid 时发生 low + high 超过 int 范围的情况
                int mid = low + (high - low) / 2;
                if (arr[mid] >= x) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            return low;
        }
    
    }
    ```
    
- ****[字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)（1）**
    
    给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
    
    返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
    
    两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。
    
    示例 1：
    
    输入：s = "loveleetcode", c = "e" 输出：[3,2,1,0,1,0,0,1,2,2,1,0] 解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。 距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。 距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。 对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。 距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。 示例 2：
    
    输入：s = "aaab", c = "b" 输出：[3,2,1,0]
    
    ```java
    class Solution {
    
        public int[] shortestToChar(String s, char c) {
            int len = s.length();
            char[] arr = s.toCharArray();
            int[] result = new int[len];
            for (int i = 0; i < len; i++) {
                int abs = findAbsDistance(arr, i, c);
                result[i] = abs;
            }
            return result;
        }
    
        private int findAbsDistance(char[] arr, int currentIndex, char target) {
            if (arr[currentIndex] == target) {
                return 0;
            }
            int left = currentIndex;
            int right = currentIndex;
            while (arr[left] != target && arr[right] != target) {
                left--;
                right++;
                if (left < 0) {
                    left++;
                }
                if (right >= arr.length) {
                    right--;
                }
            }
            if (arr[left] == target) {
                return currentIndex - left;
            }
            else {
                return right - currentIndex;
            }
        }
    
    }
    ```
    
- ****[832. 翻转图像](https://leetcode.cn/problems/flipping-an-image/) 4种情况，异或 1 取值**
    
    给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。
    
    水平翻转图片就是将图片的每一行都进行翻转，即逆序。
    
    例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。
    
    例如，反转 [0,1,1] 的结果是 [1,0,0]。
    
    示例 1：
    
    输入：image = [[1,1,0],[1,0,1],[0,0,0]] 输出：[[1,0,0],[0,1,0],[1,1,1]] 解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2：
    
    输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
    
    提示：
    
    n == image.length n == image[i].length 1 <= n <= 20 images[i][j] == 0 或 1.
    
    总共四种情况，因为都是 0 和 1。A22
    
    ```java
    class Solution {
        
        public int[][] flipAndInvertImage(int[][] image) {
            int len = image.length;
            int jlen = 0;
            if (len / 2 == 1) {
                jlen = len / 2 + 1;
            }
            else {
                jlen = len / 2;
            }
            // 水平翻转
            for (int i = 0; i < len; i++) {
                int left = 0; 
                int right = len - 1;
                while (left < right) {
                    if (image[i][left] == image[i][right]) {
                        image[i][left] ^= 1;
                        image[i][right] ^= 1;
                    }
                    left++;
                    right--;
                }
                if (left == right) {
                    image[i][left] ^= 1;
                }
            }
            return image;
        }
    }
    ```
    
- 4.****[寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)（需要同步做两个有序数组的合并，并且重新看一遍题解后自己写答案）（0）**
    
    给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
    
    算法的时间复杂度应该为 O(log (m+n)) 。
    
    示例 1：
    
    输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2：
    
    输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
    
    ```java
    class Solution {
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            int length1 = nums1.length, length2 = nums2.length;
            int totalLength = length1 + length2;
            if (totalLength % 2 == 1) {
                int midIndex = totalLength / 2;
                double median = getKthElement(nums1, nums2, midIndex + 1);
                return median;
            } else {
                int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
                double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
                return median;
            }
        }
    
        public int getKthElement(int[] nums1, int[] nums2, int k) {
            /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
             * 这里的 "/" 表示整除
             * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
             * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
             * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
             * 这样 pivot 本身最大也只能是第 k-1 小的元素
             * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
             * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
             * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
             */
    
            int length1 = nums1.length, length2 = nums2.length;
            int index1 = 0, index2 = 0;
            int kthElement = 0;
    
            while (true) {
                // 边界情况
                if (index1 == length1) {
                    return nums2[index2 + k - 1];
                }
                if (index2 == length2) {
                    return nums1[index1 + k - 1];
                }
                if (k == 1) {
                    return Math.min(nums1[index1], nums2[index2]);
                }
                
                // 正常情况
                int half = k / 2;
                int newIndex1 = Math.min(index1 + half, length1) - 1;
                int newIndex2 = Math.min(index2 + half, length2) - 1;
                int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
                if (pivot1 <= pivot2) {
                    k -= (newIndex1 - index1 + 1);
                    index1 = newIndex1 + 1;
                } else {
                    k -= (newIndex2 - index2 + 1);
                    index2 = newIndex2 + 1;
                }
            }
        }
    }
    
    class Solution1 {
    
        public double findMedianSortedArrays(int[] nums1, int[] nums2) {
            // 首先利用双指针合并数组
            int[] mergedArr = new int[nums1.length + nums2.length];
            mergeArr(mergedArr, nums1, nums2);    
            // 找出合并后的数组的中位数
            return binarySearch(mergedArr);
        }
    
        private void mergeArr(int[] mergedArr, int[] nums1, int[] nums2) {
            for(int i = 0; i < nums1.length; i++) {
                mergedArr[i] = nums1[i];
            }
            int nums1Length = nums1.length;
            for(int i = 0; i < nums2.length; i++) {
                mergedArr[nums1Length + i] = nums2[i];
            }
            Arrays.sort(mergedArr);
        }
    
        private double binarySearch(int[] mergedArr) {
            int remainder = mergedArr.length % 2;
            int midIndex = mergedArr.length / 2;
            if (remainder == 1) {
                return mergedArr[midIndex];
            }
            double result = (double)(mergedArr[midIndex - 1] + mergedArr[midIndex]) / 2;
            return result;
        }
    
    }
    ```
    
- ****[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)（7）**
    
    整数数组 nums 按升序排列，数组中的值 互不相同 。
    
    在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
    
    给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
    
    你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
    
    示例 1：
    
    输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2：
    
    输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3：
    
    输入：nums = [1], target = 0 输出：-1
    
    提示：
    
    1 <= nums.length <= 5000 -104 <= nums[i] <= 104 nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -104 <= target <= 104
    
    ```java
    class Solution {
        public int search(int[] nums, int target) {
            int n = nums.length;
            if (n == 0) {
                return -1;
            }
            if (n == 1) {
                return nums[0] == target ? 0 : -1;
            }
            int l = 0, r = n - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (nums[mid] == target) {
                    return mid;
                }
                if (nums[0] <= nums[mid]) {
                    if (nums[0] <= target && target < nums[mid]) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                } else {
                    if (nums[mid] < target && target <= nums[n - 1]) {
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
            }
            return -1;
        }
    }
    ```
	
[354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)(7)这个需要继续看，是动态规划加二分查找的题目
