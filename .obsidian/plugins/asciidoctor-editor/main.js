/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@asciidoctor/core/dist/browser/asciidoctor.js
var asciidoctor_exports = {};
__export(asciidoctor_exports, {
  default: () => Asciidoctor
});
function Asciidoctor(moduleConfig) {
  Opal.modules["asciidoctor/js/opal_ext/browser/file"] = function(Opal2) {
    var $klass = Opal2.klass, $defs = Opal2.defs, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("new");
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "File");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return $defs(self, "$read", function $$read(path) {
        var data = "";
        var status = -1;
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, false);
          xhr.addEventListener("load", function() {
            status = this.status;
            if (status === 0 || status === 200) {
              data = this.responseText;
            }
          });
          xhr.overrideMimeType("text/plain");
          xhr.send();
        } catch (e) {
          throw $$("IOError").$new("Error reading file or directory: " + path + "; reason: " + e.message);
        }
        if (status === 404 || status === 0 && !data) {
          throw $$("IOError").$new("No such file or directory: " + path);
        }
        return data;
      });
    }($nesting[0], null, $nesting);
  };
  Opal.modules["asciidoctor/js/opal_ext/browser"] = function(Opal2) {
    var $const_set = Opal2.const_set, self = Opal2.top, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("require");
    var platform, engine, framework, ioModule;
    if (typeof moduleConfig === "object" && typeof moduleConfig.runtime === "object") {
      var runtime = moduleConfig.runtime;
      platform = runtime.platform;
      engine = runtime.engine;
      framework = runtime.framework;
      ioModule = runtime.ioModule;
    }
    ioModule = ioModule || "xmlhttprequest";
    platform = platform || "browser";
    engine = engine || "";
    framework = framework || "";
    ;
    $const_set($nesting[0], "JAVASCRIPT_IO_MODULE", ioModule);
    $const_set($nesting[0], "JAVASCRIPT_PLATFORM", platform);
    $const_set($nesting[0], "JAVASCRIPT_ENGINE", engine);
    $const_set($nesting[0], "JAVASCRIPT_FRAMEWORK", framework);
    return self.$require("asciidoctor/js/opal_ext/browser/file");
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/browser/abstract_node"] = function(Opal2) {
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $truthy = Opal2.truthy, $def = Opal2.def, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("web_path,path_resolver,uriish?,[],attr?,start_with?,descends_from?,base_dir,join,prepare_source_string,read,fetch,warn,logger,normalize_system_path,read_asset");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "AbstractNode");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.document = nil;
        $def(self2, "$read_contents", function $$read_contents(target, opts) {
          var self3 = this, doc = nil, start = nil, $ret_or_1 = nil;
          if (opts == null)
            opts = $hash2([], {});
          doc = self3.document;
          if ($truthy($$("Helpers")["$uriish?"](target)) || $truthy(start = opts["$[]"]("start")) && $truthy($$("Helpers")["$uriish?"](start)) && $truthy(target = doc.$path_resolver().$web_path(target, start))) {
            if ($truthy(doc.$path_resolver()["$descends_from?"](target, doc.$base_dir())) || $truthy(target["$start_with?"]("chrome://")) || $truthy(doc["$attr?"]("allow-uri-read"))) {
              try {
                if ($truthy(opts["$[]"]("normalize"))) {
                  return $$("Helpers").$prepare_source_string($$$("File").$read(target)).$join($$("LF"));
                } else {
                  return $$$("File").$read(target);
                }
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StandardError")])) {
                  try {
                    if ($truthy(opts.$fetch("warn_on_failure", true))) {
                      self3.$logger().$warn("could not retrieve contents of " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset") + " at URI: " + target);
                    }
                    ;
                    return nil;
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
            } else {
              if ($truthy(opts.$fetch("warn_on_failure", true))) {
                self3.$logger().$warn("cannot retrieve contents of " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset") + " at URI: " + target + " (allow-uri-read attribute not enabled)");
              }
              ;
              return nil;
            }
          } else {
            target = self3.$normalize_system_path(target, opts["$[]"]("start"), nil, $hash2(["target_name"], { "target_name": $truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset" }));
            return self3.$read_asset(target, $hash2(["normalize", "warn_on_failure", "label"], { "normalize": opts["$[]"]("normalize"), "warn_on_failure": opts.$fetch("warn_on_failure", true), "label": opts["$[]"]("label") }));
          }
          ;
        }, -2);
        return $def(self2, "$generate_data_uri_from_uri", function $$generate_data_uri_from_uri(image_uri, cache_uri) {
          var self3 = this;
          if (cache_uri == null)
            cache_uri = false;
          var contentType = "";
          var b64encoded = "";
          var status = -1;
          try {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", image_uri, false);
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
            xhr.addEventListener("load", function() {
              status = this.status;
              if (status === 0 || status === 200) {
                var binary = "";
                var rawText = this.responseText;
                for (var i = 0, len = rawText.length; i < len; ++i) {
                  var c = rawText.charCodeAt(i);
                  var byteCode = c & 255;
                  binary += String.fromCharCode(byteCode);
                }
                b64encoded = btoa(binary);
                contentType = this.getResponseHeader("content-type");
              }
            });
            xhr.send(null);
            if (!contentType) {
              if (image_uri.endsWith(".jpeg") || image_uri.endsWith(".jpg") || image_uri.endsWith(".jpe")) {
                contentType = "image/jpg";
              } else if (image_uri.endsWith(".png")) {
                contentType = "image/png";
              } else if (image_uri.endsWith(".svg")) {
                contentType = "image/svg+xml";
              } else if (image_uri.endsWith(".bmp")) {
                contentType = "image/bmp";
              } else if (image_uri.endsWith(".tif") || image_uri.endsWith(".tiff")) {
                contentType = "image/tiff";
              }
            }
          } catch (e) {
            status = 0;
          }
          if (status === 404 || status === 0 && (!b64encoded || !contentType)) {
            self3.$logger().$warn("could not retrieve image data from URI: " + image_uri);
            return image_uri;
          }
          return "data:" + contentType + ";base64," + b64encoded;
        }, -2);
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/browser/open_uri"] = function(Opal2) {
    var $module = Opal2.module, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $defs = Opal2.defs, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("new,path");
    return function($base, $parent_nesting) {
      var self = $module($base, "OpenURI");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return $defs($$("OpenURI"), "$open_uri", function $$open_uri(name, $a) {
        var $post_args, rest, $yield = $$open_uri.$$p || nil, self2 = this, file = nil;
        $$open_uri.$$p = null;
        $post_args = $slice(arguments, 1);
        rest = $post_args;
        file = $send($$("File"), "new", [self2.$path()].concat($to_a(rest)));
        if ($yield !== nil) {
          return Opal2.yield1($yield, file);
        } else {
          return file;
        }
        ;
      }, -2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/browser/path_resolver"] = function(Opal2) {
    var $module = Opal2.module, $klass = Opal2.klass, $truthy = Opal2.truthy, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("absolute_path?,start_with?");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "PathResolver");
        return $def(self2, "$root?", function $PathResolver_root$ques$1(path) {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3["$absolute_path?"](path))) {
            return $ret_or_1;
          } else {
            return path["$start_with?"]("file://", "http://", "https://", "chrome://");
          }
        });
      }($nesting2[0], null);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/browser/reader"] = function(Opal2) {
    var $module = Opal2.module, $klass = Opal2.klass, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $not = Opal2.not, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("posixify,new,base_dir,start_with?,uriish?,key?,attributes,descends_from?,replace_next_line,absolute_path?,==,empty?,!,slice,length");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "PreprocessorReader");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.path_resolver = $proto.document = $proto.include_stack = $proto.dir = nil;
        return $def(self2, "$resolve_include_path", function $$resolve_include_path(target, attrlist, attributes) {
          var $a, self3 = this, p_target = nil, $ret_or_1 = nil, target_type = nil, base_dir = nil, inc_path = nil, relpath = nil, ctx_dir = nil, top_level = nil, offset = nil;
          p_target = (self3.path_resolver = $truthy($ret_or_1 = self3.path_resolver) ? $ret_or_1 : $$2("PathResolver").$new("\\")).$posixify(target);
          $a = ["file", self3.document.$base_dir()], target_type = $a[0], base_dir = $a[1], $a;
          if ($truthy(p_target["$start_with?"]("file://"))) {
            inc_path = relpath = p_target;
          } else if ($truthy($$2("Helpers")["$uriish?"](p_target))) {
            if (!($truthy(self3.path_resolver["$descends_from?"](p_target, base_dir)) || $truthy(self3.document.$attributes()["$key?"]("allow-uri-read")))) {
              return self3.$replace_next_line("link:" + target + "[" + attrlist + "]");
            }
            ;
            inc_path = relpath = p_target;
          } else if ($truthy(self3.path_resolver["$absolute_path?"](p_target))) {
            inc_path = relpath = "file://" + ($truthy(p_target["$start_with?"]("/")) ? "" : "/") + p_target;
          } else if ($eqeq(ctx_dir = $truthy(top_level = self3.include_stack["$empty?"]()) ? base_dir : self3.dir, ".")) {
            inc_path = relpath = p_target;
          } else if ($truthy(ctx_dir["$start_with?"]("file://")) || $not($$2("Helpers")["$uriish?"](ctx_dir))) {
            inc_path = "" + ctx_dir + "/" + p_target;
            if ($truthy(top_level)) {
              relpath = p_target;
            } else if ($eqeq(base_dir, ".") || $not(offset = self3.path_resolver["$descends_from?"](inc_path, base_dir))) {
              relpath = inc_path;
            } else {
              relpath = inc_path.$slice(offset, inc_path.$length());
            }
            ;
          } else if ($truthy(top_level)) {
            inc_path = "" + ctx_dir + "/" + (relpath = p_target);
          } else if ($truthy(offset = self3.path_resolver["$descends_from?"](ctx_dir, base_dir)) || $truthy(self3.document.$attributes()["$key?"]("allow-uri-read"))) {
            inc_path = "" + ctx_dir + "/" + p_target;
            relpath = $truthy(offset) ? inc_path.$slice(offset, inc_path.$length()) : p_target;
          } else {
            return self3.$replace_next_line("link:" + target + "[" + attrlist + "]");
          }
          ;
          return [inc_path, "file", relpath];
        });
      }($nesting2[0], $$("Reader"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/browser"] = function(Opal2) {
    var $eqeq = Opal2.eqeq, self = Opal2.top, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil;
    Opal2.add_stubs("==,require");
    if ($eqeq($$("JAVASCRIPT_IO_MODULE"), "xmlhttprequest")) {
      self.$require("asciidoctor/js/asciidoctor_ext/browser/abstract_node");
      self.$require("asciidoctor/js/asciidoctor_ext/browser/open_uri");
      self.$require("asciidoctor/js/asciidoctor_ext/browser/path_resolver");
      return self.$require("asciidoctor/js/asciidoctor_ext/browser/reader");
    } else {
      return nil;
    }
  };
  Opal.modules["set"] = Opal.return_val(Opal.nil);
  Opal.modules["asciidoctor/js/opal_ext/kernel"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $def = Opal2.def, $return_val = Opal2.return_val, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("new");
    return function($base, $parent_nesting) {
      var self = $module($base, "Kernel");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      $def(self, "$open", function $$open(path, $a) {
        var $post_args, rest, $yield = $$open.$$p || nil, file = nil;
        $$open.$$p = null;
        $post_args = $slice(arguments, 1);
        rest = $post_args;
        file = $send($$("File"), "new", [path].concat($to_a(rest)));
        if ($yield !== nil) {
          return Opal2.yield1($yield, file);
        } else {
          return file;
        }
        ;
      }, -2);
      return $def(self, "$__dir__", $return_val(""));
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/opal_ext/file"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $def = Opal2.def, $truthy = Opal2.truthy, $gvars = Opal2.gvars, $return_val = Opal2.return_val, $defs = Opal2.defs, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("attr_reader,delete,gsub,read,size,to_enum,chomp,each_line,readlines,split");
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "File");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
      $proto.eof = $proto.path = nil;
      self.$attr_reader("eof");
      self.$attr_reader("lineno");
      self.$attr_reader("path");
      $def(self, "$initialize", function $$initialize(path, flags) {
        var self2 = this, encoding_flag_regexp = nil;
        if (flags == null)
          flags = "r";
        self2.path = path;
        self2.contents = nil;
        self2.eof = false;
        self2.lineno = 0;
        flags = flags.$delete("b");
        encoding_flag_regexp = /:(.*)/;
        flags = flags.$gsub(encoding_flag_regexp, "");
        return self2.flags = flags;
      }, -2);
      $def(self, "$read", function $$read() {
        var self2 = this, res = nil;
        if ($truthy(self2.eof)) {
          return "";
        } else {
          res = $$("File").$read(self2.path);
          self2.eof = true;
          self2.lineno = res.$size();
          return res;
        }
      });
      $def(self, "$each_line", function $$each_line(separator) {
        var block = $$each_line.$$p || nil, self2 = this, lines = nil;
        if ($gvars["/"] == null)
          $gvars["/"] = nil;
        $$each_line.$$p = null;
        ;
        if (separator == null)
          separator = $gvars["/"];
        if ($truthy(self2.eof)) {
          return block !== nil ? self2 : [].$to_enum();
        }
        ;
        if (block !== nil) {
          lines = $$("File").$read(self2.path);
          self2.eof = false;
          self2.lineno = 0;
          var chomped = lines.$chomp(), trailing = lines.length != chomped.length, splitted = chomped.split(separator);
          for (var i = 0, length = splitted.length; i < length; i++) {
            self2.lineno += 1;
            if (i < length - 1 || trailing) {
              Opal2.yield1(block, splitted[i] + separator);
            } else {
              Opal2.yield1(block, splitted[i]);
            }
          }
          self2.eof = true;
          ;
          return self2;
        } else {
          return self2.$read().$each_line();
        }
        ;
      }, -1);
      $def(self, "$readlines", function $$readlines() {
        var self2 = this;
        return $$("File").$readlines(self2.path);
      });
      return function(self2, $parent_nesting2) {
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3);
        $def(self2, "$readlines", function $$readlines(path, separator) {
          var content = nil;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          if (separator == null)
            separator = $gvars["/"];
          content = $$2("File").$read(path);
          return content.$split(separator);
        }, -2);
        $def(self2, "$file?", $return_val(true));
        $def(self2, "$readable?", $return_val(true));
        return $def(self2, "$read", $return_val(""));
      }(Opal2.get_singleton_class(self), $nesting2);
    })($nesting[0], null, $nesting);
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "IO");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return $defs(self, "$read", function $$read(path) {
        return $$("File").$read(path);
      });
    }($nesting[0], null, $nesting);
  };
  Opal.modules["asciidoctor/js/opal_ext/match_data"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $send = Opal2.send, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("[]=");
    return function($base, $super) {
      var self = $klass($base, $super, "MatchData");
      var $proto = self.$$prototype;
      $proto.matches = nil;
      return $def(self, "$[]=", function $MatchData_$$$eq$1(idx, val) {
        var $a, self2 = this;
        return $a = [idx, val], $send(self2.matches, "[]=", $a), $a[$a.length - 1];
      });
    }($nesting[0], null);
  };
  Opal.modules["asciidoctor/js/opal_ext/string"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $truthy = Opal2.truthy, $rb_lt = Opal2.rb_lt, $def = Opal2.def, $alias = Opal2.alias, $rb_ge = Opal2.rb_ge, $eqeq = Opal2.eqeq, $rb_minus = Opal2.rb_minus, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("method_defined?,<,length,bytes,to_s,byteslice,limit_bytesize,>=,==,-,_original_byteslice,unpack,_original_unpack");
    return function($base, $super) {
      var self = $klass($base, $super, "String");
      if (!$truthy(self["$method_defined?"]("limit_bytesize"))) {
        $def(self, "$limit_bytesize", function $$limit_bytesize(size) {
          var self2 = this, result = nil;
          if (!$truthy($rb_lt(size, self2.$bytes().$length()))) {
            return self2.$to_s();
          }
          ;
          result = self2.$byteslice(0, size);
          return result.$to_s();
        });
      }
      ;
      if (!$truthy(self["$method_defined?"]("limit"))) {
        $alias(self, "limit", "limit_bytesize");
      }
      ;
      $alias(self, "_original_byteslice", "byteslice");
      $def(self, "$byteslice", function $$byteslice(index, length) {
        var self2 = this;
        if (length == null)
          length = 1;
        if ($eqeq(index, 3) && $truthy($rb_ge(length, index)) && $truthy(self2.charCodeAt() === 65279)) {
          return self2.substr(1).$byteslice(0, $rb_minus(length, 3));
        } else {
          return self2.$_original_byteslice(index, length);
        }
        ;
      }, -2);
      $alias(self, "_original_unpack", "unpack");
      return $def(self, "$unpack", function $$unpack(format) {
        var self2 = this;
        if ($eqeq(format, "C3")) {
          if ($truthy(self2.charCodeAt() === 65279)) {
            return [239, 187, 191];
          } else {
            var bytes = [];
            for (var i = 0; i < 3; i++) {
              if (i < self2.length) {
                bytes.push(self2.charCodeAt(i));
              } else {
                bytes.push(nil);
              }
            }
            return bytes;
          }
        } else {
          return self2.$_original_unpack(format);
        }
      });
    }($nesting[0], null);
  };
  Opal.modules["asciidoctor/js/opal_ext/uri"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $defs = Opal2.defs, $return_self = Opal2.return_self, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("extend");
    return function($base, $parent_nesting) {
      var self = $module($base, "URI");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      $defs(self, "$parse", function $$parse(str) {
        return str.$extend($$("URI"));
      });
      return $def(self, "$path", $return_self);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/opal_ext/base64"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $defs = Opal2.defs, $ensure_kwargs = Opal2.ensure_kwargs, $truthy = Opal2.truthy, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("delete");
    return function($base) {
      var self = $module($base, "Base64");
      var encode, decode;
      encode = Opal2.global.btoa || function(input) {
        var buffer;
        if (input instanceof Buffer) {
          buffer = input;
        } else {
          buffer = Buffer.from(input.toString(), "binary");
        }
        return buffer.toString("base64");
      };
      decode = Opal2.global.atob || function(input) {
        return Buffer.from(input, "base64").toString("binary");
      };
      ;
      $defs(self, "$decode64", function $$decode64(string) {
        return decode(string.replace(/\r?\n/g, ""));
      });
      $defs(self, "$encode64", function $$encode64(string) {
        return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
      });
      $defs(self, "$strict_decode64", function $$strict_decode64(string) {
        return decode(string);
      });
      $defs(self, "$strict_encode64", function $$strict_encode64(string) {
        return encode(string);
      });
      $defs(self, "$urlsafe_decode64", function $$urlsafe_decode64(string) {
        return decode(string.replace(/\-/g, "+").replace(/_/g, "/"));
      });
      return $defs(self, "$urlsafe_encode64", function $$urlsafe_encode64(string, $kwargs) {
        var padding, str = nil;
        $kwargs = $ensure_kwargs($kwargs);
        padding = $kwargs.$$smap["padding"];
        if (padding == null)
          padding = true;
        str = encode(string).replace(/\+/g, "-").replace(/\//g, "_");
        if (!$truthy(padding)) {
          str = str.$delete("=");
        }
        ;
        return str;
      }, -2);
    }($nesting[0]);
  };
  Opal.modules["asciidoctor/js/opal_ext/number"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $def = Opal2.def, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil;
    Opal2.add_stubs("coerce_to!,>");
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Number");
      var $nesting2 = [self].concat($parent_nesting), $$2 = Opal2.$r($nesting2);
      return $def(self, "$round", function $$round(ndigits) {
        var self2 = this;
        ;
        ndigits = $$2("Opal")["$coerce_to!"](ndigits, $$2("Integer"), "to_int");
        if ($truthy($rb_gt(ndigits, 0))) {
          return Number(self2.toFixed(ndigits));
        } else {
          return Math.round(self2);
        }
        ;
      }, -1);
    }($nesting[0], $$("Numeric"), $nesting);
  };
  Opal.modules["asciidoctor/js/opal_ext"] = function(Opal2) {
    "use strict";
    var self = Opal2.top, nil = Opal2.nil;
    Opal2.add_stubs("require");
    self.$require("asciidoctor/js/opal_ext/kernel");
    self.$require("asciidoctor/js/opal_ext/file");
    self.$require("asciidoctor/js/opal_ext/match_data");
    self.$require("asciidoctor/js/opal_ext/string");
    self.$require("asciidoctor/js/opal_ext/uri");
    self.$require("asciidoctor/js/opal_ext/base64");
    self.$require("asciidoctor/js/opal_ext/number");
    Opal2.config.unsupported_features_severity = "ignore";
    self.$require("asciidoctor/js/opal_ext/browser");
    ;
  };
  Opal.modules["asciidoctor/js/rx"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $const_set = Opal2.const_set, $send = Opal2.send, $gvars = Opal2.gvars, $truthy = Opal2.truthy, $defs = Opal2.defs, $rb_plus = Opal2.rb_plus, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("gsub,+,unpack_hex_range");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      $const_set($nesting2[0], "HEX_RANGE_RX", /([A-F0-9]{4})(?:-([A-F0-9]{4}))?/);
      $defs(self, "$unpack_hex_range", function $$unpack_hex_range(str) {
        return $send(str, "gsub", [$$("HEX_RANGE_RX")], function $$1() {
          var $a, $ret_or_1 = nil;
          return "\\u" + (($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)) + ($truthy($ret_or_1 = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)) ? "-\\u" + (($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)) : $ret_or_1);
        });
      });
      $const_set($nesting2[0], "P_L", $rb_plus("A-Za-z", self.$unpack_hex_range("00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D037F03860388-038A038C038E-03A103A3-03F503F7-0481048A-052F0531-055605590561-058705D0-05EA05F0-05F20620-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280840-085808A0-08B20904-0939093D09500958-09610971-09800985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA16F1-16F81700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191E1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA67F-A69DA6A0-A6E5A717-A71FA722-A788A78B-A78EA790-A7ADA7B0A7B1A7F7-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFA9E0-A9E4A9E6-A9EFA9FA-A9FEAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA7E-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDAAE0-AAEAAAF2-AAF4AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EAB30-AB5AAB5C-AB5FAB64AB65ABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC")));
      $const_set($nesting2[0], "P_Nl", self.$unpack_hex_range("16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF"));
      $const_set($nesting2[0], "P_Nd", $rb_plus("0-9", self.$unpack_hex_range("0660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0DE6-0DEF0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9A9F0-A9F9AA50-AA59ABF0-ABF9FF10-FF19")));
      $const_set($nesting2[0], "P_Pc", self.$unpack_hex_range("005F203F20402054FE33FE34FE4D-FE4FFF3F"));
      $const_set($nesting2[0], "CC_ALPHA", "" + $$("P_L") + $$("P_Nl"));
      $const_set($nesting2[0], "CG_ALPHA", "[" + $$("CC_ALPHA") + "]");
      $const_set($nesting2[0], "CC_ALNUM", "" + $$("CC_ALPHA") + $$("P_Nd"));
      $const_set($nesting2[0], "CG_ALNUM", "[" + $$("CC_ALNUM") + "]");
      $const_set($nesting2[0], "CC_WORD", "" + $$("CC_ALNUM") + $$("P_Pc"));
      $const_set($nesting2[0], "CG_WORD", "[" + $$("CC_WORD") + "]");
      $const_set($nesting2[0], "CG_BLANK", "[ \\t]");
      $const_set($nesting2[0], "CC_EOL", "(?=\\n|$)");
      $const_set($nesting2[0], "CG_GRAPH", "[^\\s\\x00-\\x1F\\x7F]");
      $const_set($nesting2[0], "CC_ALL", "[\\s\\S]");
      return $const_set($nesting2[0], "CC_ANY", "[^\\n]");
    }($nesting[0], $nesting);
  };
  Opal.modules["strscan"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $def = Opal2.def, $truthy = Opal2.truthy, $eqeqeq = Opal2.eqeqeq, $Opal = Opal2.Opal, $return_ivar = Opal2.return_ivar, $send = Opal2.send, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("attr_reader,anchor,empty?,===,to_s,coerce_to!,scan_until,length,size,rest,pos=,beginning_of_line?,get_byte,private");
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "StringScanner");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
      $proto.pos = $proto.string = $proto.working = $proto.matched = $proto.prev_pos = $proto.match = nil;
      self.$attr_reader("pos", "matched");
      $def(self, "$initialize", function $$initialize(string) {
        var self2 = this;
        self2.string = string;
        self2.pos = 0;
        self2.matched = nil;
        self2.working = string;
        return self2.match = [];
      });
      self.$attr_reader("string");
      $def(self, "$beginning_of_line?", function $StringScanner_beginning_of_line$ques$1() {
        var self2 = this;
        return self2.pos === 0 || self2.string.charAt(self2.pos - 1) === "\n";
      });
      $def(self, "$scan", function $$scan(pattern) {
        var self2 = this;
        pattern = self2.$anchor(pattern);
        var result = pattern.exec(self2.working);
        if (result == null) {
          return self2.matched = nil;
        }
        self2.prev_pos = self2.pos;
        self2.pos += result[0].length;
        self2.working = self2.working.substring(result[0].length);
        self2.matched = result[0];
        self2.match = result;
        return result[0];
        ;
      });
      $def(self, "$scan_until", function $$scan_until(pattern) {
        var self2 = this;
        pattern = self2.$anchor(pattern);
        var working = self2.working;
        for (var i = 0; working.length != i; ++i) {
          var result = pattern.exec(working.substr(i));
          if (result !== null) {
            var matched_size = i + result[0].length;
            var matched = working.substr(0, matched_size);
            self2.matched = result[0];
            self2.match = result;
            self2.prev_pos = self2.pos + i;
            self2.pos += matched_size;
            self2.working = working.substr(matched_size);
            return matched;
          }
        }
        return self2.matched = nil;
        ;
      });
      $def(self, "$[]", function $StringScanner_$$$2(idx) {
        var self2 = this, $ret_or_1 = nil;
        if ($truthy(self2.match["$empty?"]())) {
          return nil;
        }
        ;
        if ($eqeqeq($$("Symbol"), $ret_or_1 = idx)) {
          idx = idx.$to_s();
        } else if (!$eqeqeq($$("String"), $ret_or_1)) {
          idx = $Opal["$coerce_to!"](idx, $$("Integer"), "to_int");
        }
        ;
        var match = self2.match;
        if (idx < 0) {
          idx += match.length;
        }
        if (idx < 0 || idx >= match.length) {
          return nil;
        }
        if (match[idx] == null) {
          return nil;
        }
        return match[idx];
        ;
      });
      $def(self, "$check", function $$check(pattern) {
        var self2 = this;
        pattern = self2.$anchor(pattern);
        var result = pattern.exec(self2.working);
        if (result == null) {
          return self2.matched = nil;
        }
        return self2.matched = result[0];
        ;
      });
      $def(self, "$check_until", function $$check_until(pattern) {
        var self2 = this;
        var old_prev_pos = self2.prev_pos;
        var old_pos = self2.pos;
        var old_working = self2.working;
        var result = self2.$scan_until(pattern);
        self2.prev_pos = old_prev_pos;
        self2.pos = old_pos;
        self2.working = old_working;
        return result;
      });
      $def(self, "$peek", function $$peek(length) {
        var self2 = this;
        return self2.working.substring(0, length);
      });
      $def(self, "$eos?", function $StringScanner_eos$ques$3() {
        var self2 = this;
        return self2.working.length === 0;
      });
      $def(self, "$exist?", function $StringScanner_exist$ques$4(pattern) {
        var self2 = this;
        var result = pattern.exec(self2.working);
        if (result == null) {
          return nil;
        } else if (result.index == 0) {
          return 0;
        } else {
          return result.index + 1;
        }
      });
      $def(self, "$skip", function $$skip(pattern) {
        var self2 = this;
        pattern = self2.$anchor(pattern);
        var result = pattern.exec(self2.working);
        if (result == null) {
          self2.match = [];
          return self2.matched = nil;
        } else {
          var match_str = result[0];
          var match_len = match_str.length;
          self2.matched = match_str;
          self2.match = result;
          self2.prev_pos = self2.pos;
          self2.pos += match_len;
          self2.working = self2.working.substring(match_len);
          return match_len;
        }
        ;
      });
      $def(self, "$skip_until", function $$skip_until(pattern) {
        var self2 = this;
        var result = self2.$scan_until(pattern);
        if (result === nil) {
          return nil;
        } else {
          self2.matched = result.substr(-1);
          return result.length;
        }
      });
      $def(self, "$get_byte", function $$get_byte() {
        var self2 = this;
        var result = nil;
        if (self2.pos < self2.string.length) {
          self2.prev_pos = self2.pos;
          self2.pos += 1;
          result = self2.matched = self2.working.substring(0, 1);
          self2.working = self2.working.substring(1);
        } else {
          self2.matched = nil;
        }
        return result;
      });
      $def(self, "$match?", function $StringScanner_match$ques$5(pattern) {
        var self2 = this;
        pattern = self2.$anchor(pattern);
        var result = pattern.exec(self2.working);
        if (result == null) {
          return nil;
        } else {
          self2.prev_pos = self2.pos;
          return result[0].length;
        }
        ;
      });
      $def(self, "$pos=", function $StringScanner_pos$eq$6(pos) {
        var self2 = this;
        if (pos < 0) {
          pos += self2.string.$length();
        }
        ;
        self2.pos = pos;
        return self2.working = self2.string.slice(pos);
      });
      $def(self, "$matched_size", function $$matched_size() {
        var self2 = this;
        if (self2.matched === nil) {
          return nil;
        }
        return self2.matched.length;
      });
      $def(self, "$post_match", function $$post_match() {
        var self2 = this;
        if (self2.matched === nil) {
          return nil;
        }
        return self2.string.substr(self2.pos);
      });
      $def(self, "$pre_match", function $$pre_match() {
        var self2 = this;
        if (self2.matched === nil) {
          return nil;
        }
        return self2.string.substr(0, self2.prev_pos);
      });
      $def(self, "$reset", function $$reset() {
        var self2 = this;
        self2.working = self2.string;
        self2.matched = nil;
        return self2.pos = 0;
      });
      $def(self, "$rest", $return_ivar("working"));
      $def(self, "$rest?", function $StringScanner_rest$ques$7() {
        var self2 = this;
        return self2.working.length !== 0;
      });
      $def(self, "$rest_size", function $$rest_size() {
        var self2 = this;
        return self2.$rest().$size();
      });
      $def(self, "$terminate", function $$terminate() {
        var $a, self2 = this;
        self2.match = nil;
        return $a = [self2.string.$length()], $send(self2, "pos=", $a), $a[$a.length - 1];
      });
      $def(self, "$unscan", function $$unscan() {
        var self2 = this;
        self2.pos = self2.prev_pos;
        self2.prev_pos = nil;
        self2.match = nil;
        return self2;
      });
      $alias(self, "bol?", "beginning_of_line?");
      $alias(self, "getch", "get_byte");
      self.$private();
      return $def(self, "$anchor", function $$anchor(pattern) {
        var flags = pattern.toString().match(/\/([^\/]+)$/);
        flags = flags ? flags[1] : void 0;
        return new RegExp("^(?:" + pattern.source + ")", flags);
      });
    }($nesting[0], null, $nesting);
  };
  Opal.modules["asciidoctor/js"] = function(Opal2) {
    "use strict";
    var self = Opal2.top, nil = Opal2.nil;
    Opal2.add_stubs("require");
    self.$require("asciidoctor/js/opal_ext");
    self.$require("asciidoctor/js/rx");
    return self.$require("strscan");
  };
  Opal.modules["asciidoctor/core_ext/nil_or_empty"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $truthy = Opal2.truthy, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("method_defined?,nil?,empty?");
    (function($base, $super) {
      var self = $klass($base, $super, "NilClass");
      if ($truthy(self["$method_defined?"]("nil_or_empty?"))) {
        return nil;
      } else {
        return $alias(self, "nil_or_empty?", "nil?");
      }
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, "String");
      if ($truthy(self["$method_defined?"]("nil_or_empty?"))) {
        return nil;
      } else {
        return $alias(self, "nil_or_empty?", "empty?");
      }
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, "Array");
      if ($truthy(self["$method_defined?"]("nil_or_empty?"))) {
        return nil;
      } else {
        return $alias(self, "nil_or_empty?", "empty?");
      }
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, "Hash");
      if ($truthy(self["$method_defined?"]("nil_or_empty?"))) {
        return nil;
      } else {
        return $alias(self, "nil_or_empty?", "empty?");
      }
    })($nesting[0], null);
    return function($base, $super) {
      var self = $klass($base, $super, "Numeric");
      if ($truthy(self["$method_defined?"]("nil_or_empty?"))) {
        return nil;
      } else {
        return $alias(self, "nil_or_empty?", "nil?");
      }
    }($nesting[0], null);
  };
  Opal.modules["asciidoctor/core_ext/hash/merge"] = function(Opal2) {
    "use strict";
    var $eqeq = Opal2.eqeq, $send = Opal2.send, $slice = Opal2.slice, $truthy = Opal2.truthy, $rb_lt = Opal2.rb_lt, $rb_gt = Opal2.rb_gt, $send2 = Opal2.send2, $find_super = Opal2.find_super, $def = Opal2.def, self = Opal2.top, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil;
    Opal2.add_stubs("==,arity,instance_method,send,new,<,length,dup,>,inject,merge,[]");
    if ($eqeq($$("Hash").$instance_method("merge").$arity(), 1)) {
      return $$("Hash").$send("prepend", $send($$("Module"), "new", [], function $$1() {
        var self2 = $$1.$$s == null ? this : $$1.$$s;
        return $def(self2, "$merge", function $$merge($a) {
          var $post_args, args, $yield = $$merge.$$p || nil, self3 = this, len = nil;
          $$merge.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy($rb_lt(len = args.$length(), 1))) {
            return self3.$dup();
          } else {
            if ($truthy($rb_gt(len, 1))) {
              return $send(args, "inject", [self3], function $$2(acc, arg) {
                if (acc == null)
                  acc = nil;
                if (arg == null)
                  arg = nil;
                return acc.$merge(arg);
              });
            } else {
              return $send2(self3, $find_super(self3, "merge", $$merge, false, true), "merge", [args["$[]"](0)], null);
            }
            ;
          }
          ;
        }, -1);
      }, { $$s: self }));
    } else {
      return nil;
    }
  };
  Opal.modules["asciidoctor/core_ext/match_data/names"] = function(Opal2) {
    "use strict";
    var $truthy = Opal2.truthy, $klass = Opal2.klass, $def = Opal2.def, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil;
    Opal2.add_stubs("method_defined?");
    if ($truthy($$("MatchData")["$method_defined?"]("names"))) {
      return nil;
    } else {
      return function($base, $super) {
        var self = $klass($base, $super, "MatchData");
        return $def(self, "$names", function $$names() {
          return [];
        });
      }($nesting[0], null);
    }
  };
  Opal.modules["asciidoctor/core_ext"] = function(Opal2) {
    "use strict";
    var self = Opal2.top, nil = Opal2.nil;
    self.$require("asciidoctor/core_ext.rb/../core_ext/nil_or_empty");
    self.$require("asciidoctor/core_ext.rb/../core_ext/hash/merge");
    return self.$require("asciidoctor/core_ext.rb/../core_ext/match_data/names");
  };
  Opal.modules["asciidoctor/helpers"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $gvars = Opal2.gvars, $def = Opal2.def, $send = Opal2.send, $neqeq = Opal2.neqeq, $const_set = Opal2.const_set, $hash2 = Opal2.hash2, $to_ary = Opal2.to_ary, $rb_times = Opal2.rb_times, $eqeqeq = Opal2.eqeqeq, $rb_plus = Opal2.rb_plus, $Class = Opal2.Class, $Object = Opal2.Object, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("module_function,require,include?,include,==,path,message,raise,warn,logger,chomp,empty?,slice,unpack,[],[]=,byteslice,bytesize,map,rstrip,encode,encoding,nil_or_empty?,!=,tap,each_line,<<,!,start_with?,match?,gsub,rindex,index,basename,extname,length,directory?,dirname,mkdir_p,mkdir,private_constant,join,divmod,*,===,+,to_s,to_i,succ,class_for_name,const_get");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Helpers");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self2.$module_function();
        $def(self2, "$require_library", function $$require_library(name, gem_name, on_failure) {
          var self3 = this, details = nil;
          if ($gvars["!"] == null)
            $gvars["!"] = nil;
          if (gem_name == null)
            gem_name = true;
          if (on_failure == null)
            on_failure = "abort";
          try {
            return self3.$require(name);
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("LoadError")])) {
              try {
                if (!$truthy(self3["$include?"]($$("Logging")))) {
                  self3.$include($$("Logging"));
                }
                ;
                if ($truthy(gem_name)) {
                  if ($eqeq(gem_name, true)) {
                    gem_name = name;
                  }
                  ;
                  switch (on_failure) {
                    case "abort":
                      details = $eqeq($gvars["!"].$path(), gem_name) ? "" : " (reason: " + ($truthy($gvars["!"].$path()) ? "cannot load '" + $gvars["!"].$path() + "'" : $gvars["!"].$message()) + ")";
                      self3.$raise($$$("LoadError"), "asciidoctor: FAILED: required gem '" + gem_name + "' is not available" + details + ". Processing aborted.");
                      break;
                    case "warn":
                      details = $eqeq($gvars["!"].$path(), gem_name) ? "" : " (reason: " + ($truthy($gvars["!"].$path()) ? "cannot load '" + $gvars["!"].$path() + "'" : $gvars["!"].$message()) + ")";
                      self3.$logger().$warn("optional gem '" + gem_name + "' is not available" + details + ". Functionality disabled.");
                      break;
                    default:
                      nil;
                  }
                  ;
                } else
                  switch (on_failure) {
                    case "abort":
                      self3.$raise($$$("LoadError"), "asciidoctor: FAILED: " + $gvars["!"].$message().$chomp(".") + ". Processing aborted.");
                      break;
                    case "warn":
                      self3.$logger().$warn("" + $gvars["!"].$message().$chomp(".") + ". Functionality disabled.");
                      break;
                    default:
                      nil;
                  }
                ;
                return nil;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
        }, -2);
        $def(self2, "$prepare_source_array", function $$prepare_source_array(data, trim_end) {
          var leading_2_bytes = nil, leading_bytes = nil, first = nil;
          if (trim_end == null)
            trim_end = true;
          if ($truthy(data["$empty?"]())) {
            return [];
          }
          ;
          if ($eqeq(leading_2_bytes = (leading_bytes = (first = data["$[]"](0)).$unpack("C3")).$slice(0, 2), $$("BOM_BYTES_UTF_16LE"))) {
            data["$[]="](0, first.$byteslice(2, first.$bytesize()));
            return $truthy(trim_end) ? $send(data, "map", [], function $$1(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16LE")).$rstrip();
            }) : $send(data, "map", [], function $$2(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16LE")).$chomp();
            });
          } else if ($eqeq(leading_2_bytes, $$("BOM_BYTES_UTF_16BE"))) {
            data["$[]="](0, first.$byteslice(2, first.$bytesize()));
            return $truthy(trim_end) ? $send(data, "map", [], function $$3(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16BE")).$rstrip();
            }) : $send(data, "map", [], function $$4(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16BE")).$chomp();
            });
          } else if ($eqeq(leading_bytes, $$("BOM_BYTES_UTF_8"))) {
            data["$[]="](0, first.$byteslice(3, first.$bytesize()));
          }
          ;
          if ($eqeq(first.$encoding(), $$("UTF_8"))) {
            if ($truthy(trim_end)) {
              return $send(data, "map", [], function $$5(line) {
                if (line == null)
                  line = nil;
                return line.$rstrip();
              });
            } else {
              return $send(data, "map", [], function $$6(line) {
                if (line == null)
                  line = nil;
                return line.$chomp();
              });
            }
          } else if ($truthy(trim_end)) {
            return $send(data, "map", [], function $$7(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8")).$rstrip();
            });
          } else {
            return $send(data, "map", [], function $$8(line) {
              if (line == null)
                line = nil;
              return line.$encode($$("UTF_8")).$chomp();
            });
          }
          ;
        }, -2);
        $def(self2, "$prepare_source_string", function $$prepare_source_string(data, trim_end) {
          var leading_2_bytes = nil, leading_bytes = nil;
          if (trim_end == null)
            trim_end = true;
          if ($truthy(data["$nil_or_empty?"]())) {
            return [];
          }
          ;
          if ($eqeq(leading_2_bytes = (leading_bytes = data.$unpack("C3")).$slice(0, 2), $$("BOM_BYTES_UTF_16LE"))) {
            data = data.$byteslice(2, data.$bytesize()).$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16LE"));
          } else if ($eqeq(leading_2_bytes, $$("BOM_BYTES_UTF_16BE"))) {
            data = data.$byteslice(2, data.$bytesize()).$encode($$("UTF_8"), $$$($$$("Encoding"), "UTF_16BE"));
          } else if ($eqeq(leading_bytes, $$("BOM_BYTES_UTF_8"))) {
            data = data.$byteslice(3, data.$bytesize());
            if (!$eqeq(data.$encoding(), $$("UTF_8"))) {
              data = data.$encode($$("UTF_8"));
            }
            ;
          } else if ($neqeq(data.$encoding(), $$("UTF_8"))) {
            data = data.$encode($$("UTF_8"));
          }
          ;
          if ($truthy(trim_end)) {
            return $send([], "tap", [], function $$9(lines) {
              if (lines == null)
                lines = nil;
              return $send(data, "each_line", [], function $$10(line) {
                if (line == null)
                  line = nil;
                return lines["$<<"](line.$rstrip());
              });
            });
          } else {
            return $send([], "tap", [], function $$11(lines) {
              if (lines == null)
                lines = nil;
              return $send(data, "each_line", [], function $$12(line) {
                if (line == null)
                  line = nil;
                return lines["$<<"](line.$chomp());
              });
            });
          }
          ;
        }, -2);
        if ($eqeq($$$("RUBY_ENGINE"), "jruby")) {
          $def(self2, "$uriish?", function $Helpers_uriish$ques$13(str) {
            var $ret_or_1 = nil, $ret_or_2 = nil;
            if ($truthy($ret_or_1 = $truthy($ret_or_2 = str["$include?"](":")) ? str["$start_with?"]("uri:classloader:")["$!"]() : $ret_or_2)) {
              return $$("UriSniffRx")["$match?"](str);
            } else {
              return $ret_or_1;
            }
          });
        } else {
          $def(self2, "$uriish?", function $Helpers_uriish$ques$14(str) {
            var $ret_or_1 = nil;
            if ($truthy($ret_or_1 = str["$include?"](":"))) {
              return $$("UriSniffRx")["$match?"](str);
            } else {
              return $ret_or_1;
            }
          });
        }
        ;
        $def(self2, "$encode_uri_component", function $$encode_uri_component(str) {
          return encodeURIComponent(str).replace(/%20|[!'()*]/g, function(m) {
            return m === "%20" ? "+" : "%" + m.charCodeAt(0).toString(16);
          });
        });
        $def(self2, "$encode_spaces_in_uri", function $$encode_spaces_in_uri(str) {
          if ($truthy(str["$include?"](" "))) {
            return str.$gsub(" ", "%20");
          } else {
            return str;
          }
        });
        $def(self2, "$rootname", function $$rootname(filename) {
          var last_dot_idx = nil;
          if ($truthy(last_dot_idx = filename.$rindex("."))) {
            if ($truthy(filename.$index("/", last_dot_idx))) {
              return filename;
            } else {
              return filename.$slice(0, last_dot_idx);
            }
          } else {
            return filename;
          }
        });
        $def(self2, "$basename", function $$basename(filename, drop_ext) {
          var self3 = this;
          if (drop_ext == null)
            drop_ext = nil;
          if ($truthy(drop_ext)) {
            return $$$("File").$basename(filename, $eqeq(drop_ext, true) ? self3.$extname(filename) : drop_ext);
          } else {
            return $$$("File").$basename(filename);
          }
          ;
        }, -2);
        $def(self2, "$extname?", function $Helpers_extname$ques$15(path) {
          var $ret_or_1 = nil, last_dot_idx = nil;
          if ($truthy($ret_or_1 = last_dot_idx = path.$rindex("."))) {
            return path.$index("/", last_dot_idx)["$!"]();
          } else {
            return $ret_or_1;
          }
        });
        if ($truthy($$$($$$("File"), "ALT_SEPARATOR"))) {
          $def(self2, "$extname", function $$extname(path, fallback) {
            var last_dot_idx = nil;
            if (fallback == null)
              fallback = "";
            if ($truthy(last_dot_idx = path.$rindex("."))) {
              if ($truthy(path.$index("/", last_dot_idx)) || $truthy(path.$index($$$($$$("File"), "ALT_SEPARATOR"), last_dot_idx))) {
                return fallback;
              } else {
                return path.$slice(last_dot_idx, path.$length());
              }
            } else {
              return fallback;
            }
            ;
          }, -2);
        } else {
          $def(self2, "$extname", function $$extname(path, fallback) {
            var last_dot_idx = nil;
            if (fallback == null)
              fallback = "";
            if ($truthy(last_dot_idx = path.$rindex("."))) {
              if ($truthy(path.$index("/", last_dot_idx))) {
                return fallback;
              } else {
                return path.$slice(last_dot_idx, path.$length());
              }
            } else {
              return fallback;
            }
            ;
          }, -2);
        }
        ;
        $def(self2, "$mkdir_p", function $$mkdir_p(dir) {
          var self3 = this, parent_dir = nil;
          if ($truthy($$$("File")["$directory?"](dir))) {
            return nil;
          } else {
            if (!$eqeq(parent_dir = $$$("File").$dirname(dir), ".")) {
              self3.$mkdir_p(parent_dir);
            }
            ;
            try {
              return $$$("Dir").$mkdir(dir);
            } catch ($err) {
              if (Opal2.rescue($err, [$$$("SystemCallError")])) {
                try {
                  if ($truthy($$$("File")["$directory?"](dir))) {
                    return nil;
                  } else {
                    return self3.$raise();
                  }
                } finally {
                  Opal2.pop_exception();
                }
              } else {
                throw $err;
              }
            }
            ;
            ;
          }
        });
        $const_set($nesting3[0], "ROMAN_NUMERALS", $hash2(["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"], { "M": 1e3, "CM": 900, "D": 500, "CD": 400, "C": 100, "XC": 90, "L": 50, "XL": 40, "X": 10, "IX": 9, "V": 5, "IV": 4, "I": 1 }));
        self2.$private_constant("ROMAN_NUMERALS");
        $def(self2, "$int_to_roman", function $$int_to_roman(val) {
          return $send($$("ROMAN_NUMERALS"), "map", [], function $$16(l, i) {
            var $a, $b, repeat = nil;
            if (l == null)
              l = nil;
            if (i == null)
              i = nil;
            $b = val.$divmod(i), $a = $to_ary($b), repeat = $a[0] == null ? nil : $a[0], val = $a[1] == null ? nil : $a[1], $b;
            return $rb_times(l, repeat);
          }).$join();
        });
        $def(self2, "$nextval", function $$nextval(current) {
          var intval = nil;
          if ($eqeqeq($$$("Integer"), current)) {
            return $rb_plus(current, 1);
          } else if ($eqeq((intval = current.$to_i()).$to_s(), current.$to_s())) {
            return $rb_plus(intval, 1);
          } else {
            return current.$succ();
          }
        });
        $def(self2, "$resolve_class", function $$resolve_class(object) {
          var self3 = this;
          if ($eqeqeq($Class, object)) {
            return object;
          } else {
            if ($eqeqeq($$$("String"), object)) {
              return self3.$class_for_name(object);
            } else {
              return nil;
            }
            ;
          }
        });
        return $def(self2, "$class_for_name", function $$class_for_name(qualified_name) {
          var self3 = this, resolved = nil;
          try {
            if (!$eqeqeq($Class, resolved = $Object.$const_get(qualified_name, false))) {
              self3.$raise();
            }
            ;
            return resolved;
          } catch ($err) {
            if (Opal2.rescue($err, [$$("StandardError")])) {
              try {
                return self3.$raise($$$("NameError"), "Could not resolve class for name: " + qualified_name);
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["logger"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $module = Opal2.module, $const_set = Opal2.const_set, $send = Opal2.send, $def = Opal2.def, $eqeqeq = Opal2.eqeqeq, $rb_plus = Opal2.rb_plus, $truthy = Opal2.truthy, $rb_le = Opal2.rb_le, $rb_lt = Opal2.rb_lt, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("include,to_h,map,constants,const_get,to_s,format,chr,strftime,message_as_string,===,+,message,class,join,backtrace,inspect,attr_reader,attr_accessor,new,key,upcase,raise,add,to_proc,<=,<,write,call,[],now");
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Logger");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
      $proto.level = $proto.progname = $proto.pipe = $proto.formatter = nil;
      (function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Severity");
        var $nesting3 = [self2].concat($parent_nesting2);
        $const_set($nesting3[0], "DEBUG", 0);
        $const_set($nesting3[0], "INFO", 1);
        $const_set($nesting3[0], "WARN", 2);
        $const_set($nesting3[0], "ERROR", 3);
        $const_set($nesting3[0], "FATAL", 4);
        return $const_set($nesting3[0], "UNKNOWN", 5);
      })($nesting2[0], $nesting2);
      self.$include($$("Severity"));
      $const_set($nesting2[0], "SEVERITY_LABELS", $send($$("Severity").$constants(), "map", [], function $Logger$1(s) {
        if (s == null)
          s = nil;
        return [$$("Severity").$const_get(s), s.$to_s()];
      }).$to_h());
      (function($base2, $super2, $parent_nesting2) {
        var self2 = $klass($base2, $super2, "Formatter");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3);
        $const_set($nesting3[0], "MESSAGE_FORMAT", "%s, [%s] %5s -- %s: %s\n");
        $const_set($nesting3[0], "DATE_TIME_FORMAT", "%Y-%m-%dT%H:%M:%S.%6N");
        $def(self2, "$call", function $$call(severity, time, progname, msg) {
          var self3 = this;
          return self3.$format($$2("MESSAGE_FORMAT"), severity.$chr(), time.$strftime($$2("DATE_TIME_FORMAT")), severity, progname, self3.$message_as_string(msg));
        });
        return $def(self2, "$message_as_string", function $$message_as_string(msg) {
          var $ret_or_1 = nil, $ret_or_2 = nil;
          if ($eqeqeq($$$("String"), $ret_or_1 = msg)) {
            return msg;
          } else if ($eqeqeq($$$("Exception"), $ret_or_1)) {
            return $rb_plus("" + msg.$message() + " (" + msg.$class() + ")\n", ($truthy($ret_or_2 = msg.$backtrace()) ? $ret_or_2 : []).$join("\n"));
          } else {
            return msg.$inspect();
          }
        });
      })($nesting2[0], null, $nesting2);
      self.$attr_reader("level");
      self.$attr_accessor("progname");
      self.$attr_accessor("formatter");
      $def(self, "$initialize", function $$initialize(pipe) {
        var self2 = this;
        self2.pipe = pipe;
        self2.level = $$("DEBUG");
        return self2.formatter = $$("Formatter").$new();
      });
      $def(self, "$level=", function $Logger_level$eq$2(severity) {
        var self2 = this, level = nil;
        if ($eqeqeq($$$("Integer"), severity)) {
          return self2.level = severity;
        } else if ($truthy(level = $$("SEVERITY_LABELS").$key(severity.$to_s().$upcase()))) {
          return self2.level = level;
        } else {
          return self2.$raise($$("ArgumentError"), "invalid log level: " + severity);
        }
      });
      $def(self, "$info", function $$info(progname) {
        var block = $$info.$$p || nil, self2 = this;
        $$info.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("INFO"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$debug", function $$debug(progname) {
        var block = $$debug.$$p || nil, self2 = this;
        $$debug.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("DEBUG"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$warn", function $$warn(progname) {
        var block = $$warn.$$p || nil, self2 = this;
        $$warn.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("WARN"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$error", function $$error(progname) {
        var block = $$error.$$p || nil, self2 = this;
        $$error.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("ERROR"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$fatal", function $$fatal(progname) {
        var block = $$fatal.$$p || nil, self2 = this;
        $$fatal.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("FATAL"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$unknown", function $$unknown(progname) {
        var block = $$unknown.$$p || nil, self2 = this;
        $$unknown.$$p = null;
        ;
        if (progname == null)
          progname = nil;
        return $send(self2, "add", [$$("UNKNOWN"), nil, progname], block.$to_proc());
      }, -1);
      $def(self, "$info?", function $Logger_info$ques$3() {
        var self2 = this;
        return $rb_le(self2.level, $$("INFO"));
      });
      $def(self, "$debug?", function $Logger_debug$ques$4() {
        var self2 = this;
        return $rb_le(self2.level, $$("DEBUG"));
      });
      $def(self, "$warn?", function $Logger_warn$ques$5() {
        var self2 = this;
        return $rb_le(self2.level, $$("WARN"));
      });
      $def(self, "$error?", function $Logger_error$ques$6() {
        var self2 = this;
        return $rb_le(self2.level, $$("ERROR"));
      });
      $def(self, "$fatal?", function $Logger_fatal$ques$7() {
        var self2 = this;
        return $rb_le(self2.level, $$("FATAL"));
      });
      return $def(self, "$add", function $$add(severity, message, progname) {
        var block = $$add.$$p || nil, self2 = this, $ret_or_1 = nil;
        $$add.$$p = null;
        ;
        if (message == null)
          message = nil;
        if (progname == null)
          progname = nil;
        if ($truthy($rb_lt(severity = $truthy($ret_or_1 = severity) ? $ret_or_1 : $$("UNKNOWN"), self2.level))) {
          return true;
        }
        ;
        progname = $truthy($ret_or_1 = progname) ? $ret_or_1 : self2.progname;
        if (!$truthy(message)) {
          if (block !== nil) {
            message = Opal2.yieldX(block, []);
          } else {
            message = progname;
            progname = self2.progname;
          }
        }
        ;
        self2.pipe.$write(self2.formatter.$call($truthy($ret_or_1 = $$("SEVERITY_LABELS")["$[]"](severity)) ? $ret_or_1 : "ANY", $$$("Time").$now(), progname, message));
        return true;
      }, -2);
    }($nesting[0], null, $nesting);
  };
  Opal.modules["asciidoctor/logging"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $slice = Opal2.slice, $send2 = Opal2.send2, $find_super = Opal2.find_super, $to_a = Opal2.to_a, $send = Opal2.send, $def = Opal2.def, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $const_set = Opal2.const_set, $hash2 = Opal2.hash2, $eqeqeq = Opal2.eqeqeq, $gvars = Opal2.gvars, $alias = Opal2.alias, $defs = Opal2.defs, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("require,attr_reader,progname=,formatter=,new,level=,>,[],===,inspect,to_h,map,constants,const_get,<<,clear,empty?,max,attr_accessor,memoize_logger,private,logger,extend,private_class_method,merge");
    self.$require("logger");
    return function($base, $parent_nesting) {
      var self2 = $module($base, "Asciidoctor");
      var $nesting2 = [self2].concat($parent_nesting);
      (function($base2, $super, $parent_nesting2) {
        var self3 = $klass($base2, $super, "Logger");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self3.$$prototype;
        $proto.max_severity = nil;
        self3.$attr_reader("max_severity");
        $def(self3, "$initialize", function $$initialize($a) {
          var $post_args, args, $b, $yield = $$initialize.$$p || nil, self4 = this;
          $$initialize.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          $send2(self4, $find_super(self4, "initialize", $$initialize, false, true), "initialize", $to_a(args), $yield);
          self4["$progname="]("asciidoctor");
          self4["$formatter="]($$("BasicFormatter").$new());
          return $b = [$$("WARN")], $send(self4, "level=", $b), $b[$b.length - 1];
        }, -1);
        $def(self3, "$add", function $$add(severity, message, progname) {
          var $yield = $$add.$$p || nil, self4 = this, $ret_or_1 = nil;
          $$add.$$p = null;
          if (message == null)
            message = nil;
          if (progname == null)
            progname = nil;
          if ($truthy($rb_gt(severity = $truthy($ret_or_1 = severity) ? $ret_or_1 : $$("UNKNOWN"), self4.max_severity = $truthy($ret_or_1 = self4.max_severity) ? $ret_or_1 : severity))) {
            self4.max_severity = severity;
          }
          ;
          return $send2(self4, $find_super(self4, "add", $$add, false, true), "add", [severity, message, progname], $yield);
        }, -2);
        (function($base3, $super2, $parent_nesting3) {
          var self4 = $klass($base3, $super2, "BasicFormatter");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $const_set($nesting4[0], "SEVERITY_LABEL_SUBSTITUTES", $hash2(["WARN", "FATAL"], { "WARN": "WARNING", "FATAL": "FAILED" }));
          return $def(self4, "$call", function $$call(severity, _, progname, msg) {
            var $ret_or_1 = nil;
            return "" + progname + ": " + ($truthy($ret_or_1 = $$2("SEVERITY_LABEL_SUBSTITUTES")["$[]"](severity)) ? $ret_or_1 : severity) + ": " + ($eqeqeq($$$("String"), msg) ? msg : msg.$inspect()) + $$2("LF");
          });
        })($nesting3[0], $$("Formatter"), $nesting3);
        return function($base3) {
          var self4 = $module($base3, "AutoFormattingMessage");
          return $def(self4, "$inspect", function $$inspect() {
            var self5 = this, sloc = nil;
            if ($truthy(sloc = self5["$[]"]("source_location"))) {
              return "" + sloc + ": " + self5["$[]"]("text");
            } else {
              return self5["$[]"]("text");
            }
          });
        }($nesting3[0]);
      })($nesting2[0], $$$("Logger"), $nesting2);
      (function($base2, $super, $parent_nesting2) {
        var self3 = $klass($base2, $super, "MemoryLogger");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self3.$$prototype;
        $proto.messages = nil;
        $const_set($nesting3[0], "SEVERITY_SYMBOL_BY_VALUE", $send($$("Severity").$constants(false), "map", [], function $MemoryLogger$1(c) {
          if (c == null)
            c = nil;
          return [$$("Severity").$const_get(c), c];
        }).$to_h());
        self3.$attr_reader("messages");
        $def(self3, "$initialize", function $$initialize() {
          var self4 = this;
          self4["$level="]($$("WARN"));
          return self4.messages = [];
        });
        $def(self3, "$add", function $$add(severity, message, progname) {
          var $yield = $$add.$$p || nil, self4 = this, $ret_or_1 = nil;
          $$add.$$p = null;
          if (message == null)
            message = nil;
          if (progname == null)
            progname = nil;
          message = $truthy($ret_or_1 = message) ? $ret_or_1 : $yield !== nil ? Opal2.yieldX($yield, []) : progname;
          self4.messages["$<<"]($hash2(["severity", "message"], { "severity": $$("SEVERITY_SYMBOL_BY_VALUE")["$[]"]($truthy($ret_or_1 = severity) ? $ret_or_1 : $$("UNKNOWN")), "message": message }));
          return true;
        }, -2);
        $def(self3, "$clear", function $$clear() {
          var self4 = this;
          return self4.messages.$clear();
        });
        $def(self3, "$empty?", function $MemoryLogger_empty$ques$2() {
          var self4 = this;
          return self4.messages["$empty?"]();
        });
        return $def(self3, "$max_severity", function $$max_severity() {
          var self4 = this;
          if ($truthy(self4["$empty?"]())) {
            return nil;
          } else {
            return $send(self4.messages, "map", [], function $$3(m) {
              if (m == null)
                m = nil;
              return $$("Severity").$const_get(m["$[]"]("severity"));
            }).$max();
          }
        });
      })($nesting2[0], $$$("Logger"), $nesting2);
      (function($base2, $super, $parent_nesting2) {
        var self3 = $klass($base2, $super, "NullLogger");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self3.$$prototype;
        $proto.max_severity = nil;
        self3.$attr_reader("max_severity");
        $def(self3, "$initialize", function $$initialize() {
          var $a, self4 = this;
          return $a = [$$("WARN")], $send(self4, "level=", $a), $a[$a.length - 1];
        });
        return $def(self3, "$add", function $$add(severity, message, progname) {
          var self4 = this, $ret_or_1 = nil;
          if (message == null)
            message = nil;
          if (progname == null)
            progname = nil;
          if ($truthy($rb_gt(severity = $truthy($ret_or_1 = severity) ? $ret_or_1 : $$("UNKNOWN"), self4.max_severity = $truthy($ret_or_1 = self4.max_severity) ? $ret_or_1 : severity))) {
            self4.max_severity = severity;
          }
          ;
          return true;
        }, -2);
      })($nesting2[0], $$$("Logger"), $nesting2);
      (function($base2, $parent_nesting2) {
        var self3 = $module($base2, "LoggerManager");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self3.logger_class = $$("Logger");
        return function(self4, $parent_nesting3) {
          var $nesting4 = [self4].concat($parent_nesting3);
          self4.$attr_accessor("logger_class");
          $def(self4, "$logger", function $$logger(pipe) {
            var self5 = this, $ret_or_1 = nil;
            if (self5.logger == null)
              self5.logger = nil;
            if (self5.logger_class == null)
              self5.logger_class = nil;
            if ($gvars.stderr == null)
              $gvars.stderr = nil;
            if (pipe == null)
              pipe = $gvars.stderr;
            self5.$memoize_logger();
            return self5.logger = $truthy($ret_or_1 = self5.logger) ? $ret_or_1 : self5.logger_class.$new(pipe);
          }, -1);
          $def(self4, "$logger=", function $logger$eq$4(new_logger) {
            var self5 = this, $ret_or_1 = nil;
            if (self5.logger_class == null)
              self5.logger_class = nil;
            if ($gvars.stderr == null)
              $gvars.stderr = nil;
            return self5.logger = $truthy($ret_or_1 = new_logger) ? $ret_or_1 : self5.logger_class.$new($gvars.stderr);
          });
          self4.$private();
          return $def(self4, "$memoize_logger", function $$memoize_logger() {
            var self5 = this;
            return function(self6, $parent_nesting4) {
              $alias(self6, "logger", "logger");
              return self6.$attr_reader("logger");
            }(Opal2.get_singleton_class(self5), $nesting4);
          });
        }(Opal2.get_singleton_class(self3), $nesting3);
      })($nesting2[0], $nesting2);
      return function($base2, $parent_nesting2) {
        var self3 = $module($base2, "Logging");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        $defs(self3, "$included", function $$included(into) {
          return into.$extend($$("Logging"));
        });
        self3.$private_class_method("included");
        $def(self3, "$logger", function $$logger() {
          return $$("LoggerManager").$logger();
        });
        return $def(self3, "$message_with_context", function $$message_with_context(text, context) {
          if (context == null)
            context = $hash2([], {});
          return $hash2(["text"], { "text": text }).$merge(context).$extend($$$($$("Logger"), "AutoFormattingMessage"));
        }, -2);
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/rx"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $const_set = Opal2.const_set, $regexp = Opal2.regexp, $hash2 = Opal2.hash2, $send = Opal2.send, $truthy = Opal2.truthy, $hash = Opal2.hash, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("join,to_a,new,[]=,empty?,escape");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      $module($nesting2[0], "Rx");
      $const_set($nesting2[0], "AuthorInfoLineRx", $regexp(["^(", $$("CG_WORD"), "[", $$("CC_WORD"), "\\-'.]*)(?: +(", $$("CG_WORD"), "[", $$("CC_WORD"), "\\-'.]*))?(?: +(", $$("CG_WORD"), "[", $$("CC_WORD"), "\\-'.]*))?(?: +<([^>]+)>)?$"]));
      $const_set($nesting2[0], "AuthorDelimiterRx", /;(?: |$)/);
      $const_set($nesting2[0], "RevisionInfoLineRx", $regexp(["^(?:[^\\d{]*(", $$("CC_ANY"), "*?),)? *(?!:)(", $$("CC_ANY"), "*?)(?: *(?!^),?: *(", $$("CC_ANY"), "*))?$"]));
      $const_set($nesting2[0], "ManpageTitleVolnumRx", $regexp(["^(", $$("CC_ANY"), "+?) *\\( *(", $$("CC_ANY"), "+?) *\\)$"]));
      $const_set($nesting2[0], "ManpageNamePurposeRx", $regexp(["^(", $$("CC_ANY"), "+?) +- +(", $$("CC_ANY"), "+)$"]));
      $const_set($nesting2[0], "ConditionalDirectiveRx", $regexp(["^(\\\\)?(ifdef|ifndef|ifeval|endif)::(\\S*?(?:([,+])\\S*?)?)\\[(", $$("CC_ANY"), "+)?\\]$"]));
      $const_set($nesting2[0], "EvalExpressionRx", $regexp(["^(", $$("CC_ANY"), "+?) *([=!><]=|[><]) *(", $$("CC_ANY"), "+)$"]));
      $const_set($nesting2[0], "IncludeDirectiveRx", $regexp(["^(\\\\)?include::([^\\s\\[](?:[^\\[]*[^\\s\\[])?)\\[(", $$("CC_ANY"), "+)?\\]$"]));
      $const_set($nesting2[0], "TagDirectiveRx", /\b(?:tag|(e)nd)::(\S+?)\[\](?=$|[ \r])/m);
      $const_set($nesting2[0], "AttributeEntryRx", $regexp(["^:(!?", $$("CG_WORD"), "[^:]*):(?:[ \\t]+(", $$("CC_ANY"), "*))?$"]));
      $const_set($nesting2[0], "InvalidAttributeNameCharsRx", $regexp(["[^", $$("CC_WORD"), "-]"]));
      $const_set($nesting2[0], "AttributeEntryPassMacroRx", $regexp(["^pass:([a-z]+(?:,[a-z-]+)*)?\\[(", $$("CC_ALL"), "*)\\]$"]));
      $const_set($nesting2[0], "AttributeReferenceRx", $regexp(["(\\\\)?\\{(", $$("CG_WORD"), "[", $$("CC_WORD"), "-]*|(set|counter2?):", $$("CC_ANY"), "+?)(\\\\)?\\}"]));
      $const_set($nesting2[0], "BlockAnchorRx", $regexp(["^\\[\\[(?:|([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+))?)\\]\\]$"]));
      $const_set($nesting2[0], "BlockAttributeListRx", $regexp(["^\\[(|[", $$("CC_WORD"), `.#%{,"']`, $$("CC_ANY"), "*)\\]$"]));
      $const_set($nesting2[0], "BlockAttributeLineRx", $regexp(["^\\[(?:|[", $$("CC_WORD"), `.#%{,"']`, $$("CC_ANY"), "*|\\[(?:|[", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*(?:, *", $$("CC_ANY"), "+)?)\\])\\]$"]));
      $const_set($nesting2[0], "BlockTitleRx", $regexp(["^\\.(\\.?[^ \\t.]", $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "AdmonitionParagraphRx", $regexp(["^(", $$("ADMONITION_STYLES").$to_a().$join("|"), "):[ \\t]+"]));
      $const_set($nesting2[0], "LiteralParagraphRx", $regexp(["^([ \\t]+", $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "AtxSectionTitleRx", $regexp(["^(=={0,5})[ \\t]+(", $$("CC_ANY"), "+?)(?:[ \\t]+\\1)?$"]));
      $const_set($nesting2[0], "ExtAtxSectionTitleRx", $regexp(["^(=={0,5}|#\\#{0,5})[ \\t]+(", $$("CC_ANY"), "+?)(?:[ \\t]+\\1)?$"]));
      $const_set($nesting2[0], "SetextSectionTitleRx", $regexp(["^((?!\\.)", $$("CC_ANY"), "*?", $$("CG_ALNUM"), $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "InlineSectionAnchorRx", $regexp([" (\\\\)?\\[\\[([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+))?\\]\\]$"]));
      $const_set($nesting2[0], "InvalidSectionIdCharsRx", $regexp(["<[^>]+>|&(?:[a-z][a-z]+\\d{0,2}|#\\d\\d\\d{0,4}|#x[\\da-f][\\da-f][\\da-f]{0,3});|[^ ", $$("CC_WORD"), "\\-.]+?"]));
      $const_set($nesting2[0], "SectionLevelStyleRx", /^sect\d$/);
      $const_set($nesting2[0], "AnyListRx", $regexp(["^(?:[ \\t]*(?:-|\\*\\**|\\.\\.*|\\u2022|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]|(?!//[^/])[ \\t]*[^ \\t]", $$("CC_ANY"), "*?(?::::{0,2}|;;)(?:$|[ \\t])|<(?:\\d+|\\.)>[ \\t])"]));
      $const_set($nesting2[0], "UnorderedListRx", $regexp(["^[ \\t]*(-|\\*\\**|\\u2022)[ \\t]+(", $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "OrderedListRx", $regexp(["^[ \\t]*(\\.\\.*|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]+(", $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "OrderedListMarkerRxMap", $hash2(["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"], { "arabic": /\d+\./, "loweralpha": /[a-z]\./, "lowerroman": /[ivx]+\)/, "upperalpha": /[A-Z]\./, "upperroman": /[IVX]+\)/ }));
      $const_set($nesting2[0], "DescriptionListRx", $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$("CC_ANY"), "*?)(:::{0,2}|;;)(?:$|[ \\t]+(", $$("CC_ANY"), "*)$)"]));
      $const_set($nesting2[0], "DescriptionListSiblingRx", $hash2(["::", ":::", "::::", ";;"], { "::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$("CC_ANY"), "*?[^:]|[^ \\t:])(::)(?:$|[ \\t]+(", $$("CC_ANY"), "*)$)"]), ":::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$("CC_ANY"), "*?[^:]|[^ \\t:])(:::)(?:$|[ \\t]+(", $$("CC_ANY"), "*)$)"]), "::::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$("CC_ANY"), "*?[^:]|[^ \\t:])(::::)(?:$|[ \\t]+(", $$("CC_ANY"), "*)$)"]), ";;": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$("CC_ANY"), "*?)(;;)(?:$|[ \\t]+(", $$("CC_ANY"), "*)$)"]) }));
      $const_set($nesting2[0], "CalloutListRx", $regexp(["^<(\\d+|\\.)>[ \\t]+(", $$("CC_ANY"), "*)$"]));
      $const_set($nesting2[0], "CalloutExtractRx", /((?:\/\/|#|--|;;) ?)?(\\)?<!?(|--)(\d+|\.)\3>(?=(?: ?\\?<!?\3(?:\d+|\.)\3>)*$)/);
      $const_set($nesting2[0], "CalloutExtractRxt", "(\\\\)?<()(\\d+|\\.)>(?=(?: ?\\\\?<(?:\\d+|\\.)>)*$)");
      $const_set($nesting2[0], "CalloutExtractRxMap", $send($$$("Hash"), "new", [], function $Asciidoctor$1(h, k) {
        var $a;
        if (h == null)
          h = nil;
        if (k == null)
          k = nil;
        return $a = [k, $regexp(["(", $truthy(k["$empty?"]()) ? "" : "" + $$$("Regexp").$escape(k) + " ?", ")?", $$("CalloutExtractRxt")])], $send(h, "[]=", $a), $a[$a.length - 1];
      }));
      $const_set($nesting2[0], "CalloutScanRx", $regexp(["\\\\?<!?(|--)(\\d+|\\.)\\1>(?=(?: ?\\\\?<!?\\1(?:\\d+|\\.)\\1>)*", $$("CC_EOL"), ")"]));
      $const_set($nesting2[0], "CalloutSourceRx", $regexp(["((?://|#|--|;;) ?)?(\\\\)?&lt;!?(|--)(\\d+|\\.)\\3&gt;(?=(?: ?\\\\?&lt;!?\\3(?:\\d+|\\.)\\3&gt;)*", $$("CC_EOL"), ")"]));
      $const_set($nesting2[0], "CalloutSourceRxt", "(\\\\)?&lt;()(\\d+|\\.)&gt;(?=(?: ?\\\\?&lt;(?:\\d+|\\.)&gt;)*" + $$("CC_EOL") + ")");
      $const_set($nesting2[0], "CalloutSourceRxMap", $send($$$("Hash"), "new", [], function $Asciidoctor$2(h, k) {
        var $a;
        if (h == null)
          h = nil;
        if (k == null)
          k = nil;
        return $a = [k, $regexp(["(", $truthy(k["$empty?"]()) ? "" : "" + $$$("Regexp").$escape(k) + " ?", ")?", $$("CalloutSourceRxt")])], $send(h, "[]=", $a), $a[$a.length - 1];
      }));
      $const_set($nesting2[0], "ListRxMap", $hash2(["ulist", "olist", "dlist", "colist"], { "ulist": $$("UnorderedListRx"), "olist": $$("OrderedListRx"), "dlist": $$("DescriptionListRx"), "colist": $$("CalloutListRx") }));
      $const_set($nesting2[0], "ColumnSpecRx", /^(?:(\d+)\*)?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?(\d+%?|~)?([a-z])?$/);
      $const_set($nesting2[0], "CellSpecStartRx", /^[ \t]*(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
      $const_set($nesting2[0], "CellSpecEndRx", /[ \t]+(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
      $const_set($nesting2[0], "CustomBlockMacroRx", $regexp(["^(", $$("CG_WORD"), "[", $$("CC_WORD"), "-]*)::(|\\S|\\S", $$("CC_ANY"), "*?\\S)\\[(", $$("CC_ANY"), "+)?\\]$"]));
      $const_set($nesting2[0], "BlockMediaMacroRx", $regexp(["^(image|video|audio)::(\\S|\\S", $$("CC_ANY"), "*?\\S)\\[(", $$("CC_ANY"), "+)?\\]$"]));
      $const_set($nesting2[0], "BlockTocMacroRx", $regexp(["^toc::\\[(", $$("CC_ANY"), "+)?\\]$"]));
      $const_set($nesting2[0], "InlineAnchorRx", $regexp(["(\\\\)?(?:\\[\\[([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+?))?\\]\\]|anchor:([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)\\[(?:\\]|(", $$("CC_ANY"), "*?[^\\\\])\\]))"]));
      $const_set($nesting2[0], "InlineAnchorScanRx", $regexp(["(?:^|[^\\\\\\[])\\[\\[([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+?))?\\]\\]|(?:^|[^\\\\])anchor:([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)\\[(?:\\]|(", $$("CC_ANY"), "*?[^\\\\])\\])"]));
      $const_set($nesting2[0], "LeadingInlineAnchorRx", $regexp(["^\\[\\[([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+?))?\\]\\]"]));
      $const_set($nesting2[0], "InlineBiblioAnchorRx", $regexp(["^\\[\\[\\[([", $$("CC_ALPHA"), "_:][", $$("CC_WORD"), "\\-:.]*)(?:, *(", $$("CC_ANY"), "+?))?\\]\\]\\]"]));
      $const_set($nesting2[0], "InlineEmailRx", $regexp(["([\\\\>:/])?", $$("CG_WORD"), "(?:&amp;|[", $$("CC_WORD"), "\\-.%+])*@", $$("CG_ALNUM"), "[", $$("CC_ALNUM"), "_\\-.]*\\.[a-zA-Z]{2,5}\\b"]));
      $const_set($nesting2[0], "InlineFootnoteMacroRx", $regexp(["\\\\?footnote(?:(ref):|:([", $$("CC_WORD"), "-]+)?)\\[(?:|(", $$("CC_ALL"), "*?[^\\\\]))\\](?!</a>)"], "m"));
      $const_set($nesting2[0], "InlineImageMacroRx", $regexp(["\\\\?i(?:mage|con):([^:\\s\\[](?:[^\\n\\[]*[^\\s\\[])?)\\[(|", $$("CC_ALL"), "*?[^\\\\])\\]"], "m"));
      $const_set($nesting2[0], "InlineIndextermMacroRx", $regexp(["\\\\?(?:(indexterm2?):\\[(", $$("CC_ALL"), "*?[^\\\\])\\]|\\(\\((", $$("CC_ALL"), "+?)\\)\\)(?!\\)))"], "m"));
      $const_set($nesting2[0], "InlineKbdBtnMacroRx", $regexp(["(\\\\)?(kbd|btn):\\[(", $$("CC_ALL"), "*?[^\\\\])\\]"], "m"));
      $const_set($nesting2[0], "InlineLinkRx", $regexp(["(^|link:|", $$("CG_BLANK"), `|&lt;|[>\\(\\)\\[\\];"'])(\\\\?(?:https?|file|ftp|irc)://)(?:([^\\s\\[\\]]+)\\[(|`, $$("CC_ALL"), "*?[^\\\\])\\]|([^\\s\\[\\]<]*([^\\s,.?!\\[\\]<\\)])))"], "m"));
      $const_set($nesting2[0], "InlineLinkMacroRx", $regexp(["\\\\?(?:link|(mailto)):(|[^:\\s\\[][^\\s\\[]*)\\[(|", $$("CC_ALL"), "*?[^\\\\])\\]"], "m"));
      $const_set($nesting2[0], "MacroNameRx", $regexp(["^", $$("CG_WORD"), "[", $$("CC_WORD"), "-]*$"]));
      $const_set($nesting2[0], "InlineStemMacroRx", $regexp(["\\\\?(stem|(?:latex|ascii)math):([a-z]+(?:,[a-z-]+)*)?\\[(", $$("CC_ALL"), "*?[^\\\\])\\]"], "m"));
      $const_set($nesting2[0], "InlineMenuMacroRx", $regexp(["\\\\?menu:(", $$("CG_WORD"), "|[", $$("CC_WORD"), "&][^\\n\\[]*[^\\s\\[])\\[ *(?:|(", $$("CC_ALL"), "*?[^\\\\]))\\]"], "m"));
      $const_set($nesting2[0], "InlineMenuRx", $regexp(['\\\\?"([', $$("CC_WORD"), '&][^"]*?[ \\n]+&gt;[ \\n]+[^"]*)"']));
      $const_set($nesting2[0], "InlinePassRx", $hash(false, ["+", "-]", $regexp(["((?:^|[^", $$("CC_WORD"), ";:\\\\])(?=(\\[)|\\+)|\\\\(?=\\[)|(?=\\\\\\+))(?:\\2(x-|[^\\]]+ x-)\\]|(?:\\[([^\\]]+)\\])?(?=(\\\\)?\\+))(\\5?(\\+|`)(\\S|\\S", $$("CC_ALL"), "*?\\S)\\7)(?!", $$("CG_WORD"), ")"], "m")], true, ["`", nil, $regexp(["(^|[^`", $$("CC_WORD"), "])(?:(\\Z)()|\\[([^\\]]+)\\](?=(\\\\))?)?(\\5?(`)([^`\\s]|[^`\\s]", $$("CC_ALL"), "*?\\S)\\7)(?![`", $$("CC_WORD"), "])"], "m")]));
      $const_set($nesting2[0], "InlinePassMacroRx", $regexp(["(?:(?:(\\\\?)\\[([^\\]]+)\\])?(\\\\{0,2})(\\+\\+\\+?|\\$\\$)(", $$("CC_ALL"), "*?)\\4|(\\\\?)pass:([a-z]+(?:,[a-z-]+)*)?\\[(|", $$("CC_ALL"), "*?[^\\\\])\\])"], "m"));
      $const_set($nesting2[0], "InlineXrefMacroRx", $regexp(["\\\\?(?:&lt;&lt;([", $$("CC_WORD"), "#/.:{]", $$("CC_ALL"), "*?)&gt;&gt;|xref:([", $$("CC_WORD"), "#/.:{]", $$("CC_ALL"), "*?)\\[(?:\\]|(", $$("CC_ALL"), "*?[^\\\\])\\]))"], "m"));
      $const_set($nesting2[0], "HardLineBreakRx", $regexp(["^(", $$("CC_ANY"), "*) \\+$"], "m"));
      $const_set($nesting2[0], "MarkdownThematicBreakRx", /^ {0,3}([-*_])( *)\1\2\1$/);
      $const_set($nesting2[0], "ExtLayoutBreakRx", /^(?:'{3,}|<{3,}|([-*_])( *)\1\2\1)$/);
      $const_set($nesting2[0], "BlankLineRx", /\n{2,}/);
      $const_set($nesting2[0], "EscapedSpaceRx", /\\([ \t\n])/);
      $const_set($nesting2[0], "ReplaceableTextRx", /[&']|--|\.\.\.|\([CRT]M?\)/);
      $const_set($nesting2[0], "SpaceDelimiterRx", /([^\\])[ \t\n]+/);
      $const_set($nesting2[0], "SubModifierSniffRx", /[+-]/);
      $const_set($nesting2[0], "TrailingDigitsRx", /\d+$/);
      $const_set($nesting2[0], "UriSniffRx", $regexp(["^", $$("CG_ALPHA"), "[", $$("CC_ALNUM"), ".+-]+:/{0,2}"]));
      return $const_set($nesting2[0], "XmlSanitizeRx", /<[^>]+>/);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/substitutors"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $const_set = Opal2.const_set, $hash2 = Opal2.hash2, $hash = Opal2.hash, $rb_plus = Opal2.rb_plus, $regexp = Opal2.regexp, $not = Opal2.not, $truthy = Opal2.truthy, $send = Opal2.send, $def = Opal2.def, $alias = Opal2.alias, $gvars = Opal2.gvars, $eqeq = Opal2.eqeq, $to_ary = Opal2.to_ary, $neqeq = Opal2.neqeq, $to_a = Opal2.to_a, $eqeqeq = Opal2.eqeqeq, $rb_gt = Opal2.rb_gt, $slice = Opal2.slice, $rb_minus = Opal2.rb_minus, $rb_lt = Opal2.rb_lt, $rb_times = Opal2.rb_times, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("freeze,+,keys,!,empty?,===,[],join,include?,extract_passthroughs,each,sub_specialchars,sub_quotes,sub_attributes,sub_replacements,sub_macros,highlight_source,sub_callouts,sub_post_replacements,warn,logger,restore_passthroughs,clear,split,apply_subs,gsub,match?,compat_mode,convert_quoted_text,attributes,==,shift,store_attribute,!=,attribute_undefined,counter,key?,downcase,attribute_missing,info,squeeze,delete,reject,start_with?,do_replacement,inline_macros?,extensions,inline_macros,regexp,instance,slice,length,names,config,merge,[]=,normalize_text,parse_attributes,process_method,expand_subs,text=,text,convert,class,strip,index,min,compact,>,end_with?,map,chop,new,pop,rstrip,register,tr,basename,parse,lstrip,split_simple_csv,-,partition,extract_attributes_from_text,sub,encode_uri_component,style,extname?,rindex,catalog,info?,fetch,outfilesuffix,natural_xrefs,resolve_id,find,footnotes,id,<,size,<<,attr?,attr,to_s,read_next_id,callouts,highlight?,syntax_highlighter,sub_source,extract_callouts,name,to_i,to_sym,resolve_lines_to_highlight,highlight,nil_or_empty?,restore_callouts,count,to_a,|,sort,*,parse_quoted_text_attributes,resolve_pass_subs,basebackend?,error,chr,drop,&,resolve_subs,resolve_block_subs,parse_into,private,shorthand_property_syntax,each_char");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Substitutors");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        $const_set($nesting3[0], "SpecialCharsRx", /[<&>]/);
        $const_set($nesting3[0], "SpecialCharsTr", $hash2([">", "<", "&"], { ">": "&gt;", "<": "&lt;", "&": "&amp;" }));
        $const_set($nesting3[0], "QuotedTextSniffRx", $hash(false, /[*_`#^~]/, true, /[*'_+#^~]/));
        $const_set($nesting3[0], "BASIC_SUBS", ["specialcharacters"]).$freeze();
        $const_set($nesting3[0], "HEADER_SUBS", ["specialcharacters", "attributes"]).$freeze();
        $const_set($nesting3[0], "NO_SUBS", []).$freeze();
        $const_set($nesting3[0], "NORMAL_SUBS", ["specialcharacters", "quotes", "attributes", "replacements", "macros", "post_replacements"]).$freeze();
        $const_set($nesting3[0], "REFTEXT_SUBS", ["specialcharacters", "quotes", "replacements"]).$freeze();
        $const_set($nesting3[0], "VERBATIM_SUBS", ["specialcharacters", "callouts"]).$freeze();
        $const_set($nesting3[0], "SUB_GROUPS", $hash2(["none", "normal", "verbatim", "specialchars"], { "none": $$("NO_SUBS"), "normal": $$("NORMAL_SUBS"), "verbatim": $$("VERBATIM_SUBS"), "specialchars": $$("BASIC_SUBS") }));
        $const_set($nesting3[0], "SUB_HINTS", $hash2(["a", "m", "n", "p", "q", "r", "c", "v"], { "a": "attributes", "m": "macros", "n": "normal", "p": "post_replacements", "q": "quotes", "r": "replacements", "c": "specialcharacters", "v": "verbatim" }));
        $const_set($nesting3[0], "SUB_OPTIONS", $hash2(["block", "inline"], { "block": $rb_plus($rb_plus($$("SUB_GROUPS").$keys(), $$("NORMAL_SUBS")), ["callouts"]), "inline": $rb_plus($$("SUB_GROUPS").$keys(), $$("NORMAL_SUBS")) }));
        $const_set($nesting3[0], "CAN", "");
        $const_set($nesting3[0], "DEL", "\x7F");
        $const_set($nesting3[0], "PASS_START", "\x96");
        $const_set($nesting3[0], "PASS_END", "\x97");
        $const_set($nesting3[0], "PassSlotRx", $regexp([$$("PASS_START"), "(\\d+)", $$("PASS_END")]));
        $const_set($nesting3[0], "HighlightedPassSlotRx", $regexp(["<span\\b[^>]*>", $$("PASS_START"), "</span>[^\\d]*(\\d+)[^\\d]*<span\\b[^>]*>", $$("PASS_END"), "</span>"]));
        $const_set($nesting3[0], "RS", "\\");
        $const_set($nesting3[0], "R_SB", "]");
        $const_set($nesting3[0], "ESC_R_SB", "\\]");
        $const_set($nesting3[0], "PLUS", "+");
        $def(self2, "$apply_subs", function $$apply_subs(text, subs) {
          var self3 = this, is_multiline = nil, passthrus = nil, $ret_or_1 = nil, clear_passthrus = nil;
          if (self3.passthroughs == null)
            self3.passthroughs = nil;
          if (self3.passthroughs_locked == null)
            self3.passthroughs_locked = nil;
          if (subs == null)
            subs = $$("NORMAL_SUBS");
          if ($truthy(text["$empty?"]()) || $not(subs)) {
            return text;
          }
          ;
          if ($truthy(is_multiline = $$$("Array")["$==="](text))) {
            text = $truthy(text["$[]"](1)) ? text.$join($$("LF")) : text["$[]"](0);
          }
          ;
          if ($truthy(subs["$include?"]("macros"))) {
            text = self3.$extract_passthroughs(text);
            if (!$truthy(self3.passthroughs["$empty?"]())) {
              passthrus = self3.passthroughs;
              self3.passthroughs_locked = $truthy($ret_or_1 = self3.passthroughs_locked) ? $ret_or_1 : clear_passthrus = true;
            }
            ;
          }
          ;
          $send(subs, "each", [], function $$1(type) {
            var self4 = $$1.$$s == null ? this : $$1.$$s;
            if (type == null)
              type = nil;
            switch (type) {
              case "specialcharacters":
                return text = self4.$sub_specialchars(text);
              case "quotes":
                return text = self4.$sub_quotes(text);
              case "attributes":
                if ($truthy(text["$include?"]($$("ATTR_REF_HEAD")))) {
                  return text = self4.$sub_attributes(text);
                } else {
                  return nil;
                }
                break;
              case "replacements":
                return text = self4.$sub_replacements(text);
              case "macros":
                return text = self4.$sub_macros(text);
              case "highlight":
                return text = self4.$highlight_source(text, subs["$include?"]("callouts"));
              case "callouts":
                if ($truthy(subs["$include?"]("highlight"))) {
                  return nil;
                } else {
                  return text = self4.$sub_callouts(text);
                }
                break;
              case "post_replacements":
                return text = self4.$sub_post_replacements(text);
              default:
                return self4.$logger().$warn("unknown substitution type " + type);
            }
            ;
          }, { $$s: self3 });
          if ($truthy(passthrus)) {
            text = self3.$restore_passthroughs(text);
            if ($truthy(clear_passthrus)) {
              passthrus.$clear();
              self3.passthroughs_locked = nil;
            }
            ;
          }
          ;
          if ($truthy(is_multiline)) {
            return text.$split($$("LF"), -1);
          } else {
            return text;
          }
          ;
        }, -2);
        $def(self2, "$apply_normal_subs", function $$apply_normal_subs(text) {
          var self3 = this;
          return self3.$apply_subs(text, $$("NORMAL_SUBS"));
        });
        $def(self2, "$apply_header_subs", function $$apply_header_subs(text) {
          var self3 = this;
          return self3.$apply_subs(text, $$("HEADER_SUBS"));
        });
        $alias(self2, "apply_title_subs", "apply_subs");
        $def(self2, "$apply_reftext_subs", function $$apply_reftext_subs(text) {
          var self3 = this;
          return self3.$apply_subs(text, $$("REFTEXT_SUBS"));
        });
        $def(self2, "$sub_specialchars", function $$sub_specialchars(text) {
          if ($truthy(text["$include?"](">")) || $truthy(text["$include?"]("&")) || $truthy(text["$include?"]("<"))) {
            return text.$gsub($$("SpecialCharsRx"), $$("SpecialCharsTr"));
          } else {
            return text;
          }
        });
        $alias(self2, "sub_specialcharacters", "sub_specialchars");
        $def(self2, "$sub_quotes", function $$sub_quotes(text) {
          var self3 = this, compat = nil;
          if (self3.document == null)
            self3.document = nil;
          if ($truthy($$("QuotedTextSniffRx")["$[]"](compat = self3.document.$compat_mode())["$match?"](text))) {
            $send($$("QUOTE_SUBS")["$[]"](compat), "each", [], function $$2(type, scope, pattern) {
              var self4 = $$2.$$s == null ? this : $$2.$$s;
              if (type == null)
                type = nil;
              if (scope == null)
                scope = nil;
              if (pattern == null)
                pattern = nil;
              return text = $send(text, "gsub", [pattern], function $$3() {
                var self5 = $$3.$$s == null ? this : $$3.$$s;
                if ($gvars["~"] == null)
                  $gvars["~"] = nil;
                return self5.$convert_quoted_text($gvars["~"], type, scope);
              }, { $$s: self4 });
            }, { $$s: self3 });
          }
          ;
          return text;
        });
        $def(self2, "$sub_attributes", function $$sub_attributes(text, opts) {
          var self3 = this, doc_attrs = nil, drop = nil, drop_line = nil, drop_line_severity = nil, drop_empty_line = nil, attribute_undefined = nil, attribute_missing = nil, lines = nil;
          if (self3.document == null)
            self3.document = nil;
          if (opts == null)
            opts = $hash2([], {});
          doc_attrs = self3.document.$attributes();
          drop = drop_line = drop_line_severity = drop_empty_line = attribute_undefined = attribute_missing = nil;
          text = $send(text, "gsub", [$$("AttributeReferenceRx")], function $$4() {
            var $a, $b, self4 = $$4.$$s == null ? this : $$4.$$s, args = nil, $ret_or_2 = nil, _ = nil, value = nil, $ret_or_3 = nil, key = nil, $ret_or_4 = nil;
            if (self4.document == null)
              self4.document = nil;
            if ($eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), $$("RS")) || $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](4), $$("RS"))) {
              return "{" + (($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)) + "}";
            } else if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))) {
              switch ((args = (($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)).$split(":", 3)).$shift()) {
                case "set":
                  $b = $$("Parser").$store_attribute(args["$[]"](0), $truthy($ret_or_2 = args["$[]"](1)) ? $ret_or_2 : "", self4.document), $a = $to_ary($b), _ = $a[0] == null ? nil : $a[0], value = $a[1] == null ? nil : $a[1], $b;
                  if ($truthy(value) || $neqeq(attribute_undefined = $truthy($ret_or_2 = attribute_undefined) ? $ret_or_2 : $truthy($ret_or_3 = doc_attrs["$[]"]("attribute-undefined")) ? $ret_or_3 : $$("Compliance").$attribute_undefined(), "drop-line")) {
                    return drop = drop_empty_line = $$("DEL");
                  } else {
                    return drop = drop_line = $$("CAN");
                  }
                  ;
                  break;
                case "counter2":
                  $send(self4.document, "counter", $to_a(args));
                  return drop = drop_empty_line = $$("DEL");
                default:
                  return $send(self4.document, "counter", $to_a(args));
              }
            } else if ($truthy(doc_attrs["$key?"](key = (($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)).$downcase()))) {
              return doc_attrs["$[]"](key);
            } else if ($truthy(value = $$("INTRINSIC_ATTRIBUTES")["$[]"](key))) {
              return value;
            } else
              switch (attribute_missing = $truthy($ret_or_2 = attribute_missing) ? $ret_or_2 : $truthy($ret_or_3 = $truthy($ret_or_4 = opts["$[]"]("attribute_missing")) ? $ret_or_4 : doc_attrs["$[]"]("attribute-missing")) ? $ret_or_3 : $$("Compliance").$attribute_missing()) {
                case "drop":
                  return drop = drop_empty_line = $$("DEL");
                case "drop-line":
                  if ($eqeq(drop_line_severity = $truthy($ret_or_2 = drop_line_severity) ? $ret_or_2 : $truthy($ret_or_3 = opts["$[]"]("drop_line_severity")) ? $ret_or_3 : "info", "info")) {
                    $send(self4.$logger(), "info", [], function $$5() {
                      return "dropping line containing reference to missing attribute: " + key;
                    });
                  }
                  ;
                  return drop = drop_line = $$("CAN");
                case "warn":
                  self4.$logger().$warn("skipping reference to missing attribute: " + key);
                  return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
                default:
                  return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
              }
          }, { $$s: self3 });
          if ($truthy(drop)) {
            if ($truthy(drop_empty_line)) {
              lines = text.$squeeze($$("DEL")).$split($$("LF"), -1);
              if ($truthy(drop_line)) {
                return $send(lines, "reject", [], function $$6(line) {
                  var $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;
                  if (line == null)
                    line = nil;
                  if ($truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = line["$=="]($$("DEL"))) ? $ret_or_3 : line["$=="]($$("CAN"))) ? $ret_or_2 : line["$start_with?"]($$("CAN")))) {
                    return $ret_or_1;
                  } else {
                    return line["$include?"]($$("CAN"));
                  }
                  ;
                }).$join($$("LF")).$delete($$("DEL"));
              } else {
                return $send(lines, "reject", [], function $$7(line) {
                  if (line == null)
                    line = nil;
                  return line["$=="]($$("DEL"));
                }).$join($$("LF")).$delete($$("DEL"));
              }
              ;
            } else if ($truthy(text["$include?"]($$("LF")))) {
              return $send(text.$split($$("LF"), -1), "reject", [], function $$8(line) {
                var $ret_or_1 = nil, $ret_or_2 = nil;
                if (line == null)
                  line = nil;
                if ($truthy($ret_or_1 = $truthy($ret_or_2 = line["$=="]($$("CAN"))) ? $ret_or_2 : line["$start_with?"]($$("CAN")))) {
                  return $ret_or_1;
                } else {
                  return line["$include?"]($$("CAN"));
                }
                ;
              }).$join($$("LF"));
            } else {
              return "";
            }
          } else {
            return text;
          }
          ;
        }, -2);
        $def(self2, "$sub_replacements", function $$sub_replacements(text) {
          var self3 = this;
          if ($truthy($$("ReplaceableTextRx")["$match?"](text))) {
            $send($$("REPLACEMENTS"), "each", [], function $$9(pattern, replacement, restore) {
              var self4 = $$9.$$s == null ? this : $$9.$$s;
              if (pattern == null)
                pattern = nil;
              if (replacement == null)
                replacement = nil;
              if (restore == null)
                restore = nil;
              return text = $send(text, "gsub", [pattern], function $$10() {
                var self5 = $$10.$$s == null ? this : $$10.$$s;
                if ($gvars["~"] == null)
                  $gvars["~"] = nil;
                return self5.$do_replacement($gvars["~"], replacement, restore);
              }, { $$s: self4 });
            }, { $$s: self3 });
          }
          ;
          return text;
        });
        $def(self2, "$sub_macros", function $$sub_macros(text) {
          var self3 = this, found_square_bracket = nil, found_colon = nil, found_macroish = nil, $ret_or_1 = nil, found_macroish_short = nil, doc_attrs = nil, doc = nil, extensions = nil;
          if (self3.document == null)
            self3.document = nil;
          if (self3.parent == null)
            self3.parent = nil;
          if (self3.context == null)
            self3.context = nil;
          found_square_bracket = text["$include?"]("[");
          found_colon = text["$include?"](":");
          found_macroish = $truthy($ret_or_1 = found_square_bracket) ? found_colon : $ret_or_1;
          found_macroish_short = $truthy($ret_or_1 = found_macroish) ? text["$include?"](":[") : $ret_or_1;
          doc_attrs = (doc = self3.document).$attributes();
          if ($truthy(extensions = doc.$extensions()) && $truthy(extensions["$inline_macros?"]())) {
            $send(extensions.$inline_macros(), "each", [], function $$11(extension) {
              var self4 = $$11.$$s == null ? this : $$11.$$s;
              if (extension == null)
                extension = nil;
              return text = $send(text, "gsub", [extension.$instance().$regexp()], function $$12() {
                var $a, $b, self5 = $$12.$$s == null ? this : $$12.$$s, match = nil, target = nil, content = nil, attributes = nil, default_attrs = nil, ext_config = nil, $ret_or_2 = nil, replacement = nil, inline_subs = nil;
                if ($gvars["~"] == null)
                  $gvars["~"] = nil;
                if ($truthy((match = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                  return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                }
                ;
                if ($truthy($gvars["~"].$names()["$empty?"]())) {
                  $a = [($b = $gvars["~"]) === nil ? nil : $b["$[]"](1), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](2)], target = $a[0], content = $a[1], $a;
                } else {
                  $a = [function() {
                    try {
                      return $gvars["~"]["$[]"]("target");
                    } catch ($err) {
                      if (Opal2.rescue($err, [$$("StandardError")])) {
                        try {
                          return nil;
                        } finally {
                          Opal2.pop_exception();
                        }
                      } else {
                        throw $err;
                      }
                    }
                  }(), function() {
                    try {
                      return $gvars["~"]["$[]"]("content");
                    } catch ($err) {
                      if (Opal2.rescue($err, [$$("StandardError")])) {
                        try {
                          return nil;
                        } finally {
                          Opal2.pop_exception();
                        }
                      } else {
                        throw $err;
                      }
                    }
                  }()], target = $a[0], content = $a[1], $a;
                }
                ;
                attributes = $truthy(default_attrs = (ext_config = extension.$config())["$[]"]("default_attrs")) ? default_attrs.$merge() : $hash2([], {});
                if ($truthy(content)) {
                  if ($truthy(content["$empty?"]())) {
                    if (!$eqeq(ext_config["$[]"]("content_model"), "attributes")) {
                      attributes["$[]="]("text", content);
                    }
                  } else {
                    content = self5.$normalize_text(content, true, true);
                    if ($eqeq(ext_config["$[]"]("content_model"), "attributes")) {
                      self5.$parse_attributes(content, $truthy($ret_or_1 = $truthy($ret_or_2 = ext_config["$[]"]("positional_attrs")) ? $ret_or_2 : ext_config["$[]"]("pos_attrs")) ? $ret_or_1 : [], $hash2(["into"], { "into": attributes }));
                    } else {
                      attributes["$[]="]("text", content);
                    }
                    ;
                  }
                  ;
                  target = $truthy($ret_or_1 = target) ? $ret_or_1 : $eqeq(ext_config["$[]"]("format"), "short") ? content : target;
                }
                ;
                if ($eqeqeq($$("Inline"), replacement = extension.$process_method()["$[]"](self5, target, attributes))) {
                  if ($truthy(inline_subs = replacement.$attributes().$delete("subs")) && $truthy(inline_subs = self5.$expand_subs(inline_subs, "custom inline macro"))) {
                    replacement["$text="](self5.$apply_subs(replacement.$text(), inline_subs));
                  }
                  ;
                  return replacement.$convert();
                } else if ($truthy(replacement)) {
                  $send(self5.$logger(), "info", [], function $$13() {
                    return "expected substitution value for custom inline macro to be of type Inline; got " + replacement.$class() + ": " + match;
                  });
                  return replacement;
                } else {
                  return "";
                }
                ;
              }, { $$s: self4 });
            }, { $$s: self3 });
          }
          ;
          if ($truthy(doc_attrs["$key?"]("experimental"))) {
            if ($truthy(found_macroish_short) && ($truthy(text["$include?"]("kbd:")) || $truthy(text["$include?"]("btn:")))) {
              text = $send(text, "gsub", [$$("InlineKbdBtnMacroRx")], function $$14() {
                var $a, self4 = $$14.$$s == null ? this : $$14.$$s, keys = nil, delim_idx = nil, delim = nil;
                if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                  return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                } else if ($eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), "kbd")) {
                  if ($truthy((keys = (($a = $gvars["~"]) === nil ? nil : $a["$[]"](3)).$strip())["$include?"]($$("R_SB")))) {
                    keys = keys.$gsub($$("ESC_R_SB"), $$("R_SB"));
                  }
                  ;
                  if ($truthy($rb_gt(keys.$length(), 1)) && $truthy(delim_idx = $truthy(delim_idx = keys.$index(",", 1)) ? [delim_idx, keys.$index("+", 1)].$compact().$min() : keys.$index("+", 1))) {
                    delim = keys.$slice(delim_idx, 1);
                    if ($truthy(keys["$end_with?"](delim))) {
                      keys = $send(keys.$chop().$split(delim, -1), "map", [], function $$15(key) {
                        if (key == null)
                          key = nil;
                        return key.$strip();
                      });
                      keys["$[]="](-1, $rb_plus(keys["$[]"](-1), delim));
                    } else {
                      keys = $send(keys.$split(delim), "map", [], function $$16(key) {
                        if (key == null)
                          key = nil;
                        return key.$strip();
                      });
                    }
                    ;
                  } else {
                    keys = [keys];
                  }
                  ;
                  return $$("Inline").$new(self4, "kbd", nil, $hash2(["attributes"], { "attributes": $hash2(["keys"], { "keys": keys }) })).$convert();
                } else {
                  return $$("Inline").$new(self4, "button", self4.$normalize_text(($a = $gvars["~"]) === nil ? nil : $a["$[]"](3), true, true)).$convert();
                }
              }, { $$s: self3 });
            }
            ;
            if ($truthy(found_macroish) && $truthy(text["$include?"]("menu:"))) {
              text = $send(text, "gsub", [$$("InlineMenuMacroRx")], function $$17() {
                var $a, self4 = $$17.$$s == null ? this : $$17.$$s, menu = nil, items = nil, delim = nil, submenus = nil, menuitem = nil;
                if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                  return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                }
                ;
                menu = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1);
                if ($truthy(items = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))) {
                  if ($truthy(items["$include?"]($$("R_SB")))) {
                    items = items.$gsub($$("ESC_R_SB"), $$("R_SB"));
                  }
                  ;
                  if ($truthy(delim = $truthy(items["$include?"]("&gt;")) ? "&gt;" : $truthy(items["$include?"](",")) ? "," : nil)) {
                    submenus = $send(items.$split(delim), "map", [], function $$18(it) {
                      if (it == null)
                        it = nil;
                      return it.$strip();
                    });
                    menuitem = submenus.$pop();
                  } else {
                    $a = [[], items.$rstrip()], submenus = $a[0], menuitem = $a[1], $a;
                  }
                  ;
                } else {
                  $a = [[], nil], submenus = $a[0], menuitem = $a[1], $a;
                }
                ;
                return $$("Inline").$new(self4, "menu", nil, $hash2(["attributes"], { "attributes": $hash2(["menu", "submenus", "menuitem"], { "menu": menu, "submenus": submenus, "menuitem": menuitem }) })).$convert();
              }, { $$s: self3 });
            }
            ;
            if ($truthy(text["$include?"]('"')) && $truthy(text["$include?"]("&gt;"))) {
              text = $send(text, "gsub", [$$("InlineMenuRx")], function $$19() {
                var $a, $b, $c, self4 = $$19.$$s == null ? this : $$19.$$s, menu = nil, submenus = nil, menuitem = nil;
                if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                  return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                }
                ;
                $b = $send((($c = $gvars["~"]) === nil ? nil : $c["$[]"](1)).$split("&gt;"), "map", [], function $$20(it) {
                  if (it == null)
                    it = nil;
                  return it.$strip();
                }), $a = $to_ary($b), menu = $a[0] == null ? nil : $a[0], submenus = $slice($a, 1), $b;
                menuitem = submenus.$pop();
                return $$("Inline").$new(self4, "menu", nil, $hash2(["attributes"], { "attributes": $hash2(["menu", "submenus", "menuitem"], { "menu": menu, "submenus": submenus, "menuitem": menuitem }) })).$convert();
              }, { $$s: self3 });
            }
            ;
          }
          ;
          if ($truthy(found_macroish) && ($truthy(text["$include?"]("image:")) || $truthy(text["$include?"]("icon:")))) {
            text = $send(text, "gsub", [$$("InlineImageMacroRx")], function $$21() {
              var $a, self4 = $$21.$$s == null ? this : $$21.$$s, type = nil, posattrs = nil, target = nil, attrs = nil;
              if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
              } else if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]("icon:"))) {
                $a = ["icon", ["size"]], type = $a[0], posattrs = $a[1], $a;
              } else {
                $a = ["image", ["alt", "width", "height"]], type = $a[0], posattrs = $a[1], $a;
              }
              ;
              target = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1);
              attrs = self4.$parse_attributes(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), posattrs, $hash2(["unescape_input"], { "unescape_input": true }));
              if (!$eqeq(type, "icon")) {
                doc.$register("images", target);
                attrs["$[]="]("imagesdir", doc_attrs["$[]"]("imagesdir"));
              }
              ;
              if ($truthy($ret_or_1 = attrs["$[]"]("alt"))) {
                $ret_or_1;
              } else {
                attrs["$[]="]("alt", ($a = ["default-alt", $$("Helpers").$basename(target, true).$tr("_-", " ")], $send(attrs, "[]=", $a), $a[$a.length - 1]));
              }
              ;
              return $$("Inline").$new(self4, "image", nil, $hash2(["type", "target", "attributes"], { "type": type, "target": target, "attributes": attrs })).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(text["$include?"]("((")) && $truthy(text["$include?"]("))")) || $truthy(found_macroish_short) && $truthy(text["$include?"]("dexterm"))) {
            text = $send(text, "gsub", [$$("InlineIndextermMacroRx")], function $$22() {
              var $a, $b, self4 = $$22.$$s == null ? this : $$22.$$s, attrlist = nil, primary = nil, attrs = nil, see_also = nil, term = nil, $ret_or_2 = nil, $ret_or_3 = nil, encl_text = nil, visible = nil, before = nil, after = nil, _ = nil, see = nil, subbed_term = nil, terms = nil;
              switch (($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)) {
                case "indexterm":
                  if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                    return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                  }
                  ;
                  if ($truthy((attrlist = self4.$normalize_text(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), true, true))["$include?"]("="))) {
                    if ($truthy(primary = (attrs = $$("AttributeList").$new(attrlist, self4).$parse())["$[]"](1))) {
                      attrs["$[]="]("terms", [primary]);
                      if ($truthy(see_also = attrs["$[]"]("see-also"))) {
                        attrs["$[]="]("see-also", $truthy(see_also["$include?"](",")) ? $send(see_also.$split(","), "map", [], function $$23(it) {
                          if (it == null)
                            it = nil;
                          return it.$lstrip();
                        }) : [see_also]);
                      }
                      ;
                    } else {
                      attrs = $hash2(["terms"], { "terms": attrlist });
                    }
                  } else {
                    attrs = $hash2(["terms"], { "terms": self4.$split_simple_csv(attrlist) });
                  }
                  ;
                  return $$("Inline").$new(self4, "indexterm", nil, $hash2(["attributes"], { "attributes": attrs })).$convert();
                case "indexterm2":
                  if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                    return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                  }
                  ;
                  if ($truthy((term = self4.$normalize_text(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), true, true))["$include?"]("="))) {
                    term = $truthy($ret_or_2 = $truthy($ret_or_3 = (attrs = $$("AttributeList").$new(term, self4).$parse())["$[]"](1)) ? $ret_or_3 : attrs = nil) ? $ret_or_2 : term;
                    if ($truthy(attrs) && $truthy(see_also = attrs["$[]"]("see-also"))) {
                      attrs["$[]="]("see-also", $truthy(see_also["$include?"](",")) ? $send(see_also.$split(","), "map", [], function $$24(it) {
                        if (it == null)
                          it = nil;
                        return it.$lstrip();
                      }) : [see_also]);
                    }
                    ;
                  }
                  ;
                  return $$("Inline").$new(self4, "indexterm", term, $hash2(["attributes", "type"], { "attributes": attrs, "type": "visible" })).$convert();
                default:
                  encl_text = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
                  if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                    if ($truthy(encl_text["$start_with?"]("(")) && $truthy(encl_text["$end_with?"](")"))) {
                      encl_text = encl_text.$slice(1, $rb_minus(encl_text.$length(), 2));
                      $a = [true, "(", ")"], visible = $a[0], before = $a[1], after = $a[2], $a;
                    } else {
                      return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
                    }
                  } else {
                    visible = true;
                    if ($truthy(encl_text["$start_with?"]("("))) {
                      if ($truthy(encl_text["$end_with?"](")"))) {
                        $a = [encl_text.$slice(1, $rb_minus(encl_text.$length(), 2)), false], encl_text = $a[0], visible = $a[1], $a;
                      } else {
                        $a = [encl_text.$slice(1, encl_text.$length()), "(", ""], encl_text = $a[0], before = $a[1], after = $a[2], $a;
                      }
                    } else if ($truthy(encl_text["$end_with?"](")"))) {
                      $a = [encl_text.$chop(), "", ")"], encl_text = $a[0], before = $a[1], after = $a[2], $a;
                    }
                    ;
                  }
                  ;
                  if ($truthy(visible)) {
                    if ($truthy((term = self4.$normalize_text(encl_text, true))["$include?"](";&"))) {
                      if ($truthy(term["$include?"](" &gt;&gt; "))) {
                        $b = term.$partition(" &gt;&gt; "), $a = $to_ary($b), term = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], see = $a[2] == null ? nil : $a[2], $b;
                        attrs = $hash2(["see"], { "see": see });
                      } else if ($truthy(term["$include?"](" &amp;&gt; "))) {
                        $b = term.$split(" &amp;&gt; "), $a = $to_ary($b), term = $a[0] == null ? nil : $a[0], see_also = $slice($a, 1), $b;
                        attrs = $hash2(["see-also"], { "see-also": see_also });
                      }
                    }
                    ;
                    subbed_term = $$("Inline").$new(self4, "indexterm", term, $hash2(["attributes", "type"], { "attributes": attrs, "type": "visible" })).$convert();
                  } else {
                    attrs = $hash2([], {});
                    if ($truthy((terms = self4.$normalize_text(encl_text, true))["$include?"](";&"))) {
                      if ($truthy(terms["$include?"](" &gt;&gt; "))) {
                        $b = terms.$partition(" &gt;&gt; "), $a = $to_ary($b), terms = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], see = $a[2] == null ? nil : $a[2], $b;
                        attrs["$[]="]("see", see);
                      } else if ($truthy(terms["$include?"](" &amp;&gt; "))) {
                        $b = terms.$split(" &amp;&gt; "), $a = $to_ary($b), terms = $a[0] == null ? nil : $a[0], see_also = $slice($a, 1), $b;
                        attrs["$[]="]("see-also", see_also);
                      }
                    }
                    ;
                    attrs["$[]="]("terms", self4.$split_simple_csv(terms));
                    subbed_term = $$("Inline").$new(self4, "indexterm", nil, $hash2(["attributes"], { "attributes": attrs })).$convert();
                  }
                  ;
                  if ($truthy(before)) {
                    return "" + before + subbed_term + after;
                  } else {
                    return subbed_term;
                  }
                  ;
              }
            }, { $$s: self3 });
          }
          ;
          if ($truthy(found_colon) && $truthy(text["$include?"]("://"))) {
            text = $send(text, "gsub", [$$("InlineLinkRx")], function $$25() {
              var $a, $b, self4 = $$25.$$s == null ? this : $$25.$$s, target = nil, rs_idx = nil, prefix = nil, suffix = nil, link_text = nil, attrs = nil, link_opts = nil, new_link_text = nil, bare = nil;
              if ($truthy((target = $rb_plus(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), $truthy($ret_or_1 = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3)) ? $ret_or_1 : ($a = $gvars["~"]) === nil ? nil : $a["$[]"](5)))["$start_with?"]($$("RS")))) {
                return $rb_plus((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(0, rs_idx = (($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)).$length()), (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice($rb_plus(rs_idx, 1), (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length()));
              }
              ;
              $a = [($b = $gvars["~"]) === nil ? nil : $b["$[]"](1), ""], prefix = $a[0], suffix = $a[1], $a;
              if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](4))) {
                if ($eqeq(prefix, "link:")) {
                  prefix = "";
                }
                ;
                if ($truthy((link_text = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4))["$empty?"]())) {
                  link_text = nil;
                }
                ;
              } else {
                switch (prefix) {
                  case "link:":
                  case '"':
                  case "'":
                    return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
                  default:
                    nil;
                }
                ;
                switch (($a = $gvars["~"]) === nil ? nil : $a["$[]"](6)) {
                  case ";":
                    if ($truthy(prefix["$start_with?"]("&lt;")) && $truthy(target["$end_with?"]("&gt;"))) {
                      prefix = prefix.$slice(4, prefix.$length());
                      target = target.$slice(0, $rb_minus(target.$length(), 4));
                    } else if ($truthy((target = target.$chop())["$end_with?"](")"))) {
                      target = target.$chop();
                      suffix = ");";
                    } else {
                      suffix = ";";
                    }
                    ;
                    if ($truthy(target["$end_with?"]("://"))) {
                      return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
                    }
                    ;
                    break;
                  case ":":
                    if ($truthy((target = target.$chop())["$end_with?"](")"))) {
                      target = target.$chop();
                      suffix = "):";
                    } else {
                      suffix = ":";
                    }
                    ;
                    if ($truthy(target["$end_with?"]("://"))) {
                      return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
                    }
                    ;
                    break;
                  default:
                    nil;
                }
                ;
              }
              ;
              $a = [nil, $hash2(["type"], { "type": "link" })], attrs = $a[0], link_opts = $a[1], $a;
              if ($truthy(link_text)) {
                if ($truthy(link_text["$include?"]($$("R_SB")))) {
                  new_link_text = link_text = link_text.$gsub($$("ESC_R_SB"), $$("R_SB"));
                }
                ;
                if ($not(doc.$compat_mode()) && $truthy(link_text["$include?"]("="))) {
                  $b = self4.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), link_text = $a[0] == null ? nil : $a[0], attrs = $a[1] == null ? nil : $a[1], $b;
                  new_link_text = link_text;
                  link_opts["$[]="]("id", attrs["$[]"]("id"));
                }
                ;
                if ($truthy(link_text["$end_with?"]("^"))) {
                  new_link_text = link_text = link_text.$chop();
                  if ($truthy(attrs)) {
                    if ($truthy($ret_or_1 = attrs["$[]"]("window"))) {
                      $ret_or_1;
                    } else {
                      attrs["$[]="]("window", "_blank");
                    }
                  } else {
                    attrs = $hash2(["window"], { "window": "_blank" });
                  }
                  ;
                }
                ;
                if ($truthy(new_link_text) && $truthy(new_link_text["$empty?"]())) {
                  link_text = $truthy(doc_attrs["$key?"]("hide-uri-scheme")) ? target.$sub($$("UriSniffRx"), "") : target;
                  bare = true;
                }
                ;
              } else {
                link_text = $truthy(doc_attrs["$key?"]("hide-uri-scheme")) ? target.$sub($$("UriSniffRx"), "") : target;
                bare = true;
              }
              ;
              if ($truthy(bare)) {
                if ($truthy(attrs)) {
                  attrs["$[]="]("role", $truthy(attrs["$key?"]("role")) ? "bare " + attrs["$[]"]("role") : "bare");
                } else {
                  attrs = $hash2(["role"], { "role": "bare" });
                }
              }
              ;
              doc.$register("links", ($a = ["target", target], $send(link_opts, "[]=", $a), $a[$a.length - 1]));
              if ($truthy(attrs)) {
                link_opts["$[]="]("attributes", attrs);
              }
              ;
              return "" + prefix + $$("Inline").$new(self4, "anchor", link_text, link_opts).$convert() + suffix;
            }, { $$s: self3 });
          }
          ;
          if ($truthy(found_macroish) && ($truthy(text["$include?"]("link:")) || $truthy(text["$include?"]("ilto:")))) {
            text = $send(text, "gsub", [$$("InlineLinkMacroRx")], function $$26() {
              var $a, $b, self4 = $$26.$$s == null ? this : $$26.$$s, mailto = nil, target = nil, mailto_text = nil, attrs = nil, link_opts = nil, link_text = nil;
              if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
              } else if ($truthy(mailto = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                target = $rb_plus("mailto:", mailto_text = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2));
              } else {
                target = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2);
              }
              ;
              $a = [nil, $hash2(["type"], { "type": "link" })], attrs = $a[0], link_opts = $a[1], $a;
              if (!$truthy((link_text = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))["$empty?"]())) {
                if ($truthy(link_text["$include?"]($$("R_SB")))) {
                  link_text = link_text.$gsub($$("ESC_R_SB"), $$("R_SB"));
                }
                ;
                if ($truthy(mailto)) {
                  if ($not(doc.$compat_mode()) && $truthy(link_text["$include?"](","))) {
                    $b = self4.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), link_text = $a[0] == null ? nil : $a[0], attrs = $a[1] == null ? nil : $a[1], $b;
                    link_opts["$[]="]("id", attrs["$[]"]("id"));
                    if ($truthy(attrs["$key?"](2))) {
                      if ($truthy(attrs["$key?"](3))) {
                        target = "" + target + "?subject=" + $$("Helpers").$encode_uri_component(attrs["$[]"](2)) + "&amp;body=" + $$("Helpers").$encode_uri_component(attrs["$[]"](3));
                      } else {
                        target = "" + target + "?subject=" + $$("Helpers").$encode_uri_component(attrs["$[]"](2));
                      }
                    }
                    ;
                  }
                } else if ($not(doc.$compat_mode()) && $truthy(link_text["$include?"]("="))) {
                  $b = self4.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), link_text = $a[0] == null ? nil : $a[0], attrs = $a[1] == null ? nil : $a[1], $b;
                  link_opts["$[]="]("id", attrs["$[]"]("id"));
                }
                ;
                if ($truthy(link_text["$end_with?"]("^"))) {
                  link_text = link_text.$chop();
                  if ($truthy(attrs)) {
                    if ($truthy($ret_or_1 = attrs["$[]"]("window"))) {
                      $ret_or_1;
                    } else {
                      attrs["$[]="]("window", "_blank");
                    }
                  } else {
                    attrs = $hash2(["window"], { "window": "_blank" });
                  }
                  ;
                }
                ;
              }
              ;
              if ($truthy(link_text["$empty?"]())) {
                if ($truthy(mailto)) {
                  link_text = mailto_text;
                } else {
                  if ($truthy(doc_attrs["$key?"]("hide-uri-scheme"))) {
                    if ($truthy((link_text = target.$sub($$("UriSniffRx"), ""))["$empty?"]())) {
                      link_text = target;
                    }
                  } else {
                    link_text = target;
                  }
                  ;
                  if ($truthy(attrs)) {
                    attrs["$[]="]("role", $truthy(attrs["$key?"]("role")) ? "bare " + attrs["$[]"]("role") : "bare");
                  } else {
                    attrs = $hash2(["role"], { "role": "bare" });
                  }
                  ;
                }
              }
              ;
              doc.$register("links", ($a = ["target", target], $send(link_opts, "[]=", $a), $a[$a.length - 1]));
              if ($truthy(attrs)) {
                link_opts["$[]="]("attributes", attrs);
              }
              ;
              return $$("Inline").$new(self4, "anchor", link_text, link_opts).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(text["$include?"]("@"))) {
            text = $send(text, "gsub", [$$("InlineEmailRx")], function $$27() {
              var $a, self4 = $$27.$$s == null ? this : $$27.$$s, target = nil, address = nil;
              if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                return $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), $$("RS")) ? (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length()) : ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
              }
              ;
              target = $rb_plus("mailto:", address = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0));
              doc.$register("links", target);
              return $$("Inline").$new(self4, "anchor", address, $hash2(["type", "target"], { "type": "link", "target": target })).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(found_square_bracket) && $eqeq(self3.context, "list_item") && $eqeq(self3.parent.$style(), "bibliography")) {
            text = $send(text, "sub", [$$("InlineBiblioAnchorRx")], function $$28() {
              var $a, self4 = $$28.$$s == null ? this : $$28.$$s;
              return $$("Inline").$new(self4, "anchor", ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), $hash2(["type", "id"], { "type": "bibref", "id": ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1) })).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(found_square_bracket) && $truthy(text["$include?"]("[[")) || $truthy(found_macroish) && $truthy(text["$include?"]("or:"))) {
            text = $send(text, "gsub", [$$("InlineAnchorRx")], function $$29() {
              var $a, self4 = $$29.$$s == null ? this : $$29.$$s, id = nil, reftext = nil;
              if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
              }
              ;
              if ($truthy(id = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))) {
                reftext = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
              } else {
                id = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4);
                if ($truthy(reftext = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](5)) && $truthy(reftext["$include?"]($$("R_SB")))) {
                  reftext = reftext.$gsub($$("ESC_R_SB"), $$("R_SB"));
                }
                ;
              }
              ;
              return $$("Inline").$new(self4, "anchor", reftext, $hash2(["type", "id"], { "type": "ref", "id": id })).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(text["$include?"]("&")) && $truthy(text["$include?"](";&l")) || $truthy(found_macroish) && $truthy(text["$include?"]("xref:"))) {
            text = $send(text, "gsub", [$$("InlineXrefMacroRx")], function $$30() {
              var $a, $b, self4 = $$30.$$s == null ? this : $$30.$$s, attrs = nil, refid = nil, _ = nil, link_text = nil, macro = nil, fragment = nil, hash_idx = nil, fragment_len = nil, path = nil, src2src = nil, target = nil;
              if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
              }
              ;
              attrs = $hash2([], {});
              if ($truthy(refid = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                if ($truthy(refid["$include?"](","))) {
                  $b = refid.$partition(","), $a = $to_ary($b), refid = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], link_text = $a[2] == null ? nil : $a[2], $b;
                  if ($truthy((link_text = link_text.$lstrip())["$empty?"]())) {
                    link_text = nil;
                  }
                  ;
                }
              } else {
                macro = true;
                refid = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2);
                if ($truthy(link_text = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))) {
                  if ($truthy(link_text["$include?"]($$("R_SB")))) {
                    link_text = link_text.$gsub($$("ESC_R_SB"), $$("R_SB"));
                  }
                  ;
                  if ($not(doc.$compat_mode()) && $truthy(link_text["$include?"]("="))) {
                    $b = self4.$extract_attributes_from_text(link_text), $a = $to_ary($b), link_text = $a[0] == null ? nil : $a[0], attrs = $a[1] == null ? nil : $a[1], $b;
                  }
                  ;
                }
                ;
              }
              ;
              if ($truthy(doc.$compat_mode())) {
                fragment = refid;
              } else if ($truthy(hash_idx = refid.$index("#")) && $neqeq(refid["$[]"]($rb_minus(hash_idx, 1)), "&")) {
                if ($truthy($rb_gt(hash_idx, 0))) {
                  if ($truthy($rb_gt(fragment_len = $rb_minus($rb_minus(refid.$length(), 1), hash_idx), 0))) {
                    $a = [refid.$slice(0, hash_idx), refid.$slice($rb_plus(hash_idx, 1), fragment_len)], path = $a[0], fragment = $a[1], $a;
                  } else {
                    path = refid.$chop();
                  }
                  ;
                  if ($truthy(macro)) {
                    if ($truthy(path["$end_with?"](".adoc"))) {
                      src2src = path = path.$slice(0, $rb_minus(path.$length(), 5));
                    } else if ($not($$("Helpers")["$extname?"](path))) {
                      src2src = path;
                    }
                  } else if ($truthy($send(path, "end_with?", $to_a($$("ASCIIDOC_EXTENSIONS").$keys())))) {
                    src2src = path = path.$slice(0, path.$rindex("."));
                  } else {
                    src2src = path;
                  }
                  ;
                } else {
                  $a = [refid, refid.$slice(1, refid.$length())], target = $a[0], fragment = $a[1], $a;
                }
              } else if ($truthy(macro)) {
                if ($truthy(refid["$end_with?"](".adoc"))) {
                  src2src = path = refid.$slice(0, $rb_minus(refid.$length(), 5));
                } else if ($truthy($$("Helpers")["$extname?"](refid))) {
                  path = refid;
                } else {
                  fragment = refid;
                }
              } else {
                fragment = refid;
              }
              ;
              if ($truthy(target)) {
                refid = fragment;
                if ($truthy(self4.$logger()["$info?"]()) && $not(doc.$catalog()["$[]"]("refs")["$[]"](refid))) {
                  self4.$logger().$info("possible invalid reference: " + refid);
                }
                ;
              } else if ($truthy(path)) {
                if ($truthy(src2src) && ($eqeq(doc.$attributes()["$[]"]("docname"), path) || $truthy(doc.$catalog()["$[]"]("includes")["$[]"](path)))) {
                  if ($truthy(fragment)) {
                    $a = [fragment, nil, "#" + fragment], refid = $a[0], path = $a[1], target = $a[2], $a;
                    if ($truthy(self4.$logger()["$info?"]()) && $not(doc.$catalog()["$[]"]("refs")["$[]"](refid))) {
                      self4.$logger().$info("possible invalid reference: " + refid);
                    }
                    ;
                  } else {
                    $a = [nil, nil, "#"], refid = $a[0], path = $a[1], target = $a[2], $a;
                  }
                } else {
                  $a = [path, "" + ($truthy($ret_or_1 = doc.$attributes()["$[]"]("relfileprefix")) ? $ret_or_1 : "") + path + ($truthy(src2src) ? doc.$attributes().$fetch("relfilesuffix", doc.$outfilesuffix()) : "")], refid = $a[0], path = $a[1], $a;
                  if ($truthy(fragment)) {
                    $a = ["" + refid + "#" + fragment, "" + path + "#" + fragment], refid = $a[0], target = $a[1], $a;
                  } else {
                    target = path;
                  }
                  ;
                }
              } else if ($truthy(doc.$compat_mode()) || $not($$("Compliance").$natural_xrefs())) {
                $a = [fragment, "#" + fragment], refid = $a[0], target = $a[1], $a;
                if ($truthy(self4.$logger()["$info?"]()) && $not(doc.$catalog()["$[]"]("refs")["$[]"](refid))) {
                  self4.$logger().$info("possible invalid reference: " + refid);
                }
                ;
              } else if ($truthy(doc.$catalog()["$[]"]("refs")["$[]"](fragment))) {
                $a = [fragment, "#" + fragment], refid = $a[0], target = $a[1], $a;
              } else if (($truthy(fragment["$include?"](" ")) || $neqeq(fragment.$downcase(), fragment)) && $truthy(refid = doc.$resolve_id(fragment))) {
                $a = [refid, "#" + refid], fragment = $a[0], target = $a[1], $a;
              } else {
                $a = [fragment, "#" + fragment], refid = $a[0], target = $a[1], $a;
                if ($truthy(self4.$logger()["$info?"]())) {
                  self4.$logger().$info("possible invalid reference: " + refid);
                }
                ;
              }
              ;
              attrs["$[]="]("path", path);
              attrs["$[]="]("fragment", fragment);
              attrs["$[]="]("refid", refid);
              return $$("Inline").$new(self4, "anchor", link_text, $hash2(["type", "target", "attributes"], { "type": "xref", "target": target, "attributes": attrs })).$convert();
            }, { $$s: self3 });
          }
          ;
          if ($truthy(found_macroish) && $truthy(text["$include?"]("tnote"))) {
            text = $send(text, "gsub", [$$("InlineFootnoteMacroRx")], function $$31() {
              var $a, $b, $c, self4 = $$31.$$s == null ? this : $$31.$$s, id = nil, content = nil, footnote = nil, index = nil, type = nil, target = nil;
              if ($truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("RS")))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$slice(1, (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length());
              }
              ;
              if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))) {
                  $b = (($c = $gvars["~"]) === nil ? nil : $c["$[]"](3)).$split(",", 2), $a = $to_ary($b), id = $a[0] == null ? nil : $a[0], content = $a[1] == null ? nil : $a[1], $b;
                  if (!$truthy(doc.$compat_mode())) {
                    self4.$logger().$warn("found deprecated footnoteref macro: " + (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)) + "; use footnote macro with target instead");
                  }
                  ;
                } else {
                  return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
                }
              } else {
                id = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2);
                content = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
              }
              ;
              if ($truthy(id)) {
                if ($truthy(footnote = $send(doc.$footnotes(), "find", [], function $$32(candidate) {
                  if (candidate == null)
                    candidate = nil;
                  return candidate.$id()["$=="](id);
                }))) {
                  $a = [footnote.$index(), footnote.$text()], index = $a[0], content = $a[1], $a;
                  $a = ["xref", id, nil], type = $a[0], target = $a[1], id = $a[2], $a;
                } else if ($truthy(content)) {
                  content = self4.$restore_passthroughs(self4.$normalize_text(content, true, true));
                  index = doc.$counter("footnote-number");
                  doc.$register("footnotes", $$$($$("Document"), "Footnote").$new(index, id, content));
                  $a = ["ref", nil], type = $a[0], target = $a[1], $a;
                } else {
                  self4.$logger().$warn("invalid footnote reference: " + id);
                  $a = ["xref", id, id, nil], type = $a[0], target = $a[1], content = $a[2], id = $a[3], $a;
                }
              } else if ($truthy(content)) {
                content = self4.$restore_passthroughs(self4.$normalize_text(content, true, true));
                index = doc.$counter("footnote-number");
                doc.$register("footnotes", $$$($$("Document"), "Footnote").$new(index, id, content));
                type = target = nil;
              } else {
                return ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0);
              }
              ;
              return $$("Inline").$new(self4, "footnote", content, $hash2(["attributes", "id", "target", "type"], { "attributes": $hash2(["index"], { "index": index }), "id": id, "target": target, "type": type })).$convert();
            }, { $$s: self3 });
          }
          ;
          return text;
        });
        $def(self2, "$sub_post_replacements", function $$sub_post_replacements(text) {
          var self3 = this, lines = nil, last = nil;
          if (self3.document == null)
            self3.document = nil;
          if (self3.attributes == null)
            self3.attributes = nil;
          if ($truthy(self3.attributes["$[]"]("hardbreaks-option")) || $truthy(self3.document.$attributes()["$[]"]("hardbreaks-option"))) {
            lines = text.$split($$("LF"), -1);
            if ($truthy($rb_lt(lines.$size(), 2))) {
              return text;
            }
            ;
            last = lines.$pop();
            return $send(lines, "map", [], function $$33(line) {
              var self4 = $$33.$$s == null ? this : $$33.$$s;
              if (line == null)
                line = nil;
              return $$("Inline").$new(self4, "break", $truthy(line["$end_with?"]($$("HARD_LINE_BREAK"))) ? line.$slice(0, $rb_minus(line.$length(), 2)) : line, $hash2(["type"], { "type": "line" })).$convert();
            }, { $$s: self3 })["$<<"](last).$join($$("LF"));
          } else if ($truthy(text["$include?"]($$("PLUS"))) && $truthy(text["$include?"]($$("HARD_LINE_BREAK")))) {
            return $send(text, "gsub", [$$("HardLineBreakRx")], function $$34() {
              var $a, self4 = $$34.$$s == null ? this : $$34.$$s;
              return $$("Inline").$new(self4, "break", ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), $hash2(["type"], { "type": "line" })).$convert();
            }, { $$s: self3 });
          } else {
            return text;
          }
        });
        $def(self2, "$sub_source", function $$sub_source(source, process_callouts) {
          var self3 = this;
          if ($truthy(process_callouts)) {
            return self3.$sub_callouts(self3.$sub_specialchars(source));
          } else {
            return self3.$sub_specialchars(source);
          }
        });
        $def(self2, "$sub_callouts", function $$sub_callouts(text) {
          var self3 = this, callout_rx = nil, autonum = nil;
          callout_rx = $truthy(self3["$attr?"]("line-comment")) ? $$("CalloutSourceRxMap")["$[]"](self3.$attr("line-comment")) : $$("CalloutSourceRx");
          autonum = 0;
          return $send(text, "gsub", [callout_rx], function $$35() {
            var $a, self4 = $$35.$$s == null ? this : $$35.$$s, $ret_or_1 = nil;
            if (self4.document == null)
              self4.document = nil;
            if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))) {
              return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$sub($$("RS"), "");
            } else {
              return $$("Inline").$new(self4, "callout", $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](4), ".") ? (autonum = $rb_plus(autonum, 1)).$to_s() : ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4), $hash2(["id", "attributes"], { "id": self4.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], { "guard": $truthy($ret_or_1 = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)) ? $ret_or_1 : $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](3), "--") ? ["<!--", "-->"] : nil }) })).$convert();
            }
          }, { $$s: self3 });
        });
        $def(self2, "$highlight_source", function $$highlight_source(source, process_callouts) {
          var $a, $b, self3 = this, syntax_hl = nil, callout_marks = nil, doc_attrs = nil, syntax_hl_name = nil, start_line_number = nil, linenums_mode = nil, $ret_or_1 = nil, highlight_lines = nil, highlighted = nil, source_offset = nil;
          if (self3.document == null)
            self3.document = nil;
          if (self3.passthroughs == null)
            self3.passthroughs = nil;
          if (!($truthy(syntax_hl = self3.document.$syntax_highlighter()) && $truthy(syntax_hl["$highlight?"]()))) {
            return self3.$sub_source(source, process_callouts);
          }
          ;
          if ($truthy(process_callouts)) {
            $b = self3.$extract_callouts(source), $a = $to_ary($b), source = $a[0] == null ? nil : $a[0], callout_marks = $a[1] == null ? nil : $a[1], $b;
          }
          ;
          doc_attrs = self3.document.$attributes();
          syntax_hl_name = syntax_hl.$name();
          if ($truthy(linenums_mode = $truthy(self3["$attr?"]("linenums")) ? ($truthy($ret_or_1 = doc_attrs["$[]"]("" + syntax_hl_name + "-linenums-mode")) ? $ret_or_1 : "table").$to_sym() : nil) && $truthy($rb_lt(start_line_number = self3.$attr("start", 1).$to_i(), 1))) {
            start_line_number = 1;
          }
          ;
          if ($truthy(self3["$attr?"]("highlight"))) {
            highlight_lines = self3.$resolve_lines_to_highlight(source, self3.$attr("highlight"), start_line_number);
          }
          ;
          $b = syntax_hl.$highlight(self3, source, self3.$attr("language"), $hash2(["callouts", "css_mode", "highlight_lines", "number_lines", "start_line_number", "style"], { "callouts": callout_marks, "css_mode": ($truthy($ret_or_1 = doc_attrs["$[]"]("" + syntax_hl_name + "-css")) ? $ret_or_1 : "class").$to_sym(), "highlight_lines": highlight_lines, "number_lines": linenums_mode, "start_line_number": start_line_number, "style": doc_attrs["$[]"]("" + syntax_hl_name + "-style") })), $a = $to_ary($b), highlighted = $a[0] == null ? nil : $a[0], source_offset = $a[1] == null ? nil : $a[1], $b;
          if (!$truthy(self3.passthroughs["$empty?"]())) {
            highlighted = highlighted.$gsub($$("HighlightedPassSlotRx"), "" + $$("PASS_START") + "\\1" + $$("PASS_END"));
          }
          ;
          if ($truthy(callout_marks["$nil_or_empty?"]())) {
            return highlighted;
          } else {
            return self3.$restore_callouts(highlighted, callout_marks, source_offset);
          }
          ;
        });
        $def(self2, "$resolve_lines_to_highlight", function $$resolve_lines_to_highlight(source, spec, start) {
          var lines = nil, shift = nil;
          if (start == null)
            start = nil;
          lines = [];
          if ($truthy(spec["$include?"](" "))) {
            spec = spec.$delete(" ");
          }
          ;
          $send($truthy(spec["$include?"](",")) ? spec.$split(",") : spec.$split(";"), "map", [], function $$36(entry) {
            var $a, $b, negate = nil, delim = nil, from = nil, _ = nil, to = nil, line = nil;
            if (entry == null)
              entry = nil;
            if ($truthy(entry["$start_with?"]("!"))) {
              entry = entry.$slice(1, entry.$length());
              negate = true;
            }
            ;
            if ($truthy(delim = $truthy(entry["$include?"]("..")) ? ".." : $truthy(entry["$include?"]("-")) ? "-" : nil)) {
              $b = entry.$partition(delim), $a = $to_ary($b), from = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], to = $a[2] == null ? nil : $a[2], $b;
              if ($truthy(to["$empty?"]()) || $truthy($rb_lt(to = to.$to_i(), 0))) {
                to = $rb_plus(source.$count($$("LF")), 1);
              }
              ;
              if ($truthy(negate)) {
                return lines = $rb_minus(lines, Opal2.Range.$new(from.$to_i(), to, false).$to_a());
              } else {
                return lines = lines["$|"](Opal2.Range.$new(from.$to_i(), to, false).$to_a());
              }
              ;
            } else if ($truthy(negate)) {
              return lines.$delete(entry.$to_i());
            } else if ($not(lines["$include?"](line = entry.$to_i()))) {
              return lines["$<<"](line);
            } else {
              return nil;
            }
            ;
          });
          if (!$eqeq(shift = $truthy(start) ? $rb_minus(start, 1) : 0, 0)) {
            lines = $send(lines, "map", [], function $$37(it) {
              if (it == null)
                it = nil;
              return $rb_minus(it, shift);
            });
          }
          ;
          return lines.$sort();
        }, -3);
        $def(self2, "$extract_passthroughs", function $$extract_passthroughs(text) {
          var $a, $b, self3 = this, compat_mode = nil, passthrus = nil, pass_inline_char1 = nil, pass_inline_char2 = nil, pass_inline_rx = nil;
          if (self3.document == null)
            self3.document = nil;
          if (self3.passthroughs == null)
            self3.passthroughs = nil;
          compat_mode = self3.document.$compat_mode();
          passthrus = self3.passthroughs;
          if ($truthy(text["$include?"]("++")) || $truthy(text["$include?"]("$$")) || $truthy(text["$include?"]("ss:"))) {
            text = $send(text, "gsub", [$$("InlinePassMacroRx")], function $$38() {
              var $a2, self4 = $$38.$$s == null ? this : $$38.$$s, boundary = nil, attrlist = nil, escape_count = nil, preceding = nil, old_behavior = nil, attributes = nil, subs = nil, passthru_key = nil, $ret_or_1 = nil;
              if ($truthy(boundary = ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](4))) {
                if ($truthy(compat_mode) && $eqeq(boundary, "++")) {
                  return ($truthy(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](2)) ? "" + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](1)) + "[" + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](2)) + "]" + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](3)) : "" + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](1)) + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](3))) + "++" + self4.$extract_passthroughs(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5)) + "++";
                }
                ;
                if ($truthy(attrlist = ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](2))) {
                  if ($truthy($rb_gt(escape_count = (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](3)).$length(), 0))) {
                    return "" + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](1)) + "[" + attrlist + "]" + $rb_times($$("RS"), $rb_minus(escape_count, 1)) + boundary + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5)) + boundary;
                  } else if ($eqeq(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](1), $$("RS"))) {
                    preceding = "[" + attrlist + "]";
                  } else if ($eqeq(boundary, "++")) {
                    if ($eqeq(attrlist, "x-")) {
                      old_behavior = true;
                      attributes = $hash2([], {});
                    } else if ($truthy(attrlist["$end_with?"](" x-"))) {
                      old_behavior = true;
                      attributes = self4.$parse_quoted_text_attributes(attrlist.$slice(0, $rb_minus(attrlist.$length(), 3)));
                    } else {
                      attributes = self4.$parse_quoted_text_attributes(attrlist);
                    }
                  } else {
                    attributes = self4.$parse_quoted_text_attributes(attrlist);
                  }
                } else if ($truthy($rb_gt(escape_count = (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](3)).$length(), 0))) {
                  return "" + $rb_times($$("RS"), $rb_minus(escape_count, 1)) + boundary + (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5)) + boundary;
                }
                ;
                subs = $eqeq(boundary, "+++") ? [] : $$("BASIC_SUBS");
                if ($truthy(attributes)) {
                  if ($truthy(old_behavior)) {
                    passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "type", "attributes"], { "text": ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5), "subs": $$("NORMAL_SUBS"), "type": "monospaced", "attributes": attributes }));
                  } else {
                    passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "type", "attributes"], { "text": ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5), "subs": subs, "type": "unquoted", "attributes": attributes }));
                  }
                } else {
                  passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs"], { "text": ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](5), "subs": subs }));
                }
                ;
              } else {
                if ($eqeq(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](6), $$("RS"))) {
                  return (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](0)).$slice(1, (($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](0)).$length());
                }
                ;
                if ($truthy(subs = ($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](7))) {
                  passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs"], { "text": self4.$normalize_text(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](8), nil, true), "subs": self4.$resolve_pass_subs(subs) }));
                } else {
                  passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text"], { "text": self4.$normalize_text(($a2 = $gvars["~"]) === nil ? nil : $a2["$[]"](8), nil, true) }));
                }
                ;
              }
              ;
              return "" + ($truthy($ret_or_1 = preceding) ? $ret_or_1 : "") + $$("PASS_START") + passthru_key + $$("PASS_END");
            }, { $$s: self3 });
          }
          ;
          $b = $$("InlinePassRx")["$[]"](compat_mode), $a = $to_ary($b), pass_inline_char1 = $a[0] == null ? nil : $a[0], pass_inline_char2 = $a[1] == null ? nil : $a[1], pass_inline_rx = $a[2] == null ? nil : $a[2], $b;
          if ($truthy(text["$include?"](pass_inline_char1)) || $truthy(pass_inline_char2) && $truthy(text["$include?"](pass_inline_char2))) {
            text = $send(text, "gsub", [pass_inline_rx], function $$39() {
              var $c, self4 = $$39.$$s == null ? this : $$39.$$s, preceding = nil, attrlist = nil, $ret_or_1 = nil, escaped = nil, quoted_text = nil, format_mark = nil, content = nil, old_behavior = nil, old_behavior_forced = nil, attributes = nil, passthru_key = nil, subs = nil;
              preceding = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](1);
              attrlist = $truthy($ret_or_1 = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](4)) ? $ret_or_1 : ($c = $gvars["~"]) === nil ? nil : $c["$[]"](3);
              if ($truthy(($c = $gvars["~"]) === nil ? nil : $c["$[]"](5))) {
                escaped = true;
              }
              ;
              quoted_text = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](6);
              format_mark = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](7);
              content = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](8);
              if ($truthy(compat_mode)) {
                old_behavior = true;
              } else if ($truthy(attrlist) && ($eqeq(attrlist, "x-") || $truthy(attrlist["$end_with?"](" x-")))) {
                old_behavior = old_behavior_forced = true;
              }
              ;
              if ($truthy(attrlist)) {
                if ($truthy(escaped)) {
                  return "" + preceding + "[" + attrlist + "]" + quoted_text.$slice(1, quoted_text.$length());
                } else if ($eqeq(preceding, $$("RS"))) {
                  if ($truthy(old_behavior_forced) && $eqeq(format_mark, "`")) {
                    return "" + preceding + "[" + attrlist + "]" + quoted_text;
                  }
                  ;
                  preceding = "[" + attrlist + "]";
                } else if ($truthy(old_behavior_forced)) {
                  attributes = $eqeq(attrlist, "x-") ? $hash2([], {}) : self4.$parse_quoted_text_attributes(attrlist.$slice(0, $rb_minus(attrlist.$length(), 3)));
                } else {
                  attributes = self4.$parse_quoted_text_attributes(attrlist);
                }
              } else if ($truthy(escaped)) {
                return "" + preceding + quoted_text.$slice(1, quoted_text.$length());
              } else if ($truthy(compat_mode) && $eqeq(preceding, $$("RS"))) {
                return quoted_text;
              }
              ;
              if ($truthy(compat_mode)) {
                passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "attributes", "type"], { "text": content, "subs": $$("BASIC_SUBS"), "attributes": attributes, "type": "monospaced" }));
              } else if ($truthy(attributes)) {
                if ($truthy(old_behavior)) {
                  subs = $eqeq(format_mark, "`") ? $$("BASIC_SUBS") : $$("NORMAL_SUBS");
                  passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "attributes", "type"], { "text": content, "subs": subs, "attributes": attributes, "type": "monospaced" }));
                } else {
                  passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "attributes", "type"], { "text": content, "subs": $$("BASIC_SUBS"), "attributes": attributes, "type": "unquoted" }));
                }
              } else {
                passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs"], { "text": content, "subs": $$("BASIC_SUBS") }));
              }
              ;
              return "" + preceding + $$("PASS_START") + passthru_key + $$("PASS_END");
            }, { $$s: self3 });
          }
          ;
          if ($truthy(text["$include?"](":")) && ($truthy(text["$include?"]("stem:")) || $truthy(text["$include?"]("math:")))) {
            text = $send(text, "gsub", [$$("InlineStemMacroRx")], function $$40() {
              var $c, self4 = $$40.$$s == null ? this : $$40.$$s, type = nil, subs = nil, content = nil, passthru_key = nil;
              if (self4.document == null)
                self4.document = nil;
              if ($truthy((($c = $gvars["~"]) === nil ? nil : $c["$[]"](0))["$start_with?"]($$("RS")))) {
                return (($c = $gvars["~"]) === nil ? nil : $c["$[]"](0)).$slice(1, (($c = $gvars["~"]) === nil ? nil : $c["$[]"](0)).$length());
              }
              ;
              if ($eqeq(type = (($c = $gvars["~"]) === nil ? nil : $c["$[]"](1)).$to_sym(), "stem")) {
                type = $$("STEM_TYPE_ALIASES")["$[]"](self4.document.$attributes()["$[]"]("stem")).$to_sym();
              }
              ;
              subs = ($c = $gvars["~"]) === nil ? nil : $c["$[]"](2);
              content = self4.$normalize_text(($c = $gvars["~"]) === nil ? nil : $c["$[]"](3), nil, true);
              if ($eqeq(type, "latexmath") && $truthy(content["$start_with?"]("$")) && $truthy(content["$end_with?"]("$"))) {
                content = content.$slice(1, $rb_minus(content.$length(), 2));
              }
              ;
              subs = $truthy(subs) ? self4.$resolve_pass_subs(subs) : $truthy(self4.document["$basebackend?"]("html")) ? $$("BASIC_SUBS") : nil;
              passthrus["$[]="](passthru_key = passthrus.$size(), $hash2(["text", "subs", "type"], { "text": content, "subs": subs, "type": type }));
              return "" + $$("PASS_START") + passthru_key + $$("PASS_END");
            }, { $$s: self3 });
          }
          ;
          return text;
        });
        $def(self2, "$restore_passthroughs", function $$restore_passthroughs(text) {
          var self3 = this, passthrus = nil;
          if (self3.passthroughs == null)
            self3.passthroughs = nil;
          passthrus = self3.passthroughs;
          return $send(text, "gsub", [$$("PassSlotRx")], function $$41() {
            var $a, self4 = $$41.$$s == null ? this : $$41.$$s, pass = nil, subbed_text = nil, type = nil, attributes = nil, id = nil;
            if ($truthy(pass = passthrus["$[]"]((($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)).$to_i()))) {
              subbed_text = self4.$apply_subs(pass["$[]"]("text"), pass["$[]"]("subs"));
              if ($truthy(type = pass["$[]"]("type"))) {
                if ($truthy(attributes = pass["$[]"]("attributes"))) {
                  id = attributes["$[]"]("id");
                }
                ;
                subbed_text = $$("Inline").$new(self4, "quoted", subbed_text, $hash2(["type", "id", "attributes"], { "type": type, "id": id, "attributes": attributes })).$convert();
              }
              ;
              if ($truthy(subbed_text["$include?"]($$("PASS_START")))) {
                return self4.$restore_passthroughs(subbed_text);
              } else {
                return subbed_text;
              }
              ;
            } else {
              self4.$logger().$error("unresolved passthrough detected: " + text);
              return "??pass??";
            }
          }, { $$s: self3 });
        });
        $def(self2, "$resolve_subs", function $$resolve_subs(subs, type, defaults, subject) {
          var self3 = this, candidates = nil, modifiers_present = nil, resolved = nil, invalid = nil;
          if (type == null)
            type = "block";
          if (defaults == null)
            defaults = nil;
          if (subject == null)
            subject = nil;
          if ($truthy(subs["$nil_or_empty?"]())) {
            return nil;
          }
          ;
          candidates = nil;
          if ($truthy(subs["$include?"](" "))) {
            subs = subs.$delete(" ");
          }
          ;
          modifiers_present = $$("SubModifierSniffRx")["$match?"](subs);
          $send(subs.$split(","), "each", [], function $$42(key) {
            var modifier_operation = nil, first = nil, resolved_keys = nil, resolved_key = nil, candidate = nil, $ret_or_1 = nil;
            if (key == null)
              key = nil;
            modifier_operation = nil;
            if ($truthy(modifiers_present)) {
              if ($eqeq(first = key.$chr(), "+")) {
                modifier_operation = "append";
                key = key.$slice(1, key.$length());
              } else if ($eqeq(first, "-")) {
                modifier_operation = "remove";
                key = key.$slice(1, key.$length());
              } else if ($truthy(key["$end_with?"]("+"))) {
                modifier_operation = "prepend";
                key = key.$chop();
              }
            }
            ;
            key = key.$to_sym();
            if ($eqeq(type, "inline") && ($eqeq(key, "verbatim") || $eqeq(key, "v"))) {
              resolved_keys = $$("BASIC_SUBS");
            } else if ($truthy($$("SUB_GROUPS")["$key?"](key))) {
              resolved_keys = $$("SUB_GROUPS")["$[]"](key);
            } else if ($eqeq(type, "inline") && $eqeq(key.$length(), 1) && $truthy($$("SUB_HINTS")["$key?"](key))) {
              resolved_key = $$("SUB_HINTS")["$[]"](key);
              if ($truthy(candidate = $$("SUB_GROUPS")["$[]"](resolved_key))) {
                resolved_keys = candidate;
              } else {
                resolved_keys = [resolved_key];
              }
              ;
            } else {
              resolved_keys = [key];
            }
            ;
            if ($truthy(modifier_operation)) {
              candidates = $truthy($ret_or_1 = candidates) ? $ret_or_1 : $truthy(defaults) ? defaults.$drop(0) : [];
              switch (modifier_operation) {
                case "append":
                  return candidates = $rb_plus(candidates, resolved_keys);
                case "prepend":
                  return candidates = $rb_plus(resolved_keys, candidates);
                case "remove":
                  return candidates = $rb_minus(candidates, resolved_keys);
                default:
                  return nil;
              }
              ;
            } else {
              candidates = $truthy($ret_or_1 = candidates) ? $ret_or_1 : [];
              return candidates = $rb_plus(candidates, resolved_keys);
            }
            ;
          });
          if (!$truthy(candidates)) {
            return nil;
          }
          ;
          resolved = candidates["$&"]($$("SUB_OPTIONS")["$[]"](type));
          if (!$truthy($rb_minus(candidates, resolved)["$empty?"]())) {
            invalid = $rb_minus(candidates, resolved);
            self3.$logger().$warn("invalid substitution type" + ($truthy($rb_gt(invalid.$size(), 1)) ? "s" : "") + ($truthy(subject) ? " for " : "") + subject + ": " + invalid.$join(", "));
          }
          ;
          return resolved;
        }, -2);
        $def(self2, "$resolve_block_subs", function $$resolve_block_subs(subs, defaults, subject) {
          var self3 = this;
          return self3.$resolve_subs(subs, "block", defaults, subject);
        });
        $def(self2, "$resolve_pass_subs", function $$resolve_pass_subs(subs) {
          var self3 = this;
          return self3.$resolve_subs(subs, "inline", nil, "passthrough macro");
        });
        $def(self2, "$expand_subs", function $$expand_subs(subs, subject) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil, expanded_subs = nil;
          if (subject == null)
            subject = nil;
          if ($eqeqeq($$$("Symbol"), $ret_or_1 = subs)) {
            if ($eqeq(subs, "none")) {
              return nil;
            } else if ($truthy($ret_or_2 = $$("SUB_GROUPS")["$[]"](subs))) {
              return $ret_or_2;
            } else {
              return [subs];
            }
          } else if ($eqeqeq($$$("Array"), $ret_or_1)) {
            expanded_subs = [];
            $send(subs, "each", [], function $$43(key) {
              var sub_group = nil;
              if (key == null)
                key = nil;
              if ($eqeq(key, "none")) {
                return nil;
              } else if ($truthy(sub_group = $$("SUB_GROUPS")["$[]"](key))) {
                return expanded_subs = $rb_plus(expanded_subs, sub_group);
              } else {
                return expanded_subs["$<<"](key);
              }
              ;
            });
            if ($truthy(expanded_subs["$empty?"]())) {
              return nil;
            } else {
              return expanded_subs;
            }
            ;
          } else {
            return self3.$resolve_subs(subs, "inline", nil, subject);
          }
          ;
        }, -2);
        $def(self2, "$commit_subs", function $$commit_subs() {
          var self3 = this, default_subs = nil, custom_subs = nil, $ret_or_1 = nil, idx = nil, syntax_hl = nil;
          if (self3.default_subs == null)
            self3.default_subs = nil;
          if (self3.content_model == null)
            self3.content_model = nil;
          if (self3.context == null)
            self3.context = nil;
          if (self3.subs == null)
            self3.subs = nil;
          if (self3.attributes == null)
            self3.attributes = nil;
          if (self3.document == null)
            self3.document = nil;
          if (self3.style == null)
            self3.style = nil;
          if (!$truthy(default_subs = self3.default_subs)) {
            switch (self3.content_model) {
              case "simple":
                default_subs = $$("NORMAL_SUBS");
                break;
              case "verbatim":
                default_subs = $eqeq(self3.context, "verse") ? $$("NORMAL_SUBS") : $$("VERBATIM_SUBS");
                break;
              case "raw":
                default_subs = $eqeq(self3.context, "stem") ? $$("BASIC_SUBS") : $$("NO_SUBS");
                break;
              default:
                return self3.subs;
            }
          }
          ;
          if ($truthy(custom_subs = self3.attributes["$[]"]("subs"))) {
            self3.subs = $truthy($ret_or_1 = self3.$resolve_block_subs(custom_subs, default_subs, self3.context)) ? $ret_or_1 : [];
          } else {
            self3.subs = default_subs.$drop(0);
          }
          ;
          if ($eqeq(self3.context, "listing") && $eqeq(self3.style, "source") && $truthy(syntax_hl = self3.document.$syntax_highlighter()) && $truthy(syntax_hl["$highlight?"]()) && $truthy(idx = self3.subs.$index("specialcharacters"))) {
            self3.subs["$[]="](idx, "highlight");
          }
          ;
          return nil;
        });
        $def(self2, "$parse_attributes", function $$parse_attributes(attrlist, posattrs, opts) {
          var self3 = this, block = nil, into = nil;
          if (self3.document == null)
            self3.document = nil;
          if (posattrs == null)
            posattrs = [];
          if (opts == null)
            opts = $hash2([], {});
          if ($truthy($truthy(attrlist) ? attrlist["$empty?"]() : true)) {
            return $hash2([], {});
          }
          ;
          if ($truthy(opts["$[]"]("unescape_input"))) {
            attrlist = self3.$normalize_text(attrlist, true, true);
          }
          ;
          if ($truthy(opts["$[]"]("sub_input")) && $truthy(attrlist["$include?"]($$("ATTR_REF_HEAD")))) {
            attrlist = self3.document.$sub_attributes(attrlist);
          }
          ;
          if ($truthy(opts["$[]"]("sub_result"))) {
            block = self3;
          }
          ;
          if ($truthy(into = opts["$[]"]("into"))) {
            return $$("AttributeList").$new(attrlist, block).$parse_into(into, posattrs);
          } else {
            return $$("AttributeList").$new(attrlist, block).$parse(posattrs);
          }
          ;
        }, -2);
        self2.$private();
        $def(self2, "$extract_attributes_from_text", function $$extract_attributes_from_text(text, default_text) {
          var self3 = this, attrlist = nil, resolved_text = nil, attrs = nil;
          if (default_text == null)
            default_text = nil;
          attrlist = $truthy(text["$include?"]($$("LF"))) ? text.$tr($$("LF"), " ") : text;
          if ($truthy(resolved_text = (attrs = $$("AttributeList").$new(attrlist, self3).$parse())["$[]"](1))) {
            if ($eqeq(resolved_text, attrlist)) {
              return [text, attrs.$clear()];
            } else {
              return [resolved_text, attrs];
            }
          } else {
            return [default_text, attrs];
          }
          ;
        }, -2);
        $def(self2, "$extract_callouts", function $$extract_callouts(source) {
          var self3 = this, callout_marks = nil, autonum = nil, lineno = nil, last_lineno = nil, callout_rx = nil;
          callout_marks = $hash2([], {});
          autonum = lineno = 0;
          last_lineno = nil;
          callout_rx = $truthy(self3["$attr?"]("line-comment")) ? $$("CalloutExtractRxMap")["$[]"](self3.$attr("line-comment")) : $$("CalloutExtractRx");
          source = $send(source.$split($$("LF"), -1), "map", [], function $$44(line) {
            if (line == null)
              line = nil;
            lineno = $rb_plus(lineno, 1);
            return $send(line, "gsub", [callout_rx], function $$45() {
              var $a, $ret_or_1 = nil;
              if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))) {
                return (($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$sub($$("RS"), "");
              } else {
                ($truthy($ret_or_1 = callout_marks["$[]"](lineno)) ? $ret_or_1 : ($a = [lineno, []], $send(callout_marks, "[]=", $a), $a[$a.length - 1]))["$<<"]([$truthy($ret_or_1 = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)) ? $ret_or_1 : $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](3), "--") ? ["<!--", "-->"] : nil, $eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](4), ".") ? (autonum = $rb_plus(autonum, 1)).$to_s() : ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4)]);
                last_lineno = lineno;
                return "";
              }
            });
          }).$join($$("LF"));
          if ($truthy(last_lineno)) {
            if ($eqeq(last_lineno, lineno)) {
              source = "" + source + $$("LF");
            }
          } else {
            callout_marks = nil;
          }
          ;
          return [source, callout_marks];
        });
        $def(self2, "$restore_callouts", function $$restore_callouts(source, callout_marks, source_offset) {
          var self3 = this, preamble = nil, lineno = nil;
          if (source_offset == null)
            source_offset = nil;
          if ($truthy(source_offset)) {
            preamble = source.$slice(0, source_offset);
            source = source.$slice(source_offset, source.$length());
          } else {
            preamble = "";
          }
          ;
          lineno = 0;
          return $rb_plus(preamble, $send(source.$split($$("LF"), -1), "map", [], function $$46(line) {
            var $a, $b, self4 = $$46.$$s == null ? this : $$46.$$s, conums = nil, guard = nil, numeral = nil;
            if (self4.document == null)
              self4.document = nil;
            if (line == null)
              line = nil;
            if ($truthy(conums = callout_marks.$delete(lineno = $rb_plus(lineno, 1)))) {
              if ($eqeq(conums.$size(), 1)) {
                $b = conums["$[]"](0), $a = $to_ary($b), guard = $a[0] == null ? nil : $a[0], numeral = $a[1] == null ? nil : $a[1], $b;
                return "" + line + $$("Inline").$new(self4, "callout", numeral, $hash2(["id", "attributes"], { "id": self4.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], { "guard": guard }) })).$convert();
              } else {
                return "" + line + $send(conums, "map", [], function $$47(guard_it, numeral_it) {
                  var self5 = $$47.$$s == null ? this : $$47.$$s;
                  if (self5.document == null)
                    self5.document = nil;
                  if (guard_it == null)
                    guard_it = nil;
                  if (numeral_it == null)
                    numeral_it = nil;
                  return $$("Inline").$new(self5, "callout", numeral_it, $hash2(["id", "attributes"], { "id": self5.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], { "guard": guard_it }) })).$convert();
                }, { $$s: self4 }).$join(" ");
              }
            } else {
              return line;
            }
            ;
          }, { $$s: self3 }).$join($$("LF")));
        }, -3);
        $def(self2, "$convert_quoted_text", function $$convert_quoted_text(match, type, scope) {
          var self3 = this, attrs = nil, unescaped_attrs = nil, attrlist = nil, id = nil, attributes = nil;
          if ($truthy(match["$[]"](0)["$start_with?"]($$("RS")))) {
            if ($eqeq(scope, "constrained") && $truthy(attrs = match["$[]"](2))) {
              unescaped_attrs = "[" + attrs + "]";
            } else {
              return match["$[]"](0).$slice(1, match["$[]"](0).$length());
            }
          }
          ;
          if ($eqeq(scope, "constrained")) {
            if ($truthy(unescaped_attrs)) {
              return "" + unescaped_attrs + $$("Inline").$new(self3, "quoted", match["$[]"](3), $hash2(["type"], { "type": type })).$convert();
            } else {
              if ($truthy(attrlist = match["$[]"](2))) {
                id = (attributes = self3.$parse_quoted_text_attributes(attrlist))["$[]"]("id");
                if ($eqeq(type, "mark")) {
                  type = "unquoted";
                }
                ;
              }
              ;
              return "" + match["$[]"](1) + $$("Inline").$new(self3, "quoted", match["$[]"](3), $hash2(["type", "id", "attributes"], { "type": type, "id": id, "attributes": attributes })).$convert();
            }
          } else {
            if ($truthy(attrlist = match["$[]"](1))) {
              id = (attributes = self3.$parse_quoted_text_attributes(attrlist))["$[]"]("id");
              if ($eqeq(type, "mark")) {
                type = "unquoted";
              }
              ;
            }
            ;
            return $$("Inline").$new(self3, "quoted", match["$[]"](2), $hash2(["type", "id", "attributes"], { "type": type, "id": id, "attributes": attributes })).$convert();
          }
          ;
        });
        $def(self2, "$do_replacement", function $$do_replacement(m, replacement, restore) {
          var captured = nil;
          if ($truthy((captured = m["$[]"](0))["$include?"]($$("RS")))) {
            return captured.$sub($$("RS"), "");
          } else
            switch (restore) {
              case "none":
                return replacement;
              case "bounding":
                return $rb_plus($rb_plus(m["$[]"](1), replacement), m["$[]"](2));
              default:
                return $rb_plus(m["$[]"](1), replacement);
            }
        });
        nil;
        $def(self2, "$parse_quoted_text_attributes", function $$parse_quoted_text_attributes(str) {
          var $a, $b, self3 = this, before = nil, _ = nil, after = nil, attrs = nil, id = nil, roles = nil;
          if ($truthy(str["$include?"]($$("ATTR_REF_HEAD")))) {
            str = self3.$sub_attributes(str);
          }
          ;
          if ($truthy(str["$include?"](","))) {
            str = str.$slice(0, str.$index(","));
          }
          ;
          if ($truthy((str = str.$strip())["$empty?"]())) {
            return $hash2([], {});
          } else if ($truthy(str["$start_with?"](".", "#")) && $truthy($$("Compliance").$shorthand_property_syntax())) {
            $b = str.$partition("#"), $a = $to_ary($b), before = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], after = $a[2] == null ? nil : $a[2], $b;
            attrs = $hash2([], {});
            if ($truthy(after["$empty?"]())) {
              if ($truthy($rb_gt(before.$length(), 1))) {
                attrs["$[]="]("role", before.$tr(".", " ").$lstrip());
              }
            } else {
              $b = after.$partition("."), $a = $to_ary($b), id = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], roles = $a[2] == null ? nil : $a[2], $b;
              if (!$truthy(id["$empty?"]())) {
                attrs["$[]="]("id", id);
              }
              ;
              if ($truthy(roles["$empty?"]())) {
                if ($truthy($rb_gt(before.$length(), 1))) {
                  attrs["$[]="]("role", before.$tr(".", " ").$lstrip());
                }
              } else if ($truthy($rb_gt(before.$length(), 1))) {
                attrs["$[]="]("role", $rb_plus($rb_plus(before, "."), roles).$tr(".", " ").$lstrip());
              } else {
                attrs["$[]="]("role", roles.$tr(".", " "));
              }
              ;
            }
            ;
            return attrs;
          } else {
            return $hash2(["role"], { "role": str });
          }
          ;
        });
        $def(self2, "$normalize_text", function $$normalize_text(text, normalize_whitespace, unescape_closing_square_brackets) {
          if (normalize_whitespace == null)
            normalize_whitespace = nil;
          if (unescape_closing_square_brackets == null)
            unescape_closing_square_brackets = nil;
          if (!$truthy(text["$empty?"]())) {
            if ($truthy(normalize_whitespace)) {
              text = text.$strip().$tr($$("LF"), " ");
            }
            ;
            if ($truthy(unescape_closing_square_brackets) && $truthy(text["$include?"]($$("R_SB")))) {
              text = text.$gsub($$("ESC_R_SB"), $$("R_SB"));
            }
            ;
          }
          ;
          return text;
        }, -2);
        return $def(self2, "$split_simple_csv", function $$split_simple_csv(str) {
          var values = nil, accum = nil, quote_open = nil;
          if ($truthy(str["$empty?"]())) {
            return [];
          } else if ($truthy(str["$include?"]('"'))) {
            values = [];
            accum = "";
            quote_open = nil;
            $send(str, "each_char", [], function $$48(c) {
              if (c == null)
                c = nil;
              switch (c) {
                case ",":
                  if ($truthy(quote_open)) {
                    return accum = $rb_plus(accum, c);
                  } else {
                    values["$<<"](accum.$strip());
                    return accum = "";
                  }
                  break;
                case '"':
                  return quote_open = quote_open["$!"]();
                default:
                  return accum = $rb_plus(accum, c);
              }
              ;
            });
            return values["$<<"](accum.$strip());
          } else {
            return $send(str.$split(","), "map", [], function $$49(it) {
              if (it == null)
                it = nil;
              return it.$strip();
            });
          }
        });
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/version"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $const_set = Opal2.const_set, $nesting = [], nil = Opal2.nil;
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return $const_set($nesting2[0], "VERSION", "2.0.20");
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/abstract_node"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $eqeq = Opal2.eqeq, $truthy = Opal2.truthy, $def = Opal2.def, $send = Opal2.send, $rb_minus = Opal2.rb_minus, $eqeqeq = Opal2.eqeqeq, $rb_lt = Opal2.rb_lt, $not = Opal2.not, $to_ary = Opal2.to_ary, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("include,attr_reader,attr_accessor,==,document,to_s,[],merge,raise,converter,attributes,key?,[]=,delete,tap,new,each_key,end_with?,<<,slice,-,length,update,split,include?,===,join,empty?,apply_reftext_subs,attr?,attr,extname?,image_uri,<,safe,normalize_web_path,uriish?,encode_spaces_in_uri,generate_data_uri_from_uri,generate_data_uri,extname,normalize_system_path,readable?,strict_encode64,binread,warn,logger,require_library,!,open_uri,content_type,read,base_dir,root?,path_resolver,system_path,web_path,!=,prepare_source_string,fetch,read_asset");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "AbstractNode");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.document = $proto.attributes = $proto.parent = nil;
        self2.$include($$("Logging"));
        self2.$include($$("Substitutors"));
        self2.$attr_reader("attributes");
        self2.$attr_reader("context");
        self2.$attr_reader("document");
        self2.$attr_accessor("id");
        self2.$attr_reader("node_name");
        self2.$attr_reader("parent");
        $def(self2, "$initialize", function $$initialize(parent, context, opts) {
          var self3 = this, attrs = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($eqeq(context, "document")) {
            self3.document = self3;
          } else if ($truthy(parent)) {
            self3.document = (self3.parent = parent).$document();
          }
          ;
          self3.node_name = (self3.context = context).$to_s();
          self3.attributes = $truthy(attrs = opts["$[]"]("attributes")) ? attrs.$merge() : $hash2([], {});
          return self3.passthroughs = [];
        }, -3);
        $def(self2, "$block?", function $AbstractNode_block$ques$1() {
          var self3 = this;
          return self3.$raise($$$("NotImplementedError"));
        });
        $def(self2, "$inline?", function $AbstractNode_inline$ques$2() {
          var self3 = this;
          return self3.$raise($$$("NotImplementedError"));
        });
        $def(self2, "$converter", function $$converter() {
          var self3 = this;
          return self3.document.$converter();
        });
        $def(self2, "$parent=", function $AbstractNode_parent$eq$3(parent) {
          var $a, self3 = this;
          return $a = [parent, parent.$document()], self3.parent = $a[0], self3.document = $a[1], $a;
        });
        $def(self2, "$attr", function $$attr(name, default_value, fallback_name) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;
          if (default_value == null)
            default_value = nil;
          if (fallback_name == null)
            fallback_name = nil;
          if ($truthy($ret_or_1 = self3.attributes["$[]"](name.$to_s()))) {
            return $ret_or_1;
          } else {
            if ($truthy($ret_or_2 = $truthy($ret_or_3 = $truthy($ret_or_4 = fallback_name) ? self3.parent : $ret_or_4) ? self3.document.$attributes()["$[]"](($eqeq(fallback_name, true) ? name : fallback_name).$to_s()) : $ret_or_3)) {
              return $ret_or_2;
            } else {
              return default_value;
            }
            ;
          }
          ;
        }, -2);
        $def(self2, "$attr?", function $AbstractNode_attr$ques$4(name, expected_value, fallback_name) {
          var self3 = this, $ret_or_1 = nil;
          if (expected_value == null)
            expected_value = nil;
          if (fallback_name == null)
            fallback_name = nil;
          if ($truthy(expected_value)) {
            return expected_value["$=="]($truthy($ret_or_1 = self3.attributes["$[]"](name.$to_s())) ? $ret_or_1 : $truthy(fallback_name) && $truthy(self3.parent) ? self3.document.$attributes()["$[]"](($eqeq(fallback_name, true) ? name : fallback_name).$to_s()) : nil);
          } else if ($truthy($ret_or_1 = self3.attributes["$key?"](name.$to_s()))) {
            return $ret_or_1;
          } else {
            if ($truthy(fallback_name) && $truthy(self3.parent)) {
              return self3.document.$attributes()["$key?"](($eqeq(fallback_name, true) ? name : fallback_name).$to_s());
            } else {
              return false;
            }
            ;
          }
          ;
        }, -2);
        $def(self2, "$set_attr", function $$set_attr(name, value, overwrite) {
          var self3 = this;
          if (value == null)
            value = "";
          if (overwrite == null)
            overwrite = true;
          if ($eqeq(overwrite, false) && $truthy(self3.attributes["$key?"](name))) {
            return false;
          } else {
            self3.attributes["$[]="](name, value);
            return true;
          }
          ;
        }, -2);
        $def(self2, "$remove_attr", function $$remove_attr(name) {
          var self3 = this;
          return self3.attributes.$delete(name);
        });
        $def(self2, "$option?", function $AbstractNode_option$ques$5(name) {
          var self3 = this;
          if ($truthy(self3.attributes["$[]"]("" + name + "-option"))) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$set_option", function $$set_option(name) {
          var self3 = this;
          self3.attributes["$[]="]("" + name + "-option", "");
          return nil;
        });
        $def(self2, "$enabled_options", function $$enabled_options() {
          var self3 = this;
          return $send($$$("Set").$new(), "tap", [], function $$6(accum) {
            var self4 = $$6.$$s == null ? this : $$6.$$s;
            if (self4.attributes == null)
              self4.attributes = nil;
            if (accum == null)
              accum = nil;
            return $send(self4.attributes, "each_key", [], function $$7(k) {
              if (k == null)
                k = nil;
              if ($truthy(k.$to_s()["$end_with?"]("-option"))) {
                return accum["$<<"](k.$slice(0, $rb_minus(k.$length(), 7)));
              } else {
                return nil;
              }
              ;
            });
          }, { $$s: self3 });
        });
        $def(self2, "$update_attributes", function $$update_attributes(new_attributes) {
          var self3 = this;
          return self3.attributes.$update(new_attributes);
        });
        $def(self2, "$role", function $$role() {
          var self3 = this;
          return self3.attributes["$[]"]("role");
        });
        $def(self2, "$roles", function $$roles() {
          var self3 = this, val = nil;
          if ($truthy(val = self3.attributes["$[]"]("role"))) {
            return val.$split();
          } else {
            return [];
          }
        });
        $def(self2, "$role?", function $AbstractNode_role$ques$8(expected_value) {
          var self3 = this;
          if (expected_value == null)
            expected_value = nil;
          if ($truthy(expected_value)) {
            return expected_value["$=="](self3.attributes["$[]"]("role"));
          } else {
            return self3.attributes["$key?"]("role");
          }
          ;
        }, -1);
        $def(self2, "$has_role?", function $AbstractNode_has_role$ques$9(name) {
          var self3 = this, val = nil;
          if ($truthy(val = self3.attributes["$[]"]("role"))) {
            return (" " + val + " ")["$include?"](" " + name + " ");
          } else {
            return false;
          }
        });
        $def(self2, "$role=", function $AbstractNode_role$eq$10(names) {
          var $a, self3 = this;
          return $a = ["role", $eqeqeq($$$("Array"), names) ? names.$join(" ") : names], $send(self3.attributes, "[]=", $a), $a[$a.length - 1];
        });
        $def(self2, "$add_role", function $$add_role(name) {
          var self3 = this, val = nil;
          if ($truthy(val = self3.attributes["$[]"]("role"))) {
            if ($truthy((" " + val + " ")["$include?"](" " + name + " "))) {
              return false;
            } else {
              self3.attributes["$[]="]("role", "" + val + " " + name);
              return true;
            }
          } else {
            self3.attributes["$[]="]("role", name);
            return true;
          }
        });
        $def(self2, "$remove_role", function $$remove_role(name) {
          var self3 = this, val = nil;
          if ($truthy(val = self3.attributes["$[]"]("role")) && $truthy((val = val.$split()).$delete(name))) {
            if ($truthy(val["$empty?"]())) {
              self3.attributes.$delete("role");
            } else {
              self3.attributes["$[]="]("role", val.$join(" "));
            }
            ;
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$reftext", function $$reftext() {
          var self3 = this, val = nil;
          if ($truthy(val = self3.attributes["$[]"]("reftext"))) {
            return self3.$apply_reftext_subs(val);
          } else {
            return nil;
          }
        });
        $def(self2, "$reftext?", function $AbstractNode_reftext$ques$11() {
          var self3 = this;
          return self3.attributes["$key?"]("reftext");
        });
        $def(self2, "$icon_uri", function $$icon_uri(name) {
          var self3 = this, icon = nil;
          if ($truthy(self3["$attr?"]("icon"))) {
            icon = self3.$attr("icon");
            if (!$truthy($$("Helpers")["$extname?"](icon))) {
              icon = "" + icon + "." + self3.document.$attr("icontype", "png");
            }
            ;
          } else {
            icon = "" + name + "." + self3.document.$attr("icontype", "png");
          }
          ;
          return self3.$image_uri(icon, "iconsdir");
        });
        $def(self2, "$image_uri", function $$image_uri(target_image, asset_dir_key) {
          var self3 = this, doc = nil, images_base = nil;
          if (asset_dir_key == null)
            asset_dir_key = "imagesdir";
          if ($truthy($rb_lt((doc = self3.document).$safe(), $$$($$("SafeMode"), "SECURE"))) && $truthy(doc["$attr?"]("data-uri"))) {
            if ($truthy($$("Helpers")["$uriish?"](target_image)) && $truthy(target_image = $$("Helpers").$encode_spaces_in_uri(target_image)) || $truthy(asset_dir_key) && $truthy(images_base = doc.$attr(asset_dir_key)) && $truthy($$("Helpers")["$uriish?"](images_base)) && $truthy(target_image = self3.$normalize_web_path(target_image, images_base, false))) {
              if ($truthy(doc["$attr?"]("allow-uri-read"))) {
                return self3.$generate_data_uri_from_uri(target_image, doc["$attr?"]("cache-uri"));
              } else {
                return target_image;
              }
            } else {
              return self3.$generate_data_uri(target_image, asset_dir_key);
            }
          } else {
            return self3.$normalize_web_path(target_image, $truthy(asset_dir_key) ? doc.$attr(asset_dir_key) : nil);
          }
          ;
        }, -2);
        $def(self2, "$media_uri", function $$media_uri(target, asset_dir_key) {
          var self3 = this;
          if (asset_dir_key == null)
            asset_dir_key = "imagesdir";
          return self3.$normalize_web_path(target, $truthy(asset_dir_key) ? self3.document.$attr(asset_dir_key) : nil);
        }, -2);
        $def(self2, "$generate_data_uri", function $$generate_data_uri(target_image, asset_dir_key) {
          var self3 = this, ext = nil, mimetype = nil, image_path = nil;
          if (asset_dir_key == null)
            asset_dir_key = nil;
          if ($truthy(ext = $$("Helpers").$extname(target_image, nil))) {
            mimetype = $eqeq(ext, ".svg") ? "image/svg+xml" : "image/" + ext.$slice(1, ext.$length());
          } else {
            mimetype = "application/octet-stream";
          }
          ;
          if ($truthy(asset_dir_key)) {
            image_path = self3.$normalize_system_path(target_image, self3.document.$attr(asset_dir_key), nil, $hash2(["target_name"], { "target_name": "image" }));
          } else {
            image_path = self3.$normalize_system_path(target_image);
          }
          ;
          if ($truthy($$$("File")["$readable?"](image_path))) {
            return "data:" + mimetype + ";base64," + $$$("Base64").$strict_encode64($$$("File").$binread(image_path));
          } else {
            self3.$logger().$warn("image to embed not found or not readable: " + image_path);
            return "data:" + mimetype + ";base64,";
          }
          ;
        }, -2);
        $def(self2, "$generate_data_uri_from_uri", function $$generate_data_uri_from_uri(image_uri, cache_uri) {
          var $a, $b, self3 = this, mimetype = nil, bindata = nil;
          if (cache_uri == null)
            cache_uri = false;
          if ($truthy(cache_uri)) {
            $$("Helpers").$require_library("open-uri/cached", "open-uri-cached");
          } else if ($not($$("RUBY_ENGINE_OPAL"))) {
            $$$("OpenURI");
          }
          ;
          try {
            $b = $send($$$("OpenURI"), "open_uri", [image_uri, $$("URI_READ_MODE")], function $$12(f) {
              if (f == null)
                f = nil;
              return [f.$content_type(), f.$read()];
            }), $a = $to_ary($b), mimetype = $a[0] == null ? nil : $a[0], bindata = $a[1] == null ? nil : $a[1], $b;
            return "data:" + mimetype + ";base64," + $$$("Base64").$strict_encode64(bindata);
          } catch ($err) {
            if (Opal2.rescue($err, [$$("StandardError")])) {
              try {
                self3.$logger().$warn("could not retrieve image data from URI: " + image_uri);
                return image_uri;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
          ;
        }, -2);
        $def(self2, "$normalize_asset_path", function $$normalize_asset_path(asset_ref, asset_name, autocorrect) {
          var self3 = this;
          if (asset_name == null)
            asset_name = "path";
          if (autocorrect == null)
            autocorrect = true;
          return self3.$normalize_system_path(asset_ref, self3.document.$base_dir(), nil, $hash2(["target_name", "recover"], { "target_name": asset_name, "recover": autocorrect }));
        }, -2);
        $def(self2, "$normalize_system_path", function $$normalize_system_path(target, start, jail, opts) {
          var self3 = this, doc = nil, $ret_or_1 = nil;
          if (start == null)
            start = nil;
          if (jail == null)
            jail = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($truthy($rb_lt((doc = self3.document).$safe(), $$$($$("SafeMode"), "SAFE")))) {
            if ($truthy(start)) {
              if (!$truthy(doc.$path_resolver()["$root?"](start))) {
                start = $$$("File").$join(doc.$base_dir(), start);
              }
            } else {
              start = doc.$base_dir();
            }
          } else {
            start = $truthy($ret_or_1 = start) ? $ret_or_1 : doc.$base_dir();
            jail = $truthy($ret_or_1 = jail) ? $ret_or_1 : doc.$base_dir();
          }
          ;
          return doc.$path_resolver().$system_path(target, start, jail, opts);
        }, -2);
        $def(self2, "$normalize_web_path", function $$normalize_web_path(target, start, preserve_uri_target) {
          var self3 = this;
          if (start == null)
            start = nil;
          if (preserve_uri_target == null)
            preserve_uri_target = true;
          if ($truthy(preserve_uri_target) && $truthy($$("Helpers")["$uriish?"](target))) {
            return $$("Helpers").$encode_spaces_in_uri(target);
          } else {
            return self3.document.$path_resolver().$web_path(target, start);
          }
          ;
        }, -2);
        $def(self2, "$read_asset", function $$read_asset(path, opts) {
          var self3 = this, $ret_or_1 = nil;
          if (opts == null)
            opts = $hash2([], {});
          if (!$eqeqeq($$$("Hash"), opts)) {
            opts = $hash2(["warn_on_failure"], { "warn_on_failure": opts["$!="](false) });
          }
          ;
          if ($truthy($$$("File")["$readable?"](path))) {
            if ($truthy(opts["$[]"]("normalize"))) {
              return $$("Helpers").$prepare_source_string($$$("File").$read(path, $hash2(["mode"], { "mode": $$("FILE_READ_MODE") }))).$join($$("LF"));
            } else {
              return $$$("File").$read(path, $hash2(["mode"], { "mode": $$("FILE_READ_MODE") }));
            }
          } else if ($truthy(opts["$[]"]("warn_on_failure"))) {
            self3.$logger().$warn("" + ($truthy($ret_or_1 = self3.$attr("docfile")) ? $ret_or_1 : "<stdin>") + ": " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "file") + " does not exist or cannot be read: " + path);
            return nil;
          } else {
            return nil;
          }
          ;
        }, -2);
        $def(self2, "$read_contents", function $$read_contents(target, opts) {
          var self3 = this, doc = nil, start = nil, contents = nil, $ret_or_1 = nil;
          if (opts == null)
            opts = $hash2([], {});
          doc = self3.document;
          if ($truthy($$("Helpers")["$uriish?"](target)) || $truthy(start = opts["$[]"]("start")) && $truthy($$("Helpers")["$uriish?"](start)) && $truthy(target = doc.$path_resolver().$web_path(target, start))) {
            if ($truthy(doc["$attr?"]("allow-uri-read"))) {
              if ($truthy(doc["$attr?"]("cache-uri"))) {
                $$("Helpers").$require_library("open-uri/cached", "open-uri-cached");
              }
              ;
              try {
                if ($truthy(opts["$[]"]("normalize"))) {
                  contents = $$("Helpers").$prepare_source_string($send($$$("OpenURI"), "open_uri", [target, $$("URI_READ_MODE")], function $$13(f) {
                    if (f == null)
                      f = nil;
                    return f.$read();
                  })).$join($$("LF"));
                } else {
                  contents = $send($$$("OpenURI"), "open_uri", [target, $$("URI_READ_MODE")], function $$14(f) {
                    if (f == null)
                      f = nil;
                    return f.$read();
                  });
                }
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StandardError")])) {
                  try {
                    if ($truthy(opts.$fetch("warn_on_failure", true))) {
                      self3.$logger().$warn("could not retrieve contents of " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset") + " at URI: " + target);
                    }
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
              ;
            } else if ($truthy(opts.$fetch("warn_on_failure", true))) {
              self3.$logger().$warn("cannot retrieve contents of " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset") + " at URI: " + target + " (allow-uri-read attribute not enabled)");
            }
          } else {
            target = self3.$normalize_system_path(target, opts["$[]"]("start"), nil, $hash2(["target_name"], { "target_name": $truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset" }));
            contents = self3.$read_asset(target, $hash2(["normalize", "warn_on_failure", "label"], { "normalize": opts["$[]"]("normalize"), "warn_on_failure": opts.$fetch("warn_on_failure", true), "label": opts["$[]"]("label") }));
          }
          ;
          if ($truthy(contents) && $truthy(opts["$[]"]("warn_if_empty")) && $truthy(contents["$empty?"]())) {
            self3.$logger().$warn("contents of " + ($truthy($ret_or_1 = opts["$[]"]("label")) ? $ret_or_1 : "asset") + " is empty: " + target);
          }
          ;
          return contents;
        }, -2);
        return $def(self2, "$is_uri?", function $AbstractNode_is_uri$ques$15(str) {
          return $$("Helpers")["$uriish?"](str);
        });
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/abstract_block"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $eqeq = Opal2.eqeq, $eqeqeq = Opal2.eqeqeq, $def = Opal2.def, $return_val = Opal2.return_val, $truthy = Opal2.truthy, $alias = Opal2.alias, $send = Opal2.send, $rb_plus = Opal2.rb_plus, $not = Opal2.not, $neqeq = Opal2.neqeq, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("attr_reader,attr_writer,attr_accessor,==,===,level,file,lineno,playback_attributes,convert,converter,join,map,to_s,parent,parent=,<<,empty?,Integer,find_by_internal,to_proc,find_by,context,[],items,+,find_index,include?,next_adjacent_block,blocks,select,sub_specialchars,match?,sub_replacements,title,apply_title_subs,delete,!,reftext,nil_or_empty?,sub_placeholder,sub_quotes,compat_mode,attributes,chomp,increment_and_store_counter,index=,numbered,sectname,numeral=,counter,caption=,numeral,int_to_roman,each,assign_numeral,reindex_sections,protected,has_role?,raise,header?,!=,flatten,head,rows,merge,body,foot,style,inner_document");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "AbstractBlock");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.source_location = $proto.document = $proto.attributes = $proto.blocks = $proto.numeral = $proto.context = $proto.parent = $proto.caption = $proto.style = $proto.converted_title = $proto.title = $proto.subs = $proto.next_section_index = $proto.next_section_ordinal = $proto.id = $proto.header = nil;
        self2.$attr_reader("blocks");
        self2.$attr_writer("caption");
        self2.$attr_accessor("content_model");
        self2.$attr_accessor("level");
        self2.$attr_accessor("numeral");
        self2.$attr_accessor("source_location");
        self2.$attr_accessor("style");
        self2.$attr_reader("subs");
        $def(self2, "$initialize", function $$initialize(parent, context, opts) {
          var $yield = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          if (opts == null)
            opts = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, context, opts], $yield);
          self3.content_model = "compound";
          self3.blocks = [];
          self3.subs = [];
          self3.id = self3.title = self3.caption = self3.numeral = self3.style = self3.default_subs = self3.source_location = nil;
          if ($eqeq(context, "document") || $eqeq(context, "section")) {
            self3.level = self3.next_section_index = 0;
            return self3.next_section_ordinal = 1;
          } else if ($eqeqeq($$2("AbstractBlock"), parent)) {
            return self3.level = parent.$level();
          } else {
            return self3.level = nil;
          }
          ;
        }, -3);
        $def(self2, "$block?", $return_val(true));
        $def(self2, "$inline?", $return_val(false));
        $def(self2, "$file", function $$file() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.source_location)) {
            return self3.source_location.$file();
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$lineno", function $$lineno() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.source_location)) {
            return self3.source_location.$lineno();
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$convert", function $$convert() {
          var self3 = this;
          self3.document.$playback_attributes(self3.attributes);
          return self3.$converter().$convert(self3);
        });
        $alias(self2, "render", "convert");
        $def(self2, "$content", function $$content() {
          var self3 = this;
          return $send(self3.blocks, "map", [], function $$1(b) {
            if (b == null)
              b = nil;
            return b.$convert();
          }).$join($$2("LF"));
        });
        $def(self2, "$context=", function $AbstractBlock_context$eq$2(context) {
          var self3 = this;
          return self3.node_name = (self3.context = context).$to_s();
        });
        $def(self2, "$<<", function $AbstractBlock_$lt$lt$3(block) {
          var self3 = this;
          if (!$eqeq(block.$parent(), self3)) {
            block["$parent="](self3);
          }
          ;
          self3.blocks["$<<"](block);
          return self3;
        });
        $alias(self2, "append", "<<");
        $def(self2, "$blocks?", function $AbstractBlock_blocks$ques$4() {
          var self3 = this;
          if ($truthy(self3.blocks["$empty?"]())) {
            return false;
          } else {
            return true;
          }
        });
        $def(self2, "$sections?", $return_val(false));
        $def(self2, "$number", function $$number() {
          var self3 = this;
          try {
            return self3.$Integer(self3.numeral);
          } catch ($err) {
            if (Opal2.rescue($err, [$$2("StandardError")])) {
              try {
                return self3.numeral;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
        $def(self2, "$number=", function $AbstractBlock_number$eq$5(val) {
          var self3 = this;
          return self3.numeral = val.$to_s();
        });
        $def(self2, "$find_by", function $$find_by(selector) {
          var block = $$find_by.$$p || nil, self3 = this, result = nil;
          $$find_by.$$p = null;
          ;
          if (selector == null)
            selector = $hash2([], {});
          try {
            return $send(self3, "find_by_internal", [selector, result = []], block.$to_proc());
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("StopIteration")])) {
              try {
                return result;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
        }, -1);
        $alias(self2, "query", "find_by");
        $def(self2, "$next_adjacent_block", function $$next_adjacent_block() {
          var self3 = this, p = nil, sib = nil;
          if ($eqeq(self3.context, "document")) {
            return nil;
          } else if ($eqeq((p = self3.parent).$context(), "dlist") && $eqeq(self3.context, "list_item")) {
            if ($truthy(sib = p.$items()["$[]"]($rb_plus($send(p.$items(), "find_index", [], function $$6(terms, desc) {
              var self4 = $$6.$$s == null ? this : $$6.$$s, $ret_or_1 = nil;
              if (terms == null)
                terms = nil;
              if (desc == null)
                desc = nil;
              if ($truthy($ret_or_1 = terms["$include?"](self4))) {
                return $ret_or_1;
              } else {
                return desc["$=="](self4);
              }
              ;
            }, { $$s: self3 }), 1)))) {
              return sib;
            } else {
              return p.$next_adjacent_block();
            }
          } else if ($truthy(sib = p.$blocks()["$[]"]($rb_plus(p.$blocks().$find_index(self3), 1)))) {
            return sib;
          } else {
            return p.$next_adjacent_block();
          }
        });
        $def(self2, "$sections", function $$sections() {
          var self3 = this;
          return $send(self3.blocks, "select", [], function $$7(block) {
            if (block == null)
              block = nil;
            return block.$context()["$=="]("section");
          });
        });
        $def(self2, "$alt", function $$alt() {
          var self3 = this, text = nil;
          if ($truthy(text = self3.attributes["$[]"]("alt"))) {
            if ($eqeq(text, self3.attributes["$[]"]("default-alt"))) {
              return self3.$sub_specialchars(text);
            } else {
              text = self3.$sub_specialchars(text);
              if ($truthy($$2("ReplaceableTextRx")["$match?"](text))) {
                return self3.$sub_replacements(text);
              } else {
                return text;
              }
              ;
            }
          } else {
            return "";
          }
        });
        $def(self2, "$caption", function $$caption() {
          var self3 = this;
          if ($eqeq(self3.context, "admonition")) {
            return self3.attributes["$[]"]("textlabel");
          } else {
            return self3.caption;
          }
        });
        $def(self2, "$captioned_title", function $$captioned_title() {
          var self3 = this;
          return "" + self3.caption + self3.$title();
        });
        $def(self2, "$list_marker_keyword", function $$list_marker_keyword(list_type) {
          var self3 = this, $ret_or_1 = nil;
          if (list_type == null)
            list_type = nil;
          return $$2("ORDERED_LIST_KEYWORDS")["$[]"]($truthy($ret_or_1 = list_type) ? $ret_or_1 : self3.style);
        }, -1);
        $def(self2, "$title", function $$title() {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          return self3.converted_title = $truthy($ret_or_1 = self3.converted_title) ? $ret_or_1 : $truthy($ret_or_2 = self3.title) ? self3.$apply_title_subs(self3.title) : $ret_or_2;
        });
        $def(self2, "$title?", function $AbstractBlock_title$ques$8() {
          var self3 = this;
          if ($truthy(self3.title)) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$title=", function $AbstractBlock_title$eq$9(val) {
          var self3 = this;
          self3.converted_title = nil;
          return self3.title = val;
        });
        $def(self2, "$sub?", function $AbstractBlock_sub$ques$10(name) {
          var self3 = this;
          return self3.subs["$include?"](name);
        });
        $def(self2, "$remove_sub", function $$remove_sub(sub) {
          var self3 = this;
          self3.subs.$delete(sub);
          return nil;
        });
        $def(self2, "$xreftext", function $$xreftext(xrefstyle) {
          var self3 = this, val = nil, quoted_title = nil, prefix = nil, caption_attr_name = nil;
          if (xrefstyle == null)
            xrefstyle = nil;
          if ($truthy(val = self3.$reftext()) && $not(val["$empty?"]())) {
            return val;
          } else if ($truthy(xrefstyle) && $truthy(self3.title) && $not(self3.caption["$nil_or_empty?"]())) {
            switch (xrefstyle) {
              case "full":
                quoted_title = self3.$sub_placeholder(self3.$sub_quotes($truthy(self3.document.$compat_mode()) ? "``%s''" : '"`%s`"'), self3.$title());
                if ($truthy(self3.numeral) && $truthy(caption_attr_name = $$2("CAPTION_ATTRIBUTE_NAMES")["$[]"](self3.context)) && $truthy(prefix = self3.document.$attributes()["$[]"](caption_attr_name))) {
                  return "" + prefix + " " + self3.numeral + ", " + quoted_title;
                } else {
                  return "" + self3.caption.$chomp(". ") + ", " + quoted_title;
                }
                ;
                break;
              case "short":
                if ($truthy(self3.numeral) && $truthy(caption_attr_name = $$2("CAPTION_ATTRIBUTE_NAMES")["$[]"](self3.context)) && $truthy(prefix = self3.document.$attributes()["$[]"](caption_attr_name))) {
                  return "" + prefix + " " + self3.numeral;
                } else {
                  return self3.caption.$chomp(". ");
                }
                break;
              default:
                return self3.$title();
            }
          } else {
            return self3.$title();
          }
          ;
        }, -1);
        $def(self2, "$assign_caption", function $$assign_caption(value, caption_context) {
          var self3 = this, $ret_or_1 = nil, prefix = nil, attr_name = nil;
          if (caption_context == null)
            caption_context = self3.context;
          if ($truthy(self3.caption) || $not(self3.title) || $truthy(self3.caption = $truthy($ret_or_1 = value) ? $ret_or_1 : self3.document.$attributes()["$[]"]("caption"))) {
            return nil;
          } else if ($truthy(attr_name = $$2("CAPTION_ATTRIBUTE_NAMES")["$[]"](caption_context)) && $truthy(prefix = self3.document.$attributes()["$[]"](attr_name))) {
            self3.caption = "" + prefix + " " + (self3.numeral = self3.document.$increment_and_store_counter("" + caption_context + "-number", self3)) + ". ";
            return nil;
          } else {
            return nil;
          }
          ;
        }, -2);
        $def(self2, "$assign_numeral", function $$assign_numeral(section) {
          var $a, self3 = this, like = nil, sectname = nil, caption = nil;
          self3.next_section_index = $rb_plus(($a = [self3.next_section_index], $send(section, "index=", $a), $a[$a.length - 1]), 1);
          if ($truthy(like = section.$numbered())) {
            if ($eqeq(sectname = section.$sectname(), "appendix")) {
              section["$numeral="](self3.document.$counter("appendix-number", "A"));
              section["$caption="]($truthy(caption = self3.document.$attributes()["$[]"]("appendix-caption")) ? "" + caption + " " + section.$numeral() + ": " : "" + section.$numeral() + ". ");
            } else if ($eqeq(sectname, "chapter") || $eqeq(like, "chapter")) {
              section["$numeral="](self3.document.$counter("chapter-number", 1).$to_s());
            } else {
              section["$numeral="]($eqeq(sectname, "part") ? $$2("Helpers").$int_to_roman(self3.next_section_ordinal) : self3.next_section_ordinal.$to_s());
              self3.next_section_ordinal = $rb_plus(self3.next_section_ordinal, 1);
            }
          }
          ;
          return nil;
        });
        $def(self2, "$reindex_sections", function $$reindex_sections() {
          var self3 = this;
          self3.next_section_index = 0;
          self3.next_section_ordinal = 1;
          return $send(self3.blocks, "each", [], function $$11(block) {
            var self4 = $$11.$$s == null ? this : $$11.$$s;
            if (block == null)
              block = nil;
            if ($eqeq(block.$context(), "section")) {
              self4.$assign_numeral(block);
              return block.$reindex_sections();
            } else {
              return nil;
            }
            ;
          }, { $$s: self3 });
        });
        self2.$protected();
        return $def(self2, "$find_by_internal", function $$find_by_internal(selector, result) {
          var block = $$find_by_internal.$$p || nil, self3 = this, id_selector = nil, role_selector = nil, style_selector = nil, any_context = nil, context_selector = nil, verdict = nil;
          $$find_by_internal.$$p = null;
          ;
          if (selector == null)
            selector = $hash2([], {});
          if (result == null)
            result = [];
          if (($truthy(any_context = $truthy(context_selector = selector["$[]"]("context")) ? nil : true) || $eqeq(context_selector, self3.context)) && ($not(style_selector = selector["$[]"]("style")) || $eqeq(style_selector, self3.style)) && ($not(role_selector = selector["$[]"]("role")) || $truthy(self3["$has_role?"](role_selector))) && ($not(id_selector = selector["$[]"]("id")) || $eqeq(id_selector, self3.id))) {
            if (block !== nil) {
              if ($truthy(verdict = Opal2.yield1(block, self3))) {
                switch (verdict) {
                  case "prune":
                    result["$<<"](self3);
                    if ($truthy(id_selector)) {
                      self3.$raise($$$("StopIteration"));
                    }
                    ;
                    return result;
                  case "reject":
                    if ($truthy(id_selector)) {
                      self3.$raise($$$("StopIteration"));
                    }
                    ;
                    return result;
                  case "stop":
                    self3.$raise($$$("StopIteration"));
                    break;
                  default:
                    result["$<<"](self3);
                    if ($truthy(id_selector)) {
                      self3.$raise($$$("StopIteration"));
                    }
                    ;
                }
              } else if ($truthy(id_selector)) {
                self3.$raise($$$("StopIteration"));
              }
            } else {
              result["$<<"](self3);
              if ($truthy(id_selector)) {
                self3.$raise($$$("StopIteration"));
              }
              ;
            }
          }
          ;
          switch (self3.context) {
            case "document":
              if (!$eqeq(context_selector, "document")) {
                if ($truthy(self3["$header?"]()) && ($truthy(any_context) || $eqeq(context_selector, "section"))) {
                  $send(self3.header, "find_by_internal", [selector, result], block.$to_proc());
                }
                ;
                $send(self3.blocks, "each", [], function $$12(b) {
                  if (b == null)
                    b = nil;
                  if ($eqeq(context_selector, "section") && $neqeq(b.$context(), "section")) {
                    return nil;
                  }
                  ;
                  return $send(b, "find_by_internal", [selector, result], block.$to_proc());
                });
              }
              break;
            case "dlist":
              if ($truthy(any_context) || $neqeq(context_selector, "section")) {
                $send(self3.blocks.$flatten(), "each", [], function $$13(b) {
                  if (b == null)
                    b = nil;
                  if ($truthy(b)) {
                    return $send(b, "find_by_internal", [selector, result], block.$to_proc());
                  } else {
                    return nil;
                  }
                  ;
                });
              }
              break;
            case "table":
              if ($truthy(selector["$[]"]("traverse_documents"))) {
                $send(self3.$rows().$head(), "each", [], function $$14(r) {
                  if (r == null)
                    r = nil;
                  return $send(r, "each", [], function $$15(c) {
                    if (c == null)
                      c = nil;
                    return $send(c, "find_by_internal", [selector, result], block.$to_proc());
                  });
                });
                if ($eqeq(context_selector, "inner_document")) {
                  selector = selector.$merge($hash2(["context"], { "context": "document" }));
                }
                ;
                $send($rb_plus(self3.$rows().$body(), self3.$rows().$foot()), "each", [], function $$16(r) {
                  if (r == null)
                    r = nil;
                  return $send(r, "each", [], function $$17(c) {
                    if (c == null)
                      c = nil;
                    $send(c, "find_by_internal", [selector, result], block.$to_proc());
                    if ($eqeq(c.$style(), "asciidoc")) {
                      return $send(c.$inner_document(), "find_by_internal", [selector, result], block.$to_proc());
                    } else {
                      return nil;
                    }
                    ;
                  });
                });
              } else {
                $send($rb_plus($rb_plus(self3.$rows().$head(), self3.$rows().$body()), self3.$rows().$foot()), "each", [], function $$18(r) {
                  if (r == null)
                    r = nil;
                  return $send(r, "each", [], function $$19(c) {
                    if (c == null)
                      c = nil;
                    return $send(c, "find_by_internal", [selector, result], block.$to_proc());
                  });
                });
              }
              break;
            default:
              $send(self3.blocks, "each", [], function $$20(b) {
                if (b == null)
                  b = nil;
                if ($eqeq(context_selector, "section") && $neqeq(b.$context(), "section")) {
                  return nil;
                }
                ;
                return $send(b, "find_by_internal", [selector, result], block.$to_proc());
              });
          }
          ;
          return result;
        }, -1);
      }($nesting2[0], $$("AbstractNode"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/attribute_list"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $hash = Opal2.hash, $regexp = Opal2.regexp, $hash2 = Opal2.hash2, $def = Opal2.def, $truthy = Opal2.truthy, $rb_plus = Opal2.rb_plus, $send = Opal2.send, $defs = Opal2.defs, $eqeqeq = Opal2.eqeqeq, $eqeq = Opal2.eqeq, $rb_times = Opal2.rb_times, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("new,[],update,parse,parse_attribute,eos?,skip_delimiter,+,rekey,each_with_index,[]=,private,skip_blank,===,peek,parse_attribute_value,get_byte,start_with?,scan_name,end_with?,rstrip,string,==,unscan,scan_to_delimiter,*,include?,delete,each,split,empty?,apply_subs,scan_to_quote,gsub,skip,scan");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "AttributeList");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.attributes = $proto.scanner = $proto.delimiter = $proto.block = $proto.delimiter_skip_pattern = $proto.delimiter_boundary_pattern = nil;
        $const_set($nesting3[0], "APOS", "'");
        $const_set($nesting3[0], "BACKSLASH", "\\");
        $const_set($nesting3[0], "QUOT", '"');
        $const_set($nesting3[0], "BoundaryRx", $hash($$("QUOT"), /.*?[^\\](?=")/, $$("APOS"), /.*?[^\\](?=')/, ",", /.*?(?=[ \t]*(,|$))/));
        $const_set($nesting3[0], "EscapedQuotes", $hash($$("QUOT"), '\\"', $$("APOS"), "\\'"));
        $const_set($nesting3[0], "NameRx", $regexp([$$("CG_WORD"), "[", $$("CC_WORD"), "\\-.]*"]));
        $const_set($nesting3[0], "BlankRx", /[ \t]+/);
        $const_set($nesting3[0], "SkipRx", $hash2([","], { ",": /[ \t]*(,|$)/ }));
        $def(self2, "$initialize", function $$initialize(source, block, delimiter) {
          var self3 = this;
          if (block == null)
            block = nil;
          if (delimiter == null)
            delimiter = ",";
          self3.scanner = $$$("StringScanner").$new(source);
          self3.block = block;
          self3.delimiter = delimiter;
          self3.delimiter_skip_pattern = $$("SkipRx")["$[]"](delimiter);
          self3.delimiter_boundary_pattern = $$("BoundaryRx")["$[]"](delimiter);
          return self3.attributes = nil;
        }, -2);
        $def(self2, "$parse_into", function $$parse_into(attributes, positional_attrs) {
          var self3 = this;
          if (positional_attrs == null)
            positional_attrs = [];
          return attributes.$update(self3.$parse(positional_attrs));
        }, -2);
        $def(self2, "$parse", function $$parse(positional_attrs) {
          var self3 = this, index = nil;
          if (positional_attrs == null)
            positional_attrs = [];
          if ($truthy(self3.attributes)) {
            return self3.attributes;
          }
          ;
          self3.attributes = $hash2([], {});
          index = 0;
          while ($truthy(self3.$parse_attribute(index, positional_attrs))) {
            if ($truthy(self3.scanner["$eos?"]())) {
              break;
            }
            ;
            self3.$skip_delimiter();
            index = $rb_plus(index, 1);
          }
          ;
          return self3.attributes;
        }, -1);
        $def(self2, "$rekey", function $$rekey(positional_attrs) {
          var self3 = this;
          return $$("AttributeList").$rekey(self3.attributes, positional_attrs);
        });
        $defs(self2, "$rekey", function $$rekey(attributes, positional_attrs) {
          $send(positional_attrs, "each_with_index", [], function $$1(key, index) {
            var $a, val = nil;
            if (key == null)
              key = nil;
            if (index == null)
              index = nil;
            if ($truthy(key) && $truthy(val = attributes["$[]"]($rb_plus(index, 1)))) {
              return $a = [key, val], $send(attributes, "[]=", $a), $a[$a.length - 1];
            } else {
              return nil;
            }
            ;
          });
          return attributes;
        });
        self2.$private();
        $def(self2, "$parse_attribute", function $$parse_attribute(index, positional_attrs) {
          var self3 = this, continue$ = nil, $ret_or_1 = nil, name = nil, single_quoted = nil, skipped = nil, $ret_or_2 = nil, $ret_or_3 = nil, c = nil, value = nil, positional_attr_name = nil;
          continue$ = true;
          self3.$skip_blank();
          if ($eqeqeq($$("QUOT"), $ret_or_1 = self3.scanner.$peek(1))) {
            name = self3.$parse_attribute_value(self3.scanner.$get_byte());
          } else if ($eqeqeq($$("APOS"), $ret_or_1)) {
            name = self3.$parse_attribute_value(self3.scanner.$get_byte());
            if (!$truthy(name["$start_with?"]($$("APOS")))) {
              single_quoted = true;
            }
            ;
          } else {
            skipped = $truthy($ret_or_2 = $truthy($ret_or_3 = name = self3.$scan_name()) ? self3.$skip_blank() : $ret_or_3) ? $ret_or_2 : 0;
            if ($truthy(self3.scanner["$eos?"]())) {
              if (!($truthy(name) || $truthy(self3.scanner.$string().$rstrip()["$end_with?"](self3.delimiter)))) {
                return nil;
              }
              ;
              continue$ = nil;
            } else if ($eqeq(c = self3.scanner.$get_byte(), self3.delimiter)) {
              self3.scanner.$unscan();
            } else if ($truthy(name)) {
              if ($eqeq(c, "=")) {
                self3.$skip_blank();
                if ($eqeqeq($$("QUOT"), $ret_or_2 = c = self3.scanner.$get_byte())) {
                  value = self3.$parse_attribute_value(c);
                } else if ($eqeqeq($$("APOS"), $ret_or_2)) {
                  value = self3.$parse_attribute_value(c);
                  if (!$truthy(value["$start_with?"]($$("APOS")))) {
                    single_quoted = true;
                  }
                  ;
                } else if ($eqeqeq(self3.delimiter, $ret_or_2)) {
                  value = "";
                  self3.scanner.$unscan();
                } else if ($eqeqeq(nil, $ret_or_2)) {
                  value = "";
                } else {
                  value = "" + c + self3.$scan_to_delimiter();
                  if ($eqeq(value, "None")) {
                    return true;
                  }
                  ;
                }
                ;
              } else {
                name = "" + name + $rb_times(" ", skipped) + c + self3.$scan_to_delimiter();
              }
            } else {
              name = "" + c + self3.$scan_to_delimiter();
            }
            ;
          }
          ;
          if ($truthy(value)) {
            switch (name) {
              case "options":
              case "opts":
                if ($truthy(value["$include?"](","))) {
                  if ($truthy(value["$include?"](" "))) {
                    value = value.$delete(" ");
                  }
                  ;
                  $send(value.$split(","), "each", [], function $$2(opt) {
                    var $a, self4 = $$2.$$s == null ? this : $$2.$$s;
                    if (self4.attributes == null)
                      self4.attributes = nil;
                    if (opt == null)
                      opt = nil;
                    if ($truthy(opt["$empty?"]())) {
                      return nil;
                    } else {
                      return $a = ["" + opt + "-option", ""], $send(self4.attributes, "[]=", $a), $a[$a.length - 1];
                    }
                    ;
                  }, { $$s: self3 });
                } else if (!$truthy(value["$empty?"]())) {
                  self3.attributes["$[]="]("" + value + "-option", "");
                }
                break;
              default:
                if ($truthy(single_quoted) && $truthy(self3.block)) {
                  switch (name) {
                    case "title":
                    case "reftext":
                      self3.attributes["$[]="](name, value);
                      break;
                    default:
                      self3.attributes["$[]="](name, self3.block.$apply_subs(value));
                  }
                } else {
                  self3.attributes["$[]="](name, value);
                }
            }
          } else {
            if ($truthy(single_quoted) && $truthy(self3.block)) {
              name = self3.block.$apply_subs(name);
            }
            ;
            if ($truthy(positional_attr_name = positional_attrs["$[]"](index)) && $truthy(name)) {
              self3.attributes["$[]="](positional_attr_name, name);
            }
            ;
            self3.attributes["$[]="]($rb_plus(index, 1), name);
          }
          ;
          return continue$;
        });
        $def(self2, "$parse_attribute_value", function $$parse_attribute_value(quote) {
          var self3 = this, value = nil;
          if ($eqeq(self3.scanner.$peek(1), quote)) {
            self3.scanner.$get_byte();
            return "";
          } else if ($truthy(value = self3.$scan_to_quote(quote))) {
            self3.scanner.$get_byte();
            if ($truthy(value["$include?"]($$("BACKSLASH")))) {
              return value.$gsub($$("EscapedQuotes")["$[]"](quote), quote);
            } else {
              return value;
            }
            ;
          } else {
            return "" + quote + self3.$scan_to_delimiter();
          }
        });
        $def(self2, "$skip_blank", function $$skip_blank() {
          var self3 = this;
          return self3.scanner.$skip($$("BlankRx"));
        });
        $def(self2, "$skip_delimiter", function $$skip_delimiter() {
          var self3 = this;
          return self3.scanner.$skip(self3.delimiter_skip_pattern);
        });
        $def(self2, "$scan_name", function $$scan_name() {
          var self3 = this;
          return self3.scanner.$scan($$("NameRx"));
        });
        $def(self2, "$scan_to_delimiter", function $$scan_to_delimiter() {
          var self3 = this;
          return self3.scanner.$scan(self3.delimiter_boundary_pattern);
        });
        return $def(self2, "$scan_to_quote", function $$scan_to_quote(quote) {
          var self3 = this;
          return self3.scanner.$scan($$("BoundaryRx")["$[]"](quote));
        });
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/block"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $hash2 = Opal2.hash2, $alias = Opal2.alias, $send2 = Opal2.send2, $find_super = Opal2.find_super, $truthy = Opal2.truthy, $eqeqeq = Opal2.eqeqeq, $def = Opal2.def, $rb_lt = Opal2.rb_lt, $eqeq = Opal2.eqeq, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("default=,context,attr_accessor,[],key?,===,drop,delete,[]=,to_s,commit_subs,nil_or_empty?,prepare_source_string,apply_subs,join,<,size,empty?,rstrip,shift,pop,==,warn,logger,class,object_id,inspect");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Block");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.attributes = $proto.content_model = $proto.lines = $proto.subs = $proto.blocks = $proto.context = $proto.style = nil;
        $const_set($nesting3[0], "DEFAULT_CONTENT_MODEL", $hash2(["audio", "image", "listing", "literal", "stem", "open", "page_break", "pass", "thematic_break", "video"], { "audio": "empty", "image": "empty", "listing": "verbatim", "literal": "verbatim", "stem": "raw", "open": "compound", "page_break": "empty", "pass": "raw", "thematic_break": "empty", "video": "empty" }))["$default="]("simple");
        $alias(self2, "blockname", "context");
        self2.$attr_accessor("lines");
        $def(self2, "$initialize", function $$initialize(parent, context, opts) {
          var $yield = $$initialize.$$p || nil, self3 = this, $ret_or_1 = nil, subs = nil, raw_source = nil;
          $$initialize.$$p = null;
          if (opts == null)
            opts = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, context, opts], $yield);
          self3.content_model = $truthy($ret_or_1 = opts["$[]"]("content_model")) ? $ret_or_1 : $$2("DEFAULT_CONTENT_MODEL")["$[]"](context);
          if ($truthy(opts["$key?"]("subs"))) {
            if ($truthy(subs = opts["$[]"]("subs"))) {
              if ($eqeqeq("default", $ret_or_1 = subs)) {
                self3.default_subs = opts["$[]"]("default_subs");
              } else if ($eqeqeq($$$("Array"), $ret_or_1)) {
                self3.default_subs = subs.$drop(0);
                self3.attributes.$delete("subs");
              } else {
                self3.default_subs = nil;
                self3.attributes["$[]="]("subs", subs.$to_s());
              }
              ;
              self3.$commit_subs();
            } else {
              self3.default_subs = [];
              self3.attributes.$delete("subs");
            }
          } else {
            self3.default_subs = nil;
          }
          ;
          if ($truthy((raw_source = opts["$[]"]("source"))["$nil_or_empty?"]())) {
            return self3.lines = [];
          } else if ($eqeqeq($$$("String"), raw_source)) {
            return self3.lines = $$2("Helpers").$prepare_source_string(raw_source);
          } else {
            return self3.lines = raw_source.$drop(0);
          }
          ;
        }, -3);
        $def(self2, "$content", function $$content() {
          var $yield = $$content.$$p || nil, self3 = this, result = nil, $ret_or_2 = nil, first = nil, last = nil;
          $$content.$$p = null;
          switch (self3.content_model) {
            case "compound":
              return $send2(self3, $find_super(self3, "content", $$content, false, true), "content", [], $yield);
            case "simple":
              return self3.$apply_subs(self3.lines.$join($$2("LF")), self3.subs);
            case "verbatim":
            case "raw":
              result = self3.$apply_subs(self3.lines, self3.subs);
              if ($truthy($rb_lt(result.$size(), 2))) {
                if ($truthy($ret_or_2 = result["$[]"](0))) {
                  return $ret_or_2;
                } else {
                  return "";
                }
              } else {
                while ($truthy($truthy($ret_or_2 = first = result["$[]"](0)) ? first.$rstrip()["$empty?"]() : $ret_or_2)) {
                  result.$shift();
                }
                ;
                while ($truthy($truthy($ret_or_2 = last = result["$[]"](-1)) ? last.$rstrip()["$empty?"]() : $ret_or_2)) {
                  result.$pop();
                }
                ;
                return result.$join($$2("LF"));
              }
              ;
              break;
            default:
              if (!$eqeq(self3.content_model, "empty")) {
                self3.$logger().$warn("unknown content model '" + self3.content_model + "' for block: " + self3);
              }
              ;
              return nil;
          }
        });
        $def(self2, "$source", function $$source() {
          var self3 = this;
          return self3.lines.$join($$2("LF"));
        });
        return $def(self2, "$to_s", function $$to_s() {
          var self3 = this, content_summary = nil;
          content_summary = $eqeq(self3.content_model, "compound") ? "blocks: " + self3.blocks.$size() : "lines: " + self3.lines.$size();
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {context: " + self3.context.$inspect() + ", content_model: " + self3.content_model.$inspect() + ", style: " + self3.style.$inspect() + ", " + content_summary + "}>";
        });
      }($nesting2[0], $$("AbstractBlock"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/callouts"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $def = Opal2.def, $hash2 = Opal2.hash2, $rb_plus = Opal2.rb_plus, $truthy = Opal2.truthy, $rb_le = Opal2.rb_le, $rb_minus = Opal2.rb_minus, $send = Opal2.send, $eqeq = Opal2.eqeq, $rb_lt = Opal2.rb_lt, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("next_list,<<,current_list,to_i,generate_next_callout_id,+,<=,size,[],-,chop,join,map,==,<,private,generate_callout_id");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "Callouts");
        var $proto = self2.$$prototype;
        $proto.co_index = $proto.lists = $proto.list_index = nil;
        $def(self2, "$initialize", function $$initialize() {
          var self3 = this;
          self3.lists = [];
          self3.list_index = 0;
          return self3.$next_list();
        });
        $def(self2, "$register", function $$register(li_ordinal) {
          var self3 = this, id = nil;
          self3.$current_list()["$<<"]($hash2(["ordinal", "id"], { "ordinal": li_ordinal.$to_i(), "id": id = self3.$generate_next_callout_id() }));
          self3.co_index = $rb_plus(self3.co_index, 1);
          return id;
        });
        $def(self2, "$read_next_id", function $$read_next_id() {
          var self3 = this, id = nil, list = nil;
          id = nil;
          list = self3.$current_list();
          if ($truthy($rb_le(self3.co_index, list.$size()))) {
            id = list["$[]"]($rb_minus(self3.co_index, 1))["$[]"]("id");
          }
          ;
          self3.co_index = $rb_plus(self3.co_index, 1);
          return id;
        });
        $def(self2, "$callout_ids", function $$callout_ids(li_ordinal) {
          var self3 = this;
          return $send(self3.$current_list(), "map", [], function $$1(it) {
            if (it == null)
              it = nil;
            if ($eqeq(it["$[]"]("ordinal"), li_ordinal)) {
              return "" + it["$[]"]("id") + " ";
            } else {
              return "";
            }
            ;
          }).$join().$chop();
        });
        $def(self2, "$current_list", function $$current_list() {
          var self3 = this;
          return self3.lists["$[]"]($rb_minus(self3.list_index, 1));
        });
        $def(self2, "$next_list", function $$next_list() {
          var self3 = this;
          self3.list_index = $rb_plus(self3.list_index, 1);
          if ($truthy($rb_lt(self3.lists.$size(), self3.list_index))) {
            self3.lists["$<<"]([]);
          }
          ;
          self3.co_index = 1;
          return nil;
        });
        $def(self2, "$rewind", function $$rewind() {
          var self3 = this;
          self3.list_index = 1;
          self3.co_index = 1;
          return nil;
        });
        self2.$private();
        $def(self2, "$generate_next_callout_id", function $$generate_next_callout_id() {
          var self3 = this;
          return self3.$generate_callout_id(self3.list_index, self3.co_index);
        });
        return $def(self2, "$generate_callout_id", function $$generate_callout_id(list_index, co_index) {
          return "CO" + list_index + "-" + co_index;
        });
      }($nesting2[0], null);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/converter/composite"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $slice = Opal2.slice, $extract_kwargs = Opal2.extract_kwargs, $ensure_kwargs = Opal2.ensure_kwargs, $send = Opal2.send, $truthy = Opal2.truthy, $def = Opal2.def, $thrower = Opal2.thrower, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("attr_reader,each,respond_to?,composed,init_backend_traits,backend_traits,new,[]=,find_converter,convert,converter_for,node_name,[],handles?,raise");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "CompositeConverter");
        var $proto = self2.$$prototype;
        $proto.converter_cache = $proto.converters = nil;
        self2.$attr_reader("converters");
        $def(self2, "$initialize", function $$initialize(backend, $a, $b) {
          var $post_args, $kwargs, converters, backend_traits_source, self3 = this;
          $post_args = $slice(arguments, 1);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          converters = $post_args;
          backend_traits_source = $kwargs.$$smap["backend_traits_source"];
          if (backend_traits_source == null)
            backend_traits_source = nil;
          self3.backend = backend;
          $send(self3.converters = converters, "each", [], function $$1(converter) {
            var self4 = $$1.$$s == null ? this : $$1.$$s;
            if (converter == null)
              converter = nil;
            if ($truthy(converter["$respond_to?"]("composed"))) {
              return converter.$composed(self4);
            } else {
              return nil;
            }
            ;
          }, { $$s: self3 });
          if ($truthy(backend_traits_source)) {
            self3.$init_backend_traits(backend_traits_source.$backend_traits());
          }
          ;
          return self3.converter_cache = $send($$$("Hash"), "new", [], function $$2(hash, key) {
            var $c, self4 = $$2.$$s == null ? this : $$2.$$s;
            if (hash == null)
              hash = nil;
            if (key == null)
              key = nil;
            return $c = [key, self4.$find_converter(key)], $send(hash, "[]=", $c), $c[$c.length - 1];
          }, { $$s: self3 });
        }, -2);
        $def(self2, "$convert", function $$convert(node, transform, opts) {
          var self3 = this, $ret_or_1 = nil;
          if (transform == null)
            transform = nil;
          if (opts == null)
            opts = nil;
          return self3.$converter_for(transform = $truthy($ret_or_1 = transform) ? $ret_or_1 : node.$node_name()).$convert(node, transform, opts);
        }, -2);
        $def(self2, "$converter_for", function $$converter_for(transform) {
          var self3 = this;
          return self3.converter_cache["$[]"](transform);
        });
        return $def(self2, "$find_converter", function $$find_converter(transform) {
          try {
            var $t_return = $thrower("return");
            var self3 = this;
            $send(self3.converters, "each", [], function $$3(candidate) {
              if (candidate == null)
                candidate = nil;
              if ($truthy(candidate["$handles?"](transform))) {
                $t_return.$throw(candidate);
              } else {
                return nil;
              }
              ;
            }, { $$ret: $t_return });
            return self3.$raise("Could not find a converter to handle transform: " + transform);
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        });
      }($$("Converter"), $$$($$("Converter"), "Base"));
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/converter"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $hash2 = Opal2.hash2, $def = Opal2.def, $return_val = Opal2.return_val, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $defs = Opal2.defs, $send = Opal2.send, $alias = Opal2.alias, $slice = Opal2.slice, $to_a = Opal2.to_a, $extract_kwargs = Opal2.extract_kwargs, $ensure_kwargs = Opal2.ensure_kwargs, $eqeqeq = Opal2.eqeqeq, $Class = Opal2.Class, $klass = Opal2.klass, $class_variable_set = Opal2.class_variable_set, $class_variable_get = Opal2.class_variable_get, $rb_plus = Opal2.rb_plus, $gvars = Opal2.gvars, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("autoload,attr_reader,raise,class,[],sub,slice,length,==,[]=,backend_traits,derive_backend_traits,register,map,to_s,new,create,default,each,default=,registry,for,===,supports_templates?,merge,private,include,delete,clear,send,extend,private_class_method,node_name,+,name,receiver,warn,logger,respond_to?,content");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Converter");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self2.$autoload("CompositeConverter", "asciidoctor/converter/composite");
        nil;
        self2.$attr_reader("backend");
        $def(self2, "$initialize", function $$initialize(backend, opts) {
          var self3 = this;
          if (opts == null)
            opts = $hash2([], {});
          return self3.backend = backend;
        }, -2);
        $def(self2, "$convert", function $$convert(node, transform, opts) {
          var self3 = this;
          if (self3.backend == null)
            self3.backend = nil;
          if (transform == null)
            transform = nil;
          if (opts == null)
            opts = nil;
          return self3.$raise($$$("NotImplementedError"), "" + self3.$class() + " (backend: " + self3.backend + ") must implement the #convert method");
        }, -2);
        $def(self2, "$handles?", $return_val(true));
        $defs(self2, "$derive_backend_traits", function $$derive_backend_traits(backend, basebackend) {
          var outfilesuffix = nil, $ret_or_1 = nil, filetype = nil;
          if (basebackend == null)
            basebackend = nil;
          if (!$truthy(backend)) {
            return $hash2([], {});
          }
          ;
          if ($truthy(outfilesuffix = $$("DEFAULT_EXTENSIONS")["$[]"](basebackend = $truthy($ret_or_1 = basebackend) ? $ret_or_1 : backend.$sub($$("TrailingDigitsRx"), "")))) {
            filetype = outfilesuffix.$slice(1, outfilesuffix.$length());
          } else {
            outfilesuffix = "." + (filetype = basebackend);
          }
          ;
          if ($eqeq(filetype, "html")) {
            return $hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix"], { "basebackend": basebackend, "filetype": filetype, "htmlsyntax": "html", "outfilesuffix": outfilesuffix });
          } else {
            return $hash2(["basebackend", "filetype", "outfilesuffix"], { "basebackend": basebackend, "filetype": filetype, "outfilesuffix": outfilesuffix });
          }
          ;
        }, -2);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "BackendTraits");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $def(self3, "$basebackend", function $$basebackend(value) {
            var $a, self4 = this;
            if (value == null)
              value = nil;
            if ($truthy(value)) {
              return $a = ["basebackend", value], $send(self4.$backend_traits(value), "[]=", $a), $a[$a.length - 1];
            } else {
              return self4.$backend_traits()["$[]"]("basebackend");
            }
            ;
          }, -1);
          $def(self3, "$filetype", function $$filetype(value) {
            var $a, self4 = this;
            if (value == null)
              value = nil;
            if ($truthy(value)) {
              return $a = ["filetype", value], $send(self4.$backend_traits(), "[]=", $a), $a[$a.length - 1];
            } else {
              return self4.$backend_traits()["$[]"]("filetype");
            }
            ;
          }, -1);
          $def(self3, "$htmlsyntax", function $$htmlsyntax(value) {
            var $a, self4 = this;
            if (value == null)
              value = nil;
            if ($truthy(value)) {
              return $a = ["htmlsyntax", value], $send(self4.$backend_traits(), "[]=", $a), $a[$a.length - 1];
            } else {
              return self4.$backend_traits()["$[]"]("htmlsyntax");
            }
            ;
          }, -1);
          $def(self3, "$outfilesuffix", function $$outfilesuffix(value) {
            var $a, self4 = this;
            if (value == null)
              value = nil;
            if ($truthy(value)) {
              return $a = ["outfilesuffix", value], $send(self4.$backend_traits(), "[]=", $a), $a[$a.length - 1];
            } else {
              return self4.$backend_traits()["$[]"]("outfilesuffix");
            }
            ;
          }, -1);
          $def(self3, "$supports_templates", function $$supports_templates(value) {
            var $a, self4 = this;
            if (value == null)
              value = true;
            return $a = ["supports_templates", value], $send(self4.$backend_traits(), "[]=", $a), $a[$a.length - 1];
          }, -1);
          $def(self3, "$supports_templates?", function $BackendTraits_supports_templates$ques$1() {
            var self4 = this;
            return self4.$backend_traits()["$[]"]("supports_templates");
          });
          $def(self3, "$init_backend_traits", function $$init_backend_traits(value) {
            var self4 = this, $ret_or_1 = nil;
            if (value == null)
              value = nil;
            return self4.backend_traits = $truthy($ret_or_1 = value) ? $ret_or_1 : $hash2([], {});
          }, -1);
          $def(self3, "$backend_traits", function $$backend_traits(basebackend) {
            var self4 = this, $ret_or_1 = nil;
            if (self4.backend_traits == null)
              self4.backend_traits = nil;
            if (self4.backend == null)
              self4.backend = nil;
            if (basebackend == null)
              basebackend = nil;
            return self4.backend_traits = $truthy($ret_or_1 = self4.backend_traits) ? $ret_or_1 : $$2("Converter").$derive_backend_traits(self4.backend, basebackend);
          }, -1);
          $alias(self3, "backend_info", "backend_traits");
          return $defs(self3, "$derive_backend_traits", function $$derive_backend_traits(backend, basebackend) {
            if (basebackend == null)
              basebackend = nil;
            return $$2("Converter").$derive_backend_traits(backend, basebackend);
          }, -2);
        })($nesting3[0], $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "Config");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          return $def(self3, "$register_for", function $$register_for($a) {
            var $post_args, backends, self4 = this;
            $post_args = $slice(arguments);
            backends = $post_args;
            return $send($$2("Converter"), "register", [self4].concat($to_a($send(backends, "map", [], function $$22(backend) {
              if (backend == null)
                backend = nil;
              return backend.$to_s();
            }))));
          }, -1);
        })($nesting3[0], $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "Factory");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $defs(self3, "$new", function $Factory_new$3($a, $b) {
            var $post_args, $kwargs, converters, proxy_default;
            $post_args = $slice(arguments);
            $kwargs = $extract_kwargs($post_args);
            $kwargs = $ensure_kwargs($kwargs);
            if ($post_args.length > 0)
              converters = $post_args.shift();
            if (converters == null)
              converters = nil;
            proxy_default = $kwargs.$$smap["proxy_default"];
            if (proxy_default == null)
              proxy_default = true;
            if ($truthy(proxy_default)) {
              return $$2("DefaultFactoryProxy").$new(converters);
            } else {
              return $$2("CustomFactory").$new(converters);
            }
            ;
          }, -1);
          $defs(self3, "$default", function $Factory_default$4($a) {
            var $post_args, args;
            $post_args = $slice(arguments);
            args = $post_args;
            return $$2("Converter");
          }, -1);
          $defs(self3, "$create", function $$create(backend, opts) {
            var self4 = this;
            if (opts == null)
              opts = $hash2([], {});
            return self4.$default().$create(backend, opts);
          }, -2);
          $def(self3, "$register", function $$register(converter, $a) {
            var $post_args, backends, self4 = this;
            $post_args = $slice(arguments, 1);
            backends = $post_args;
            return $send(backends, "each", [], function $$5(backend) {
              var $b, self5 = $$5.$$s == null ? this : $$5.$$s;
              if (backend == null)
                backend = nil;
              if ($eqeq(backend, "*")) {
                return $b = [converter], $send(self5.$registry(), "default=", $b), $b[$b.length - 1];
              } else {
                return $b = [backend, converter], $send(self5.$registry(), "[]=", $b), $b[$b.length - 1];
              }
              ;
            }, { $$s: self4 });
          }, -2);
          $def(self3, "$for", function $Factory_for$6(backend) {
            var self4 = this;
            return self4.$registry()["$[]"](backend);
          });
          $def(self3, "$create", function $$create(backend, opts) {
            var self4 = this, converter = nil, template_dirs = nil, delegate_backend = nil;
            if (opts == null)
              opts = $hash2([], {});
            if ($truthy(converter = self4.$for(backend))) {
              if ($eqeqeq($Class, converter)) {
                converter = converter.$new(backend, opts);
              }
              ;
              if ($truthy(template_dirs = opts["$[]"]("template_dirs")) && $eqeqeq($$2("BackendTraits"), converter) && $truthy(converter["$supports_templates?"]())) {
                return $$2("CompositeConverter").$new(backend, $$2("TemplateConverter").$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], { "backend_traits_source": converter }));
              } else {
                return converter;
              }
              ;
            } else if ($truthy(template_dirs = opts["$[]"]("template_dirs"))) {
              if ($truthy(delegate_backend = opts["$[]"]("delegate_backend")) && $truthy(converter = self4.$for(delegate_backend))) {
                if ($eqeqeq($Class, converter)) {
                  converter = converter.$new(delegate_backend, opts);
                }
                ;
                return $$2("CompositeConverter").$new(backend, $$2("TemplateConverter").$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], { "backend_traits_source": converter }));
              } else {
                return $$2("TemplateConverter").$new(backend, template_dirs, opts);
              }
            } else {
              return nil;
            }
            ;
          }, -2);
          $def(self3, "$converters", function $$converters() {
            var self4 = this;
            return self4.$registry().$merge();
          });
          self3.$private();
          return $def(self3, "$registry", function $$registry() {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("Factory") + " subclass " + self4.$class() + " must implement the #registry method");
          });
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "CustomFactory");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("Factory"));
          $def(self3, "$initialize", function $$initialize(seed_registry) {
            var self4 = this;
            if (seed_registry == null)
              seed_registry = nil;
            if ($truthy(seed_registry)) {
              seed_registry["$default="](seed_registry.$delete("*"));
              return self4.registry = seed_registry;
            } else {
              return self4.registry = $hash2([], {});
            }
            ;
          }, -1);
          $def(self3, "$unregister_all", function $$unregister_all() {
            var $a, self4 = this;
            return $a = [nil], $send(self4.$registry().$clear(), "default=", $a), $a[$a.length - 1];
          });
          self3.$private();
          return self3.$attr_reader("registry");
        })($nesting3[0], null, $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "DefaultFactory");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("Factory"));
          self3.$private();
          $class_variable_set($nesting4[0], "@@registry", $hash2([], {}));
          $def(self3, "$registry", function $$registry() {
            return $class_variable_get($nesting4[0], "@@registry", false);
          });
          return nil;
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "DefaultFactoryProxy");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("DefaultFactory"));
          return nil;
        })($nesting3[0], $$("CustomFactory"), $nesting3);
        $defs(self2, "$included", function $$included(into) {
          into.$send("include", $$("BackendTraits"));
          return into.$extend($$("Config"));
        });
        self2.$private_class_method("included");
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Base");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.backend = nil;
          self3.$include($$2("Logging"));
          self3.$include($$2("Converter"));
          $def(self3, "$convert", function $$convert(node, transform, opts) {
            var self4 = this, ex = nil;
            if ($gvars["!"] == null)
              $gvars["!"] = nil;
            if (transform == null)
              transform = node.$node_name();
            if (opts == null)
              opts = nil;
            try {
              if ($truthy(opts)) {
                return self4.$send($rb_plus("convert_", transform), node, opts);
              } else {
                return self4.$send($rb_plus("convert_", transform), node);
              }
            } catch ($err) {
              if (Opal2.rescue($err, [$$2("StandardError")])) {
                try {
                  if (!($eqeqeq($$$("NoMethodError"), ex = $gvars["!"]) && $eqeq(ex.$receiver(), self4) && $eqeq(ex.$name().$to_s(), transform))) {
                    self4.$raise();
                  }
                  ;
                  self4.$logger().$warn("missing convert handler for " + ex.$name() + " node in " + self4.backend + " backend (" + self4.$class() + ")");
                  return nil;
                } finally {
                  Opal2.pop_exception();
                }
              } else {
                throw $err;
              }
            }
            ;
          }, -2);
          $def(self3, "$handles?", function $Base_handles$ques$7(transform) {
            var self4 = this;
            return self4["$respond_to?"]("convert_" + transform);
          });
          $def(self3, "$content_only", function $$content_only(node) {
            return node.$content();
          });
          return $def(self3, "$skip", $return_val(nil));
        })($nesting3[0], null, $nesting3);
        return self2.$extend($$("DefaultFactory"));
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/document"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $send = Opal2.send, $alias = Opal2.alias, $truthy = Opal2.truthy, $def = Opal2.def, $hash2 = Opal2.hash2, $not = Opal2.not, $to_ary = Opal2.to_ary, $return_ivar = Opal2.return_ivar, $send2 = Opal2.send2, $find_super = Opal2.find_super, $rb_minus = Opal2.rb_minus, $eqeq = Opal2.eqeq, $eqeqeq = Opal2.eqeqeq, $hash = Opal2.hash, $rb_ge = Opal2.rb_ge, $rb_plus = Opal2.rb_plus, $neqeq = Opal2.neqeq, $thrower = Opal2.thrower, $rb_gt = Opal2.rb_gt, $rb_lt = Opal2.rb_lt, $gvars = Opal2.gvars, $to_a = Opal2.to_a, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("new,target,attr_reader,nil?,<<,[],[]=,main,include?,strip,squeeze,gsub,!,empty?,rpartition,attr_accessor,catalog,delete,base_dir,options,merge,instance_variable_get,attributes,safe,compat_mode,outfilesuffix,sourcemap,path_resolver,converter,extensions,syntax_highlighter,each,end_with?,start_with?,slice,-,length,chop,==,downcase,===,extname,value_for_name,key?,freeze,attribute_undefined,attribute_missing,update,&,keys,name_for_value,expand_path,pwd,to_s,>=,+,abs,to_i,delete_if,update_doctype_attributes,cursor,parse,restore_attributes,update_backend_attributes,fetch,fill_datetime_attributes,activate,groups,create,to_proc,preprocessors?,preprocessors,process_method,tree_processors?,tree_processors,!=,counter,nil_or_empty?,attribute_locked?,nextval,value,save_to,increment_and_store_counter,register,tap,xreftext,>,source,source_lines,doctitle,sectname=,title=,first_section,title,reftext,<,find,context,header?,assign_numeral,clear_playback_attributes,save_attributes,name,negate,rewind,replace,apply_attribute_value_subs,delete?,start,doctype,content_model,warn,logger,content,convert,postprocessors?,postprocessors,record,write,respond_to?,chomp,class,write_alternate_pages,map,split,resolve_docinfo_subs,normalize_system_path,read_asset,apply_subs,docinfo_processors?,join,concat,compact,docinfo_processors,object_id,inspect,size,private,=~,resolve_pass_subs,apply_header_subs,limit_bytesize,bytesize,valid_encoding?,byteslice,resolve_subs,utc,at,Integer,now,index,strftime,year,utc_offset,partition,create_converter,basebackend,filetype,htmlsyntax,derive_backend_traits,raise");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Document");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.attributes = $proto.safe = $proto.sourcemap = $proto.reader = $proto.base_dir = $proto.parsed = $proto.parent_document = $proto.extensions = $proto.options = $proto.counters = $proto.catalog = $proto.reftexts = $proto.next_section_index = $proto.header = $proto.blocks = $proto.header_attributes = $proto.attributes_modified = $proto.backend = $proto.attribute_overrides = $proto.timings = $proto.converter = $proto.outfilesuffix = $proto.docinfo_processor_extensions = $proto.document = $proto.max_attribute_value_size = $proto.id = $proto.doctype = nil;
        $const_set($nesting3[0], "ImageReference", $send($$$("Struct"), "new", ["target", "imagesdir"], function $Document$1() {
          var self3 = $Document$1.$$s == null ? this : $Document$1.$$s;
          return $alias(self3, "to_s", "target");
        }, { $$s: self2 }));
        $const_set($nesting3[0], "Footnote", $$$("Struct").$new("index", "id", "text"));
        (function($base3, $super2) {
          var self3 = $klass($base3, $super2, "AttributeEntry");
          self3.$attr_reader("name", "value", "negate");
          $def(self3, "$initialize", function $$initialize(name, value, negate) {
            var self4 = this;
            if (negate == null)
              negate = nil;
            self4.name = name;
            self4.value = value;
            return self4.negate = $truthy(negate["$nil?"]()) ? value["$nil?"]() : negate;
          }, -3);
          return $def(self3, "$save_to", function $$save_to(block_attributes) {
            var $a, self4 = this, $ret_or_1 = nil;
            ($truthy($ret_or_1 = block_attributes["$[]"]("attribute_entries")) ? $ret_or_1 : ($a = ["attribute_entries", []], $send(block_attributes, "[]=", $a), $a[$a.length - 1]))["$<<"](self4);
            return self4;
          });
        })($nesting3[0], null);
        (function($base3, $super2, $parent_nesting3) {
          var self3 = $klass($base3, $super2, "Title");
          var $nesting4 = [self3].concat($parent_nesting3), $$3 = Opal2.$r($nesting4), $proto2 = self3.$$prototype;
          $proto2.subtitle = nil;
          self3.$attr_reader("main");
          $alias(self3, "title", "main");
          self3.$attr_reader("subtitle");
          self3.$attr_reader("combined");
          $def(self3, "$initialize", function $$initialize(val, opts) {
            var $a, $b, self4 = this, sep = nil, $ret_or_1 = nil, _ = nil;
            if (opts == null)
              opts = $hash2([], {});
            if ($truthy(self4.sanitized = opts["$[]"]("sanitize")) && $truthy(val["$include?"]("<"))) {
              val = val.$gsub($$3("XmlSanitizeRx"), "").$squeeze(" ").$strip();
            }
            ;
            if ($truthy((sep = $truthy($ret_or_1 = opts["$[]"]("separator")) ? $ret_or_1 : ":")["$empty?"]()) || $not(val["$include?"](sep = "" + sep + " "))) {
              self4.main = val;
              self4.subtitle = nil;
            } else {
              $b = val.$rpartition(sep), $a = $to_ary($b), self4.main = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], self4.subtitle = $a[2] == null ? nil : $a[2], $b;
            }
            ;
            return self4.combined = val;
          }, -2);
          $def(self3, "$sanitized?", $return_ivar("sanitized"));
          $def(self3, "$subtitle?", function $Title_subtitle$ques$2() {
            var self4 = this;
            if ($truthy(self4.subtitle)) {
              return true;
            } else {
              return false;
            }
          });
          return $def(self3, "$to_s", $return_ivar("combined"));
        })($nesting3[0], null, $nesting3);
        $const_set($nesting3[0], "Author", $$$("Struct").$new("name", "firstname", "middlename", "lastname", "initials", "email"));
        self2.$attr_reader("safe");
        self2.$attr_reader("compat_mode");
        self2.$attr_reader("backend");
        self2.$attr_reader("doctype");
        self2.$attr_accessor("sourcemap");
        self2.$attr_reader("catalog");
        $alias(self2, "references", "catalog");
        self2.$attr_reader("counters");
        self2.$attr_reader("header");
        self2.$attr_reader("base_dir");
        self2.$attr_reader("options");
        self2.$attr_reader("outfilesuffix");
        self2.$attr_reader("parent_document");
        self2.$attr_reader("reader");
        self2.$attr_reader("path_resolver");
        self2.$attr_reader("converter");
        self2.$attr_reader("syntax_highlighter");
        self2.$attr_reader("extensions");
        $def(self2, "$initialize", function $$initialize(data, options) {
          var $a, $b, $c, $d, $e, $yield = $$initialize.$$p || nil, self3 = this, parent_doc = nil, $ret_or_1 = nil, attr_overrides = nil, parent_doctype = nil, initialize_extensions = nil, to_file = nil, safe_mode = nil, input_mtime = nil, standalone = nil, attrs = nil, safe_mode_name = nil, base_dir_val = nil, backend_val = nil, doctype_val = nil, size = nil, initial_backend = nil, ext_registry = nil, ext_block = nil;
          $$initialize.$$p = null;
          if (data == null)
            data = nil;
          if (options == null)
            options = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [self3, "document"], null);
          if ($truthy(parent_doc = options.$delete("parent"))) {
            self3.parent_document = parent_doc;
            if ($truthy($ret_or_1 = options["$[]"]("base_dir"))) {
              $ret_or_1;
            } else {
              options["$[]="]("base_dir", parent_doc.$base_dir());
            }
            ;
            if ($truthy(parent_doc.$options()["$[]"]("catalog_assets"))) {
              options["$[]="]("catalog_assets", true);
            }
            ;
            if ($truthy(parent_doc.$options()["$[]"]("to_dir"))) {
              options["$[]="]("to_dir", parent_doc.$options()["$[]"]("to_dir"));
            }
            ;
            self3.catalog = parent_doc.$catalog().$merge($hash2(["footnotes"], { "footnotes": [] }));
            self3.attribute_overrides = attr_overrides = parent_doc.$instance_variable_get("@attribute_overrides").$merge(parent_doc.$attributes());
            attr_overrides.$delete("compat-mode");
            parent_doctype = attr_overrides.$delete("doctype");
            attr_overrides.$delete("notitle");
            attr_overrides.$delete("showtitle");
            attr_overrides.$delete("toc");
            self3.attributes["$[]="]("toc-placement", $truthy($ret_or_1 = attr_overrides.$delete("toc-placement")) ? $ret_or_1 : "auto");
            attr_overrides.$delete("toc-position");
            self3.safe = parent_doc.$safe();
            if ($truthy(self3.compat_mode = parent_doc.$compat_mode())) {
              self3.attributes["$[]="]("compat-mode", "");
            }
            ;
            self3.outfilesuffix = parent_doc.$outfilesuffix();
            self3.sourcemap = parent_doc.$sourcemap();
            self3.timings = nil;
            self3.path_resolver = parent_doc.$path_resolver();
            self3.converter = parent_doc.$converter();
            initialize_extensions = nil;
            self3.extensions = parent_doc.$extensions();
            self3.syntax_highlighter = parent_doc.$syntax_highlighter();
          } else {
            self3.parent_document = nil;
            self3.catalog = $hash2(["ids", "refs", "footnotes", "links", "images", "callouts", "includes"], { "ids": $hash2([], {}), "refs": $hash2([], {}), "footnotes": [], "links": [], "images": [], "callouts": $$2("Callouts").$new(), "includes": $hash2([], {}) });
            self3.attribute_overrides = attr_overrides = $hash2([], {});
            $send($truthy($ret_or_1 = options["$[]"]("attributes")) ? $ret_or_1 : $hash2([], {}), "each", [], function $$3(key, val) {
              var $a2;
              if (key == null)
                key = nil;
              if (val == null)
                val = nil;
              if ($truthy(key["$end_with?"]("@"))) {
                if ($truthy(key["$start_with?"]("!"))) {
                  $a2 = [key.$slice(1, $rb_minus(key.$length(), 2)), false], key = $a2[0], val = $a2[1], $a2;
                } else if ($truthy(key["$end_with?"]("!@"))) {
                  $a2 = [key.$slice(0, $rb_minus(key.$length(), 2)), false], key = $a2[0], val = $a2[1], $a2;
                } else {
                  $a2 = [key.$chop(), "" + val + "@"], key = $a2[0], val = $a2[1], $a2;
                }
              } else if ($truthy(key["$start_with?"]("!"))) {
                $a2 = [key.$slice(1, key.$length()), $eqeq(val, "@") ? false : nil], key = $a2[0], val = $a2[1], $a2;
              } else if ($truthy(key["$end_with?"]("!"))) {
                $a2 = [key.$chop(), $eqeq(val, "@") ? false : nil], key = $a2[0], val = $a2[1], $a2;
              }
              ;
              return $a2 = [key.$downcase(), val], $send(attr_overrides, "[]=", $a2), $a2[$a2.length - 1];
            });
            if ($eqeqeq($$$("String"), to_file = options["$[]"]("to_file"))) {
              attr_overrides["$[]="]("outfilesuffix", $$2("Helpers").$extname(to_file));
            }
            ;
            if ($not(safe_mode = options["$[]"]("safe"))) {
              self3.safe = $$$($$2("SafeMode"), "SECURE");
            } else if ($eqeqeq($$$("Integer"), safe_mode)) {
              self3.safe = safe_mode;
            } else {
              self3.safe = function() {
                try {
                  return $$2("SafeMode").$value_for_name(safe_mode);
                } catch ($err) {
                  if (Opal2.rescue($err, [$$2("StandardError")])) {
                    try {
                      return $$$($$2("SafeMode"), "SECURE");
                    } finally {
                      Opal2.pop_exception();
                    }
                  } else {
                    throw $err;
                  }
                }
              }();
            }
            ;
            input_mtime = options.$delete("input_mtime");
            self3.compat_mode = attr_overrides["$key?"]("compat-mode");
            self3.sourcemap = options["$[]"]("sourcemap");
            self3.timings = options.$delete("timings");
            self3.path_resolver = $$2("PathResolver").$new();
            initialize_extensions = $truthy(($b = $$$("::", "Asciidoctor", "skip_raise")) && ($a = $$$($b, "Extensions", "skip_raise")) ? "constant" : nil) || $truthy(options["$key?"]("extensions")) ? $$$($$$("Asciidoctor"), "Extensions") : nil;
            self3.extensions = nil;
            if ($truthy(options["$key?"]("header_footer")) && $not(options["$key?"]("standalone"))) {
              options["$[]="]("standalone", options["$[]"]("header_footer"));
            }
            ;
          }
          ;
          self3.parsed = self3.reftexts = self3.header = self3.header_attributes = nil;
          self3.counters = $hash2([], {});
          self3.attributes_modified = $$$("Set").$new();
          self3.docinfo_processor_extensions = $hash2([], {});
          standalone = options["$[]"]("standalone");
          (self3.options = options).$freeze();
          attrs = self3.attributes;
          if (!$truthy(parent_doc)) {
            attrs["$[]="]("attribute-undefined", $$2("Compliance").$attribute_undefined());
            attrs["$[]="]("attribute-missing", $$2("Compliance").$attribute_missing());
            attrs.$update($$2("DEFAULT_ATTRIBUTES"));
          }
          ;
          if ($truthy(standalone)) {
            attr_overrides["$[]="]("embedded", nil);
            attrs["$[]="]("copycss", "");
            attrs["$[]="]("iconfont-remote", "");
            attrs["$[]="]("stylesheet", "");
            attrs["$[]="]("webfonts", "");
          } else {
            attr_overrides["$[]="]("embedded", "");
            if ($truthy(attr_overrides["$key?"]("showtitle")) && $eqeq(attr_overrides.$keys()["$&"](["notitle", "showtitle"])["$[]"](-1), "showtitle")) {
              attr_overrides["$[]="]("notitle", $hash(nil, "", false, "@", "@", false)["$[]"](attr_overrides["$[]"]("showtitle")));
            } else if ($truthy(attr_overrides["$key?"]("notitle"))) {
              attr_overrides["$[]="]("showtitle", $hash(nil, "", false, "@", "@", false)["$[]"](attr_overrides["$[]"]("notitle")));
            } else {
              attrs["$[]="]("notitle", "");
            }
            ;
          }
          ;
          attr_overrides["$[]="]("asciidoctor", "");
          attr_overrides["$[]="]("asciidoctor-version", $$$($$$("Asciidoctor"), "VERSION"));
          attr_overrides["$[]="]("safe-mode-name", safe_mode_name = $$2("SafeMode").$name_for_value(self3.safe));
          attr_overrides["$[]="]("safe-mode-" + safe_mode_name, "");
          attr_overrides["$[]="]("safe-mode-level", self3.safe);
          if ($truthy($ret_or_1 = attr_overrides["$[]"]("max-include-depth"))) {
            $ret_or_1;
          } else {
            attr_overrides["$[]="]("max-include-depth", 64);
          }
          ;
          if ($truthy($ret_or_1 = attr_overrides["$[]"]("allow-uri-read"))) {
            $ret_or_1;
          } else {
            attr_overrides["$[]="]("allow-uri-read", nil);
          }
          ;
          if ($truthy(attr_overrides["$key?"]("numbered"))) {
            attr_overrides["$[]="]("sectnums", attr_overrides.$delete("numbered"));
          }
          ;
          if ($truthy(attr_overrides["$key?"]("hardbreaks"))) {
            attr_overrides["$[]="]("hardbreaks-option", attr_overrides.$delete("hardbreaks"));
          }
          ;
          if ($truthy(base_dir_val = options["$[]"]("base_dir"))) {
            self3.base_dir = ($c = ["docdir", $$$("File").$expand_path(base_dir_val)], $send(attr_overrides, "[]=", $c), $c[$c.length - 1]);
          } else if ($truthy(attr_overrides["$[]"]("docdir"))) {
            self3.base_dir = attr_overrides["$[]"]("docdir");
          } else {
            self3.base_dir = ($c = ["docdir", $$$("Dir").$pwd()], $send(attr_overrides, "[]=", $c), $c[$c.length - 1]);
          }
          ;
          if ($truthy(backend_val = options["$[]"]("backend"))) {
            attr_overrides["$[]="]("backend", backend_val.$to_s());
          }
          ;
          if ($truthy(doctype_val = options["$[]"]("doctype"))) {
            attr_overrides["$[]="]("doctype", doctype_val.$to_s());
          }
          ;
          if ($truthy($rb_ge(self3.safe, $$$($$2("SafeMode"), "SERVER")))) {
            if ($truthy($ret_or_1 = attr_overrides["$[]"]("copycss"))) {
              $ret_or_1;
            } else {
              attr_overrides["$[]="]("copycss", nil);
            }
            ;
            if ($truthy($ret_or_1 = attr_overrides["$[]"]("source-highlighter"))) {
              $ret_or_1;
            } else {
              attr_overrides["$[]="]("source-highlighter", nil);
            }
            ;
            if ($truthy($ret_or_1 = attr_overrides["$[]"]("backend"))) {
              $ret_or_1;
            } else {
              attr_overrides["$[]="]("backend", $$2("DEFAULT_BACKEND"));
            }
            ;
            if ($not(parent_doc) && $truthy(attr_overrides["$key?"]("docfile"))) {
              attr_overrides["$[]="]("docfile", attr_overrides["$[]"]("docfile")["$[]"](Opal2.Range.$new($rb_plus(attr_overrides["$[]"]("docdir").$length(), 1), -1, false)));
            }
            ;
            attr_overrides["$[]="]("docdir", "");
            if ($truthy($ret_or_1 = attr_overrides["$[]"]("user-home"))) {
              $ret_or_1;
            } else {
              attr_overrides["$[]="]("user-home", ".");
            }
            ;
            if ($truthy($rb_ge(self3.safe, $$$($$2("SafeMode"), "SECURE")))) {
              if (!$truthy(attr_overrides["$key?"]("max-attribute-value-size"))) {
                attr_overrides["$[]="]("max-attribute-value-size", 4096);
              }
              ;
              if (!$truthy(attr_overrides["$key?"]("linkcss"))) {
                attr_overrides["$[]="]("linkcss", "");
              }
              ;
              if ($truthy($ret_or_1 = attr_overrides["$[]"]("icons"))) {
                $ret_or_1;
              } else {
                attr_overrides["$[]="]("icons", nil);
              }
              ;
            }
            ;
          } else if ($truthy($ret_or_1 = attr_overrides["$[]"]("user-home"))) {
            $ret_or_1;
          } else {
            attr_overrides["$[]="]("user-home", $$2("USER_HOME"));
          }
          ;
          self3.max_attribute_value_size = $truthy(size = $truthy($ret_or_1 = attr_overrides["$[]"]("max-attribute-value-size")) ? $ret_or_1 : ($c = ["max-attribute-value-size", nil], $send(attr_overrides, "[]=", $c), $c[$c.length - 1])) ? size.$to_i().$abs() : nil;
          $send(attr_overrides, "delete_if", [], function $$4(key, val) {
            var $d2, verdict = nil;
            if (key == null)
              key = nil;
            if (val == null)
              val = nil;
            if ($truthy(val)) {
              if ($eqeqeq($$$("String"), val) && $truthy(val["$end_with?"]("@"))) {
                $d2 = [val.$chop(), true], val = $d2[0], verdict = $d2[1], $d2;
              }
              ;
              attrs["$[]="](key, val);
            } else {
              attrs.$delete(key);
              verdict = val["$=="](false);
            }
            ;
            return verdict;
          });
          if ($truthy(parent_doc)) {
            self3.backend = attrs["$[]"]("backend");
            if (!$eqeq(self3.doctype = ($c = ["doctype", parent_doctype], $send(attrs, "[]=", $c), $c[$c.length - 1]), $$2("DEFAULT_DOCTYPE"))) {
              self3.$update_doctype_attributes($$2("DEFAULT_DOCTYPE"));
            }
            ;
            self3.reader = $$2("Reader").$new(data, options["$[]"]("cursor"));
            if ($truthy(self3.sourcemap)) {
              self3.source_location = self3.reader.$cursor();
            }
            ;
            $$2("Parser").$parse(self3.reader, self3);
            self3.$restore_attributes();
            return self3.parsed = true;
          } else {
            self3.backend = nil;
            if ($eqeq(initial_backend = $truthy($ret_or_1 = attrs["$[]"]("backend")) ? $ret_or_1 : $$2("DEFAULT_BACKEND"), "manpage")) {
              self3.doctype = ($c = ["doctype", ($d = ["doctype", "manpage"], $send(attr_overrides, "[]=", $d), $d[$d.length - 1])], $send(attrs, "[]=", $c), $c[$c.length - 1]);
            } else {
              self3.doctype = $truthy($ret_or_1 = attrs["$[]"]("doctype")) ? $ret_or_1 : ($c = ["doctype", $$2("DEFAULT_DOCTYPE")], $send(attrs, "[]=", $c), $c[$c.length - 1]);
            }
            ;
            self3.$update_backend_attributes(initial_backend, true);
            if ($truthy($ret_or_1 = attrs["$[]"]("stylesdir"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("stylesdir", ".");
            }
            ;
            if ($truthy($ret_or_1 = attrs["$[]"]("iconsdir"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("iconsdir", "" + attrs.$fetch("imagesdir", "./images") + "/icons");
            }
            ;
            self3.$fill_datetime_attributes(attrs, input_mtime);
            if ($truthy(initialize_extensions)) {
              if ($truthy(ext_registry = options["$[]"]("extension_registry"))) {
                if ($eqeqeq($$$($$2("Extensions"), "Registry"), ext_registry) || $truthy(($e = $$$("::", "AsciidoctorJ", "skip_raise")) && ($d = $$$($e, "Extensions", "skip_raise")) && ($c = $$$($d, "ExtensionRegistry", "skip_raise")) ? "constant" : nil) && $eqeqeq($$$($$$($$$("AsciidoctorJ"), "Extensions"), "ExtensionRegistry"), ext_registry)) {
                  self3.extensions = ext_registry.$activate(self3);
                }
              } else if ($truthy((ext_block = options["$[]"]("extensions"))["$nil?"]())) {
                if (!$truthy($$2("Extensions").$groups()["$empty?"]())) {
                  self3.extensions = $$$($$2("Extensions"), "Registry").$new().$activate(self3);
                }
              } else if ($eqeqeq($$$("Proc"), ext_block)) {
                self3.extensions = $send($$2("Extensions"), "create", [], ext_block.$to_proc()).$activate(self3);
              }
            }
            ;
            self3.reader = $$2("PreprocessorReader").$new(self3, data, $$$($$2("Reader"), "Cursor").$new(attrs["$[]"]("docfile"), self3.base_dir), $hash2(["normalize"], { "normalize": true }));
            if ($truthy(self3.sourcemap)) {
              return self3.source_location = self3.reader.$cursor();
            } else {
              return nil;
            }
            ;
          }
          ;
        }, -1);
        $def(self2, "$parse", function $$parse(data) {
          var self3 = this, doc = nil, exts = nil;
          if (data == null)
            data = nil;
          if ($truthy(self3.parsed)) {
            return self3;
          } else {
            doc = self3;
            if ($truthy(data)) {
              self3.reader = $$2("PreprocessorReader").$new(doc, data, $$$($$2("Reader"), "Cursor").$new(self3.attributes["$[]"]("docfile"), self3.base_dir), $hash2(["normalize"], { "normalize": true }));
              if ($truthy(self3.sourcemap)) {
                self3.source_location = self3.reader.$cursor();
              }
              ;
            }
            ;
            if ($truthy(exts = $truthy(self3.parent_document) ? nil : self3.extensions) && $truthy(exts["$preprocessors?"]())) {
              $send(exts.$preprocessors(), "each", [], function $$5(ext) {
                var self4 = $$5.$$s == null ? this : $$5.$$s, $ret_or_1 = nil;
                if (self4.reader == null)
                  self4.reader = nil;
                if (ext == null)
                  ext = nil;
                return self4.reader = $truthy($ret_or_1 = ext.$process_method()["$[]"](doc, self4.reader)) ? $ret_or_1 : self4.reader;
              }, { $$s: self3 });
            }
            ;
            $$2("Parser").$parse(self3.reader, doc, $hash2(["header_only"], { "header_only": self3.options["$[]"]("parse_header_only") }));
            self3.$restore_attributes();
            if ($truthy(exts) && $truthy(exts["$tree_processors?"]())) {
              $send(exts.$tree_processors(), "each", [], function $$6(ext) {
                var result = nil;
                if (ext == null)
                  ext = nil;
                if ($truthy(result = ext.$process_method()["$[]"](doc)) && $eqeqeq($$2("Document"), result) && $neqeq(result, doc)) {
                  return doc = result;
                } else {
                  return nil;
                }
                ;
              });
            }
            ;
            self3.parsed = true;
            return doc;
          }
          ;
        }, -1);
        $def(self2, "$parsed?", $return_ivar("parsed"));
        $def(self2, "$counter", function $$counter(name, seed) {
          var $a, self3 = this, curr_val = nil, locked = nil, next_val = nil;
          if (seed == null)
            seed = nil;
          if ($truthy(self3.parent_document)) {
            return self3.parent_document.$counter(name, seed);
          }
          ;
          if ($truthy(locked = self3["$attribute_locked?"](name)) && $truthy(curr_val = self3.counters["$[]"](name)) || $not((curr_val = self3.attributes["$[]"](name))["$nil_or_empty?"]())) {
            next_val = ($a = [name, $$2("Helpers").$nextval(curr_val)], $send(self3.counters, "[]=", $a), $a[$a.length - 1]);
          } else if ($truthy(seed)) {
            next_val = ($a = [name, $eqeq(seed, seed.$to_i().$to_s()) ? seed.$to_i() : seed], $send(self3.counters, "[]=", $a), $a[$a.length - 1]);
          } else {
            next_val = ($a = [name, 1], $send(self3.counters, "[]=", $a), $a[$a.length - 1]);
          }
          ;
          if (!$truthy(locked)) {
            self3.attributes["$[]="](name, next_val);
          }
          ;
          return next_val;
        }, -2);
        $def(self2, "$increment_and_store_counter", function $$increment_and_store_counter(counter_name, block) {
          var self3 = this;
          return $$2("AttributeEntry").$new(counter_name, self3.$counter(counter_name)).$save_to(block.$attributes()).$value();
        });
        $alias(self2, "counter_increment", "increment_and_store_counter");
        $def(self2, "$register", function $$register(type, value) {
          var self3 = this, id = nil, $logical_op_recvr_tmp_1 = nil, $ret_or_2 = nil, ref = nil;
          switch (type) {
            case "ids":
              return self3.$register("refs", [id = value["$[]"](0), $$2("Inline").$new(self3, "anchor", value["$[]"](1), $hash2(["type", "id"], { "type": "ref", "id": id }))]);
            case "refs":
              $logical_op_recvr_tmp_1 = self3.catalog["$[]"]("refs");
              if ($truthy($ret_or_2 = $logical_op_recvr_tmp_1["$[]"](value["$[]"](0)))) {
                $ret_or_2;
              } else {
                $logical_op_recvr_tmp_1["$[]="](value["$[]"](0), ref = value["$[]"](1));
              }
              ;
              ;
              return ref;
            case "footnotes":
              return self3.catalog["$[]"](type)["$<<"](value);
            default:
              if ($truthy(self3.options["$[]"]("catalog_assets"))) {
                return self3.catalog["$[]"](type)["$<<"]($eqeq(type, "images") ? $$2("ImageReference").$new(value, self3.attributes["$[]"]("imagesdir")) : value);
              } else {
                return nil;
              }
          }
        });
        $def(self2, "$resolve_id", function $$resolve_id(text) {
          var self3 = this, resolved_id = nil, accum = nil;
          if ($truthy(self3.reftexts)) {
            return self3.reftexts["$[]"](text);
          } else if ($truthy(self3.parsed)) {
            return $send(self3.reftexts = $hash2([], {}), "tap", [], function $$7(accum2) {
              var self4 = $$7.$$s == null ? this : $$7.$$s;
              if (self4.catalog == null)
                self4.catalog = nil;
              if (accum2 == null)
                accum2 = nil;
              return $send(self4.catalog["$[]"]("refs"), "each", [], function $$8(id, ref) {
                var $a, $ret_or_1 = nil;
                if (id == null)
                  id = nil;
                if (ref == null)
                  ref = nil;
                if ($truthy($ret_or_1 = accum2["$[]"](ref.$xreftext()))) {
                  return $ret_or_1;
                } else {
                  return $a = [ref.$xreftext(), id], $send(accum2, "[]=", $a), $a[$a.length - 1];
                }
                ;
              });
            }, { $$s: self3 })["$[]"](text);
          } else {
            resolved_id = nil;
            self3.reftexts = accum = $hash2([], {});
            (function() {
              try {
                var $t_break = $thrower("break");
                return $send(self3.catalog["$[]"]("refs"), "each", [], function $$9(id, ref) {
                  var $a, xreftext = nil, $ret_or_1 = nil;
                  if (id == null)
                    id = nil;
                  if (ref == null)
                    ref = nil;
                  if ($eqeq(xreftext = ref.$xreftext(), text)) {
                    resolved_id = id;
                    $t_break.$throw();
                  }
                  ;
                  if ($truthy($ret_or_1 = accum["$[]"](xreftext))) {
                    return $ret_or_1;
                  } else {
                    return $a = [xreftext, id], $send(accum, "[]=", $a), $a[$a.length - 1];
                  }
                  ;
                });
              } catch ($e) {
                if ($e === $t_break)
                  return $e.$v;
                throw $e;
              }
            })();
            self3.reftexts = nil;
            return resolved_id;
          }
        });
        $def(self2, "$sections?", function $Document_sections$ques$10() {
          var self3 = this;
          return $rb_gt(self3.next_section_index, 0);
        });
        $def(self2, "$footnotes?", function $Document_footnotes$ques$11() {
          var self3 = this;
          if ($truthy(self3.catalog["$[]"]("footnotes")["$empty?"]())) {
            return false;
          } else {
            return true;
          }
        });
        $def(self2, "$footnotes", function $$footnotes() {
          var self3 = this;
          return self3.catalog["$[]"]("footnotes");
        });
        $def(self2, "$callouts", function $$callouts() {
          var self3 = this;
          return self3.catalog["$[]"]("callouts");
        });
        $def(self2, "$nested?", function $Document_nested$ques$12() {
          var self3 = this;
          if ($truthy(self3.parent_document)) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$embedded?", function $Document_embedded$ques$13() {
          var self3 = this;
          return self3.attributes["$key?"]("embedded");
        });
        $def(self2, "$extensions?", function $Document_extensions$ques$14() {
          var self3 = this;
          if ($truthy(self3.extensions)) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$source", function $$source() {
          var self3 = this;
          if ($truthy(self3.reader)) {
            return self3.reader.$source();
          } else {
            return nil;
          }
        });
        $def(self2, "$source_lines", function $$source_lines() {
          var self3 = this;
          if ($truthy(self3.reader)) {
            return self3.reader.$source_lines();
          } else {
            return nil;
          }
        });
        $def(self2, "$basebackend?", function $Document_basebackend$ques$15(base) {
          var self3 = this;
          return self3.attributes["$[]"]("basebackend")["$=="](base);
        });
        $def(self2, "$title", function $$title() {
          var self3 = this;
          return self3.$doctitle();
        });
        $def(self2, "$title=", function $Document_title$eq$16(title) {
          var $a, self3 = this, sect = nil;
          if (!$truthy(sect = self3.header)) {
            (sect = self3.header = $$2("Section").$new(self3, 0))["$sectname="]("header");
          }
          ;
          return $a = [title], $send(sect, "title=", $a), $a[$a.length - 1];
        });
        $def(self2, "$doctitle", function $$doctitle(opts) {
          var self3 = this, val = nil, sect = nil, $ret_or_1 = nil, separator = nil;
          if (opts == null)
            opts = $hash2([], {});
          if (!$truthy(val = self3.attributes["$[]"]("title"))) {
            if ($truthy(sect = self3.$first_section())) {
              val = sect.$title();
            } else if ($not($truthy($ret_or_1 = opts["$[]"]("use_fallback")) ? val = self3.attributes["$[]"]("untitled-label") : $ret_or_1)) {
              return nil;
            }
          }
          ;
          if ($truthy(separator = opts["$[]"]("partition"))) {
            return $$2("Title").$new(val, opts.$merge($hash2(["separator"], { "separator": $eqeq(separator, true) ? self3.attributes["$[]"]("title-separator") : separator })));
          } else if ($truthy(opts["$[]"]("sanitize")) && $truthy(val["$include?"]("<"))) {
            return val.$gsub($$2("XmlSanitizeRx"), "").$squeeze(" ").$strip();
          } else {
            return val;
          }
          ;
        }, -1);
        $alias(self2, "name", "doctitle");
        $def(self2, "$xreftext", function $$xreftext(xrefstyle) {
          var self3 = this, val = nil;
          if (xrefstyle == null)
            xrefstyle = nil;
          if ($truthy(val = self3.$reftext()) && $not(val["$empty?"]())) {
            return val;
          } else {
            return self3.$title();
          }
          ;
        }, -1);
        $def(self2, "$author", function $$author() {
          var self3 = this;
          return self3.attributes["$[]"]("author");
        });
        $def(self2, "$authors", function $$authors() {
          var self3 = this, attrs = nil, authors = nil, num_authors = nil, $ret_or_1 = nil, idx = nil;
          if ($truthy((attrs = self3.attributes)["$key?"]("author"))) {
            authors = [$$2("Author").$new(attrs["$[]"]("author"), attrs["$[]"]("firstname"), attrs["$[]"]("middlename"), attrs["$[]"]("lastname"), attrs["$[]"]("authorinitials"), attrs["$[]"]("email"))];
            if ($truthy($rb_gt(num_authors = $truthy($ret_or_1 = attrs["$[]"]("authorcount")) ? $ret_or_1 : 0, 1))) {
              idx = 1;
              while ($truthy($rb_lt(idx, num_authors))) {
                idx = $rb_plus(idx, 1);
                authors["$<<"]($$2("Author").$new(attrs["$[]"]("author_" + idx), attrs["$[]"]("firstname_" + idx), attrs["$[]"]("middlename_" + idx), attrs["$[]"]("lastname_" + idx), attrs["$[]"]("authorinitials_" + idx), attrs["$[]"]("email_" + idx)));
              }
              ;
            }
            ;
            return authors;
          } else {
            return [];
          }
        });
        $def(self2, "$revdate", function $$revdate() {
          var self3 = this;
          return self3.attributes["$[]"]("revdate");
        });
        $def(self2, "$notitle", function $$notitle() {
          var self3 = this;
          return self3.attributes["$key?"]("notitle");
        });
        $def(self2, "$noheader", function $$noheader() {
          var self3 = this;
          return self3.attributes["$key?"]("noheader");
        });
        $def(self2, "$nofooter", function $$nofooter() {
          var self3 = this;
          return self3.attributes["$key?"]("nofooter");
        });
        $def(self2, "$first_section", function $$first_section() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.header)) {
            return $ret_or_1;
          } else {
            return $send(self3.blocks, "find", [], function $$17(e) {
              if (e == null)
                e = nil;
              return e.$context()["$=="]("section");
            });
          }
        });
        $def(self2, "$header?", function $Document_header$ques$18() {
          var self3 = this;
          if ($truthy(self3.header)) {
            return true;
          } else {
            return false;
          }
        });
        $alias(self2, "has_header?", "header?");
        $def(self2, "$<<", function $Document_$lt$lt$19(block) {
          var $yield = $Document_$lt$lt$19.$$p || nil, self3 = this;
          $Document_$lt$lt$19.$$p = null;
          if ($eqeq(block.$context(), "section")) {
            self3.$assign_numeral(block);
          }
          ;
          return $send2(self3, $find_super(self3, "<<", $Document_$lt$lt$19, false, true), "<<", [block], $yield);
        });
        $def(self2, "$finalize_header", function $$finalize_header(unrooted_attributes, header_valid) {
          var self3 = this;
          if (header_valid == null)
            header_valid = true;
          self3.$clear_playback_attributes(unrooted_attributes);
          self3.$save_attributes();
          if (!$truthy(header_valid)) {
            unrooted_attributes["$[]="]("invalid-header", true);
          }
          ;
          return unrooted_attributes;
        }, -2);
        $def(self2, "$playback_attributes", function $$playback_attributes(block_attributes) {
          var self3 = this;
          if ($truthy(block_attributes["$key?"]("attribute_entries"))) {
            return $send(block_attributes["$[]"]("attribute_entries"), "each", [], function $$20(entry) {
              var self4 = $$20.$$s == null ? this : $$20.$$s, name = nil;
              if (self4.attributes == null)
                self4.attributes = nil;
              if (entry == null)
                entry = nil;
              name = entry.$name();
              if ($truthy(entry.$negate())) {
                self4.attributes.$delete(name);
                if ($eqeq(name, "compat-mode")) {
                  return self4.compat_mode = false;
                } else {
                  return nil;
                }
                ;
              } else {
                self4.attributes["$[]="](name, entry.$value());
                if ($eqeq(name, "compat-mode")) {
                  return self4.compat_mode = true;
                } else {
                  return nil;
                }
                ;
              }
              ;
            }, { $$s: self3 });
          } else {
            return nil;
          }
        });
        $def(self2, "$restore_attributes", function $$restore_attributes() {
          var self3 = this;
          if (!$truthy(self3.parent_document)) {
            self3.catalog["$[]"]("callouts").$rewind();
          }
          ;
          return self3.attributes.$replace(self3.header_attributes);
        });
        $def(self2, "$set_attribute", function $$set_attribute(name, value) {
          var self3 = this, $ret_or_2 = nil;
          if (value == null)
            value = "";
          if ($truthy(self3["$attribute_locked?"](name))) {
            return nil;
          } else {
            if (!$truthy(value["$empty?"]())) {
              value = self3.$apply_attribute_value_subs(value);
            }
            ;
            if ($truthy(self3.header_attributes)) {
              self3.attributes["$[]="](name, value);
            } else {
              switch (name) {
                case "backend":
                  self3.$update_backend_attributes(value, $truthy($ret_or_2 = self3.attributes_modified["$delete?"]("htmlsyntax")) ? value["$=="](self3.backend) : $ret_or_2);
                  break;
                case "doctype":
                  self3.$update_doctype_attributes(value);
                  break;
                default:
                  self3.attributes["$[]="](name, value);
              }
              ;
              self3.attributes_modified["$<<"](name);
            }
            ;
            return value;
          }
          ;
        }, -2);
        $def(self2, "$delete_attribute", function $$delete_attribute(name) {
          var self3 = this;
          if ($truthy(self3["$attribute_locked?"](name))) {
            return false;
          } else {
            self3.attributes.$delete(name);
            self3.attributes_modified["$<<"](name);
            return true;
          }
        });
        $def(self2, "$attribute_locked?", function $Document_attribute_locked$ques$21(name) {
          var self3 = this;
          return self3.attribute_overrides["$key?"](name);
        });
        $def(self2, "$set_header_attribute", function $$set_header_attribute(name, value, overwrite) {
          var self3 = this, attrs = nil, $ret_or_1 = nil;
          if (value == null)
            value = "";
          if (overwrite == null)
            overwrite = true;
          attrs = $truthy($ret_or_1 = self3.header_attributes) ? $ret_or_1 : self3.attributes;
          if ($eqeq(overwrite, false) && $truthy(attrs["$key?"](name))) {
            return false;
          } else {
            attrs["$[]="](name, value);
            return true;
          }
          ;
        }, -2);
        $def(self2, "$convert", function $$convert(opts) {
          var $a, self3 = this, block = nil, $ret_or_1 = nil, output = nil, transform = nil, exts = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($truthy(self3.timings)) {
            self3.timings.$start("convert");
          }
          ;
          if (!$truthy(self3.parsed)) {
            self3.$parse();
          }
          ;
          if (!($truthy($rb_ge(self3.safe, $$$($$2("SafeMode"), "SERVER"))) || $truthy(opts["$empty?"]()))) {
            if (!$truthy(($a = ["outfile", opts["$[]"]("outfile")], $send(self3.attributes, "[]=", $a), $a[$a.length - 1]))) {
              self3.attributes.$delete("outfile");
            }
            ;
            if (!$truthy(($a = ["outdir", opts["$[]"]("outdir")], $send(self3.attributes, "[]=", $a), $a[$a.length - 1]))) {
              self3.attributes.$delete("outdir");
            }
            ;
          }
          ;
          if ($eqeq(self3.$doctype(), "inline")) {
            if ($truthy(block = $truthy($ret_or_1 = self3.blocks["$[]"](0)) ? $ret_or_1 : self3.header)) {
              if ($eqeq(block.$content_model(), "compound") || $eqeq(block.$content_model(), "empty")) {
                self3.$logger().$warn("no inline candidate; use the inline doctype to convert a single paragragh, verbatim, or raw block");
              } else {
                output = block.$content();
              }
            }
          } else {
            if ($truthy(opts["$key?"]("standalone"))) {
              transform = $truthy(opts["$[]"]("standalone")) ? "document" : "embedded";
            } else if ($truthy(opts["$key?"]("header_footer"))) {
              transform = $truthy(opts["$[]"]("header_footer")) ? "document" : "embedded";
            } else {
              transform = $truthy(self3.options["$[]"]("standalone")) ? "document" : "embedded";
            }
            ;
            output = self3.converter.$convert(self3, transform);
          }
          ;
          if (!$truthy(self3.parent_document)) {
            if ($truthy(exts = self3.extensions) && $truthy(exts["$postprocessors?"]())) {
              $send(exts.$postprocessors(), "each", [], function $$22(ext) {
                var self4 = $$22.$$s == null ? this : $$22.$$s;
                if (ext == null)
                  ext = nil;
                return output = ext.$process_method()["$[]"](self4, output);
              }, { $$s: self3 });
            }
          }
          ;
          if ($truthy(self3.timings)) {
            self3.timings.$record("convert");
          }
          ;
          return output;
        }, -1);
        $alias(self2, "render", "convert");
        $def(self2, "$write", function $$write(output, target) {
          var self3 = this;
          if ($truthy(self3.timings)) {
            self3.timings.$start("write");
          }
          ;
          if ($eqeqeq($$2("Writer"), self3.converter)) {
            self3.converter.$write(output, target);
          } else {
            if ($truthy(target["$respond_to?"]("write"))) {
              if (!$truthy(output["$nil_or_empty?"]())) {
                target.$write(output.$chomp());
                target.$write($$2("LF"));
              }
            } else {
              $$$("File").$write(target, output, $hash2(["mode"], { "mode": $$2("FILE_WRITE_MODE") }));
            }
            ;
            if ($eqeq(self3.backend, "manpage") && $eqeqeq($$$("String"), target) && $truthy(self3.converter.$class()["$respond_to?"]("write_alternate_pages"))) {
              self3.converter.$class().$write_alternate_pages(self3.attributes["$[]"]("mannames"), self3.attributes["$[]"]("manvolnum"), target);
            }
            ;
          }
          ;
          if ($truthy(self3.timings)) {
            self3.timings.$record("write");
          }
          ;
          return nil;
        });
        $def(self2, "$content", function $$content() {
          var $yield = $$content.$$p || nil, self3 = this;
          $$content.$$p = null;
          self3.attributes.$delete("title");
          return $send2(self3, $find_super(self3, "content", $$content, false, true), "content", [], $yield);
        });
        $def(self2, "$docinfo", function $$docinfo(location, suffix) {
          var $a, self3 = this, qualifier = nil, $ret_or_1 = nil, docinfo = nil, content = nil, docinfo_file = nil, docinfo_dir = nil, docinfo_subs = nil, docinfo_path = nil, shared_docinfo = nil, private_docinfo = nil;
          if (location == null)
            location = "head";
          if (suffix == null)
            suffix = nil;
          if ($truthy($rb_lt(self3.$safe(), $$$($$2("SafeMode"), "SECURE")))) {
            if (!$eqeq(location, "head")) {
              qualifier = "-" + location;
            }
            ;
            suffix = $truthy($ret_or_1 = suffix) ? $ret_or_1 : self3.outfilesuffix;
            if ($truthy((docinfo = self3.attributes["$[]"]("docinfo"))["$nil_or_empty?"]())) {
              if ($truthy(self3.attributes["$key?"]("docinfo2"))) {
                docinfo = ["private", "shared"];
              } else if ($truthy(self3.attributes["$key?"]("docinfo1"))) {
                docinfo = ["shared"];
              } else {
                docinfo = $truthy(docinfo) ? ["private"] : nil;
              }
            } else {
              docinfo = $send(docinfo.$split(","), "map", [], function $$23(it) {
                if (it == null)
                  it = nil;
                return it.$strip();
              });
            }
            ;
            if ($truthy(docinfo)) {
              content = [];
              $a = ["docinfo" + qualifier + suffix, self3.attributes["$[]"]("docinfodir"), self3.$resolve_docinfo_subs()], docinfo_file = $a[0], docinfo_dir = $a[1], docinfo_subs = $a[2], $a;
              if (!$truthy(docinfo["$&"](["shared", "shared-" + location])["$empty?"]())) {
                docinfo_path = self3.$normalize_system_path(docinfo_file, docinfo_dir);
                if ($truthy(shared_docinfo = self3.$read_asset(docinfo_path, $hash2(["normalize"], { "normalize": true })))) {
                  content["$<<"](self3.$apply_subs(shared_docinfo, docinfo_subs));
                }
                ;
              }
              ;
              if (!($truthy(self3.attributes["$[]"]("docname")["$nil_or_empty?"]()) || $truthy(docinfo["$&"](["private", "private-" + location])["$empty?"]()))) {
                docinfo_path = self3.$normalize_system_path("" + self3.attributes["$[]"]("docname") + "-" + docinfo_file, docinfo_dir);
                if ($truthy(private_docinfo = self3.$read_asset(docinfo_path, $hash2(["normalize"], { "normalize": true })))) {
                  content["$<<"](self3.$apply_subs(private_docinfo, docinfo_subs));
                }
                ;
              }
              ;
            }
            ;
          }
          ;
          if ($truthy(self3.extensions) && $truthy(self3["$docinfo_processors?"](location))) {
            return ($truthy($ret_or_1 = content) ? $ret_or_1 : []).$concat($send(self3.docinfo_processor_extensions["$[]"](location), "map", [], function $$24(ext) {
              var self4 = $$24.$$s == null ? this : $$24.$$s;
              if (ext == null)
                ext = nil;
              return ext.$process_method()["$[]"](self4);
            }, { $$s: self3 }).$compact()).$join($$2("LF"));
          } else if ($truthy(content)) {
            return content.$join($$2("LF"));
          } else {
            return "";
          }
          ;
        }, -1);
        $def(self2, "$docinfo_processors?", function $Document_docinfo_processors$ques$25(location) {
          var $a, self3 = this;
          if (location == null)
            location = "head";
          if ($truthy(self3.docinfo_processor_extensions["$key?"](location))) {
            return self3.docinfo_processor_extensions["$[]"](location)["$!="](false);
          } else if ($truthy(self3.extensions) && $truthy(self3.document.$extensions()["$docinfo_processors?"](location))) {
            return ($a = [location, self3.document.$extensions().$docinfo_processors(location)], $send(self3.docinfo_processor_extensions, "[]=", $a), $a[$a.length - 1])["$!"]()["$!"]();
          } else {
            return $a = [location, false], $send(self3.docinfo_processor_extensions, "[]=", $a), $a[$a.length - 1];
          }
          ;
        }, -1);
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this, $ret_or_1 = nil;
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {doctype: " + self3.$doctype().$inspect() + ", doctitle: " + ($truthy($ret_or_1 = self3.header) ? self3.header.$title() : $ret_or_1).$inspect() + ", blocks: " + self3.blocks.$size() + "}>";
        });
        self2.$private();
        $def(self2, "$apply_attribute_value_subs", function $$apply_attribute_value_subs(value) {
          var $a, self3 = this;
          if ($truthy($$2("AttributeEntryPassMacroRx")["$=~"](value))) {
            value = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2);
            if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
              value = self3.$apply_subs(value, self3.$resolve_pass_subs(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)));
            }
            ;
          } else {
            value = self3.$apply_header_subs(value);
          }
          ;
          if ($truthy(self3.max_attribute_value_size)) {
            return self3.$limit_bytesize(value, self3.max_attribute_value_size);
          } else {
            return value;
          }
          ;
        });
        $def(self2, "$limit_bytesize", function $$limit_bytesize(str, max) {
          if ($truthy($rb_gt(str.$bytesize(), max))) {
            while (!$truthy((str = str.$byteslice(0, max))["$valid_encoding?"]())) {
              max = $rb_minus(max, 1);
            }
          }
          ;
          return str;
        });
        $def(self2, "$resolve_docinfo_subs", function $$resolve_docinfo_subs() {
          var self3 = this;
          if ($truthy(self3.attributes["$key?"]("docinfosubs"))) {
            return self3.$resolve_subs(self3.attributes["$[]"]("docinfosubs"), "block", nil, "docinfo");
          } else {
            return ["attributes"];
          }
        });
        $def(self2, "$create_converter", function $$create_converter(backend, delegate_backend) {
          var self3 = this, converter_opts = nil, template_dirs = nil, $ret_or_1 = nil, opts = nil, converter = nil;
          converter_opts = $hash2(["document", "htmlsyntax"], { "document": self3, "htmlsyntax": self3.attributes["$[]"]("htmlsyntax") });
          if ($truthy(template_dirs = $truthy($ret_or_1 = (opts = self3.options)["$[]"]("template_dirs")) ? $ret_or_1 : opts["$[]"]("template_dir"))) {
            converter_opts["$[]="]("template_dirs", [].concat($to_a(template_dirs)));
            converter_opts["$[]="]("template_cache", opts.$fetch("template_cache", true));
            converter_opts["$[]="]("template_engine", opts["$[]"]("template_engine"));
            converter_opts["$[]="]("template_engine_options", opts["$[]"]("template_engine_options"));
            converter_opts["$[]="]("eruby", opts["$[]"]("eruby"));
            converter_opts["$[]="]("safe", self3.safe);
            if ($truthy(delegate_backend)) {
              converter_opts["$[]="]("delegate_backend", delegate_backend);
            }
            ;
          }
          ;
          if ($truthy(converter = opts["$[]"]("converter"))) {
            return $$$($$2("Converter"), "CustomFactory").$new($hash(backend, converter)).$create(backend, converter_opts);
          } else {
            return opts.$fetch("converter_factory", $$2("Converter")).$create(backend, converter_opts);
          }
          ;
        });
        $def(self2, "$clear_playback_attributes", function $$clear_playback_attributes(attributes) {
          return attributes.$delete("attribute_entries");
        });
        $def(self2, "$save_attributes", function $$save_attributes() {
          var self3 = this, doctitle_val = nil, attrs = nil, $ret_or_1 = nil, toc_val = nil, toc_position_val = nil, toc_placement_val = nil, default_toc_position = nil, default_toc_class = nil, position = nil, icons_val = nil, basebackend = nil, syntax_hl_name = nil, syntax_hl_factory = nil, syntax_hls = nil;
          if (!($truthy((attrs = self3.attributes)["$key?"]("doctitle")) || $not(doctitle_val = self3.$doctitle()))) {
            attrs["$[]="]("doctitle", doctitle_val);
          }
          ;
          self3.id = $truthy($ret_or_1 = self3.id) ? $ret_or_1 : attrs["$[]"]("css-signature");
          if ($truthy(toc_val = $truthy(attrs.$delete("toc2")) ? "left" : attrs["$[]"]("toc"))) {
            toc_position_val = $truthy(toc_placement_val = attrs.$fetch("toc-placement", "macro")) && $neqeq(toc_placement_val, "auto") ? toc_placement_val : attrs["$[]"]("toc-position");
            if (!($truthy(toc_val["$empty?"]()) && $truthy(toc_position_val["$nil_or_empty?"]()))) {
              default_toc_position = "left";
              default_toc_class = "toc2";
              position = $truthy(toc_position_val["$nil_or_empty?"]()) ? $truthy(toc_val["$empty?"]()) ? default_toc_position : toc_val : toc_position_val;
              attrs["$[]="]("toc", "");
              attrs["$[]="]("toc-placement", "auto");
              switch (position) {
                case "left":
                case "<":
                case "&lt;":
                  attrs["$[]="]("toc-position", "left");
                  break;
                case "right":
                case ">":
                case "&gt;":
                  attrs["$[]="]("toc-position", "right");
                  break;
                case "top":
                case "^":
                  attrs["$[]="]("toc-position", "top");
                  break;
                case "bottom":
                case "v":
                  attrs["$[]="]("toc-position", "bottom");
                  break;
                case "preamble":
                case "macro":
                  attrs["$[]="]("toc-position", "content");
                  attrs["$[]="]("toc-placement", position);
                  default_toc_class = nil;
                  break;
                default:
                  attrs.$delete("toc-position");
                  default_toc_class = nil;
              }
              ;
              if ($truthy(default_toc_class)) {
                if ($truthy($ret_or_1 = attrs["$[]"]("toc-class"))) {
                  $ret_or_1;
                } else {
                  attrs["$[]="]("toc-class", default_toc_class);
                }
              }
              ;
            }
            ;
          }
          ;
          if ($truthy(icons_val = attrs["$[]"]("icons")) && $not(attrs["$key?"]("icontype"))) {
            switch (icons_val) {
              case "":
              case "font":
                break;
              default:
                attrs["$[]="]("icons", "");
                if (!$eqeq(icons_val, "image")) {
                  attrs["$[]="]("icontype", icons_val);
                }
                ;
            }
          }
          ;
          if ($truthy(self3.compat_mode = attrs["$key?"]("compat-mode")) && $truthy(attrs["$key?"]("language"))) {
            attrs["$[]="]("source-language", attrs["$[]"]("language"));
          }
          ;
          if (!$truthy(self3.parent_document)) {
            if ($eqeq(basebackend = attrs["$[]"]("basebackend"), "html")) {
              if ($truthy(syntax_hl_name = attrs["$[]"]("source-highlighter")) && $not(attrs["$[]"]("" + syntax_hl_name + "-unavailable"))) {
                if ($truthy(syntax_hl_factory = self3.options["$[]"]("syntax_highlighter_factory"))) {
                  self3.syntax_highlighter = syntax_hl_factory.$create(syntax_hl_name, self3.backend, $hash2(["document"], { "document": self3 }));
                } else if ($truthy(syntax_hls = self3.options["$[]"]("syntax_highlighters"))) {
                  self3.syntax_highlighter = $$$($$2("SyntaxHighlighter"), "DefaultFactoryProxy").$new(syntax_hls).$create(syntax_hl_name, self3.backend, $hash2(["document"], { "document": self3 }));
                } else {
                  self3.syntax_highlighter = $$2("SyntaxHighlighter").$create(syntax_hl_name, self3.backend, $hash2(["document"], { "document": self3 }));
                }
              }
            } else if ($eqeq(basebackend, "docbook")) {
              if (!($truthy(self3["$attribute_locked?"]("toc")) || $truthy(self3.attributes_modified["$include?"]("toc")))) {
                attrs["$[]="]("toc", "");
              }
              ;
              if (!($truthy(self3["$attribute_locked?"]("sectnums")) || $truthy(self3.attributes_modified["$include?"]("sectnums")))) {
                attrs["$[]="]("sectnums", "");
              }
              ;
            }
            ;
            self3.outfilesuffix = attrs["$[]"]("outfilesuffix");
            $send($$2("FLEXIBLE_ATTRIBUTES"), "each", [], function $$26(name) {
              var self4 = $$26.$$s == null ? this : $$26.$$s;
              if (self4.attribute_overrides == null)
                self4.attribute_overrides = nil;
              if (name == null)
                name = nil;
              if ($truthy(self4.attribute_overrides["$key?"](name)) && $truthy(self4.attribute_overrides["$[]"](name))) {
                return self4.attribute_overrides.$delete(name);
              } else {
                return nil;
              }
              ;
            }, { $$s: self3 });
          }
          ;
          return self3.header_attributes = attrs.$merge();
        });
        $def(self2, "$fill_datetime_attributes", function $$fill_datetime_attributes(attrs, input_mtime) {
          var $a, self3 = this, now = nil, source_date_epoch = nil, localdate = nil, $ret_or_1 = nil, localtime = nil, $ret_or_2 = nil, docdate = nil, doctime = nil;
          now = $truthy($$$("ENV")["$key?"]("SOURCE_DATE_EPOCH")) ? source_date_epoch = $$$("Time").$at(self3.$Integer($$$("ENV")["$[]"]("SOURCE_DATE_EPOCH"))).$utc() : $$$("Time").$now();
          if ($truthy(localdate = attrs["$[]"]("localdate"))) {
            if ($truthy($ret_or_1 = attrs["$[]"]("localyear"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("localyear", $eqeq(localdate.$index("-"), 4) ? localdate.$slice(0, 4) : nil);
            }
          } else {
            localdate = ($a = ["localdate", now.$strftime("%F")], $send(attrs, "[]=", $a), $a[$a.length - 1]);
            if ($truthy($ret_or_1 = attrs["$[]"]("localyear"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("localyear", now.$year().$to_s());
            }
            ;
          }
          ;
          localtime = $truthy($ret_or_1 = attrs["$[]"]("localtime")) ? $ret_or_1 : ($a = ["localtime", now.$strftime("%T " + ($eqeq(now.$utc_offset(), 0) ? "UTC" : "%z"))], $send(attrs, "[]=", $a), $a[$a.length - 1]);
          if ($truthy($ret_or_1 = attrs["$[]"]("localdatetime"))) {
            $ret_or_1;
          } else {
            attrs["$[]="]("localdatetime", "" + localdate + " " + localtime);
          }
          ;
          input_mtime = $truthy($ret_or_1 = $truthy($ret_or_2 = source_date_epoch) ? $ret_or_2 : input_mtime) ? $ret_or_1 : now;
          if ($truthy(docdate = attrs["$[]"]("docdate"))) {
            if ($truthy($ret_or_1 = attrs["$[]"]("docyear"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("docyear", $eqeq(docdate.$index("-"), 4) ? docdate.$slice(0, 4) : nil);
            }
          } else {
            docdate = ($a = ["docdate", input_mtime.$strftime("%F")], $send(attrs, "[]=", $a), $a[$a.length - 1]);
            if ($truthy($ret_or_1 = attrs["$[]"]("docyear"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("docyear", input_mtime.$year().$to_s());
            }
            ;
          }
          ;
          doctime = $truthy($ret_or_1 = attrs["$[]"]("doctime")) ? $ret_or_1 : ($a = ["doctime", input_mtime.$strftime("%T " + ($eqeq(input_mtime.$utc_offset(), 0) ? "UTC" : "%z"))], $send(attrs, "[]=", $a), $a[$a.length - 1]);
          if ($truthy($ret_or_1 = attrs["$[]"]("docdatetime"))) {
            $ret_or_1;
          } else {
            attrs["$[]="]("docdatetime", "" + docdate + " " + doctime);
          }
          ;
          return nil;
        });
        $def(self2, "$update_backend_attributes", function $$update_backend_attributes(new_backend, init) {
          var $a, $b, self3 = this, current_backend = nil, current_basebackend = nil, attrs = nil, current_doctype = nil, actual_backend = nil, _ = nil, $ret_or_1 = nil, delegate_backend = nil, converter = nil, new_basebackend = nil, new_filetype = nil, htmlsyntax = nil, backend_traits = nil, current_filetype = nil, page_width = nil;
          if (init == null)
            init = nil;
          if ($truthy(init) || $neqeq(new_backend, self3.backend)) {
            current_backend = self3.backend;
            current_basebackend = (attrs = self3.attributes)["$[]"]("basebackend");
            current_doctype = self3.doctype;
            if ($truthy(new_backend["$include?"](":"))) {
              $b = new_backend.$partition(":"), $a = $to_ary($b), actual_backend = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], new_backend = $a[2] == null ? nil : $a[2], $b;
            }
            ;
            if ($truthy(new_backend["$start_with?"]("xhtml"))) {
              attrs["$[]="]("htmlsyntax", "xml");
              new_backend = new_backend.$slice(1, new_backend.$length());
            } else if ($truthy(new_backend["$start_with?"]("html"))) {
              if ($truthy($ret_or_1 = attrs["$[]"]("htmlsyntax"))) {
                $ret_or_1;
              } else {
                attrs["$[]="]("htmlsyntax", "html");
              }
            }
            ;
            new_backend = $truthy($ret_or_1 = $$2("BACKEND_ALIASES")["$[]"](new_backend)) ? $ret_or_1 : new_backend;
            if ($truthy(actual_backend)) {
              $a = [actual_backend, new_backend], new_backend = $a[0], delegate_backend = $a[1], $a;
            }
            ;
            if ($truthy(current_doctype)) {
              if ($truthy(current_backend)) {
                attrs.$delete("backend-" + current_backend);
                attrs.$delete("backend-" + current_backend + "-doctype-" + current_doctype);
              }
              ;
              attrs["$[]="]("backend-" + new_backend + "-doctype-" + current_doctype, "");
              attrs["$[]="]("doctype-" + current_doctype, "");
            } else if ($truthy(current_backend)) {
              attrs.$delete("backend-" + current_backend);
            }
            ;
            attrs["$[]="]("backend-" + new_backend, "");
            self3.backend = ($a = ["backend", new_backend], $send(attrs, "[]=", $a), $a[$a.length - 1]);
            if ($eqeqeq($$$($$2("Converter"), "BackendTraits"), converter = self3.$create_converter(new_backend, delegate_backend))) {
              new_basebackend = converter.$basebackend();
              new_filetype = converter.$filetype();
              if ($truthy(htmlsyntax = converter.$htmlsyntax())) {
                attrs["$[]="]("htmlsyntax", htmlsyntax);
              }
              ;
              if ($truthy(init)) {
                if ($truthy($ret_or_1 = attrs["$[]"]("outfilesuffix"))) {
                  $ret_or_1;
                } else {
                  attrs["$[]="]("outfilesuffix", converter.$outfilesuffix());
                }
              } else if (!$truthy(self3["$attribute_locked?"]("outfilesuffix"))) {
                attrs["$[]="]("outfilesuffix", converter.$outfilesuffix());
              }
              ;
            } else if ($truthy(converter)) {
              backend_traits = $$2("Converter").$derive_backend_traits(new_backend);
              new_basebackend = backend_traits["$[]"]("basebackend");
              new_filetype = backend_traits["$[]"]("filetype");
              if ($truthy(init)) {
                if ($truthy($ret_or_1 = attrs["$[]"]("outfilesuffix"))) {
                  $ret_or_1;
                } else {
                  attrs["$[]="]("outfilesuffix", backend_traits["$[]"]("outfilesuffix"));
                }
              } else if (!$truthy(self3["$attribute_locked?"]("outfilesuffix"))) {
                attrs["$[]="]("outfilesuffix", backend_traits["$[]"]("outfilesuffix"));
              }
              ;
            } else {
              self3.$raise($$$("NotImplementedError"), "asciidoctor: FAILED: missing converter for backend '" + new_backend + "'. Processing aborted.");
            }
            ;
            self3.converter = converter;
            if ($truthy(current_filetype = attrs["$[]"]("filetype"))) {
              attrs.$delete("filetype-" + current_filetype);
            }
            ;
            attrs["$[]="]("filetype", new_filetype);
            attrs["$[]="]("filetype-" + new_filetype, "");
            if ($truthy(page_width = $$2("DEFAULT_PAGE_WIDTHS")["$[]"](new_basebackend))) {
              attrs["$[]="]("pagewidth", page_width);
            } else {
              attrs.$delete("pagewidth");
            }
            ;
            if ($neqeq(new_basebackend, current_basebackend)) {
              if ($truthy(current_doctype)) {
                if ($truthy(current_basebackend)) {
                  attrs.$delete("basebackend-" + current_basebackend);
                  attrs.$delete("basebackend-" + current_basebackend + "-doctype-" + current_doctype);
                }
                ;
                attrs["$[]="]("basebackend-" + new_basebackend + "-doctype-" + current_doctype, "");
              } else if ($truthy(current_basebackend)) {
                attrs.$delete("basebackend-" + current_basebackend);
              }
              ;
              attrs["$[]="]("basebackend-" + new_basebackend, "");
              attrs["$[]="]("basebackend", new_basebackend);
            }
            ;
            return new_backend;
          } else {
            return nil;
          }
          ;
        }, -2);
        return $def(self2, "$update_doctype_attributes", function $$update_doctype_attributes(new_doctype) {
          var $a, self3 = this, attrs = nil, current_backend = nil, current_basebackend = nil, current_doctype = nil;
          if ($truthy(new_doctype) && $neqeq(new_doctype, self3.doctype)) {
            $a = [self3.backend, (attrs = self3.attributes)["$[]"]("basebackend"), self3.doctype], current_backend = $a[0], current_basebackend = $a[1], current_doctype = $a[2], $a;
            if ($truthy(current_doctype)) {
              attrs.$delete("doctype-" + current_doctype);
              if ($truthy(current_backend)) {
                attrs.$delete("backend-" + current_backend + "-doctype-" + current_doctype);
                attrs["$[]="]("backend-" + current_backend + "-doctype-" + new_doctype, "");
              }
              ;
              if ($truthy(current_basebackend)) {
                attrs.$delete("basebackend-" + current_basebackend + "-doctype-" + current_doctype);
                attrs["$[]="]("basebackend-" + current_basebackend + "-doctype-" + new_doctype, "");
              }
              ;
            } else {
              if ($truthy(current_backend)) {
                attrs["$[]="]("backend-" + current_backend + "-doctype-" + new_doctype, "");
              }
              ;
              if ($truthy(current_basebackend)) {
                attrs["$[]="]("basebackend-" + current_basebackend + "-doctype-" + new_doctype, "");
              }
              ;
            }
            ;
            attrs["$[]="]("doctype-" + new_doctype, "");
            return self3.doctype = ($a = ["doctype", new_doctype], $send(attrs, "[]=", $a), $a[$a.length - 1]);
          } else {
            return nil;
          }
        });
      }($nesting2[0], $$("AbstractBlock"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/inline"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $def = Opal2.def, $return_val = Opal2.return_val, $alias = Opal2.alias, $truthy = Opal2.truthy, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("attr_accessor,attr_reader,[],convert,converter,attr,==,apply_reftext_subs,reftext");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "Inline");
        var $proto = self2.$$prototype;
        $proto.text = $proto.type = nil;
        self2.$attr_accessor("text");
        self2.$attr_reader("type");
        self2.$attr_accessor("target");
        $def(self2, "$initialize", function $$initialize(parent, context, text, opts) {
          var $yield = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          if (text == null)
            text = nil;
          if (opts == null)
            opts = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, context, opts], null);
          self3.node_name = "inline_" + context;
          self3.text = text;
          self3.id = opts["$[]"]("id");
          self3.type = opts["$[]"]("type");
          return self3.target = opts["$[]"]("target");
        }, -3);
        $def(self2, "$block?", $return_val(false));
        $def(self2, "$inline?", $return_val(true));
        $def(self2, "$convert", function $$convert() {
          var self3 = this;
          return self3.$converter().$convert(self3);
        });
        $alias(self2, "render", "convert");
        $def(self2, "$alt", function $$alt() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.$attr("alt"))) {
            return $ret_or_1;
          } else {
            return "";
          }
        });
        $def(self2, "$reftext?", function $Inline_reftext$ques$1() {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($truthy($ret_or_1 = self3.text)) {
            if ($truthy($ret_or_2 = self3.type["$=="]("ref"))) {
              return $ret_or_2;
            } else {
              return self3.type["$=="]("bibref");
            }
            ;
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$reftext", function $$reftext() {
          var self3 = this, val = nil;
          if ($truthy(val = self3.text)) {
            return self3.$apply_reftext_subs(val);
          } else {
            return nil;
          }
        });
        return $def(self2, "$xreftext", function $$xreftext(xrefstyle) {
          var self3 = this;
          if (xrefstyle == null)
            xrefstyle = nil;
          return self3.$reftext();
        }, -1);
      }($nesting2[0], $$("AbstractNode"));
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/list"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $alias = Opal2.alias, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $def = Opal2.def, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("blocks,blocks?,==,next_list,callouts,convert,class,object_id,inspect,size,items,parent,attr_accessor,level,drop,nil_or_empty?,apply_subs,attr_writer,empty?,===,[],outline?,!,simple?,source,shift,context");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      (function($base2, $super) {
        var self2 = $klass($base2, $super, "List");
        var $proto = self2.$$prototype;
        $proto.context = $proto.document = $proto.style = nil;
        $alias(self2, "items", "blocks");
        $alias(self2, "content", "blocks");
        $alias(self2, "items?", "blocks?");
        $def(self2, "$initialize", function $$initialize(parent, context, opts) {
          var $yield = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          if (opts == null)
            opts = $hash2([], {});
          return $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, context, opts], $yield);
        }, -3);
        $def(self2, "$outline?", function $List_outline$ques$1() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.context["$=="]("ulist"))) {
            return $ret_or_1;
          } else {
            return self3.context["$=="]("olist");
          }
        });
        $def(self2, "$convert", function $$convert() {
          var $yield = $$convert.$$p || nil, self3 = this, result = nil;
          $$convert.$$p = null;
          if ($eqeq(self3.context, "colist")) {
            result = $send2(self3, $find_super(self3, "convert", $$convert, false, true), "convert", [], $yield);
            self3.document.$callouts().$next_list();
            return result;
          } else {
            return $send2(self3, $find_super(self3, "convert", $$convert, false, true), "convert", [], $yield);
          }
        });
        $alias(self2, "render", "convert");
        return $def(self2, "$to_s", function $$to_s() {
          var self3 = this;
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {context: " + self3.context.$inspect() + ", style: " + self3.style.$inspect() + ", items: " + self3.$items().$size() + "}>";
        });
      })($nesting2[0], $$("AbstractBlock"));
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "ListItem");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.text = $proto.subs = $proto.blocks = nil;
        $alias(self2, "list", "parent");
        self2.$attr_accessor("marker");
        $def(self2, "$initialize", function $$initialize(parent, text) {
          var $yield = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          if (text == null)
            text = nil;
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, "list_item"], null);
          self3.text = text;
          self3.level = parent.$level();
          return self3.subs = $$2("NORMAL_SUBS").$drop(0);
        }, -2);
        $def(self2, "$text?", function $ListItem_text$ques$2() {
          var self3 = this;
          if ($truthy(self3.text["$nil_or_empty?"]())) {
            return false;
          } else {
            return true;
          }
        });
        $def(self2, "$text", function $$text() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.text)) {
            return self3.$apply_subs(self3.text, self3.subs);
          } else {
            return $ret_or_1;
          }
        });
        self2.$attr_writer("text");
        $def(self2, "$simple?", function $ListItem_simple$ques$3() {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, blk = nil;
          if ($truthy($ret_or_1 = self3.blocks["$empty?"]())) {
            return $ret_or_1;
          } else {
            if ($truthy($ret_or_2 = $truthy($ret_or_3 = self3.blocks.$size()["$=="](1)) ? $$2("List")["$==="](blk = self3.blocks["$[]"](0)) : $ret_or_3)) {
              return blk["$outline?"]();
            } else {
              return $ret_or_2;
            }
            ;
          }
        });
        $def(self2, "$compound?", function $ListItem_compound$ques$4() {
          var self3 = this;
          return self3["$simple?"]()["$!"]();
        });
        $def(self2, "$fold_first", function $$fold_first() {
          var self3 = this;
          self3.text = $truthy(self3.text["$nil_or_empty?"]()) ? self3.blocks.$shift().$source() : "" + self3.text + $$2("LF") + self3.blocks.$shift().$source();
          return nil;
        });
        return $def(self2, "$to_s", function $$to_s() {
          var self3 = this, $ret_or_1 = nil;
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {list_context: " + self3.$parent().$context().$inspect() + ", text: " + self3.text.$inspect() + ", blocks: " + ($truthy($ret_or_1 = self3.blocks) ? $ret_or_1 : []).$size() + "}>";
        });
      }($nesting2[0], $$("AbstractBlock"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/parser"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $send = Opal2.send, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $to_ary = Opal2.to_ary, $defs = Opal2.defs, $eqeq = Opal2.eqeq, $not = Opal2.not, $gvars = Opal2.gvars, $neqeq = Opal2.neqeq, $rb_plus = Opal2.rb_plus, $rb_lt = Opal2.rb_lt, $rb_gt = Opal2.rb_gt, $to_a = Opal2.to_a, $eqeqeq = Opal2.eqeqeq, $rb_minus = Opal2.rb_minus, $rb_times = Opal2.rb_times, $thrower = Opal2.thrower, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("include,new,proc,start_with?,match?,is_delimited_block?,private_class_method,parse_document_header,[],has_more_lines?,next_section,assign_numeral,<<,blocks,skip_blank_lines,parse_block_metadata_lines,attributes,is_next_line_doctitle?,[]=,finalize_header,nil_or_empty?,title=,sourcemap,cursor,parse_section_title,id=,include?,sub_specialchars,sub_attributes,source_location=,header,attribute_locked?,id,clear,delete,instance_variable_get,parse_header_metadata,==,!,register,process_authors,update,doctype,parse_manpage_header,=~,downcase,error,logger,message_with_context,cursor_at_line,backend,save,is_next_line_section?,initialize_section,join,map,read_lines_until,lstrip,split,title,restore_save,discard_save,header?,empty?,context,!=,attr?,attr,key?,document,+,level,special,sectname,to_i,<,>,warn,next_block,blocks?,style,style=,parent=,content_model,content_model=,lines,subs,size,context=,shift,unwrap_standalone_preamble,source_location,merge,fetch,parse_block_metadata_line,extensions,block_macros?,mark,read_line,terminator,to_s,masq,to_sym,registered_for_block?,debug?,debug,cursor_at_mark,strict_verbatim_paragraphs,unshift_line,markdown_syntax,keys,chr,uniform?,length,end_with?,parse_attributes,attribute_missing,tr,basename,assign_caption,registered_for_block_macro?,config,process_method,replace,parse_callout_list,callouts,===,parse_list,parse_description_list,underline_style_section_titles,is_section_title?,peek_line,atx_section_title?,generate_id,level=,read_paragraph_lines,adjust_indentation!,map!,slice,pop,build_block,apply_subs,chop,catalog_inline_anchors,rekey,index,strip,-,parse_table,each,raise,title?,update_attributes,commit_subs,sub?,catalog_callouts,source,remove_sub,block_terminates_paragraph,to_proc,nil?,parse_blocks,parse_list_item,items,scan,gsub,count,advance,dup,match,callout_ids,next_list,catalog_inline_anchor,marker=,catalog_inline_biblio_anchor,set_option,text=,resolve_ordered_list_marker,read_lines_for_list_item,skip_line_comments,unshift_lines,fold_first,text?,is_sibling_list_item?,concat,find,casecmp,sectname=,special=,numbered=,numbered,lineno,peek_lines,setext_section_title?,abs,cursor_at_prev_line,process_attribute_entries,next_line_empty?,apply_header_subs,rstrip,each_with_index,compact,to_h,squeeze,to_a,parse_style_attribute,process_attribute_entry,skip_comment_lines,store_attribute,sanitize_attribute_name,set_attribute,save_to,delete_attribute,ord,int_to_roman,resolve_list_marker,parse_colspecs,create_columns,has_header_option=,format,starts_with_delimiter?,close_open_cell,parse_cellspec,delimiter,match_delimiter,pre_match,post_match,buffer_has_unclosed_quotes?,skip_past_delimiter,buffer=,buffer,skip_past_escaped_delimiter,keep_cell_open,push_cellspec,close_cell,cell_open?,columns,assign_column_widths,partition_header_footer,upto,partition,shorthand_property_syntax,each_char,yield_buffered_attribute,any?,*,each_byte,%");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Parser");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self2.$include($$("Logging"));
        $const_set($nesting3[0], "BlockMatchData", $$("Struct").$new("context", "masq", "tip", "terminator"));
        $const_set($nesting3[0], "TAB", "	");
        $const_set($nesting3[0], "TabIndentRx", /^\t+/);
        $const_set($nesting3[0], "StartOfBlockProc", $send(self2, "proc", [], function $Parser$1(l) {
          var self3 = $Parser$1.$$s == null ? this : $Parser$1.$$s, $ret_or_1 = nil, $ret_or_2 = nil;
          if (l == null)
            l = nil;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = l["$start_with?"]("[")) ? $$("BlockAttributeLineRx")["$match?"](l) : $ret_or_2)) {
            return $ret_or_1;
          } else {
            return self3["$is_delimited_block?"](l);
          }
          ;
        }, { $$s: self2 }));
        $const_set($nesting3[0], "StartOfListProc", $send(self2, "proc", [], function $Parser$2(l) {
          if (l == null)
            l = nil;
          return $$("AnyListRx")["$match?"](l);
        }));
        $const_set($nesting3[0], "StartOfBlockOrListProc", $send(self2, "proc", [], function $Parser$3(l) {
          var self3 = $Parser$3.$$s == null ? this : $Parser$3.$$s, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;
          if (l == null)
            l = nil;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = self3["$is_delimited_block?"](l)) ? $ret_or_2 : $truthy($ret_or_3 = l["$start_with?"]("[")) ? $$("BlockAttributeLineRx")["$match?"](l) : $ret_or_3)) {
            return $ret_or_1;
          } else {
            return $$("AnyListRx")["$match?"](l);
          }
          ;
        }, { $$s: self2 }));
        $const_set($nesting3[0], "NoOp", nil);
        $const_set($nesting3[0], "AuthorKeys", ["author", "authorinitials", "firstname", "middlename", "lastname", "email"]);
        $const_set($nesting3[0], "TableCellHorzAlignments", $hash2(["<", ">", "^"], { "<": "left", ">": "right", "^": "center" }));
        $const_set($nesting3[0], "TableCellVertAlignments", $hash2(["<", ">", "^"], { "<": "top", ">": "bottom", "^": "middle" }));
        $const_set($nesting3[0], "TableCellStyles", $hash2(["d", "s", "e", "m", "h", "l", "a"], { "d": "none", "s": "strong", "e": "emphasis", "m": "monospaced", "h": "header", "l": "literal", "a": "asciidoc" }));
        self2.$private_class_method("new");
        $defs(self2, "$parse", function $$parse(reader, document2, options) {
          var $a, $b, self3 = this, block_attributes = nil, header_only = nil, new_section = nil;
          if (options == null)
            options = $hash2([], {});
          block_attributes = self3.$parse_document_header(reader, document2, header_only = options["$[]"]("header_only"));
          if (!$truthy(header_only)) {
            while ($truthy(reader["$has_more_lines?"]())) {
              $b = self3.$next_section(reader, document2, block_attributes), $a = $to_ary($b), new_section = $a[0] == null ? nil : $a[0], block_attributes = $a[1] == null ? nil : $a[1], $b;
              if ($truthy(new_section)) {
                document2.$assign_numeral(new_section);
                document2.$blocks()["$<<"](new_section);
              }
              ;
            }
          }
          ;
          return document2;
        }, -3);
        $defs(self2, "$parse_document_header", function $$parse_document_header(reader, document2, header_only) {
          var $a, $b, $c, self3 = this, block_attrs = nil, doc_attrs = nil, implicit_doctitle = nil, val = nil, doctitle_attr_val = nil, source_location = nil, _ = nil, l0_section_title = nil, atx = nil, separator = nil, doc_id = nil, role = nil, reftext = nil, modified_attrs = nil, author = nil, author_metadata = nil;
          if (header_only == null)
            header_only = false;
          block_attrs = $truthy(reader.$skip_blank_lines()) ? self3.$parse_block_metadata_lines(reader, document2) : $hash2([], {});
          doc_attrs = document2.$attributes();
          if ($truthy(implicit_doctitle = self3["$is_next_line_doctitle?"](reader, block_attrs, doc_attrs["$[]"]("leveloffset"))) && $truthy(block_attrs["$[]"]("title"))) {
            doc_attrs["$[]="]("authorcount", 0);
            return document2.$finalize_header(block_attrs, false);
          }
          ;
          if (!$truthy((val = doc_attrs["$[]"]("doctitle"))["$nil_or_empty?"]())) {
            document2["$title="](doctitle_attr_val = val);
          }
          ;
          if ($truthy(implicit_doctitle)) {
            if ($truthy(document2.$sourcemap())) {
              source_location = reader.$cursor();
            }
            ;
            $b = self3.$parse_section_title(reader, document2), $a = $to_ary($b), $c = [$a[0] == null ? nil : $a[0]], $send(document2, "id=", $c), $c[$c.length - 1], _ = $a[1] == null ? nil : $a[1], l0_section_title = $a[2] == null ? nil : $a[2], _ = $a[3] == null ? nil : $a[3], atx = $a[4] == null ? nil : $a[4], $b;
            if ($truthy(doctitle_attr_val)) {
              l0_section_title = nil;
            } else {
              document2["$title="](l0_section_title);
              if ($truthy(($a = ["doctitle", doctitle_attr_val = document2.$sub_specialchars(l0_section_title)], $send(doc_attrs, "[]=", $a), $a[$a.length - 1])["$include?"]($$("ATTR_REF_HEAD")))) {
                doc_attrs["$[]="]("doctitle", doctitle_attr_val = document2.$sub_attributes(doctitle_attr_val, $hash2(["attribute_missing"], { "attribute_missing": "skip" })));
              }
              ;
            }
            ;
            if ($truthy(source_location)) {
              document2.$header()["$source_location="](source_location);
            }
            ;
            if (!($truthy(atx) || $truthy(document2["$attribute_locked?"]("compat-mode")))) {
              doc_attrs["$[]="]("compat-mode", "");
            }
            ;
            if ($truthy(separator = block_attrs["$[]"]("separator"))) {
              if (!$truthy(document2["$attribute_locked?"]("title-separator"))) {
                doc_attrs["$[]="]("title-separator", separator);
              }
            }
            ;
            if ($truthy(doc_id = block_attrs["$[]"]("id"))) {
              document2["$id="](doc_id);
            } else {
              doc_id = document2.$id();
            }
            ;
            if ($truthy(role = block_attrs["$[]"]("role"))) {
              doc_attrs["$[]="]("role", role);
            }
            ;
            if ($truthy(reftext = block_attrs["$[]"]("reftext"))) {
              doc_attrs["$[]="]("reftext", reftext);
            }
            ;
            block_attrs.$clear();
            (modified_attrs = document2.$instance_variable_get("@attributes_modified")).$delete("doctitle");
            self3.$parse_header_metadata(reader, document2, nil);
            if ($truthy(modified_attrs["$include?"]("doctitle"))) {
              if ($truthy((val = doc_attrs["$[]"]("doctitle"))["$nil_or_empty?"]()) || $eqeq(val, doctitle_attr_val)) {
                doc_attrs["$[]="]("doctitle", doctitle_attr_val);
              } else {
                document2["$title="](val);
              }
            } else if ($not(l0_section_title)) {
              modified_attrs["$<<"]("doctitle");
            }
            ;
            if ($truthy(doc_id)) {
              document2.$register("refs", [doc_id, document2]);
            }
            ;
          } else if ($truthy(author = doc_attrs["$[]"]("author"))) {
            author_metadata = self3.$process_authors(author, true, false);
            if ($truthy(doc_attrs["$[]"]("authorinitials"))) {
              author_metadata.$delete("authorinitials");
            }
            ;
            doc_attrs.$update(author_metadata);
          } else if ($truthy(author = doc_attrs["$[]"]("authors"))) {
            author_metadata = self3.$process_authors(author, true);
            doc_attrs.$update(author_metadata);
          } else {
            doc_attrs["$[]="]("authorcount", 0);
          }
          ;
          if ($eqeq(document2.$doctype(), "manpage")) {
            self3.$parse_manpage_header(reader, document2, block_attrs, header_only);
          }
          ;
          return document2.$finalize_header(block_attrs);
        }, -3);
        $defs(self2, "$parse_manpage_header", function $$parse_manpage_header(reader, document2, block_attributes, header_only) {
          var $a, self3 = this, doc_attrs = nil, manvolnum = nil, mantitle = nil, $ret_or_1 = nil, $ret_or_2 = nil, manname = nil, name_section_level = nil, name_section = nil, name_section_buffer = nil, mannames = nil, manpurpose = nil, error_msg = nil;
          if (header_only == null)
            header_only = false;
          if ($truthy($$("ManpageTitleVolnumRx")["$=~"]((doc_attrs = document2.$attributes())["$[]"]("doctitle")))) {
            doc_attrs["$[]="]("manvolnum", manvolnum = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2));
            doc_attrs["$[]="]("mantitle", ($truthy((mantitle = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))["$include?"]($$("ATTR_REF_HEAD"))) ? document2.$sub_attributes(mantitle) : mantitle).$downcase());
          } else {
            self3.$logger().$error(self3.$message_with_context("non-conforming manpage title", $hash2(["source_location"], { "source_location": reader.$cursor_at_line(1) })));
            doc_attrs["$[]="]("mantitle", $truthy($ret_or_1 = $truthy($ret_or_2 = doc_attrs["$[]"]("doctitle")) ? $ret_or_2 : doc_attrs["$[]"]("docname")) ? $ret_or_1 : "command");
            doc_attrs["$[]="]("manvolnum", manvolnum = "1");
          }
          ;
          if ($truthy(manname = doc_attrs["$[]"]("manname")) && $truthy(doc_attrs["$[]"]("manpurpose"))) {
            if ($truthy($ret_or_1 = doc_attrs["$[]"]("manname-title"))) {
              $ret_or_1;
            } else {
              doc_attrs["$[]="]("manname-title", "Name");
            }
            ;
            doc_attrs["$[]="]("mannames", [manname]);
            if ($eqeq(document2.$backend(), "manpage")) {
              doc_attrs["$[]="]("docname", manname);
              doc_attrs["$[]="]("outfilesuffix", "." + manvolnum);
            }
            ;
          } else if (!$truthy(header_only)) {
            reader.$skip_blank_lines();
            reader.$save();
            block_attributes.$update(self3.$parse_block_metadata_lines(reader, document2));
            if ($truthy(name_section_level = self3["$is_next_line_section?"](reader, $hash2([], {})))) {
              if ($eqeq(name_section_level, 1)) {
                name_section = self3.$initialize_section(reader, document2, $hash2([], {}));
                name_section_buffer = $send(reader.$read_lines_until($hash2(["break_on_blank_lines", "skip_line_comments"], { "break_on_blank_lines": true, "skip_line_comments": true })), "map", [], function $$4(l) {
                  if (l == null)
                    l = nil;
                  return l.$lstrip();
                }).$join(" ");
                if ($truthy($$("ManpageNamePurposeRx")["$=~"](name_section_buffer))) {
                  if ($truthy((manname = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))["$include?"]($$("ATTR_REF_HEAD")))) {
                    manname = document2.$sub_attributes(manname);
                  }
                  ;
                  if ($truthy(manname["$include?"](","))) {
                    manname = (mannames = $send(manname.$split(","), "map", [], function $$5(n) {
                      if (n == null)
                        n = nil;
                      return n.$lstrip();
                    }))["$[]"](0);
                  } else {
                    mannames = [manname];
                  }
                  ;
                  if ($truthy((manpurpose = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))["$include?"]($$("ATTR_REF_HEAD")))) {
                    manpurpose = document2.$sub_attributes(manpurpose);
                  }
                  ;
                  if ($truthy($ret_or_1 = doc_attrs["$[]"]("manname-title"))) {
                    $ret_or_1;
                  } else {
                    doc_attrs["$[]="]("manname-title", name_section.$title());
                  }
                  ;
                  if ($truthy(name_section.$id())) {
                    doc_attrs["$[]="]("manname-id", name_section.$id());
                  }
                  ;
                  doc_attrs["$[]="]("manname", manname);
                  doc_attrs["$[]="]("mannames", mannames);
                  doc_attrs["$[]="]("manpurpose", manpurpose);
                  if ($eqeq(document2.$backend(), "manpage")) {
                    doc_attrs["$[]="]("docname", manname);
                    doc_attrs["$[]="]("outfilesuffix", "." + manvolnum);
                  }
                  ;
                } else {
                  error_msg = "non-conforming name section body";
                }
                ;
              } else {
                error_msg = "name section must be at level 1";
              }
            } else {
              error_msg = "name section expected";
            }
            ;
            if ($truthy(error_msg)) {
              reader.$restore_save();
              self3.$logger().$error(self3.$message_with_context(error_msg, $hash2(["source_location"], { "source_location": reader.$cursor() })));
              doc_attrs["$[]="]("manname", manname = $truthy($ret_or_1 = doc_attrs["$[]"]("docname")) ? $ret_or_1 : "command");
              doc_attrs["$[]="]("mannames", [manname]);
              if ($eqeq(document2.$backend(), "manpage")) {
                doc_attrs["$[]="]("docname", manname);
                doc_attrs["$[]="]("outfilesuffix", "." + manvolnum);
              }
              ;
            } else {
              reader.$discard_save();
            }
            ;
          }
          ;
          return nil;
        }, -4);
        $defs(self2, "$next_section", function $$next_section(reader, parent, attributes) {
          var $a, $b, self3 = this, preamble = nil, intro = nil, part = nil, has_header = nil, book = nil, document2 = nil, section = nil, current_level = nil, expected_next_level = nil, expected_next_level_alt = nil, title = nil, sectname = nil, next_level = nil, expected_condition = nil, new_section = nil, block_cursor = nil, new_block = nil, $ret_or_1 = nil, first_block = nil, child_block = nil;
          if (attributes == null)
            attributes = $hash2([], {});
          preamble = intro = part = false;
          if ($eqeq(parent.$context(), "document") && $truthy(parent.$blocks()["$empty?"]()) && ($truthy(has_header = parent["$header?"]()) || $truthy(attributes.$delete("invalid-header")) || $not(self3["$is_next_line_section?"](reader, attributes)))) {
            book = (document2 = parent).$doctype()["$=="]("book");
            if ($truthy(has_header) || $truthy(book) && $neqeq(attributes["$[]"](1), "abstract")) {
              preamble = intro = $$("Block").$new(parent, "preamble", $hash2(["content_model"], { "content_model": "compound" }));
              if ($truthy(book) && $truthy(parent["$attr?"]("preface-title"))) {
                preamble["$title="](parent.$attr("preface-title"));
              }
              ;
              parent.$blocks()["$<<"](preamble);
            }
            ;
            section = parent;
            current_level = 0;
            if ($truthy(parent.$attributes()["$key?"]("fragment"))) {
              expected_next_level = -1;
            } else if ($truthy(book)) {
              $a = [1, 0], expected_next_level = $a[0], expected_next_level_alt = $a[1], $a;
            } else {
              expected_next_level = 1;
            }
            ;
          } else {
            book = (document2 = parent.$document()).$doctype()["$=="]("book");
            section = self3.$initialize_section(reader, parent, attributes);
            attributes = $truthy(title = attributes["$[]"]("title")) ? $hash2(["title"], { "title": title }) : $hash2([], {});
            expected_next_level = $rb_plus(current_level = section.$level(), 1);
            if ($eqeq(current_level, 0)) {
              part = book;
            } else if ($eqeq(current_level, 1) && $truthy(section.$special())) {
              if (!($eqeq(sectname = section.$sectname(), "appendix") || $eqeq(sectname, "preface") || $eqeq(sectname, "abstract"))) {
                expected_next_level = nil;
              }
            }
            ;
          }
          ;
          reader.$skip_blank_lines();
          while ($truthy(reader["$has_more_lines?"]())) {
            self3.$parse_block_metadata_lines(reader, document2, attributes);
            if ($truthy(next_level = self3["$is_next_line_section?"](reader, attributes))) {
              if ($truthy(document2["$attr?"]("leveloffset"))) {
                next_level = $rb_plus(next_level, document2.$attr("leveloffset").$to_i());
                if ($truthy($rb_lt(next_level, 0))) {
                  next_level = 0;
                }
                ;
              }
              ;
              if ($truthy($rb_gt(next_level, current_level))) {
                if ($truthy(expected_next_level)) {
                  if (!($eqeq(next_level, expected_next_level) || $truthy(expected_next_level_alt) && $eqeq(next_level, expected_next_level_alt) || $truthy($rb_lt(expected_next_level, 0)))) {
                    expected_condition = $truthy(expected_next_level_alt) ? "expected levels " + expected_next_level_alt + " or " + expected_next_level : "expected level " + expected_next_level;
                    self3.$logger().$warn(self3.$message_with_context("section title out of sequence: " + expected_condition + ", got level " + next_level, $hash2(["source_location"], { "source_location": reader.$cursor() })));
                  }
                } else {
                  self3.$logger().$error(self3.$message_with_context("" + sectname + " sections do not support nested sections", $hash2(["source_location"], { "source_location": reader.$cursor() })));
                }
                ;
                $b = self3.$next_section(reader, section, attributes), $a = $to_ary($b), new_section = $a[0] == null ? nil : $a[0], attributes = $a[1] == null ? nil : $a[1], $b;
                section.$assign_numeral(new_section);
                section.$blocks()["$<<"](new_section);
              } else if ($eqeq(next_level, 0) && $eqeq(section, document2)) {
                if (!$truthy(book)) {
                  self3.$logger().$error(self3.$message_with_context("level 0 sections can only be used when doctype is book", $hash2(["source_location"], { "source_location": reader.$cursor() })));
                }
                ;
                $b = self3.$next_section(reader, section, attributes), $a = $to_ary($b), new_section = $a[0] == null ? nil : $a[0], attributes = $a[1] == null ? nil : $a[1], $b;
                section.$assign_numeral(new_section);
                section.$blocks()["$<<"](new_section);
              } else {
                break;
              }
              ;
            } else {
              block_cursor = reader.$cursor();
              if ($truthy(new_block = self3.$next_block(reader, $truthy($ret_or_1 = intro) ? $ret_or_1 : section, attributes, $hash2(["parse_metadata"], { "parse_metadata": false })))) {
                if ($truthy(part)) {
                  if ($not(section["$blocks?"]())) {
                    if ($neqeq(new_block.$style(), "partintro")) {
                      if ($eqeq(new_block.$style(), "open") && $eqeq(new_block.$context(), "open")) {
                        new_block["$style="]("partintro");
                      } else {
                        new_block["$parent="](intro = $$("Block").$new(section, "open", $hash2(["content_model"], { "content_model": "compound" })));
                        intro["$style="]("partintro");
                        section.$blocks()["$<<"](intro);
                      }
                    } else if ($eqeq(new_block.$content_model(), "simple")) {
                      new_block["$content_model="]("compound");
                      new_block["$<<"]($$("Block").$new(new_block, "paragraph", $hash2(["source", "subs"], { "source": new_block.$lines(), "subs": new_block.$subs() })));
                      new_block.$lines().$clear();
                      new_block.$subs().$clear();
                    }
                  } else if ($eqeq(section.$blocks().$size(), 1)) {
                    first_block = section.$blocks()["$[]"](0);
                    if ($not(intro) && $eqeq(first_block.$content_model(), "compound")) {
                      self3.$logger().$error(self3.$message_with_context("illegal block content outside of partintro block", $hash2(["source_location"], { "source_location": block_cursor })));
                    } else if ($neqeq(first_block.$content_model(), "compound")) {
                      new_block["$parent="](intro = $$("Block").$new(section, "open", $hash2(["content_model"], { "content_model": "compound" })));
                      if ($eqeq(first_block.$style(), ($a = ["partintro"], $send(intro, "style=", $a), $a[$a.length - 1]))) {
                        first_block["$context="]("paragraph");
                        first_block["$style="](nil);
                      }
                      ;
                      section.$blocks().$shift();
                      intro["$<<"](first_block);
                      section.$blocks()["$<<"](intro);
                    }
                    ;
                  }
                }
                ;
                ($truthy($ret_or_1 = intro) ? $ret_or_1 : section).$blocks()["$<<"](new_block);
                attributes.$clear();
              }
              ;
            }
            ;
            if ($truthy($ret_or_1 = reader.$skip_blank_lines())) {
              $ret_or_1;
            } else {
              break;
            }
            ;
          }
          ;
          if ($truthy(part)) {
            if (!($truthy(section["$blocks?"]()) && $eqeq(section.$blocks()["$[]"](-1).$context(), "section"))) {
              self3.$logger().$error(self3.$message_with_context("invalid part, must have at least one section (e.g., chapter, appendix, etc.)", $hash2(["source_location"], { "source_location": reader.$cursor() })));
            }
          } else if ($truthy(preamble)) {
            if ($truthy(preamble["$blocks?"]())) {
              if ($truthy(book) || $truthy(document2.$blocks()["$[]"](1)) || $not($$("Compliance").$unwrap_standalone_preamble())) {
                if ($truthy(document2.$sourcemap())) {
                  preamble["$source_location="](preamble.$blocks()["$[]"](0).$source_location());
                }
              } else {
                document2.$blocks().$shift();
                while ($truthy(child_block = preamble.$blocks().$shift())) {
                  document2["$<<"](child_block);
                }
                ;
              }
            } else {
              document2.$blocks().$shift();
            }
          }
          ;
          return [$eqeq(section, parent) ? nil : section, attributes.$merge()];
        }, -3);
        $defs(self2, "$next_block", function $$next_block(reader, parent, attributes, options) {
          var $a, $b, self3 = this, skipped = nil, text_only = nil, document2 = nil, $ret_or_1 = nil, extensions = nil, block_extensions = nil, block_macro_extensions = nil, this_line = nil, doc_attrs = nil, style = nil, block = nil, block_context = nil, cloaked_context = nil, terminator = nil, delimited_block = nil, indented = nil, md_syntax = nil, ch0 = nil, layout_break_chars = nil, ll = nil, blk_ctx = nil, target = nil, blk_attrs = nil, posattrs = nil, expanded_target = nil, $ret_or_2 = nil, scaledwidth = nil, block_title = nil, extension = nil, report_unknown_block_macro = nil, content = nil, ext_config = nil, default_attrs = nil, float_id = nil, float_reftext = nil, float_level = nil, lines = nil, content_adjacent = nil, admonition_name = nil, credit_line = nil, attribution = nil, citetitle = nil, language2 = nil, comma_idx = nil, block_cursor = nil, block_reader = nil, content_model = nil, positional_attrs = nil, block_id = nil;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          if (attributes == null)
            attributes = $hash2([], {});
          if (options == null)
            options = $hash2([], {});
          if (!$truthy(skipped = reader.$skip_blank_lines())) {
            return nil;
          }
          ;
          if ($truthy(text_only = options["$[]"]("text_only")) && $truthy($rb_gt(skipped, 0))) {
            options.$delete("text_only");
            text_only = nil;
          }
          ;
          document2 = parent.$document();
          if ($truthy(options.$fetch("parse_metadata", true))) {
            while ($truthy(self3.$parse_block_metadata_line(reader, document2, attributes, options))) {
              reader.$shift();
              if ($truthy($ret_or_1 = reader.$skip_blank_lines())) {
                $ret_or_1;
              } else {
                return nil;
              }
              ;
            }
          }
          ;
          if ($truthy(extensions = document2.$extensions())) {
            $a = [extensions["$blocks?"](), extensions["$block_macros?"]()], block_extensions = $a[0], block_macro_extensions = $a[1], $a;
          }
          ;
          reader.$mark();
          $a = [reader.$read_line(), document2.$attributes(), attributes["$[]"](1)], this_line = $a[0], doc_attrs = $a[1], style = $a[2], $a;
          block = block_context = cloaked_context = terminator = nil;
          if ($truthy(delimited_block = self3["$is_delimited_block?"](this_line, true))) {
            block_context = cloaked_context = delimited_block.$context();
            terminator = delimited_block.$terminator();
            if ($truthy(style)) {
              if (!$eqeq(style, block_context.$to_s())) {
                if ($truthy(delimited_block.$masq()["$include?"](style))) {
                  block_context = style.$to_sym();
                } else if ($truthy(delimited_block.$masq()["$include?"]("admonition")) && $truthy($$("ADMONITION_STYLES")["$include?"](style))) {
                  block_context = "admonition";
                } else if ($truthy(block_extensions) && $truthy(extensions["$registered_for_block?"](style, block_context))) {
                  block_context = style.$to_sym();
                } else {
                  if ($truthy(self3.$logger()["$debug?"]())) {
                    self3.$logger().$debug(self3.$message_with_context("unknown style for " + block_context + " block: " + style, $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
                  }
                  ;
                  style = block_context.$to_s();
                }
              }
            } else {
              style = ($a = ["style", block_context.$to_s()], $send(attributes, "[]=", $a), $a[$a.length - 1]);
            }
            ;
          }
          ;
          if (!$truthy(delimited_block)) {
            while ($truthy(true)) {
              if ($truthy(style) && $truthy($$("Compliance").$strict_verbatim_paragraphs()) && $truthy($$("VERBATIM_STYLES")["$include?"](style))) {
                block_context = style.$to_sym();
                reader.$unshift_line(this_line);
                break;
              }
              ;
              if ($truthy(text_only)) {
                indented = this_line["$start_with?"](" ", $$("TAB"));
              } else {
                md_syntax = $$("Compliance").$markdown_syntax();
                if ($truthy(this_line["$start_with?"](" "))) {
                  $a = [true, " "], indented = $a[0], ch0 = $a[1], $a;
                  if ($truthy(md_syntax) && $truthy($send(this_line.$lstrip(), "start_with?", $to_a($$("MARKDOWN_THEMATIC_BREAK_CHARS").$keys()))) && $truthy($$("MarkdownThematicBreakRx")["$match?"](this_line))) {
                    block = $$("Block").$new(parent, "thematic_break", $hash2(["content_model"], { "content_model": "empty" }));
                    break;
                  }
                  ;
                } else if ($truthy(this_line["$start_with?"]($$("TAB")))) {
                  $a = [true, $$("TAB")], indented = $a[0], ch0 = $a[1], $a;
                } else {
                  $a = [false, this_line.$chr()], indented = $a[0], ch0 = $a[1], $a;
                  layout_break_chars = $truthy(md_syntax) ? $$("HYBRID_LAYOUT_BREAK_CHARS") : $$("LAYOUT_BREAK_CHARS");
                  if ($truthy(layout_break_chars["$key?"](ch0)) && $truthy($truthy(md_syntax) ? $$("ExtLayoutBreakRx")["$match?"](this_line) : $truthy($ret_or_1 = self3["$uniform?"](this_line, ch0, ll = this_line.$length())) ? $rb_gt(ll, 2) : $ret_or_1)) {
                    block = $$("Block").$new(parent, layout_break_chars["$[]"](ch0), $hash2(["content_model"], { "content_model": "empty" }));
                    break;
                  } else if ($truthy(this_line["$end_with?"]("]")) && $truthy(this_line["$include?"]("::"))) {
                    if (($eqeq(ch0, "i") || $truthy(this_line["$start_with?"]("video:", "audio:"))) && $truthy($$("BlockMediaMacroRx")["$=~"](this_line))) {
                      $a = [(($b = $gvars["~"]) === nil ? nil : $b["$[]"](1)).$to_sym(), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](2), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](3)], blk_ctx = $a[0], target = $a[1], blk_attrs = $a[2], $a;
                      block = $$("Block").$new(parent, blk_ctx, $hash2(["content_model"], { "content_model": "empty" }));
                      if ($truthy(blk_attrs)) {
                        switch (blk_ctx) {
                          case "video":
                            posattrs = ["poster", "width", "height"];
                            break;
                          case "audio":
                            posattrs = [];
                            break;
                          default:
                            posattrs = ["alt", "width", "height"];
                        }
                        ;
                        block.$parse_attributes(blk_attrs, posattrs, $hash2(["sub_input", "into"], { "sub_input": true, "into": attributes }));
                      }
                      ;
                      if ($truthy(attributes["$key?"]("style"))) {
                        attributes.$delete("style");
                      }
                      ;
                      if ($truthy(target["$include?"]($$("ATTR_REF_HEAD")))) {
                        if ($truthy((expanded_target = block.$sub_attributes(target))["$empty?"]()) && $eqeq($truthy($ret_or_1 = doc_attrs["$[]"]("attribute-missing")) ? $ret_or_1 : $$("Compliance").$attribute_missing(), "drop-line") && $truthy(block.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], { "attribute_missing": "drop-line", "drop_line_severity": "ignore" }))["$empty?"]())) {
                          attributes.$clear();
                          return nil;
                        } else {
                          target = expanded_target;
                        }
                      }
                      ;
                      if ($eqeq(blk_ctx, "image")) {
                        document2.$register("images", target);
                        attributes["$[]="]("imagesdir", doc_attrs["$[]"]("imagesdir"));
                        if ($truthy($ret_or_1 = attributes["$[]"]("alt"))) {
                          $ret_or_1;
                        } else {
                          attributes["$[]="]("alt", $truthy($ret_or_2 = style) ? $ret_or_2 : ($a = ["default-alt", $$("Helpers").$basename(target, true).$tr("_-", " ")], $send(attributes, "[]=", $a), $a[$a.length - 1]));
                        }
                        ;
                        if (!$truthy((scaledwidth = attributes.$delete("scaledwidth"))["$nil_or_empty?"]())) {
                          attributes["$[]="]("scaledwidth", $truthy($$("TrailingDigitsRx")["$match?"](scaledwidth)) ? "" + scaledwidth + "%" : scaledwidth);
                        }
                        ;
                        if ($truthy(attributes["$[]"]("title"))) {
                          block["$title="](block_title = attributes.$delete("title"));
                          block.$assign_caption(attributes.$delete("caption"), "figure");
                        }
                        ;
                      }
                      ;
                      attributes["$[]="]("target", target);
                      break;
                    } else if ($eqeq(ch0, "t") && $truthy(this_line["$start_with?"]("toc:")) && $truthy($$("BlockTocMacroRx")["$=~"](this_line))) {
                      block = $$("Block").$new(parent, "toc", $hash2(["content_model"], { "content_model": "empty" }));
                      if ($truthy(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                        block.$parse_attributes(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), [], $hash2(["into"], { "into": attributes }));
                      }
                      ;
                      break;
                    } else if ($truthy($truthy(block_macro_extensions) ? $truthy($ret_or_1 = $truthy($ret_or_2 = $$("CustomBlockMacroRx")["$=~"](this_line)) ? extension = extensions["$registered_for_block_macro?"](($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)) : $ret_or_2) ? $ret_or_1 : report_unknown_block_macro = self3.$logger()["$debug?"]() : $truthy($ret_or_1 = self3.$logger()["$debug?"]()) ? report_unknown_block_macro = $$("CustomBlockMacroRx")["$=~"](this_line) : $ret_or_1)) {
                      if ($truthy(report_unknown_block_macro)) {
                        self3.$logger().$debug(self3.$message_with_context("unknown name for block macro: " + (($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)), $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
                      } else {
                        content = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
                        if ($truthy((target = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))["$include?"]($$("ATTR_REF_HEAD")))) {
                          if ($truthy((expanded_target = parent.$sub_attributes(target))["$empty?"]()) && $eqeq($truthy($ret_or_1 = doc_attrs["$[]"]("attribute-missing")) ? $ret_or_1 : $$("Compliance").$attribute_missing(), "drop-line") && $truthy(parent.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], { "attribute_missing": "drop-line", "drop_line_severity": "ignore" }))["$empty?"]())) {
                            attributes.$clear();
                            return nil;
                          } else {
                            target = expanded_target;
                          }
                        }
                        ;
                        if ($eqeq((ext_config = extension.$config())["$[]"]("content_model"), "attributes")) {
                          if ($truthy(content)) {
                            document2.$parse_attributes(content, $truthy($ret_or_1 = $truthy($ret_or_2 = ext_config["$[]"]("positional_attrs")) ? $ret_or_2 : ext_config["$[]"]("pos_attrs")) ? $ret_or_1 : [], $hash2(["sub_input", "into"], { "sub_input": true, "into": attributes }));
                          }
                        } else {
                          attributes["$[]="]("text", $truthy($ret_or_1 = content) ? $ret_or_1 : "");
                        }
                        ;
                        if ($truthy(default_attrs = ext_config["$[]"]("default_attrs"))) {
                          $send(attributes, "update", [default_attrs], function $$6(_, old_v) {
                            if (_ == null)
                              _ = nil;
                            if (old_v == null)
                              old_v = nil;
                            return old_v;
                          });
                        }
                        ;
                        if ($truthy(block = extension.$process_method()["$[]"](parent, target, attributes)) && $neqeq(block, parent)) {
                          attributes.$replace(block.$attributes());
                          break;
                        } else {
                          attributes.$clear();
                          return nil;
                        }
                        ;
                      }
                    }
                  }
                  ;
                }
                ;
              }
              ;
              if ($not(indented) && $eqeq(ch0 = $truthy($ret_or_1 = ch0) ? $ret_or_1 : this_line.$chr(), "<") && $truthy($$("CalloutListRx")["$=~"](this_line))) {
                reader.$unshift_line(this_line);
                block = self3.$parse_callout_list(reader, $gvars["~"], parent, document2.$callouts());
                attributes["$[]="]("style", "arabic");
                break;
              } else if ($truthy($$("UnorderedListRx")["$match?"](this_line))) {
                reader.$unshift_line(this_line);
                if ($not(style) && $eqeqeq($$("Section"), parent) && $eqeq(parent.$sectname(), "bibliography")) {
                  attributes["$[]="]("style", style = "bibliography");
                }
                ;
                block = self3.$parse_list(reader, "ulist", parent, style);
                break;
              } else if ($truthy($$("OrderedListRx")["$match?"](this_line))) {
                reader.$unshift_line(this_line);
                block = self3.$parse_list(reader, "olist", parent, style);
                if ($truthy(block.$style())) {
                  attributes["$[]="]("style", block.$style());
                }
                ;
                break;
              } else if (($truthy(this_line["$include?"]("::")) || $truthy(this_line["$include?"](";;"))) && $truthy($$("DescriptionListRx")["$=~"](this_line))) {
                reader.$unshift_line(this_line);
                block = self3.$parse_description_list(reader, $gvars["~"], parent);
                break;
              } else if (($eqeq(style, "float") || $eqeq(style, "discrete")) && $truthy($truthy($$("Compliance").$underline_style_section_titles()) ? self3["$is_section_title?"](this_line, reader.$peek_line()) : $truthy($ret_or_1 = indented["$!"]()) ? self3["$atx_section_title?"](this_line) : $ret_or_1)) {
                reader.$unshift_line(this_line);
                $b = self3.$parse_section_title(reader, document2, attributes["$[]"]("id")), $a = $to_ary($b), float_id = $a[0] == null ? nil : $a[0], float_reftext = $a[1] == null ? nil : $a[1], block_title = $a[2] == null ? nil : $a[2], float_level = $a[3] == null ? nil : $a[3], $b;
                if ($truthy(float_reftext)) {
                  attributes["$[]="]("reftext", float_reftext);
                }
                ;
                block = $$("Block").$new(parent, "floating_title", $hash2(["content_model"], { "content_model": "empty" }));
                block["$title="](block_title);
                attributes.$delete("title");
                block["$id="]($truthy($ret_or_1 = float_id) ? $ret_or_1 : $truthy(doc_attrs["$key?"]("sectids")) ? $$("Section").$generate_id(block.$title(), document2) : nil);
                block["$level="](float_level);
                break;
              } else if ($truthy(style) && $neqeq(style, "normal")) {
                if ($truthy($$("PARAGRAPH_STYLES")["$include?"](style))) {
                  block_context = style.$to_sym();
                  cloaked_context = "paragraph";
                  reader.$unshift_line(this_line);
                  break;
                } else if ($truthy($$("ADMONITION_STYLES")["$include?"](style))) {
                  block_context = "admonition";
                  cloaked_context = "paragraph";
                  reader.$unshift_line(this_line);
                  break;
                } else if ($truthy(block_extensions) && $truthy(extensions["$registered_for_block?"](style, "paragraph"))) {
                  block_context = style.$to_sym();
                  cloaked_context = "paragraph";
                  reader.$unshift_line(this_line);
                  break;
                } else {
                  if ($truthy(self3.$logger()["$debug?"]())) {
                    self3.$logger().$debug(self3.$message_with_context("unknown style for paragraph: " + style, $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
                  }
                  ;
                  style = nil;
                }
              }
              ;
              reader.$unshift_line(this_line);
              if ($truthy(indented) && $not(style)) {
                lines = self3.$read_paragraph_lines(reader, content_adjacent = $eqeq(skipped, 0) ? options["$[]"]("list_type") : nil, $hash2(["skip_line_comments"], { "skip_line_comments": text_only }));
                self3["$adjust_indentation!"](lines);
                if ($truthy(text_only) || $eqeq(content_adjacent, "dlist")) {
                  block = $$("Block").$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], { "content_model": "simple", "source": lines, "attributes": attributes }));
                } else {
                  block = $$("Block").$new(parent, "literal", $hash2(["content_model", "source", "attributes"], { "content_model": "verbatim", "source": lines, "attributes": attributes }));
                }
                ;
              } else {
                lines = self3.$read_paragraph_lines(reader, $truthy($ret_or_1 = skipped["$=="](0)) ? options["$[]"]("list_type") : $ret_or_1, $hash2(["skip_line_comments"], { "skip_line_comments": true }));
                if ($truthy(text_only)) {
                  if ($truthy(indented) && $eqeq(style, "normal")) {
                    self3["$adjust_indentation!"](lines);
                  }
                  ;
                  block = $$("Block").$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], { "content_model": "simple", "source": lines, "attributes": attributes }));
                } else if ($truthy($$("ADMONITION_STYLE_HEADS")["$include?"](ch0)) && $truthy(this_line["$include?"](":")) && $truthy($$("AdmonitionParagraphRx")["$=~"](this_line))) {
                  lines["$[]="](0, ($a = $gvars["~"]) === nil ? nil : $a.$post_match());
                  attributes["$[]="]("name", admonition_name = ($a = ["style", ($b = $gvars["~"]) === nil ? nil : $b["$[]"](1)], $send(attributes, "[]=", $a), $a[$a.length - 1]).$downcase());
                  attributes["$[]="]("textlabel", $truthy($ret_or_1 = attributes.$delete("caption")) ? $ret_or_1 : doc_attrs["$[]"]("" + admonition_name + "-caption"));
                  block = $$("Block").$new(parent, "admonition", $hash2(["content_model", "source", "attributes"], { "content_model": "simple", "source": lines, "attributes": attributes }));
                } else if ($truthy(md_syntax) && $eqeq(ch0, ">") && $truthy(this_line["$start_with?"]("> "))) {
                  $send(lines, "map!", [], function $$7(line) {
                    if (line == null)
                      line = nil;
                    if ($eqeq(line, ">")) {
                      return line.$slice(1, line.$length());
                    } else {
                      if ($truthy(line["$start_with?"]("> "))) {
                        return line.$slice(2, line.$length());
                      } else {
                        return line;
                      }
                      ;
                    }
                    ;
                  });
                  if ($truthy(lines["$[]"](-1)["$start_with?"]("-- "))) {
                    credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                    if (!$truthy(lines["$empty?"]())) {
                      while ($truthy(lines["$[]"](-1)["$empty?"]())) {
                        lines.$pop();
                      }
                    }
                    ;
                  }
                  ;
                  attributes["$[]="]("style", "quote");
                  block = self3.$build_block("quote", "compound", false, parent, $$("Reader").$new(lines), attributes);
                  if ($truthy(credit_line)) {
                    $b = block.$apply_subs(credit_line).$split(", ", 2), $a = $to_ary($b), attribution = $a[0] == null ? nil : $a[0], citetitle = $a[1] == null ? nil : $a[1], $b;
                    if ($truthy(attribution)) {
                      attributes["$[]="]("attribution", attribution);
                    }
                    ;
                    if ($truthy(citetitle)) {
                      attributes["$[]="]("citetitle", citetitle);
                    }
                    ;
                  }
                  ;
                } else if ($eqeq(ch0, '"') && $truthy($rb_gt(lines.$size(), 1)) && $truthy(lines["$[]"](-1)["$start_with?"]("-- ")) && $truthy(lines["$[]"](-2)["$end_with?"]('"'))) {
                  lines["$[]="](0, this_line.$slice(1, this_line.$length()));
                  credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                  while ($truthy(lines["$[]"](-1)["$empty?"]())) {
                    lines.$pop();
                  }
                  ;
                  lines["$<<"](lines.$pop().$chop());
                  attributes["$[]="]("style", "quote");
                  block = $$("Block").$new(parent, "quote", $hash2(["content_model", "source", "attributes"], { "content_model": "simple", "source": lines, "attributes": attributes }));
                  $b = block.$apply_subs(credit_line).$split(", ", 2), $a = $to_ary($b), attribution = $a[0] == null ? nil : $a[0], citetitle = $a[1] == null ? nil : $a[1], $b;
                  if ($truthy(attribution)) {
                    attributes["$[]="]("attribution", attribution);
                  }
                  ;
                  if ($truthy(citetitle)) {
                    attributes["$[]="]("citetitle", citetitle);
                  }
                  ;
                } else {
                  if ($truthy(indented) && $eqeq(style, "normal")) {
                    self3["$adjust_indentation!"](lines);
                  }
                  ;
                  block = $$("Block").$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], { "content_model": "simple", "source": lines, "attributes": attributes }));
                }
                ;
                self3.$catalog_inline_anchors(lines.$join($$("LF")), block, document2, reader);
              }
              ;
              break;
            }
          }
          ;
          if (!$truthy(block)) {
            switch (block_context) {
              case "listing":
              case "source":
                if ($eqeq(block_context, "source") || $not(attributes["$[]"](1)) && $truthy(language2 = $truthy($ret_or_2 = attributes["$[]"](2)) ? $ret_or_2 : doc_attrs["$[]"]("source-language"))) {
                  if ($truthy(language2)) {
                    attributes["$[]="]("style", "source");
                    attributes["$[]="]("language", language2);
                    $$("AttributeList").$rekey(attributes, [nil, nil, "linenums"]);
                  } else {
                    $$("AttributeList").$rekey(attributes, [nil, "language", "linenums"]);
                    if (!$truthy(attributes["$key?"]("language"))) {
                      if ($truthy(doc_attrs["$key?"]("source-language"))) {
                        attributes["$[]="]("language", doc_attrs["$[]"]("source-language"));
                      }
                    }
                    ;
                  }
                  ;
                  if (!$truthy(attributes["$key?"]("linenums"))) {
                    if ($truthy(attributes["$[]"]("linenums-option")) || $truthy(doc_attrs["$[]"]("source-linenums-option"))) {
                      attributes["$[]="]("linenums", "");
                    }
                  }
                  ;
                  if (!$truthy(attributes["$key?"]("indent"))) {
                    if ($truthy(doc_attrs["$key?"]("source-indent"))) {
                      attributes["$[]="]("indent", doc_attrs["$[]"]("source-indent"));
                    }
                  }
                  ;
                }
                ;
                block = self3.$build_block("listing", "verbatim", terminator, parent, reader, attributes);
                break;
              case "fenced_code":
                attributes["$[]="]("style", "source");
                if ($truthy($rb_gt(ll = this_line.$length(), 3))) {
                  if ($truthy(comma_idx = (language2 = this_line.$slice(3, ll)).$index(","))) {
                    if ($truthy($rb_gt(comma_idx, 0))) {
                      language2 = language2.$slice(0, comma_idx).$strip();
                      if ($truthy($rb_lt(comma_idx, $rb_minus(ll, 4)))) {
                        attributes["$[]="]("linenums", "");
                      }
                      ;
                    } else if ($truthy($rb_gt(ll, 4))) {
                      attributes["$[]="]("linenums", "");
                    }
                  } else {
                    language2 = language2.$lstrip();
                  }
                }
                ;
                if ($truthy(language2["$nil_or_empty?"]())) {
                  if ($truthy(doc_attrs["$key?"]("source-language"))) {
                    attributes["$[]="]("language", doc_attrs["$[]"]("source-language"));
                  }
                } else {
                  attributes["$[]="]("language", language2);
                }
                ;
                if (!$truthy(attributes["$key?"]("linenums"))) {
                  if ($truthy(attributes["$[]"]("linenums-option")) || $truthy(doc_attrs["$[]"]("source-linenums-option"))) {
                    attributes["$[]="]("linenums", "");
                  }
                }
                ;
                if (!$truthy(attributes["$key?"]("indent"))) {
                  if ($truthy(doc_attrs["$key?"]("source-indent"))) {
                    attributes["$[]="]("indent", doc_attrs["$[]"]("source-indent"));
                  }
                }
                ;
                terminator = terminator.$slice(0, 3);
                block = self3.$build_block("listing", "verbatim", terminator, parent, reader, attributes);
                break;
              case "table":
                block_cursor = reader.$cursor();
                block_reader = $$("Reader").$new(reader.$read_lines_until($hash2(["terminator", "skip_line_comments", "context", "cursor"], { "terminator": terminator, "skip_line_comments": true, "context": "table", "cursor": "at_mark" })), block_cursor);
                if (!$truthy(terminator["$start_with?"]("|", "!"))) {
                  if ($truthy($ret_or_2 = attributes["$[]"]("format"))) {
                    $ret_or_2;
                  } else {
                    attributes["$[]="]("format", $truthy(terminator["$start_with?"](",")) ? "csv" : "dsv");
                  }
                }
                ;
                block = self3.$parse_table(block_reader, parent, attributes);
                break;
              case "sidebar":
                block = self3.$build_block(block_context, "compound", terminator, parent, reader, attributes);
                break;
              case "admonition":
                attributes["$[]="]("name", admonition_name = style.$downcase());
                attributes["$[]="]("textlabel", $truthy($ret_or_2 = attributes.$delete("caption")) ? $ret_or_2 : doc_attrs["$[]"]("" + admonition_name + "-caption"));
                block = self3.$build_block(block_context, "compound", terminator, parent, reader, attributes);
                break;
              case "open":
              case "abstract":
              case "partintro":
                block = self3.$build_block("open", "compound", terminator, parent, reader, attributes);
                break;
              case "literal":
                block = self3.$build_block(block_context, "verbatim", terminator, parent, reader, attributes);
                break;
              case "example":
                if ($truthy(attributes["$[]"]("collapsible-option"))) {
                  attributes["$[]="]("caption", "");
                }
                ;
                block = self3.$build_block(block_context, "compound", terminator, parent, reader, attributes);
                break;
              case "quote":
              case "verse":
                $$("AttributeList").$rekey(attributes, [nil, "attribution", "citetitle"]);
                block = self3.$build_block(block_context, $eqeq(block_context, "verse") ? "verbatim" : "compound", terminator, parent, reader, attributes);
                break;
              case "stem":
              case "latexmath":
              case "asciimath":
                if ($eqeq(block_context, "stem")) {
                  attributes["$[]="]("style", $$("STEM_TYPE_ALIASES")["$[]"]($truthy($ret_or_2 = attributes["$[]"](2)) ? $ret_or_2 : doc_attrs["$[]"]("stem")));
                }
                ;
                block = self3.$build_block("stem", "raw", terminator, parent, reader, attributes);
                break;
              case "pass":
                block = self3.$build_block(block_context, "raw", terminator, parent, reader, attributes);
                break;
              case "comment":
                self3.$build_block(block_context, "skip", terminator, parent, reader, attributes);
                attributes.$clear();
                return nil;
              default:
                if ($truthy(block_extensions) && $truthy(extension = extensions["$registered_for_block?"](block_context, cloaked_context))) {
                  if (!$eqeq(content_model = (ext_config = extension.$config())["$[]"]("content_model"), "skip")) {
                    if (!$truthy((positional_attrs = $truthy($ret_or_2 = ext_config["$[]"]("positional_attrs")) ? $ret_or_2 : ext_config["$[]"]("pos_attrs"))["$nil_or_empty?"]())) {
                      $$("AttributeList").$rekey(attributes, $rb_plus([nil], positional_attrs));
                    }
                    ;
                    if ($truthy(default_attrs = ext_config["$[]"]("default_attrs"))) {
                      $send(default_attrs, "each", [], function $$8(k, v) {
                        var $c;
                        if (k == null)
                          k = nil;
                        if (v == null)
                          v = nil;
                        if ($truthy($ret_or_2 = attributes["$[]"](k))) {
                          return $ret_or_2;
                        } else {
                          return $c = [k, v], $send(attributes, "[]=", $c), $c[$c.length - 1];
                        }
                        ;
                      });
                    }
                    ;
                    attributes["$[]="]("cloaked-context", cloaked_context);
                  }
                  ;
                  if (!$truthy(block = self3.$build_block(block_context, content_model, terminator, parent, reader, attributes, $hash2(["extension"], { "extension": extension })))) {
                    attributes.$clear();
                    return nil;
                  }
                  ;
                } else {
                  self3.$raise("Unsupported block type " + block_context + " at " + reader.$cursor());
                }
            }
          }
          ;
          if ($truthy(document2.$sourcemap())) {
            block["$source_location="](reader.$cursor_at_mark());
          }
          ;
          if ($truthy(attributes["$[]"]("title"))) {
            block["$title="](block_title = attributes.$delete("title"));
            if ($truthy($$("CAPTION_ATTRIBUTE_NAMES")["$[]"](block.$context()))) {
              block.$assign_caption(attributes.$delete("caption"));
            }
            ;
          }
          ;
          block["$style="](attributes["$[]"]("style"));
          if ($truthy(block_id = $truthy($ret_or_1 = block.$id()) ? $ret_or_1 : ($a = [attributes["$[]"]("id")], $send(block, "id=", $a), $a[$a.length - 1]))) {
            if ($truthy($truthy(block_title) ? block_title["$include?"]($$("ATTR_REF_HEAD")) : block["$title?"]())) {
              block.$title();
            }
            ;
            if (!$truthy(document2.$register("refs", [block_id, block]))) {
              self3.$logger().$warn(self3.$message_with_context("id assigned to block already in use: " + block_id, $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
            }
            ;
          }
          ;
          if (!$truthy(attributes["$empty?"]())) {
            block.$update_attributes(attributes);
          }
          ;
          block.$commit_subs();
          if ($truthy(block["$sub?"]("callouts"))) {
            if (!$truthy(self3.$catalog_callouts(block.$source(), document2))) {
              block.$remove_sub("callouts");
            }
          }
          ;
          return block;
        }, -3);
        $defs(self2, "$read_paragraph_lines", function $$read_paragraph_lines(reader, break_at_list, opts) {
          var break_condition = nil;
          if (opts == null)
            opts = $hash2([], {});
          opts["$[]="]("break_on_blank_lines", true);
          opts["$[]="]("break_on_list_continuation", true);
          opts["$[]="]("preserve_last_line", true);
          break_condition = $truthy(break_at_list) ? $truthy($$("Compliance").$block_terminates_paragraph()) ? $$("StartOfBlockOrListProc") : $$("StartOfListProc") : $truthy($$("Compliance").$block_terminates_paragraph()) ? $$("StartOfBlockProc") : $$("NoOp");
          return $send(reader, "read_lines_until", [opts], break_condition.$to_proc());
        }, -3);
        $defs(self2, "$is_delimited_block?", function $Parser_is_delimited_block$ques$9(line, return_match_data) {
          var $a, $b, self3 = this, line_len = nil, tip = nil, tip_len = nil, context = nil, masq = nil;
          if (return_match_data == null)
            return_match_data = nil;
          if (!($truthy($rb_gt(line_len = line.$length(), 1)) && $truthy($$("DELIMITED_BLOCK_HEADS")["$[]"](line.$slice(0, 2))))) {
            return nil;
          }
          ;
          if ($eqeq(line_len, 2)) {
            tip = line;
            tip_len = 2;
          } else {
            if ($truthy($rb_lt(line_len, 5))) {
              tip = line;
              tip_len = line_len;
            } else {
              tip = line.$slice(0, tip_len = 4);
            }
            ;
            if ($truthy($$("Compliance").$markdown_syntax()) && $truthy(tip["$start_with?"]("`"))) {
              if ($eqeq(tip_len, 4)) {
                if ($eqeq(tip, "````") || $neqeq(tip = tip.$chop(), "```")) {
                  return nil;
                }
                ;
                line = tip;
                line_len = tip_len = 3;
              } else if ($neqeq(tip, "```")) {
                return nil;
              }
            } else if ($eqeq(tip_len, 3)) {
              return nil;
            }
            ;
          }
          ;
          $b = $$("DELIMITED_BLOCKS")["$[]"](tip), $a = $to_ary($b), context = $a[0] == null ? nil : $a[0], masq = $a[1] == null ? nil : $a[1], $b;
          if ($truthy(context) && ($eqeq(line_len, tip_len) || $truthy(self3["$uniform?"](line.$slice(1, line_len), $$("DELIMITED_BLOCK_TAILS")["$[]"](tip), $rb_minus(line_len, 1))))) {
            if ($truthy(return_match_data)) {
              return $$("BlockMatchData").$new(context, masq, tip, line);
            } else {
              return true;
            }
          } else {
            return nil;
          }
          ;
        }, -2);
        $defs(self2, "$build_block", function $$build_block(block_context, content_model, terminator, parent, reader, attributes, options) {
          var $a, self3 = this, skip_processing = nil, parse_as_content_model = nil, lines = nil, block_reader = nil, block_cursor = nil, tab_size = nil, $ret_or_2 = nil, indent = nil, extension = nil, block = nil, $ret_or_1 = nil;
          if (options == null)
            options = $hash2([], {});
          switch (content_model) {
            case "skip":
              $a = [true, "simple"], skip_processing = $a[0], parse_as_content_model = $a[1], $a;
              break;
            case "raw":
              $a = [false, "simple"], skip_processing = $a[0], parse_as_content_model = $a[1], $a;
              break;
            default:
              $a = [false, content_model], skip_processing = $a[0], parse_as_content_model = $a[1], $a;
          }
          ;
          if ($truthy(terminator["$nil?"]())) {
            if ($eqeq(parse_as_content_model, "verbatim")) {
              lines = reader.$read_lines_until($hash2(["break_on_blank_lines", "break_on_list_continuation"], { "break_on_blank_lines": true, "break_on_list_continuation": true }));
            } else {
              if ($eqeq(content_model, "compound")) {
                content_model = "simple";
              }
              ;
              lines = self3.$read_paragraph_lines(reader, false, $hash2(["skip_line_comments", "skip_processing"], { "skip_line_comments": true, "skip_processing": skip_processing }));
            }
            ;
            block_reader = nil;
          } else if ($neqeq(parse_as_content_model, "compound")) {
            lines = reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], { "terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark" }));
            block_reader = nil;
          } else if ($eqeq(terminator, false)) {
            lines = nil;
            block_reader = reader;
          } else {
            lines = nil;
            block_cursor = reader.$cursor();
            block_reader = $$("Reader").$new(reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], { "terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark" })), block_cursor);
          }
          ;
          switch (content_model) {
            case "verbatim":
              tab_size = ($truthy($ret_or_2 = attributes["$[]"]("tabsize")) ? $ret_or_2 : parent.$document().$attributes()["$[]"]("tabsize")).$to_i();
              if ($truthy(indent = attributes["$[]"]("indent"))) {
                self3["$adjust_indentation!"](lines, indent.$to_i(), tab_size);
              } else if ($truthy($rb_gt(tab_size, 0))) {
                self3["$adjust_indentation!"](lines, -1, tab_size);
              }
              ;
              break;
            case "skip":
              return nil;
            default:
              nil;
          }
          ;
          if ($truthy(extension = options["$[]"]("extension"))) {
            attributes.$delete("style");
            if ($truthy(block = extension.$process_method()["$[]"](parent, $truthy($ret_or_1 = block_reader) ? $ret_or_1 : $$("Reader").$new(lines), attributes.$merge())) && $neqeq(block, parent)) {
              attributes.$replace(block.$attributes());
              if ($eqeq(block.$content_model(), "compound") && $eqeqeq($$("Block"), block) && $not((lines = block.$lines())["$empty?"]())) {
                content_model = "compound";
                block_reader = $$("Reader").$new(lines);
              }
              ;
            } else {
              return nil;
            }
            ;
          } else {
            block = $$("Block").$new(parent, block_context, $hash2(["content_model", "source", "attributes"], { "content_model": content_model, "source": lines, "attributes": attributes }));
          }
          ;
          if ($eqeq(content_model, "compound")) {
            self3.$parse_blocks(block_reader, block);
          }
          ;
          return block;
        }, -7);
        $defs(self2, "$parse_blocks", function $$parse_blocks(reader, parent, attributes) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil, block = nil;
          if (attributes == null)
            attributes = nil;
          if ($truthy(attributes)) {
            while ($truthy($truthy($ret_or_1 = $truthy($ret_or_2 = block = self3.$next_block(reader, parent, attributes.$merge())) ? parent.$blocks()["$<<"](block) : $ret_or_2) ? $ret_or_1 : reader["$has_more_lines?"]())) {
            }
          } else {
            while ($truthy($truthy($ret_or_1 = $truthy($ret_or_2 = block = self3.$next_block(reader, parent)) ? parent.$blocks()["$<<"](block) : $ret_or_2) ? $ret_or_1 : reader["$has_more_lines?"]())) {
            }
          }
          ;
          return nil;
        }, -3);
        $defs(self2, "$parse_list", function $$parse_list(reader, list_type, parent, style) {
          var $a, self3 = this, list_block = nil, list_rx = nil, $ret_or_1 = nil, list_item = nil;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          list_block = $$("List").$new(parent, list_type);
          list_rx = $$("ListRxMap")["$[]"](list_type);
          while ($truthy($truthy($ret_or_1 = reader["$has_more_lines?"]()) ? list_rx["$=~"](reader.$peek_line()) : $ret_or_1)) {
            if ($truthy(list_item = self3.$parse_list_item(reader, list_block, $gvars["~"], ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), style))) {
              list_block.$items()["$<<"](list_item);
            }
            ;
            if ($truthy($ret_or_1 = reader.$skip_blank_lines())) {
              $ret_or_1;
            } else {
              break;
            }
            ;
          }
          ;
          return list_block;
        });
        $defs(self2, "$catalog_callouts", function $$catalog_callouts(text, document2) {
          var found = nil, autonum = nil;
          found = false;
          autonum = 0;
          if ($truthy(text["$include?"]("<"))) {
            $send(text, "scan", [$$("CalloutScanRx")], function $$10() {
              var $a;
              if (!$truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]("\\"))) {
                document2.$callouts().$register($eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), ".") ? (autonum = $rb_plus(autonum, 1)).$to_s() : ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2));
              }
              ;
              return found = true;
            });
          }
          ;
          return found;
        });
        $defs(self2, "$catalog_inline_anchor", function $$catalog_inline_anchor(id, reftext, node, location, doc) {
          var self3 = this;
          if (doc == null)
            doc = node.$document();
          if ($truthy(reftext) && $truthy(reftext["$include?"]($$("ATTR_REF_HEAD")))) {
            reftext = doc.$sub_attributes(reftext);
          }
          ;
          if (!$truthy(doc.$register("refs", [id, $$("Inline").$new(node, "anchor", reftext, $hash2(["type", "id"], { "type": "ref", "id": id }))]))) {
            if ($eqeqeq($$("Reader"), location)) {
              location = location.$cursor();
            }
            ;
            self3.$logger().$warn(self3.$message_with_context("id assigned to anchor already in use: " + id, $hash2(["source_location"], { "source_location": location })));
          }
          ;
          return nil;
        }, -5);
        $defs(self2, "$catalog_inline_anchors", function $$catalog_inline_anchors(text, block, document2, reader) {
          var self3 = this;
          if ($truthy(text["$include?"]("[[")) || $truthy(text["$include?"]("or:"))) {
            $send(text, "scan", [$$("InlineAnchorScanRx")], function $$11() {
              var $a, self4 = $$11.$$s == null ? this : $$11.$$s, id = nil, reftext = nil, location = nil, offset = nil;
              if ($truthy(id = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                if ($truthy(reftext = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)) && $truthy(reftext["$include?"]($$("ATTR_REF_HEAD"))) && $truthy((reftext = document2.$sub_attributes(reftext))["$empty?"]())) {
                  return nil;
                }
              } else {
                id = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
                if ($truthy(reftext = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4))) {
                  if ($truthy(reftext["$include?"]("]"))) {
                    reftext = reftext.$gsub("\\]", "]");
                    if ($truthy(reftext["$include?"]($$("ATTR_REF_HEAD")))) {
                      reftext = document2.$sub_attributes(reftext);
                    }
                    ;
                  } else if ($truthy(reftext["$include?"]($$("ATTR_REF_HEAD")))) {
                    if ($truthy((reftext = document2.$sub_attributes(reftext))["$empty?"]())) {
                      reftext = nil;
                    }
                  }
                }
                ;
              }
              ;
              if ($truthy(document2.$register("refs", [id, $$("Inline").$new(block, "anchor", reftext, $hash2(["type", "id"], { "type": "ref", "id": id }))]))) {
                return nil;
              } else {
                location = reader.$cursor_at_mark();
                if ($truthy($rb_gt(offset = $rb_plus((($a = $gvars["~"]) === nil ? nil : $a.$pre_match()).$count($$("LF")), $truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0))["$start_with?"]($$("LF"))) ? 1 : 0), 0))) {
                  (location = location.$dup()).$advance(offset);
                }
                ;
                return self4.$logger().$warn(self4.$message_with_context("id assigned to anchor already in use: " + id, $hash2(["source_location"], { "source_location": location })));
              }
              ;
            }, { $$s: self3 });
          }
          ;
          return nil;
        });
        $defs(self2, "$catalog_inline_biblio_anchor", function $$catalog_inline_biblio_anchor(id, reftext, node, reader) {
          var self3 = this, $ret_or_1 = nil;
          if (!$truthy(node.$document().$register("refs", [id, $$("Inline").$new(node, "anchor", $truthy($ret_or_1 = reftext) ? "[" + reftext + "]" : $ret_or_1, $hash2(["type", "id"], { "type": "bibref", "id": id }))]))) {
            self3.$logger().$warn(self3.$message_with_context("id assigned to bibliography anchor already in use: " + id, $hash2(["source_location"], { "source_location": reader.$cursor() })));
          }
          ;
          return nil;
        });
        $defs(self2, "$parse_description_list", function $$parse_description_list(reader, match, parent) {
          var self3 = this, list_block = nil, sibling_pattern = nil, current_pair = nil, $ret_or_1 = nil, next_pair = nil;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          list_block = $$("List").$new(parent, "dlist");
          sibling_pattern = $$("DescriptionListSiblingRx")["$[]"](match["$[]"](2));
          list_block.$items()["$<<"](current_pair = self3.$parse_list_item(reader, list_block, match, sibling_pattern));
          while ($truthy($truthy($ret_or_1 = reader["$has_more_lines?"]()) ? sibling_pattern["$=~"](reader.$peek_line()) : $ret_or_1)) {
            next_pair = self3.$parse_list_item(reader, list_block, $gvars["~"], sibling_pattern);
            if ($truthy(current_pair["$[]"](1))) {
              list_block.$items()["$<<"](current_pair = next_pair);
            } else {
              current_pair["$[]"](0)["$<<"](next_pair["$[]"](0)["$[]"](0));
              current_pair["$[]="](1, next_pair["$[]"](1));
            }
            ;
          }
          ;
          return list_block;
        });
        $defs(self2, "$parse_callout_list", function $$parse_callout_list(reader, match, parent, callouts) {
          var self3 = this, list_block = nil, next_index = nil, autonum = nil, $ret_or_1 = nil, $ret_or_2 = nil, num = nil, list_item = nil, coids = nil;
          list_block = $$("List").$new(parent, "colist");
          next_index = 1;
          autonum = 0;
          while ($truthy($truthy($ret_or_1 = match) ? $ret_or_1 : $truthy($ret_or_2 = match = $$("CalloutListRx").$match(reader.$peek_line())) ? reader.$mark() : $ret_or_2)) {
            if ($eqeq(num = match["$[]"](1), ".")) {
              num = (autonum = $rb_plus(autonum, 1)).$to_s();
            }
            ;
            if (!$eqeq(num, next_index.$to_s())) {
              self3.$logger().$warn(self3.$message_with_context("callout list item index: expected " + next_index + ", got " + num, $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
            }
            ;
            if ($truthy(list_item = self3.$parse_list_item(reader, list_block, match, "<1>"))) {
              list_block.$items()["$<<"](list_item);
              if ($truthy((coids = callouts.$callout_ids(list_block.$items().$size()))["$empty?"]())) {
                self3.$logger().$warn(self3.$message_with_context("no callout found for <" + list_block.$items().$size() + ">", $hash2(["source_location"], { "source_location": reader.$cursor_at_mark() })));
              } else {
                list_item.$attributes()["$[]="]("coids", coids);
              }
              ;
            }
            ;
            next_index = $rb_plus(next_index, 1);
            match = nil;
          }
          ;
          callouts.$next_list();
          return list_block;
        });
        $defs(self2, "$parse_list_item", function $$parse_list_item(reader, list_block, match, sibling_trait, style) {
          var $a, $b, self3 = this, list_type = nil, dlist = nil, list_term = nil, term_text = nil, $ret_or_1 = nil, item_text = nil, has_text = nil, list_item = nil, sourcemap_assignment_deferred = nil, ordinal = nil, implicit_style = nil, $ret_or_2 = nil, $ret_or_3 = nil, block_cursor = nil, list_item_reader = nil, comment_lines = nil, subsequent_line = nil, content_adjacent = nil, block = nil, first_block = nil;
          if (style == null)
            style = nil;
          if ($eqeq(list_type = list_block.$context(), "dlist")) {
            dlist = true;
            list_term = $$("ListItem").$new(list_block, term_text = match["$[]"](1));
            if ($truthy(term_text["$start_with?"]("[[")) && $truthy($$("LeadingInlineAnchorRx")["$=~"](term_text))) {
              self3.$catalog_inline_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), $truthy($ret_or_1 = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2)) ? $ret_or_1 : (($a = $gvars["~"]) === nil ? nil : $a.$post_match()).$lstrip(), list_term, reader);
            }
            ;
            if ($truthy(item_text = match["$[]"](3))) {
              has_text = true;
            }
            ;
            list_item = $$("ListItem").$new(list_block, item_text);
            if ($truthy(list_block.$document().$sourcemap())) {
              list_term["$source_location="](reader.$cursor());
              if ($truthy(has_text)) {
                list_item["$source_location="](list_term.$source_location());
              } else {
                sourcemap_assignment_deferred = true;
              }
              ;
            }
            ;
          } else {
            has_text = true;
            list_item = $$("ListItem").$new(list_block, item_text = match["$[]"](2));
            if ($truthy(list_block.$document().$sourcemap())) {
              list_item["$source_location="](reader.$cursor());
            }
            ;
            switch (list_type) {
              case "ulist":
                list_item["$marker="](sibling_trait);
                if ($truthy(item_text["$start_with?"]("["))) {
                  if ($truthy(style) && $eqeq(style, "bibliography")) {
                    if ($truthy($$("InlineBiblioAnchorRx")["$=~"](item_text))) {
                      self3.$catalog_inline_biblio_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), list_item, reader);
                    }
                  } else if ($truthy(item_text["$start_with?"]("[["))) {
                    if ($truthy($$("LeadingInlineAnchorRx")["$=~"](item_text))) {
                      self3.$catalog_inline_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), list_item, reader);
                    }
                  } else if ($truthy(item_text["$start_with?"]("[ ] ", "[x] ", "[*] "))) {
                    list_block.$set_option("checklist");
                    list_item.$attributes()["$[]="]("checkbox", "");
                    if (!$truthy(item_text["$start_with?"]("[ "))) {
                      list_item.$attributes()["$[]="]("checked", "");
                    }
                    ;
                    list_item["$text="](item_text.$slice(4, item_text.$length()));
                  }
                }
                ;
                break;
              case "olist":
                $b = self3.$resolve_ordered_list_marker(sibling_trait, ordinal = list_block.$items().$size(), true, reader), $a = $to_ary($b), sibling_trait = $a[0] == null ? nil : $a[0], implicit_style = $a[1] == null ? nil : $a[1], $b;
                list_item["$marker="](sibling_trait);
                if ($eqeq(ordinal, 0) && $not(style)) {
                  list_block["$style="]($truthy($ret_or_2 = implicit_style) ? $ret_or_2 : ($truthy($ret_or_3 = $$("ORDERED_LIST_STYLES")["$[]"]($rb_minus(sibling_trait.$length(), 1))) ? $ret_or_3 : "arabic").$to_s());
                }
                ;
                if ($truthy(item_text["$start_with?"]("[[")) && $truthy($$("LeadingInlineAnchorRx")["$=~"](item_text))) {
                  self3.$catalog_inline_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), list_item, reader);
                }
                ;
                break;
              default:
                list_item["$marker="](sibling_trait);
                if ($truthy(item_text["$start_with?"]("[[")) && $truthy($$("LeadingInlineAnchorRx")["$=~"](item_text))) {
                  self3.$catalog_inline_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), list_item, reader);
                }
                ;
            }
            ;
          }
          ;
          reader.$shift();
          block_cursor = reader.$cursor();
          list_item_reader = $$("Reader").$new(self3.$read_lines_for_list_item(reader, list_type, sibling_trait, has_text), block_cursor);
          if ($truthy(list_item_reader["$has_more_lines?"]())) {
            if ($truthy(sourcemap_assignment_deferred)) {
              list_item["$source_location="](block_cursor);
            }
            ;
            comment_lines = list_item_reader.$skip_line_comments();
            if ($truthy(subsequent_line = list_item_reader.$peek_line())) {
              if (!$truthy(comment_lines["$empty?"]())) {
                list_item_reader.$unshift_lines(comment_lines);
              }
              ;
              if (!$truthy(subsequent_line["$empty?"]())) {
                content_adjacent = true;
                if (!$truthy(dlist)) {
                  has_text = nil;
                }
                ;
              }
              ;
            }
            ;
            if ($truthy(block = self3.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["text_only", "list_type"], { "text_only": $truthy(has_text) ? nil : true, "list_type": list_type })))) {
              list_item.$blocks()["$<<"](block);
            }
            ;
            while ($truthy(list_item_reader["$has_more_lines?"]())) {
              if ($truthy(block = self3.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["list_type"], { "list_type": list_type })))) {
                list_item.$blocks()["$<<"](block);
              }
            }
            ;
            if ($truthy(content_adjacent) && $truthy(first_block = list_item.$blocks()["$[]"](0)) && $eqeq(first_block.$context(), "paragraph")) {
              list_item.$fold_first();
            }
            ;
          }
          ;
          if ($truthy(dlist)) {
            return [[list_term], $truthy(list_item["$text?"]()) || $truthy(list_item["$blocks?"]()) ? list_item : nil];
          } else {
            return list_item;
          }
          ;
        }, -5);
        $defs(self2, "$read_lines_for_list_item", function $$read_lines_for_list_item(reader, list_type, sibling_trait, has_text) {
          var $a, self3 = this, buffer = nil, continuation = nil, within_nested_list = nil, detached_continuation = nil, dlist = nil, this_line = nil, prev_line = nil, match = nil, block_attribute_lines = nil, next_line = nil, interrupt = nil, ch0 = nil, nested_list_type = nil, $ret_or_1 = nil, last_line = nil;
          if (sibling_trait == null)
            sibling_trait = nil;
          if (has_text == null)
            has_text = true;
          buffer = [];
          continuation = "inactive";
          within_nested_list = false;
          detached_continuation = nil;
          dlist = list_type["$=="]("dlist");
          while ($truthy(reader["$has_more_lines?"]())) {
            this_line = reader.$read_line();
            if ($truthy(self3["$is_sibling_list_item?"](this_line, list_type, sibling_trait))) {
              break;
            }
            ;
            prev_line = $truthy(buffer["$empty?"]()) ? nil : buffer["$[]"](-1);
            if ($eqeq(prev_line, $$("LIST_CONTINUATION"))) {
              if ($eqeq(continuation, "inactive")) {
                continuation = "active";
                has_text = true;
                if (!$truthy(within_nested_list)) {
                  buffer["$[]="](-1, "");
                }
                ;
              }
              ;
              if ($eqeq(this_line, $$("LIST_CONTINUATION"))) {
                if ($neqeq(continuation, "frozen")) {
                  continuation = "frozen";
                  buffer["$<<"](this_line);
                }
                ;
                this_line = nil;
                continue;
              }
              ;
            }
            ;
            if ($truthy(match = self3["$is_delimited_block?"](this_line, true))) {
              if (!$eqeq(continuation, "active")) {
                break;
              }
              ;
              buffer["$<<"](this_line);
              buffer.$concat(reader.$read_lines_until($hash2(["terminator", "read_last_line", "context"], { "terminator": match.$terminator(), "read_last_line": true, "context": nil })));
              continuation = "inactive";
            } else if ($truthy(dlist) && $neqeq(continuation, "active") && $truthy(this_line["$start_with?"]("[")) && $truthy($$("BlockAttributeLineRx")["$match?"](this_line))) {
              block_attribute_lines = [this_line];
              while ($truthy(next_line = reader.$peek_line())) {
                if ($truthy(self3["$is_delimited_block?"](next_line))) {
                  interrupt = true;
                } else if ($truthy(next_line["$empty?"]()) || $truthy(next_line["$start_with?"]("[")) && $truthy($$("BlockAttributeLineRx")["$match?"](next_line))) {
                  block_attribute_lines["$<<"](reader.$read_line());
                  continue;
                } else if ($truthy($$("AnyListRx")["$match?"](next_line)) && $not(self3["$is_sibling_list_item?"](next_line, list_type, sibling_trait))) {
                  buffer.$concat(block_attribute_lines);
                } else {
                  interrupt = true;
                }
                ;
                break;
              }
              ;
              if ($truthy(interrupt)) {
                reader.$unshift_lines(block_attribute_lines);
                break;
              }
              ;
            } else if ($eqeq(continuation, "active") && $not(this_line["$empty?"]())) {
              if ($truthy($$("LiteralParagraphRx")["$match?"](this_line))) {
                reader.$unshift_line(this_line);
                if ($truthy(dlist)) {
                  buffer.$concat($send(reader, "read_lines_until", [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], { "preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true })], function $$12(line) {
                    var self4 = $$12.$$s == null ? this : $$12.$$s;
                    if (line == null)
                      line = nil;
                    return self4["$is_sibling_list_item?"](line, list_type, sibling_trait);
                  }, { $$s: self3 }));
                } else {
                  buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], { "preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true })));
                }
                ;
                continuation = "inactive";
              } else if ($eqeq(ch0 = this_line.$chr(), ".") && $truthy($$("BlockTitleRx")["$match?"](this_line)) || $eqeq(ch0, "[") && $truthy($$("BlockAttributeLineRx")["$match?"](this_line)) || $eqeq(ch0, ":") && $truthy($$("AttributeEntryRx")["$match?"](this_line))) {
                buffer["$<<"](this_line);
              } else {
                if ($truthy(nested_list_type = $send($truthy(within_nested_list) ? ["dlist"] : $$("NESTABLE_LIST_CONTEXTS"), "find", [], function $$13(ctx) {
                  if (ctx == null)
                    ctx = nil;
                  return $$("ListRxMap")["$[]"](ctx)["$match?"](this_line);
                }))) {
                  within_nested_list = true;
                  if ($eqeq(nested_list_type, "dlist") && $truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))["$nil_or_empty?"]())) {
                    has_text = false;
                  }
                  ;
                }
                ;
                buffer["$<<"](this_line);
                continuation = "inactive";
              }
            } else if ($truthy(prev_line) && $truthy(prev_line["$empty?"]())) {
              if ($truthy(this_line["$empty?"]())) {
                if (!$truthy(this_line = $truthy($ret_or_1 = reader.$skip_blank_lines()) ? reader.$read_line() : $ret_or_1)) {
                  break;
                }
                ;
                if ($truthy(self3["$is_sibling_list_item?"](this_line, list_type, sibling_trait))) {
                  break;
                }
                ;
              }
              ;
              if ($eqeq(this_line, $$("LIST_CONTINUATION"))) {
                detached_continuation = buffer.$size();
                buffer["$<<"](this_line);
              } else if ($truthy(has_text)) {
                if ($truthy(self3["$is_sibling_list_item?"](this_line, list_type, sibling_trait))) {
                  break;
                } else if ($truthy(nested_list_type = $send($$("NESTABLE_LIST_CONTEXTS"), "find", [], function $$14(ctx) {
                  if (ctx == null)
                    ctx = nil;
                  return $$("ListRxMap")["$[]"](ctx)["$=~"](this_line);
                }))) {
                  buffer["$<<"](this_line);
                  within_nested_list = true;
                  if ($eqeq(nested_list_type, "dlist") && $truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))["$nil_or_empty?"]())) {
                    has_text = false;
                  }
                  ;
                } else if ($truthy($$("LiteralParagraphRx")["$match?"](this_line))) {
                  reader.$unshift_line(this_line);
                  if ($truthy(dlist)) {
                    buffer.$concat($send(reader, "read_lines_until", [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], { "preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true })], function $$15(line) {
                      var self4 = $$15.$$s == null ? this : $$15.$$s;
                      if (line == null)
                        line = nil;
                      return self4["$is_sibling_list_item?"](line, list_type, sibling_trait);
                    }, { $$s: self3 }));
                  } else {
                    buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], { "preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true })));
                  }
                  ;
                } else {
                  break;
                }
              } else {
                if (!$truthy(within_nested_list)) {
                  buffer.$pop();
                }
                ;
                buffer["$<<"](this_line);
                has_text = true;
              }
              ;
            } else {
              if (!$truthy(this_line["$empty?"]())) {
                has_text = true;
              }
              ;
              if ($truthy(nested_list_type = $send($truthy(within_nested_list) ? ["dlist"] : $$("NESTABLE_LIST_CONTEXTS"), "find", [], function $$16(ctx) {
                if (ctx == null)
                  ctx = nil;
                return $$("ListRxMap")["$[]"](ctx)["$=~"](this_line);
              }))) {
                within_nested_list = true;
                if ($eqeq(nested_list_type, "dlist") && $truthy((($a = $gvars["~"]) === nil ? nil : $a["$[]"](3))["$nil_or_empty?"]())) {
                  has_text = false;
                }
                ;
              }
              ;
              buffer["$<<"](this_line);
            }
            ;
            this_line = nil;
          }
          ;
          if ($truthy(this_line)) {
            reader.$unshift_line(this_line);
          }
          ;
          if ($truthy(detached_continuation)) {
            buffer["$[]="](detached_continuation, "");
          }
          ;
          while (!$truthy(buffer["$empty?"]())) {
            if ($truthy((last_line = buffer["$[]"](-1))["$empty?"]())) {
              buffer.$pop();
            } else {
              if ($eqeq(last_line, $$("LIST_CONTINUATION"))) {
                buffer.$pop();
              }
              ;
              break;
            }
          }
          ;
          return buffer;
        }, -3);
        $defs(self2, "$initialize_section", function $$initialize_section(reader, parent, attributes) {
          var $a, $b, self3 = this, document2 = nil, book = nil, doctype = nil, source_location = nil, sect_style = nil, sect_id = nil, sect_reftext = nil, sect_title = nil, sect_level = nil, sect_atx = nil, sect_name = nil, sect_special = nil, sect_numbered = nil, section = nil, $ret_or_1 = nil, id = nil, generated_id = nil;
          if (attributes == null)
            attributes = $hash2([], {});
          document2 = parent.$document();
          book = (doctype = document2.$doctype())["$=="]("book");
          if ($truthy(document2.$sourcemap())) {
            source_location = reader.$cursor();
          }
          ;
          sect_style = attributes["$[]"](1);
          $b = self3.$parse_section_title(reader, document2, attributes["$[]"]("id")), $a = $to_ary($b), sect_id = $a[0] == null ? nil : $a[0], sect_reftext = $a[1] == null ? nil : $a[1], sect_title = $a[2] == null ? nil : $a[2], sect_level = $a[3] == null ? nil : $a[3], sect_atx = $a[4] == null ? nil : $a[4], $b;
          if ($truthy(sect_style)) {
            if ($truthy(book) && $eqeq(sect_style, "abstract")) {
              $a = ["chapter", 1], sect_name = $a[0], sect_level = $a[1], $a;
            } else if ($truthy(sect_style["$start_with?"]("sect")) && $truthy($$("SectionLevelStyleRx")["$match?"](sect_style))) {
              sect_name = "section";
            } else {
              $a = [sect_style, true], sect_name = $a[0], sect_special = $a[1], $a;
              if ($eqeq(sect_level, 0)) {
                sect_level = 1;
              }
              ;
              sect_numbered = sect_name["$=="]("appendix");
            }
          } else if ($truthy(book)) {
            sect_name = $eqeq(sect_level, 0) ? "part" : $truthy($rb_gt(sect_level, 1)) ? "section" : "chapter";
          } else if ($eqeq(doctype, "manpage") && $eqeq(sect_title.$casecmp("synopsis"), 0)) {
            $a = ["synopsis", true], sect_name = $a[0], sect_special = $a[1], $a;
          } else {
            sect_name = "section";
          }
          ;
          if ($truthy(sect_reftext)) {
            attributes["$[]="]("reftext", sect_reftext);
          }
          ;
          section = $$("Section").$new(parent, sect_level);
          $a = [sect_id, sect_title, sect_name, source_location], $b = [$a[0]], $send(section, "id=", $b), $b[$b.length - 1], $b = [$a[1]], $send(section, "title=", $b), $b[$b.length - 1], $b = [$a[2]], $send(section, "sectname=", $b), $b[$b.length - 1], $b = [$a[3]], $send(section, "source_location=", $b), $b[$b.length - 1], $a;
          if ($truthy(sect_special)) {
            section["$special="](true);
            if ($truthy(sect_numbered)) {
              section["$numbered="](true);
            } else if ($eqeq(document2.$attributes()["$[]"]("sectnums"), "all")) {
              section["$numbered="]($truthy(book) && $eqeq(sect_level, 1) ? "chapter" : true);
            }
            ;
          } else if ($truthy(document2.$attributes()["$[]"]("sectnums")) && $truthy($rb_gt(sect_level, 0))) {
            section["$numbered="]($truthy(section.$special()) ? $truthy($ret_or_1 = parent.$numbered()) || $ret_or_1 : true);
          } else if ($truthy(book) && $eqeq(sect_level, 0) && $truthy(document2.$attributes()["$[]"]("partnums"))) {
            section["$numbered="](true);
          }
          ;
          if ($truthy(id = $truthy($ret_or_1 = section.$id()) ? $ret_or_1 : ($a = [$truthy(document2.$attributes()["$key?"]("sectids")) ? generated_id = $$("Section").$generate_id(section.$title(), document2) : nil], $send(section, "id=", $a), $a[$a.length - 1]))) {
            if (!($truthy(generated_id) || $not(sect_title["$include?"]($$("ATTR_REF_HEAD"))))) {
              section.$title();
            }
            ;
            if (!$truthy(document2.$register("refs", [id, section]))) {
              self3.$logger().$warn(self3.$message_with_context("id assigned to section already in use: " + id, $hash2(["source_location"], { "source_location": reader.$cursor_at_line($rb_minus(reader.$lineno(), $truthy(sect_atx) ? 1 : 2)) })));
            }
            ;
          }
          ;
          section.$update_attributes(attributes);
          reader.$skip_blank_lines();
          return section;
        }, -3);
        $defs(self2, "$is_next_line_section?", function $Parser_is_next_line_section$ques$17(reader, attributes) {
          var self3 = this, style = nil, next_lines = nil, $ret_or_1 = nil;
          if ($truthy(style = attributes["$[]"](1)) && ($eqeq(style, "discrete") || $eqeq(style, "float"))) {
            return nil;
          }
          ;
          if ($truthy($$("Compliance").$underline_style_section_titles())) {
            next_lines = reader.$peek_lines(2, $truthy($ret_or_1 = style) ? style["$=="]("comment") : $ret_or_1);
            return self3["$is_section_title?"]($truthy($ret_or_1 = next_lines["$[]"](0)) ? $ret_or_1 : "", next_lines["$[]"](1));
          } else {
            return self3["$atx_section_title?"]($truthy($ret_or_1 = reader.$peek_line()) ? $ret_or_1 : "");
          }
          ;
        });
        $defs(self2, "$is_next_line_doctitle?", function $Parser_is_next_line_doctitle$ques$18(reader, attributes, leveloffset) {
          var self3 = this, $ret_or_1 = nil, sect_level = nil;
          if ($truthy(leveloffset)) {
            if ($truthy($ret_or_1 = sect_level = self3["$is_next_line_section?"](reader, attributes))) {
              return $rb_plus(sect_level, leveloffset.$to_i())["$=="](0);
            } else {
              return $ret_or_1;
            }
          } else {
            return self3["$is_next_line_section?"](reader, attributes)["$=="](0);
          }
        });
        $defs(self2, "$is_section_title?", function $Parser_is_section_title$ques$19(line1, line2) {
          var self3 = this, $ret_or_1 = nil;
          if (line2 == null)
            line2 = nil;
          if ($truthy($ret_or_1 = self3["$atx_section_title?"](line1))) {
            return $ret_or_1;
          } else {
            if ($truthy(line2["$nil_or_empty?"]())) {
              return nil;
            } else {
              return self3["$setext_section_title?"](line1, line2);
            }
            ;
          }
          ;
        }, -2);
        $defs(self2, "$atx_section_title?", function $Parser_atx_section_title$ques$20(line) {
          var $a, $ret_or_1 = nil;
          if ($truthy($truthy($$("Compliance").$markdown_syntax()) ? $truthy($ret_or_1 = line["$start_with?"]("=", "#")) ? $$("ExtAtxSectionTitleRx")["$=~"](line) : $ret_or_1 : $truthy($ret_or_1 = line["$start_with?"]("=")) ? $$("AtxSectionTitleRx")["$=~"](line) : $ret_or_1)) {
            return $rb_minus((($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)).$length(), 1);
          } else {
            return nil;
          }
        });
        $defs(self2, "$setext_section_title?", function $Parser_setext_section_title$ques$21(line1, line2) {
          var self3 = this, line2_len = nil, level = nil, line2_ch0 = nil;
          if ($truthy(level = $$("SETEXT_SECTION_LEVELS")["$[]"](line2_ch0 = line2.$chr())) && $truthy(self3["$uniform?"](line2, line2_ch0, line2_len = line2.$length())) && $truthy($$("SetextSectionTitleRx")["$match?"](line1)) && $truthy($rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2))) {
            return level;
          } else {
            return nil;
          }
        });
        $defs(self2, "$parse_section_title", function $$parse_section_title(reader, document2, sect_id) {
          var $a, $b, self3 = this, sect_reftext = nil, line1 = nil, $ret_or_1 = nil, sect_level = nil, sect_title = nil, atx = nil, line2_len = nil, line2_ch0 = nil, line2 = nil;
          if (sect_id == null)
            sect_id = nil;
          sect_reftext = nil;
          line1 = reader.$read_line();
          if ($truthy($truthy($$("Compliance").$markdown_syntax()) ? $truthy($ret_or_1 = line1["$start_with?"]("=", "#")) ? $$("ExtAtxSectionTitleRx")["$=~"](line1) : $ret_or_1 : $truthy($ret_or_1 = line1["$start_with?"]("=")) ? $$("AtxSectionTitleRx")["$=~"](line1) : $ret_or_1)) {
            $a = [$rb_minus((($b = $gvars["~"]) === nil ? nil : $b["$[]"](1)).$length(), 1), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](2), true], sect_level = $a[0], sect_title = $a[1], atx = $a[2], $a;
            if (!$truthy(sect_id)) {
              if ($truthy(sect_title["$end_with?"]("]]")) && $truthy($$("InlineSectionAnchorRx")["$=~"](sect_title)) && $not(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars["~"]) === nil ? nil : $b["$[]"](0)).$length())), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](2), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](3)], sect_title = $a[0], sect_id = $a[1], sect_reftext = $a[2], $a;
              }
            }
            ;
          } else if ($truthy($$("Compliance").$underline_style_section_titles()) && $truthy(line2 = reader.$peek_line(true)) && $truthy(sect_level = $$("SETEXT_SECTION_LEVELS")["$[]"](line2_ch0 = line2.$chr())) && $truthy(self3["$uniform?"](line2, line2_ch0, line2_len = line2.$length())) && $truthy(sect_title = $truthy($ret_or_1 = $$("SetextSectionTitleRx")["$=~"](line1)) ? ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1) : $ret_or_1) && $truthy($rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2))) {
            atx = false;
            if (!$truthy(sect_id)) {
              if ($truthy(sect_title["$end_with?"]("]]")) && $truthy($$("InlineSectionAnchorRx")["$=~"](sect_title)) && $not(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1))) {
                $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars["~"]) === nil ? nil : $b["$[]"](0)).$length())), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](2), ($b = $gvars["~"]) === nil ? nil : $b["$[]"](3)], sect_title = $a[0], sect_id = $a[1], sect_reftext = $a[2], $a;
              }
            }
            ;
            reader.$shift();
          } else {
            self3.$raise("Unrecognized section at " + reader.$cursor_at_prev_line());
          }
          ;
          if ($truthy(document2["$attr?"]("leveloffset"))) {
            sect_level = $rb_plus(sect_level, document2.$attr("leveloffset").$to_i());
            if ($truthy($rb_lt(sect_level, 0))) {
              sect_level = 0;
            }
            ;
          }
          ;
          return [sect_id, sect_reftext, sect_title, sect_level, atx];
        }, -3);
        $defs(self2, "$parse_header_metadata", function $$parse_header_metadata(reader, document2, retrieve) {
          var $a, self3 = this, doc_attrs = nil, $ret_or_1 = nil, authorcount = nil, implicit_author_metadata = nil, implicit_author = nil, implicit_authorinitials = nil, implicit_authors = nil, rev_line = nil, match = nil, rev_metadata = nil, component = nil, author_line = nil, author_metadata = nil, authors = nil, author_idx = nil, author_key = nil, explicit = nil, sparse = nil, author_override = nil;
          if (document2 == null)
            document2 = nil;
          if (retrieve == null)
            retrieve = true;
          doc_attrs = $truthy($ret_or_1 = document2) ? document2.$attributes() : $ret_or_1;
          self3.$process_attribute_entries(reader, document2);
          if ($truthy(reader["$has_more_lines?"]()) && $not(reader["$next_line_empty?"]())) {
            authorcount = (implicit_author_metadata = self3.$process_authors(reader.$read_line())).$delete("authorcount");
            if ($truthy(document2) && $truthy($rb_gt(($a = ["authorcount", authorcount], $send(doc_attrs, "[]=", $a), $a[$a.length - 1]), 0))) {
              $send(implicit_author_metadata, "each", [], function $$22(key, val) {
                var $b;
                if (key == null)
                  key = nil;
                if (val == null)
                  val = nil;
                if ($truthy(doc_attrs["$key?"](key))) {
                  return nil;
                } else {
                  return $b = [key, document2.$apply_header_subs(val)], $send(doc_attrs, "[]=", $b), $b[$b.length - 1];
                }
                ;
              });
              implicit_author = doc_attrs["$[]"]("author");
              implicit_authorinitials = doc_attrs["$[]"]("authorinitials");
              implicit_authors = doc_attrs["$[]"]("authors");
            }
            ;
            implicit_author_metadata["$[]="]("authorcount", authorcount);
            self3.$process_attribute_entries(reader, document2);
            if ($truthy(reader["$has_more_lines?"]()) && $not(reader["$next_line_empty?"]())) {
              rev_line = reader.$read_line();
              if ($truthy(match = $$("RevisionInfoLineRx").$match(rev_line))) {
                rev_metadata = $hash2([], {});
                if ($truthy(match["$[]"](1))) {
                  rev_metadata["$[]="]("revnumber", match["$[]"](1).$rstrip());
                }
                ;
                if (!$truthy((component = match["$[]"](2).$strip())["$empty?"]())) {
                  if ($not(match["$[]"](1)) && $truthy(component["$start_with?"]("v"))) {
                    rev_metadata["$[]="]("revnumber", component.$slice(1, component.$length()));
                  } else {
                    rev_metadata["$[]="]("revdate", component);
                  }
                }
                ;
                if ($truthy(match["$[]"](3))) {
                  rev_metadata["$[]="]("revremark", match["$[]"](3).$rstrip());
                }
                ;
                if ($truthy(document2) && $not(rev_metadata["$empty?"]())) {
                  $send(rev_metadata, "each", [], function $$23(key, val) {
                    var $b;
                    if (key == null)
                      key = nil;
                    if (val == null)
                      val = nil;
                    if ($truthy(doc_attrs["$key?"](key))) {
                      return nil;
                    } else {
                      return $b = [key, document2.$apply_header_subs(val)], $send(doc_attrs, "[]=", $b), $b[$b.length - 1];
                    }
                    ;
                  });
                }
                ;
              } else {
                reader.$unshift_line(rev_line);
              }
              ;
            }
            ;
            self3.$process_attribute_entries(reader, document2);
            reader.$skip_blank_lines();
          } else {
            implicit_author_metadata = $hash2([], {});
          }
          ;
          if ($truthy(document2)) {
            if ($truthy(doc_attrs["$key?"]("author")) && $neqeq(author_line = doc_attrs["$[]"]("author"), implicit_author)) {
              author_metadata = self3.$process_authors(author_line, true, false);
              if ($neqeq(doc_attrs["$[]"]("authorinitials"), implicit_authorinitials)) {
                author_metadata.$delete("authorinitials");
              }
              ;
            } else if ($truthy(doc_attrs["$key?"]("authors")) && $neqeq(author_line = doc_attrs["$[]"]("authors"), implicit_authors)) {
              author_metadata = self3.$process_authors(author_line, true);
            } else {
              $a = [[], 1, "author_1", false, false], authors = $a[0], author_idx = $a[1], author_key = $a[2], explicit = $a[3], sparse = $a[4], $a;
              while ($truthy(doc_attrs["$key?"](author_key))) {
                if ($eqeq(author_override = doc_attrs["$[]"](author_key), implicit_author_metadata["$[]"](author_key))) {
                  authors["$<<"](nil);
                  sparse = true;
                } else {
                  authors["$<<"](author_override);
                  explicit = true;
                }
                ;
                author_key = "author_" + (author_idx = $rb_plus(author_idx, 1));
              }
              ;
              if ($truthy(explicit)) {
                if ($truthy(sparse)) {
                  $send(authors, "each_with_index", [], function $$24(author, idx) {
                    var $b, name_idx = nil;
                    if (author == null)
                      author = nil;
                    if (idx == null)
                      idx = nil;
                    if ($truthy(author)) {
                      return nil;
                    }
                    ;
                    return $b = [idx, $send([implicit_author_metadata["$[]"]("firstname_" + (name_idx = $rb_plus(idx, 1))), implicit_author_metadata["$[]"]("middlename_" + name_idx), implicit_author_metadata["$[]"]("lastname_" + name_idx)].$compact(), "map", [], function $$25(it) {
                      if (it == null)
                        it = nil;
                      return it.$tr(" ", "_");
                    }).$join(" ")], $send(authors, "[]=", $b), $b[$b.length - 1];
                  });
                }
                ;
                author_metadata = self3.$process_authors(authors, true, false);
              } else {
                author_metadata = $hash2(["authorcount"], { "authorcount": 0 });
              }
              ;
            }
            ;
            if ($eqeq(author_metadata["$[]"]("authorcount"), 0)) {
              if ($truthy(authorcount)) {
                author_metadata = nil;
              } else {
                doc_attrs["$[]="]("authorcount", 0);
              }
            } else {
              doc_attrs.$update(author_metadata);
              if ($not(doc_attrs["$key?"]("email")) && $truthy(doc_attrs["$key?"]("email_1"))) {
                doc_attrs["$[]="]("email", doc_attrs["$[]"]("email_1"));
              }
              ;
            }
            ;
          }
          ;
          if ($truthy(retrieve)) {
            return implicit_author_metadata.$merge(rev_metadata.$to_h(), author_metadata.$to_h());
          } else {
            return nil;
          }
          ;
        }, -2);
        $defs(self2, "$process_authors", function $$process_authors(author_line, names_only, multiple) {
          var author_metadata = nil, author_idx = nil;
          if (names_only == null)
            names_only = false;
          if (multiple == null)
            multiple = true;
          author_metadata = $hash2([], {});
          author_idx = 0;
          $send($truthy(multiple) && $truthy(author_line["$include?"](";")) ? author_line.$split($$("AuthorDelimiterRx")) : [].concat($to_a(author_line)), "each", [], function $$26(author_entry) {
            var $a, key_map = nil, segments = nil, match = nil, author = nil, fname = nil, mname = nil, lname = nil, $ret_or_1 = nil;
            if (author_entry == null)
              author_entry = nil;
            if ($truthy(author_entry["$empty?"]())) {
              return nil;
            }
            ;
            key_map = $hash2([], {});
            if ($eqeq(author_idx = $rb_plus(author_idx, 1), 1)) {
              $send($$("AuthorKeys"), "each", [], function $$27(key) {
                var $a2;
                if (key == null)
                  key = nil;
                return $a2 = [key.$to_sym(), key], $send(key_map, "[]=", $a2), $a2[$a2.length - 1];
              });
            } else {
              $send($$("AuthorKeys"), "each", [], function $$28(key) {
                var $a2;
                if (key == null)
                  key = nil;
                return $a2 = [key.$to_sym(), "" + key + "_" + author_idx], $send(key_map, "[]=", $a2), $a2[$a2.length - 1];
              });
            }
            ;
            if ($truthy(names_only)) {
              if ($truthy(author_entry["$include?"]("<"))) {
                author_metadata["$[]="](key_map["$[]"]("author"), author_entry.$tr("_", " "));
                author_entry = author_entry.$gsub($$("XmlSanitizeRx"), "");
              }
              ;
              if ($eqeq((segments = author_entry.$split(nil, 3)).$size(), 3)) {
                segments["$<<"](segments.$pop().$squeeze(" "));
              }
              ;
            } else if ($truthy(match = $$("AuthorInfoLineRx").$match(author_entry))) {
              (segments = match.$to_a()).$shift();
            }
            ;
            if ($truthy(segments)) {
              author = ($a = [key_map["$[]"]("firstname"), fname = segments["$[]"](0).$tr("_", " ")], $send(author_metadata, "[]=", $a), $a[$a.length - 1]);
              author_metadata["$[]="](key_map["$[]"]("authorinitials"), fname.$chr());
              if ($truthy(segments["$[]"](1))) {
                if ($truthy(segments["$[]"](2))) {
                  author_metadata["$[]="](key_map["$[]"]("middlename"), mname = segments["$[]"](1).$tr("_", " "));
                  author_metadata["$[]="](key_map["$[]"]("lastname"), lname = segments["$[]"](2).$tr("_", " "));
                  author = $rb_plus($rb_plus($rb_plus($rb_plus(fname, " "), mname), " "), lname);
                  author_metadata["$[]="](key_map["$[]"]("authorinitials"), "" + fname.$chr() + mname.$chr() + lname.$chr());
                } else {
                  author_metadata["$[]="](key_map["$[]"]("lastname"), lname = segments["$[]"](1).$tr("_", " "));
                  author = $rb_plus($rb_plus(fname, " "), lname);
                  author_metadata["$[]="](key_map["$[]"]("authorinitials"), "" + fname.$chr() + lname.$chr());
                }
              }
              ;
              if ($truthy($ret_or_1 = author_metadata["$[]"](key_map["$[]"]("author")))) {
                $ret_or_1;
              } else {
                author_metadata["$[]="](key_map["$[]"]("author"), author);
              }
              ;
              if (!($truthy(names_only) || $not(segments["$[]"](3)))) {
                author_metadata["$[]="](key_map["$[]"]("email"), segments["$[]"](3));
              }
              ;
            } else {
              author_metadata["$[]="](key_map["$[]"]("author"), ($a = [key_map["$[]"]("firstname"), fname = author_entry.$squeeze(" ").$strip()], $send(author_metadata, "[]=", $a), $a[$a.length - 1]));
              author_metadata["$[]="](key_map["$[]"]("authorinitials"), fname.$chr());
            }
            ;
            if ($eqeq(author_idx, 1)) {
              return $a = ["authors", author_metadata["$[]"](key_map["$[]"]("author"))], $send(author_metadata, "[]=", $a), $a[$a.length - 1];
            } else {
              if ($eqeq(author_idx, 2)) {
                $send($$("AuthorKeys"), "each", [], function $$29(key) {
                  var $b;
                  if (key == null)
                    key = nil;
                  if ($truthy(author_metadata["$key?"](key))) {
                    return $b = ["" + key + "_1", author_metadata["$[]"](key)], $send(author_metadata, "[]=", $b), $b[$b.length - 1];
                  } else {
                    return nil;
                  }
                  ;
                });
              }
              ;
              return $a = ["authors", "" + author_metadata["$[]"]("authors") + ", " + author_metadata["$[]"](key_map["$[]"]("author"))], $send(author_metadata, "[]=", $a), $a[$a.length - 1];
            }
            ;
          });
          author_metadata["$[]="]("authorcount", author_idx);
          return author_metadata;
        }, -2);
        $defs(self2, "$parse_block_metadata_lines", function $$parse_block_metadata_lines(reader, document2, attributes, options) {
          var self3 = this, $ret_or_1 = nil;
          if (attributes == null)
            attributes = $hash2([], {});
          if (options == null)
            options = $hash2([], {});
          while ($truthy(self3.$parse_block_metadata_line(reader, document2, attributes, options))) {
            reader.$shift();
            if ($truthy($ret_or_1 = reader.$skip_blank_lines())) {
              $ret_or_1;
            } else {
              break;
            }
            ;
          }
          ;
          return attributes;
        }, -3);
        $defs(self2, "$parse_block_metadata_line", function $$parse_block_metadata_line(reader, document2, attributes, options) {
          var $a, self3 = this, normal = nil, next_line = nil, reftext = nil, current_style = nil, $ret_or_1 = nil, ll = nil;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          if (options == null)
            options = $hash2([], {});
          if ($truthy(next_line = reader.$peek_line()) && $truthy($truthy(options["$[]"]("text_only")) ? next_line["$start_with?"]("[", "/") : normal = next_line["$start_with?"]("[", ".", "/", ":"))) {
            if ($truthy(next_line["$start_with?"]("["))) {
              if ($truthy(next_line["$start_with?"]("[["))) {
                if ($truthy(next_line["$end_with?"]("]]")) && $truthy($$("BlockAnchorRx")["$=~"](next_line))) {
                  attributes["$[]="]("id", ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1));
                  if ($truthy(reftext = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2))) {
                    attributes["$[]="]("reftext", $truthy(reftext["$include?"]($$("ATTR_REF_HEAD"))) ? document2.$sub_attributes(reftext) : reftext);
                  }
                  ;
                  return true;
                }
              } else if ($truthy(next_line["$end_with?"]("]")) && $truthy($$("BlockAttributeListRx")["$=~"](next_line))) {
                current_style = attributes["$[]"](1);
                if ($truthy(document2.$parse_attributes(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), [], $hash2(["sub_input", "sub_result", "into"], { "sub_input": true, "sub_result": true, "into": attributes }))["$[]"](1))) {
                  attributes["$[]="](1, $truthy($ret_or_1 = self3.$parse_style_attribute(attributes, reader)) ? $ret_or_1 : current_style);
                }
                ;
                return true;
              }
            } else if ($truthy(normal) && $truthy(next_line["$start_with?"]("."))) {
              if ($truthy($$("BlockTitleRx")["$=~"](next_line))) {
                attributes["$[]="]("title", ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1));
                return true;
              }
            } else if ($not(normal) || $truthy(next_line["$start_with?"]("/"))) {
              if ($truthy(next_line["$start_with?"]("//"))) {
                if ($eqeq(next_line, "//")) {
                  return true;
                } else if ($truthy(normal) && $truthy(self3["$uniform?"](next_line, "/", ll = next_line.$length()))) {
                  if (!$eqeq(ll, 3)) {
                    reader.$read_lines_until($hash2(["terminator", "skip_first_line", "preserve_last_line", "skip_processing", "context"], { "terminator": next_line, "skip_first_line": true, "preserve_last_line": true, "skip_processing": true, "context": "comment" }));
                    return true;
                  }
                } else if (!$truthy(next_line["$start_with?"]("///"))) {
                  return true;
                }
              }
            } else if ($truthy(normal) && $truthy(next_line["$start_with?"](":")) && $truthy($$("AttributeEntryRx")["$=~"](next_line))) {
              self3.$process_attribute_entry(reader, document2, attributes, $gvars["~"]);
              return true;
            }
          }
          ;
          return nil;
        }, -4);
        $defs(self2, "$process_attribute_entries", function $$process_attribute_entries(reader, document2, attributes) {
          var self3 = this;
          if (attributes == null)
            attributes = nil;
          reader.$skip_comment_lines();
          while ($truthy(self3.$process_attribute_entry(reader, document2, attributes))) {
            reader.$shift();
            reader.$skip_comment_lines();
          }
          ;
        }, -3);
        $defs(self2, "$process_attribute_entry", function $$process_attribute_entry(reader, document2, attributes, match) {
          var $a, self3 = this, value = nil, con = nil, $ret_or_1 = nil, next_line = nil, $ret_or_2 = nil, keep_open = nil;
          if (attributes == null)
            attributes = nil;
          if (match == null)
            match = nil;
          if ($truthy(match) || $truthy(match = $truthy(reader["$has_more_lines?"]()) ? $$("AttributeEntryRx").$match(reader.$peek_line()) : nil)) {
            if ($truthy((value = match["$[]"](2))["$nil_or_empty?"]())) {
              value = "";
            } else if ($truthy(value["$end_with?"]($$("LINE_CONTINUATION"), $$("LINE_CONTINUATION_LEGACY")))) {
              $a = [value.$slice($rb_minus(value.$length(), 2), 2), value.$slice(0, $rb_minus(value.$length(), 2)).$rstrip()], con = $a[0], value = $a[1], $a;
              while ($truthy($truthy($ret_or_1 = reader.$advance()) ? (next_line = $truthy($ret_or_2 = reader.$peek_line()) ? $ret_or_2 : "")["$empty?"]()["$!"]() : $ret_or_1)) {
                next_line = next_line.$lstrip();
                if ($truthy(keep_open = next_line["$end_with?"](con))) {
                  next_line = next_line.$slice(0, $rb_minus(next_line.$length(), 2)).$rstrip();
                }
                ;
                value = "" + value + ($truthy(value["$end_with?"]($$("HARD_LINE_BREAK"))) ? $$("LF") : " ") + next_line;
                if (!$truthy(keep_open)) {
                  break;
                }
                ;
              }
              ;
            }
            ;
            self3.$store_attribute(match["$[]"](1), value, document2, attributes);
            return true;
          } else {
            return nil;
          }
          ;
        }, -3);
        $defs(self2, "$store_attribute", function $$store_attribute(name, value, doc, attrs) {
          var self3 = this, resolved_value = nil;
          if (doc == null)
            doc = nil;
          if (attrs == null)
            attrs = nil;
          if ($truthy(name["$end_with?"]("!"))) {
            name = name.$chop();
            value = nil;
          } else if ($truthy(name["$start_with?"]("!"))) {
            name = name.$slice(1, name.$length());
            value = nil;
          }
          ;
          if ($eqeq(name = self3.$sanitize_attribute_name(name), "numbered")) {
            name = "sectnums";
          } else if ($eqeq(name, "hardbreaks")) {
            name = "hardbreaks-option";
          } else if ($eqeq(name, "showtitle")) {
            self3.$store_attribute("notitle", $truthy(value) ? nil : "", doc, attrs);
          }
          ;
          if ($truthy(doc)) {
            if ($truthy(value)) {
              if ($eqeq(name, "leveloffset")) {
                if ($truthy(value["$start_with?"]("+"))) {
                  value = $rb_plus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s();
                } else if ($truthy(value["$start_with?"]("-"))) {
                  value = $rb_minus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s();
                }
              }
              ;
              if ($truthy(resolved_value = doc.$set_attribute(name, value))) {
                value = resolved_value;
                if ($truthy(attrs)) {
                  $$$($$("Document"), "AttributeEntry").$new(name, value).$save_to(attrs);
                }
                ;
              }
              ;
            } else if ($truthy(doc.$delete_attribute(name)) && $truthy(attrs)) {
              $$$($$("Document"), "AttributeEntry").$new(name, value).$save_to(attrs);
            }
          } else if ($truthy(attrs)) {
            $$$($$("Document"), "AttributeEntry").$new(name, value).$save_to(attrs);
          }
          ;
          return [name, value];
        }, -3);
        $defs(self2, "$resolve_list_marker", function $$resolve_list_marker(list_type, marker, ordinal, validate, reader) {
          var self3 = this;
          if (ordinal == null)
            ordinal = 0;
          if (validate == null)
            validate = false;
          if (reader == null)
            reader = nil;
          switch (list_type) {
            case "ulist":
              return marker;
            case "olist":
              return self3.$resolve_ordered_list_marker(marker, ordinal, validate, reader)["$[]"](0);
            default:
              return "<1>";
          }
          ;
        }, -3);
        $defs(self2, "$resolve_ordered_list_marker", function $$resolve_ordered_list_marker(marker, ordinal, validate, reader) {
          var self3 = this, style = nil, expected = nil, actual = nil;
          if (ordinal == null)
            ordinal = 0;
          if (validate == null)
            validate = false;
          if (reader == null)
            reader = nil;
          if ($truthy(marker["$start_with?"]("."))) {
            return [marker];
          }
          ;
          switch (style = $send($$("ORDERED_LIST_STYLES"), "find", [], function $$30(s) {
            if (s == null)
              s = nil;
            return $$("OrderedListMarkerRxMap")["$[]"](s)["$match?"](marker);
          })) {
            case "arabic":
              if ($truthy(validate)) {
                expected = $rb_plus(ordinal, 1);
                actual = marker.$to_i();
              }
              ;
              marker = "1.";
              break;
            case "loweralpha":
              if ($truthy(validate)) {
                expected = $rb_plus("a"["$[]"](0).$ord(), ordinal).$chr();
                actual = marker.$chop();
              }
              ;
              marker = "a.";
              break;
            case "upperalpha":
              if ($truthy(validate)) {
                expected = $rb_plus("A"["$[]"](0).$ord(), ordinal).$chr();
                actual = marker.$chop();
              }
              ;
              marker = "A.";
              break;
            case "lowerroman":
              if ($truthy(validate)) {
                expected = $$("Helpers").$int_to_roman($rb_plus(ordinal, 1)).$downcase();
                actual = marker.$chop();
              }
              ;
              marker = "i)";
              break;
            case "upperroman":
              if ($truthy(validate)) {
                expected = $$("Helpers").$int_to_roman($rb_plus(ordinal, 1));
                actual = marker.$chop();
              }
              ;
              marker = "I)";
              break;
            default:
              nil;
          }
          ;
          if ($truthy(validate) && $neqeq(expected, actual)) {
            self3.$logger().$warn(self3.$message_with_context("list item index: expected " + expected + ", got " + actual, $hash2(["source_location"], { "source_location": reader.$cursor() })));
          }
          ;
          return [marker, style];
        }, -2);
        $defs(self2, "$is_sibling_list_item?", function $Parser_is_sibling_list_item$ques$31(line, list_type, sibling_trait) {
          var $a, self3 = this, $ret_or_1 = nil;
          if ($eqeqeq($$$("Regexp"), sibling_trait)) {
            return sibling_trait["$match?"](line);
          } else if ($truthy($ret_or_1 = $$("ListRxMap")["$[]"](list_type)["$=~"](line))) {
            return sibling_trait["$=="](self3.$resolve_list_marker(list_type, ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1)));
          } else {
            return $ret_or_1;
          }
        });
        $defs(self2, "$parse_table", function $$parse_table(table_reader, parent, attributes) {
          var $a, $b, $c, self3 = this, table = nil, colspecs = nil, explicit_colspecs = nil, skipped = nil, $ret_or_1 = nil, implicit_header = nil, parser_ctx = nil, format = nil, loop_idx = nil, implicit_header_boundary = nil, line = nil, beyond_first = nil, next_cellspec = nil, m = nil, pre_match = nil, post_match = nil, cell_text = nil, $logical_op_recvr_tmp_2 = nil;
          table = $$("Table").$new(parent, attributes);
          if ($truthy(attributes["$key?"]("cols")) && $not((colspecs = self3.$parse_colspecs(attributes["$[]"]("cols")))["$empty?"]())) {
            table.$create_columns(colspecs);
            explicit_colspecs = true;
          }
          ;
          skipped = $truthy($ret_or_1 = table_reader.$skip_blank_lines()) ? $ret_or_1 : 0;
          if ($truthy(attributes["$[]"]("header-option"))) {
            table["$has_header_option="](true);
          } else if ($eqeq(skipped, 0) && $not(attributes["$[]"]("noheader-option"))) {
            table["$has_header_option="]("implicit");
            implicit_header = true;
          }
          ;
          parser_ctx = $$$($$("Table"), "ParserContext").$new(table_reader, table, attributes);
          $a = [parser_ctx.$format(), -1, nil], format = $a[0], loop_idx = $a[1], implicit_header_boundary = $a[2], $a;
          while ($truthy(line = table_reader.$read_line())) {
            if ($truthy(beyond_first = $rb_gt(loop_idx = $rb_plus(loop_idx, 1), 0)) && $truthy(line["$empty?"]())) {
              line = nil;
              if ($truthy(implicit_header_boundary)) {
                implicit_header_boundary = $rb_plus(implicit_header_boundary, 1);
              }
              ;
            } else if ($eqeq(format, "psv")) {
              if ($truthy(parser_ctx["$starts_with_delimiter?"](line))) {
                line = line.$slice(1, line.$length());
                parser_ctx.$close_open_cell();
                if ($truthy(implicit_header_boundary)) {
                  implicit_header_boundary = nil;
                }
                ;
              } else {
                $b = self3.$parse_cellspec(line, "start", parser_ctx.$delimiter()), $a = $to_ary($b), next_cellspec = $a[0] == null ? nil : $a[0], line = $a[1] == null ? nil : $a[1], $b;
                if ($truthy(next_cellspec)) {
                  parser_ctx.$close_open_cell(next_cellspec);
                  if ($truthy(implicit_header_boundary)) {
                    implicit_header_boundary = nil;
                  }
                  ;
                } else if ($truthy(implicit_header_boundary) && $eqeq(implicit_header_boundary, loop_idx)) {
                  table["$has_header_option="](implicit_header = implicit_header_boundary = nil);
                }
                ;
              }
            }
            ;
            if (!$truthy(beyond_first)) {
              table_reader.$mark();
              if ($truthy(implicit_header)) {
                if ($truthy(table_reader["$has_more_lines?"]()) && $truthy(table_reader.$peek_line()["$empty?"]())) {
                  implicit_header_boundary = 1;
                } else {
                  table["$has_header_option="](implicit_header = nil);
                }
              }
              ;
            }
            ;
            $a = false;
            while ($a || $truthy(true)) {
              $a = false;
              if ($truthy(line) && $truthy(m = parser_ctx.$match_delimiter(line))) {
                $b = [m.$pre_match(), m.$post_match()], pre_match = $b[0], post_match = $b[1], $b;
                if ($eqeqeq("csv", $ret_or_1 = format)) {
                  if ($truthy(parser_ctx["$buffer_has_unclosed_quotes?"](pre_match))) {
                    parser_ctx.$skip_past_delimiter(pre_match);
                    if ($truthy((line = post_match)["$empty?"]())) {
                      break;
                    }
                    ;
                    $a = true;
                    continue;
                  }
                  ;
                  parser_ctx["$buffer="]("" + parser_ctx.$buffer() + pre_match);
                } else if ($eqeqeq("dsv", $ret_or_1)) {
                  if ($truthy(pre_match["$end_with?"]("\\"))) {
                    parser_ctx.$skip_past_escaped_delimiter(pre_match);
                    if ($truthy((line = post_match)["$empty?"]())) {
                      parser_ctx["$buffer="]("" + parser_ctx.$buffer() + $$("LF"));
                      parser_ctx.$keep_cell_open();
                      break;
                    }
                    ;
                    $a = true;
                    continue;
                  }
                  ;
                  parser_ctx["$buffer="]("" + parser_ctx.$buffer() + pre_match);
                } else {
                  if ($truthy(pre_match["$end_with?"]("\\"))) {
                    parser_ctx.$skip_past_escaped_delimiter(pre_match);
                    if ($truthy((line = post_match)["$empty?"]())) {
                      parser_ctx["$buffer="]("" + parser_ctx.$buffer() + $$("LF"));
                      parser_ctx.$keep_cell_open();
                      break;
                    }
                    ;
                    $a = true;
                    continue;
                  }
                  ;
                  $c = self3.$parse_cellspec(pre_match), $b = $to_ary($c), next_cellspec = $b[0] == null ? nil : $b[0], cell_text = $b[1] == null ? nil : $b[1], $c;
                  parser_ctx.$push_cellspec(next_cellspec);
                  parser_ctx["$buffer="]("" + parser_ctx.$buffer() + cell_text);
                }
                ;
                if ($truthy((line = post_match)["$empty?"]())) {
                  line = nil;
                }
                ;
                parser_ctx.$close_cell();
              } else {
                parser_ctx["$buffer="]("" + parser_ctx.$buffer() + line + $$("LF"));
                switch (format) {
                  case "csv":
                    if ($truthy(parser_ctx["$buffer_has_unclosed_quotes?"]())) {
                      if ($truthy(implicit_header_boundary) && $eqeq(loop_idx, 0)) {
                        table["$has_header_option="](implicit_header = implicit_header_boundary = nil);
                      }
                      ;
                      parser_ctx.$keep_cell_open();
                    } else {
                      parser_ctx.$close_cell(true);
                    }
                    break;
                  case "dsv":
                    parser_ctx.$close_cell(true);
                    break;
                  default:
                    parser_ctx.$keep_cell_open();
                }
                ;
                break;
              }
            }
            ;
            if ($truthy(parser_ctx["$cell_open?"]())) {
              if (!$truthy(table_reader["$has_more_lines?"]())) {
                parser_ctx.$close_cell(true);
              }
            } else if ($truthy($ret_or_1 = table_reader.$skip_blank_lines())) {
              $ret_or_1;
            } else {
              break;
            }
            ;
          }
          ;
          if (!($eqeq(($logical_op_recvr_tmp_2 = table.$attributes(), $truthy($ret_or_1 = $logical_op_recvr_tmp_2["$[]"]("colcount")) ? $ret_or_1 : ($a = ["colcount", table.$columns().$size()], $send($logical_op_recvr_tmp_2, "[]=", $a), $a[$a.length - 1])), 0) || $truthy(explicit_colspecs))) {
            table.$assign_column_widths();
          }
          ;
          if ($truthy(implicit_header)) {
            table["$has_header_option="](true);
          }
          ;
          table.$partition_header_footer(attributes);
          return table;
        });
        $defs(self2, "$parse_colspecs", function $$parse_colspecs(records) {
          var specs = nil;
          if ($truthy(records["$include?"](" "))) {
            records = records.$delete(" ");
          }
          ;
          if ($eqeq(records, records.$to_i().$to_s())) {
            return $send($$$("Array"), "new", [records.$to_i()], function $$32() {
              return $hash2(["width"], { "width": 1 });
            });
          }
          ;
          specs = [];
          $send($truthy(records["$include?"](",")) ? records.$split(",", -1) : records.$split(";", -1), "each", [], function $$33(record) {
            var $a, $b, m = nil, spec = nil, colspec = nil, rowspec = nil, width = nil;
            if (record == null)
              record = nil;
            if ($truthy(record["$empty?"]())) {
              return specs["$<<"]($hash2(["width"], { "width": 1 }));
            } else if ($truthy(m = $$("ColumnSpecRx").$match(record))) {
              spec = $hash2([], {});
              if ($truthy(m["$[]"](2))) {
                $b = m["$[]"](2).$split("."), $a = $to_ary($b), colspec = $a[0] == null ? nil : $a[0], rowspec = $a[1] == null ? nil : $a[1], $b;
                if ($not(colspec["$nil_or_empty?"]()) && $truthy($$("TableCellHorzAlignments")["$key?"](colspec))) {
                  spec["$[]="]("halign", $$("TableCellHorzAlignments")["$[]"](colspec));
                }
                ;
                if ($not(rowspec["$nil_or_empty?"]()) && $truthy($$("TableCellVertAlignments")["$key?"](rowspec))) {
                  spec["$[]="]("valign", $$("TableCellVertAlignments")["$[]"](rowspec));
                }
                ;
              }
              ;
              if ($truthy(width = m["$[]"](3))) {
                spec["$[]="]("width", $eqeq(width, "~") ? -1 : width.$to_i());
              } else {
                spec["$[]="]("width", 1);
              }
              ;
              if ($truthy(m["$[]"](4)) && $truthy($$("TableCellStyles")["$key?"](m["$[]"](4)))) {
                spec["$[]="]("style", $$("TableCellStyles")["$[]"](m["$[]"](4)));
              }
              ;
              if ($truthy(m["$[]"](1))) {
                return $send(1, "upto", [m["$[]"](1).$to_i()], function $$34() {
                  return specs["$<<"](spec.$merge());
                });
              } else {
                return specs["$<<"](spec);
              }
              ;
            } else {
              return nil;
            }
            ;
          });
          return specs;
        });
        $defs(self2, "$parse_cellspec", function $$parse_cellspec(line, pos, delimiter) {
          var $a, $b, m = nil, rest = nil, spec_part = nil, _ = nil, spec = nil, colspec = nil, rowspec = nil;
          if (pos == null)
            pos = "end";
          if (delimiter == null)
            delimiter = nil;
          $a = [nil, ""], m = $a[0], rest = $a[1], $a;
          if ($eqeq(pos, "start")) {
            if ($truthy(line["$include?"](delimiter))) {
              $b = line.$partition(delimiter), $a = $to_ary($b), spec_part = $a[0] == null ? nil : $a[0], _ = $a[1] == null ? nil : $a[1], rest = $a[2] == null ? nil : $a[2], $b;
              if ($truthy(m = $$("CellSpecStartRx").$match(spec_part))) {
                if ($truthy(m["$[]"](0)["$empty?"]())) {
                  return [$hash2([], {}), rest];
                }
              } else {
                return [nil, line];
              }
              ;
            } else {
              return [nil, line];
            }
          } else if ($truthy(m = $$("CellSpecEndRx").$match(line))) {
            if ($truthy(m["$[]"](0).$lstrip()["$empty?"]())) {
              return [$hash2([], {}), line.$rstrip()];
            }
            ;
            rest = m.$pre_match();
          } else {
            return [$hash2([], {}), line];
          }
          ;
          spec = $hash2([], {});
          if ($truthy(m["$[]"](1))) {
            $b = m["$[]"](1).$split("."), $a = $to_ary($b), colspec = $a[0] == null ? nil : $a[0], rowspec = $a[1] == null ? nil : $a[1], $b;
            colspec = $truthy(colspec["$nil_or_empty?"]()) ? 1 : colspec.$to_i();
            rowspec = $truthy(rowspec["$nil_or_empty?"]()) ? 1 : rowspec.$to_i();
            switch (m["$[]"](2)) {
              case "+":
                if (!$eqeq(colspec, 1)) {
                  spec["$[]="]("colspan", colspec);
                }
                ;
                if (!$eqeq(rowspec, 1)) {
                  spec["$[]="]("rowspan", rowspec);
                }
                ;
                break;
              case "*":
                if (!$eqeq(colspec, 1)) {
                  spec["$[]="]("repeatcol", colspec);
                }
                break;
              default:
                nil;
            }
            ;
          }
          ;
          if ($truthy(m["$[]"](3))) {
            $b = m["$[]"](3).$split("."), $a = $to_ary($b), colspec = $a[0] == null ? nil : $a[0], rowspec = $a[1] == null ? nil : $a[1], $b;
            if ($not(colspec["$nil_or_empty?"]()) && $truthy($$("TableCellHorzAlignments")["$key?"](colspec))) {
              spec["$[]="]("halign", $$("TableCellHorzAlignments")["$[]"](colspec));
            }
            ;
            if ($not(rowspec["$nil_or_empty?"]()) && $truthy($$("TableCellVertAlignments")["$key?"](rowspec))) {
              spec["$[]="]("valign", $$("TableCellVertAlignments")["$[]"](rowspec));
            }
            ;
          }
          ;
          if ($truthy(m["$[]"](4)) && $truthy($$("TableCellStyles")["$key?"](m["$[]"](4)))) {
            spec["$[]="]("style", $$("TableCellStyles")["$[]"](m["$[]"](4)));
          }
          ;
          return [spec, rest];
        }, -2);
        $defs(self2, "$parse_style_attribute", function $$parse_style_attribute(attributes, reader) {
          var $a, self3 = this, raw_style = nil, name = nil, accum = nil, parsed_attrs = nil, parsed_style = nil, existing_role = nil;
          if (reader == null)
            reader = nil;
          if ($truthy(raw_style = attributes["$[]"](1)) && $not(raw_style["$include?"](" ")) && $truthy($$("Compliance").$shorthand_property_syntax())) {
            name = nil;
            accum = "";
            parsed_attrs = $hash2([], {});
            $send(raw_style, "each_char", [], function $$35(c) {
              var self4 = $$35.$$s == null ? this : $$35.$$s;
              if (c == null)
                c = nil;
              switch (c) {
                case ".":
                  self4.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                  accum = "";
                  return name = "role";
                case "#":
                  self4.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                  accum = "";
                  return name = "id";
                case "%":
                  self4.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                  accum = "";
                  return name = "option";
                default:
                  return accum = $rb_plus(accum, c);
              }
              ;
            }, { $$s: self3 });
            if ($truthy(name)) {
              self3.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
              if ($truthy(parsed_style = parsed_attrs["$[]"]("style"))) {
                attributes["$[]="]("style", parsed_style);
              }
              ;
              if ($truthy(parsed_attrs["$key?"]("id"))) {
                attributes["$[]="]("id", parsed_attrs["$[]"]("id"));
              }
              ;
              if ($truthy(parsed_attrs["$key?"]("role"))) {
                attributes["$[]="]("role", $truthy((existing_role = attributes["$[]"]("role"))["$nil_or_empty?"]()) ? parsed_attrs["$[]"]("role").$join(" ") : "" + existing_role + " " + parsed_attrs["$[]"]("role").$join(" "));
              }
              ;
              if ($truthy(parsed_attrs["$key?"]("option"))) {
                $send(parsed_attrs["$[]"]("option"), "each", [], function $$36(opt) {
                  var $a2;
                  if (opt == null)
                    opt = nil;
                  return $a2 = ["" + opt + "-option", ""], $send(attributes, "[]=", $a2), $a2[$a2.length - 1];
                });
              }
              ;
              return parsed_style;
            } else {
              return $a = ["style", raw_style], $send(attributes, "[]=", $a), $a[$a.length - 1];
            }
            ;
          } else {
            return $a = ["style", raw_style], $send(attributes, "[]=", $a), $a[$a.length - 1];
          }
          ;
        }, -2);
        $defs(self2, "$yield_buffered_attribute", function $$yield_buffered_attribute(attrs, name, value, reader) {
          var $a, self3 = this, $ret_or_1 = nil;
          if ($truthy(name)) {
            if ($truthy(value["$empty?"]())) {
              if ($truthy(reader)) {
                self3.$logger().$warn(self3.$message_with_context("invalid empty " + name + " detected in style attribute", $hash2(["source_location"], { "source_location": reader.$cursor_at_prev_line() })));
              } else {
                self3.$logger().$warn("invalid empty " + name + " detected in style attribute");
              }
            } else if ($eqeq(name, "id")) {
              if ($truthy(attrs["$key?"]("id"))) {
                if ($truthy(reader)) {
                  self3.$logger().$warn(self3.$message_with_context("multiple ids detected in style attribute", $hash2(["source_location"], { "source_location": reader.$cursor_at_prev_line() })));
                } else {
                  self3.$logger().$warn("multiple ids detected in style attribute");
                }
              }
              ;
              attrs["$[]="](name, value);
            } else {
              ($truthy($ret_or_1 = attrs["$[]"](name)) ? $ret_or_1 : ($a = [name, []], $send(attrs, "[]=", $a), $a[$a.length - 1]))["$<<"](value);
            }
          } else if (!$truthy(value["$empty?"]())) {
            attrs["$[]="]("style", value);
          }
          ;
          return nil;
        });
        $defs(self2, "$adjust_indentation!", function $Parser_adjust_indentation$excl$37(lines, indent_size, tab_size) {
          var full_tab_space = nil, block_indent = nil, new_block_indent = nil;
          if (indent_size == null)
            indent_size = 0;
          if (tab_size == null)
            tab_size = 0;
          if ($truthy(lines["$empty?"]())) {
            return nil;
          }
          ;
          if ($truthy($rb_gt(tab_size, 0)) && $truthy($send(lines, "any?", [], function $$38(line) {
            if (line == null)
              line = nil;
            return line["$include?"]($$("TAB"));
          }))) {
            full_tab_space = $rb_times(" ", tab_size);
            $send(lines, "map!", [], function $$39(line) {
              var tab_idx = nil, leading_tabs = nil, spaces_added = nil, idx = nil, result = nil;
              if (line == null)
                line = nil;
              if ($truthy(line["$empty?"]()) || $truthy((tab_idx = line.$index($$("TAB")))["$nil?"]())) {
                return line;
              } else {
                if ($eqeq(tab_idx, 0)) {
                  leading_tabs = 0;
                  (function() {
                    try {
                      var $t_break = $thrower("break");
                      return $send(line, "each_byte", [], function $$40(b) {
                        if (b == null)
                          b = nil;
                        if (!$eqeq(b, 9)) {
                          $t_break.$throw();
                        }
                        ;
                        return leading_tabs = $rb_plus(leading_tabs, 1);
                      });
                    } catch ($e) {
                      if ($e === $t_break)
                        return $e.$v;
                      throw $e;
                    }
                  })();
                  line = "" + $rb_times(full_tab_space, leading_tabs) + line.$slice(leading_tabs, line.$length());
                  if (!$truthy(line["$include?"]($$("TAB")))) {
                    return line;
                  }
                  ;
                }
                ;
                spaces_added = 0;
                idx = 0;
                result = "";
                $send(line, "each_char", [], function $$41(c) {
                  var offset = nil, spaces = nil;
                  if (c == null)
                    c = nil;
                  if ($eqeq(c, $$("TAB"))) {
                    if ($eqeq((offset = $rb_plus(idx, spaces_added))["$%"](tab_size), 0)) {
                      spaces_added = $rb_plus(spaces_added, $rb_minus(tab_size, 1));
                      result = $rb_plus(result, full_tab_space);
                    } else {
                      if (!$eqeq(spaces = $rb_minus(tab_size, offset["$%"](tab_size)), 1)) {
                        spaces_added = $rb_plus(spaces_added, $rb_minus(spaces, 1));
                      }
                      ;
                      result = $rb_plus(result, $rb_times(" ", spaces));
                    }
                  } else {
                    result = $rb_plus(result, c);
                  }
                  ;
                  return idx = $rb_plus(idx, 1);
                });
                return result;
              }
              ;
            });
          }
          ;
          if ($truthy($rb_lt(indent_size, 0))) {
            return nil;
          }
          ;
          block_indent = nil;
          (function() {
            try {
              var $t_break = $thrower("break");
              return $send(lines, "each", [], function $$42(line) {
                var line_indent = nil;
                if (line == null)
                  line = nil;
                if ($truthy(line["$empty?"]())) {
                  return nil;
                }
                ;
                if ($eqeq(line_indent = $rb_minus(line.$length(), line.$lstrip().$length()), 0)) {
                  block_indent = nil;
                  $t_break.$throw();
                }
                ;
                if ($truthy(block_indent) && $truthy($rb_lt(block_indent, line_indent))) {
                  return nil;
                } else {
                  return block_indent = line_indent;
                }
                ;
              });
            } catch ($e) {
              if ($e === $t_break)
                return $e.$v;
              throw $e;
            }
          })();
          if ($eqeq(indent_size, 0)) {
            if ($truthy(block_indent)) {
              $send(lines, "map!", [], function $$43(line) {
                if (line == null)
                  line = nil;
                if ($truthy(line["$empty?"]())) {
                  return line;
                } else {
                  return line.$slice(block_indent, line.$length());
                }
                ;
              });
            }
          } else {
            new_block_indent = $rb_times(" ", indent_size);
            if ($truthy(block_indent)) {
              $send(lines, "map!", [], function $$44(line) {
                if (line == null)
                  line = nil;
                if ($truthy(line["$empty?"]())) {
                  return line;
                } else {
                  return $rb_plus(new_block_indent, line.$slice(block_indent, line.$length()));
                }
                ;
              });
            } else {
              $send(lines, "map!", [], function $$45(line) {
                if (line == null)
                  line = nil;
                if ($truthy(line["$empty?"]())) {
                  return line;
                } else {
                  return $rb_plus(new_block_indent, line);
                }
                ;
              });
            }
            ;
          }
          ;
          return nil;
        }, -2);
        $defs(self2, "$uniform?", function $Parser_uniform$ques$46(str, chr, len) {
          return str.$count(chr)["$=="](len);
        });
        return $defs(self2, "$sanitize_attribute_name", function $$sanitize_attribute_name(name) {
          return name.$gsub($$("InvalidAttributeNameCharsRx"), "").$downcase();
        });
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/path_resolver"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $def = Opal2.def, $eqeq = Opal2.eqeq, $alias = Opal2.alias, $rb_plus = Opal2.rb_plus, $to_ary = Opal2.to_ary, $send = Opal2.send, $not = Opal2.not, $neqeq = Opal2.neqeq, $rb_gt = Opal2.rb_gt, $gvars = Opal2.gvars, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("include,attr_accessor,root?,posixify,expand_path,pwd,start_with?,==,match?,absolute_path?,+,length,descends_from?,slice,to_s,relative_path_from,new,include?,tr,partition_path,each,pop,<<,join_path,[],web_root?,unc?,index,split,delete,[]=,join,raise,!,fetch,warn,logger,empty?,nil_or_empty?,chomp,!=,>,size,extract_uri_prefix,end_with?,gsub,private,=~");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "PathResolver");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.file_separator = $proto._partition_path_web = $proto._partition_path_sys = $proto.working_dir = nil;
        self2.$include($$("Logging"));
        $const_set($nesting3[0], "DOT", ".");
        $const_set($nesting3[0], "DOT_DOT", "..");
        $const_set($nesting3[0], "DOT_SLASH", "./");
        $const_set($nesting3[0], "SLASH", "/");
        $const_set($nesting3[0], "BACKSLASH", "\\");
        $const_set($nesting3[0], "DOUBLE_SLASH", "//");
        $const_set($nesting3[0], "URI_CLASSLOADER", "uri:classloader:");
        $const_set($nesting3[0], "WindowsRootRx", /^(?:[a-zA-Z]:)?[\\\/]/);
        self2.$attr_accessor("file_separator");
        self2.$attr_accessor("working_dir");
        $def(self2, "$initialize", function $$initialize(file_separator, working_dir) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if (file_separator == null)
            file_separator = nil;
          if (working_dir == null)
            working_dir = nil;
          self3.file_separator = $truthy($ret_or_1 = $truthy($ret_or_2 = file_separator) ? $ret_or_2 : $$$($$$("File"), "ALT_SEPARATOR")) ? $ret_or_1 : $$$($$$("File"), "SEPARATOR");
          self3.working_dir = $truthy(working_dir) ? $truthy(self3["$root?"](working_dir)) ? self3.$posixify(working_dir) : $$$("File").$expand_path(working_dir) : $$$("Dir").$pwd();
          self3._partition_path_sys = $hash2([], {});
          return self3._partition_path_web = $hash2([], {});
        }, -1);
        $def(self2, "$absolute_path?", function $PathResolver_absolute_path$ques$1(path) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($truthy($ret_or_1 = path["$start_with?"]($$("SLASH")))) {
            return $ret_or_1;
          } else {
            if ($truthy($ret_or_2 = self3.file_separator["$=="]($$("BACKSLASH")))) {
              return $$("WindowsRootRx")["$match?"](path);
            } else {
              return $ret_or_2;
            }
            ;
          }
        });
        if ($eqeq($$("RUBY_ENGINE"), "opal") && $eqeq($$$("JAVASCRIPT_IO_MODULE"), "xmlhttprequest")) {
          $def(self2, "$root?", function $PathResolver_root$ques$2(path) {
            var self3 = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self3["$absolute_path?"](path))) {
              return $ret_or_1;
            } else {
              return path["$start_with?"]("file://", "http://", "https://");
            }
          });
        } else if ($eqeq($$$("RUBY_ENGINE"), "jruby")) {
          $def(self2, "$root?", function $PathResolver_root$ques$3(path) {
            var self3 = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self3["$absolute_path?"](path))) {
              return $ret_or_1;
            } else {
              return path["$start_with?"]($$("URI_CLASSLOADER"));
            }
          });
        } else {
          $alias(self2, "root?", "absolute_path?");
        }
        ;
        $def(self2, "$unc?", function $PathResolver_unc$ques$4(path) {
          return path["$start_with?"]($$("DOUBLE_SLASH"));
        });
        $def(self2, "$web_root?", function $PathResolver_web_root$ques$5(path) {
          return path["$start_with?"]($$("SLASH"));
        });
        $def(self2, "$descends_from?", function $PathResolver_descends_from$ques$6(path, base) {
          var $ret_or_1 = nil;
          if ($eqeq(base, path)) {
            return 0;
          } else if ($eqeq(base, $$("SLASH"))) {
            if ($truthy($ret_or_1 = path["$start_with?"]($$("SLASH")))) {
              return 1;
            } else {
              return $ret_or_1;
            }
          } else if ($truthy($ret_or_1 = path["$start_with?"]($rb_plus(base, $$("SLASH"))))) {
            return $rb_plus(base.$length(), 1);
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$relative_path", function $$relative_path(path, base) {
          var self3 = this, offset = nil;
          if ($truthy(self3["$root?"](path))) {
            if ($truthy(offset = self3["$descends_from?"](path, base))) {
              return path.$slice(offset, path.$length());
            } else {
              try {
                return $$("Pathname").$new(path).$relative_path_from($$("Pathname").$new(base)).$to_s();
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StandardError")])) {
                  try {
                    return path;
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
            }
          } else {
            return path;
          }
        });
        $def(self2, "$posixify", function $$posixify(path) {
          var self3 = this;
          if ($truthy(path)) {
            if ($eqeq(self3.file_separator, $$("BACKSLASH")) && $truthy(path["$include?"]($$("BACKSLASH")))) {
              return path.$tr($$("BACKSLASH"), $$("SLASH"));
            } else {
              return path;
            }
          } else {
            return "";
          }
        });
        $alias(self2, "posixfy", "posixify");
        $def(self2, "$expand_path", function $$expand_path(path) {
          var $a, $b, self3 = this, path_segments = nil, path_root = nil, resolved_segments = nil;
          $b = self3.$partition_path(path), $a = $to_ary($b), path_segments = $a[0] == null ? nil : $a[0], path_root = $a[1] == null ? nil : $a[1], $b;
          if ($truthy(path["$include?"]($$("DOT_DOT")))) {
            resolved_segments = [];
            $send(path_segments, "each", [], function $$7(segment) {
              if (segment == null)
                segment = nil;
              if ($eqeq(segment, $$("DOT_DOT"))) {
                return resolved_segments.$pop();
              } else {
                return resolved_segments["$<<"](segment);
              }
              ;
            });
            return self3.$join_path(resolved_segments, path_root);
          } else {
            return self3.$join_path(path_segments, path_root);
          }
          ;
        });
        $def(self2, "$partition_path", function $$partition_path(path, web) {
          var $a, self3 = this, result = nil, cache = nil, posix_path = nil, root = nil, path_segments = nil;
          if (web == null)
            web = nil;
          if ($truthy(result = (cache = $truthy(web) ? self3._partition_path_web : self3._partition_path_sys)["$[]"](path))) {
            return result;
          }
          ;
          posix_path = self3.$posixify(path);
          if ($truthy(web)) {
            if ($truthy(self3["$web_root?"](posix_path))) {
              root = $$("SLASH");
            } else if ($truthy(posix_path["$start_with?"]($$("DOT_SLASH")))) {
              root = $$("DOT_SLASH");
            }
          } else if ($truthy(self3["$root?"](posix_path))) {
            if ($truthy(self3["$unc?"](posix_path))) {
              root = $$("DOUBLE_SLASH");
            } else if ($truthy(posix_path["$start_with?"]($$("SLASH")))) {
              root = $$("SLASH");
            } else if ($truthy(posix_path["$start_with?"]($$("URI_CLASSLOADER")))) {
              root = posix_path.$slice(0, $$("URI_CLASSLOADER").$length());
            } else {
              root = posix_path.$slice(0, $rb_plus(posix_path.$index($$("SLASH")), 1));
            }
          } else if ($truthy(posix_path["$start_with?"]($$("DOT_SLASH")))) {
            root = $$("DOT_SLASH");
          }
          ;
          path_segments = ($truthy(root) ? posix_path.$slice(root.$length(), posix_path.$length()) : posix_path).$split($$("SLASH"));
          path_segments.$delete($$("DOT"));
          return $a = [path, [path_segments, root]], $send(cache, "[]=", $a), $a[$a.length - 1];
        }, -2);
        $def(self2, "$join_path", function $$join_path(segments, root) {
          if (root == null)
            root = nil;
          if ($truthy(root)) {
            return "" + root + segments.$join($$("SLASH"));
          } else {
            return segments.$join($$("SLASH"));
          }
          ;
        }, -2);
        $def(self2, "$system_path", function $$system_path(target, start, jail, opts) {
          var $a, $b, self3 = this, target_path = nil, $ret_or_1 = nil, target_segments = nil, jail_segments = nil, jail_root = nil, recheck = nil, start_segments = nil, start_root = nil, resolved_segments = nil, unresolved_segments = nil, warned = nil;
          if (start == null)
            start = nil;
          if (jail == null)
            jail = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($truthy(jail)) {
            if (!$truthy(self3["$root?"](jail))) {
              self3.$raise($$$("SecurityError"), "Jail is not an absolute path: " + jail);
            }
            ;
            jail = self3.$posixify(jail);
          }
          ;
          if ($truthy(target)) {
            if ($truthy(self3["$root?"](target))) {
              target_path = self3.$expand_path(target);
              if ($truthy(jail) && $not(self3["$descends_from?"](target_path, jail))) {
                if ($truthy(opts.$fetch("recover", true))) {
                  self3.$logger().$warn("" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " is outside of jail; recovering automatically");
                  $b = self3.$partition_path(target_path), $a = $to_ary($b), target_segments = $a[0] == null ? nil : $a[0], $b;
                  $b = self3.$partition_path(jail), $a = $to_ary($b), jail_segments = $a[0] == null ? nil : $a[0], jail_root = $a[1] == null ? nil : $a[1], $b;
                  return self3.$join_path($rb_plus(jail_segments, target_segments), jail_root);
                } else {
                  self3.$raise($$$("SecurityError"), "" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " " + target + " is outside of jail: " + jail + " (disallowed in safe mode)");
                }
              }
              ;
              return target_path;
            } else {
              $b = self3.$partition_path(target), $a = $to_ary($b), target_segments = $a[0] == null ? nil : $a[0], $b;
            }
          } else {
            target_segments = [];
          }
          ;
          if ($truthy(target_segments["$empty?"]())) {
            if ($truthy(start["$nil_or_empty?"]())) {
              return $truthy($ret_or_1 = jail) ? $ret_or_1 : self3.working_dir;
            } else if ($truthy(self3["$root?"](start))) {
              if ($truthy(jail)) {
                start = self3.$posixify(start);
              } else {
                return self3.$expand_path(start);
              }
            } else {
              $b = self3.$partition_path(start), $a = $to_ary($b), target_segments = $a[0] == null ? nil : $a[0], $b;
              start = $truthy($ret_or_1 = jail) ? $ret_or_1 : self3.working_dir;
            }
          } else if ($truthy(start["$nil_or_empty?"]())) {
            start = $truthy($ret_or_1 = jail) ? $ret_or_1 : self3.working_dir;
          } else if ($truthy(self3["$root?"](start))) {
            if ($truthy(jail)) {
              start = self3.$posixify(start);
            }
          } else {
            start = "" + ($truthy($ret_or_1 = jail) ? $ret_or_1 : self3.working_dir).$chomp("/") + "/" + start;
          }
          ;
          if ($truthy(jail) && $truthy(recheck = self3["$descends_from?"](start, jail)["$!"]()) && $eqeq(self3.file_separator, $$("BACKSLASH"))) {
            $b = self3.$partition_path(start), $a = $to_ary($b), start_segments = $a[0] == null ? nil : $a[0], start_root = $a[1] == null ? nil : $a[1], $b;
            $b = self3.$partition_path(jail), $a = $to_ary($b), jail_segments = $a[0] == null ? nil : $a[0], jail_root = $a[1] == null ? nil : $a[1], $b;
            if ($neqeq(start_root, jail_root)) {
              if ($truthy(opts.$fetch("recover", true))) {
                self3.$logger().$warn("start path for " + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " is outside of jail root; recovering automatically");
                start_segments = jail_segments;
                recheck = false;
              } else {
                self3.$raise($$$("SecurityError"), "start path for " + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " " + start + " refers to location outside jail root: " + jail + " (disallowed in safe mode)");
              }
            }
            ;
          } else {
            $b = self3.$partition_path(start), $a = $to_ary($b), start_segments = $a[0] == null ? nil : $a[0], jail_root = $a[1] == null ? nil : $a[1], $b;
          }
          ;
          if ($truthy((resolved_segments = $rb_plus(start_segments, target_segments))["$include?"]($$("DOT_DOT")))) {
            $a = [resolved_segments, []], unresolved_segments = $a[0], resolved_segments = $a[1], $a;
            if ($truthy(jail)) {
              if (!$truthy(jail_segments)) {
                $b = self3.$partition_path(jail), $a = $to_ary($b), jail_segments = $a[0] == null ? nil : $a[0], $b;
              }
              ;
              warned = false;
              $send(unresolved_segments, "each", [], function $$8(segment) {
                var self4 = $$8.$$s == null ? this : $$8.$$s;
                if (segment == null)
                  segment = nil;
                if ($eqeq(segment, $$("DOT_DOT"))) {
                  if ($truthy($rb_gt(resolved_segments.$size(), jail_segments.$size()))) {
                    return resolved_segments.$pop();
                  } else if ($truthy(opts.$fetch("recover", true))) {
                    if ($truthy(warned)) {
                      return nil;
                    } else {
                      self4.$logger().$warn("" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " has illegal reference to ancestor of jail; recovering automatically");
                      return warned = true;
                    }
                  } else {
                    return self4.$raise($$$("SecurityError"), "" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " " + target + " refers to location outside jail: " + jail + " (disallowed in safe mode)");
                  }
                } else {
                  return resolved_segments["$<<"](segment);
                }
                ;
              }, { $$s: self3 });
            } else {
              $send(unresolved_segments, "each", [], function $$9(segment) {
                if (segment == null)
                  segment = nil;
                if ($eqeq(segment, $$("DOT_DOT"))) {
                  return resolved_segments.$pop();
                } else {
                  return resolved_segments["$<<"](segment);
                }
                ;
              });
            }
            ;
          }
          ;
          if ($truthy(recheck)) {
            target_path = self3.$join_path(resolved_segments, jail_root);
            if ($truthy(self3["$descends_from?"](target_path, jail))) {
              return target_path;
            } else if ($truthy(opts.$fetch("recover", true))) {
              self3.$logger().$warn("" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " is outside of jail; recovering automatically");
              if (!$truthy(jail_segments)) {
                $b = self3.$partition_path(jail), $a = $to_ary($b), jail_segments = $a[0] == null ? nil : $a[0], $b;
              }
              ;
              return self3.$join_path($rb_plus(jail_segments, target_segments), jail_root);
            } else {
              return self3.$raise($$$("SecurityError"), "" + ($truthy($ret_or_1 = opts["$[]"]("target_name")) ? $ret_or_1 : "path") + " " + target + " is outside of jail: " + jail + " (disallowed in safe mode)");
            }
            ;
          } else {
            return self3.$join_path(resolved_segments, jail_root);
          }
          ;
        }, -2);
        $def(self2, "$web_path", function $$web_path(target, start) {
          var $a, $b, self3 = this, uri_prefix = nil, target_segments = nil, target_root = nil, resolved_segments = nil, resolved_path = nil;
          if (start == null)
            start = nil;
          target = self3.$posixify(target);
          start = self3.$posixify(start);
          if (!($truthy(start["$nil_or_empty?"]()) || $truthy(self3["$web_root?"](target)))) {
            $b = self3.$extract_uri_prefix("" + start + ($truthy(start["$end_with?"]($$("SLASH"))) ? "" : $$("SLASH")) + target), $a = $to_ary($b), target = $a[0] == null ? nil : $a[0], uri_prefix = $a[1] == null ? nil : $a[1], $b;
          }
          ;
          $b = self3.$partition_path(target, true), $a = $to_ary($b), target_segments = $a[0] == null ? nil : $a[0], target_root = $a[1] == null ? nil : $a[1], $b;
          resolved_segments = [];
          $send(target_segments, "each", [], function $$10(segment) {
            if (segment == null)
              segment = nil;
            if ($eqeq(segment, $$("DOT_DOT"))) {
              if ($truthy(resolved_segments["$empty?"]())) {
                if ($truthy(target_root) && $neqeq(target_root, $$("DOT_SLASH"))) {
                  return nil;
                } else {
                  return resolved_segments["$<<"](segment);
                }
              } else if ($eqeq(resolved_segments["$[]"](-1), $$("DOT_DOT"))) {
                return resolved_segments["$<<"](segment);
              } else {
                return resolved_segments.$pop();
              }
            } else {
              return resolved_segments["$<<"](segment);
            }
            ;
          });
          if ($truthy((resolved_path = self3.$join_path(resolved_segments, target_root))["$include?"](" "))) {
            resolved_path = resolved_path.$gsub(" ", "%20");
          }
          ;
          if ($truthy(uri_prefix)) {
            return "" + uri_prefix + resolved_path;
          } else {
            return resolved_path;
          }
          ;
        }, -2);
        self2.$private();
        return $def(self2, "$extract_uri_prefix", function $$extract_uri_prefix(str) {
          var $a;
          if ($truthy(str["$include?"](":")) && $truthy($$("UriSniffRx")["$=~"](str))) {
            return [str.$slice((($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)).$length(), str.$length()), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](0)];
          } else {
            return str;
          }
        });
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/reader"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $def = Opal2.def, $rb_plus = Opal2.rb_plus, $alias = Opal2.alias, $hash2 = Opal2.hash2, $not = Opal2.not, $eqeqeq = Opal2.eqeqeq, $to_ary = Opal2.to_ary, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $send = Opal2.send, $rb_minus = Opal2.rb_minus, $thrower = Opal2.thrower, $eqeq = Opal2.eqeq, $rb_times = Opal2.rb_times, $neqeq = Opal2.neqeq, $to_a = Opal2.to_a, $assign_ivar_val = Opal2.assign_ivar_val, $send2 = Opal2.send2, $find_super = Opal2.find_super, $rb_ge = Opal2.rb_ge, $gvars = Opal2.gvars, $rb_lt = Opal2.rb_lt, $hash = Opal2.hash, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("include,attr_reader,+,line_info,attr_accessor,!,===,split,file,dir,dirname,path,basename,lineno,reverse,prepare_lines,empty?,nil_or_empty?,peek_line,[],>,slice,length,process_line,times,shift,read_line,<<,-,unshift_all,has_more_lines?,read_lines,join,unshift,unshift_line,unshift_lines,replace_next_line,start_with?,==,*,read_lines_until,size,clear,cursor,[]=,fetch,!=,cursor_at_mark,warn,logger,message_with_context,pop,push,respond_to?,reverse_each,new,tap,each,instance_variables,instance_variable_get,drop,instance_variable_set,class,object_id,inspect,private,prepare_source_array,prepare_source_string,chomp,valid_encoding?,to_s,raise,to_i,attributes,catalog,pop_include,parse,path=,dup,end_with?,keys,rindex,rootname,key?,attr,reverse!,>=,exceeds_max_depth?,nil?,include_processors?,extensions,extensions?,include_processors,map,skip_front_matter!,adjust_indentation!,include?,=~,preprocess_conditional_directive,preprocess_include_directive,downcase,error,none?,any?,all?,strip,send,resolve_expr_val,rstrip,sub_attributes,attribute_missing,info,parse_attributes,find,handles?,instance,process_method,safe,resolve_include_path,method,split_delimited_value,partition,<,to_a,uniq,sort,call,each_line,infinite?,push_include,delete,first,values,value?,create_include_cursor,delete_at,keep_if,read,uriish?,attr?,require_library,normalize_system_path,file?,relative_path,path_resolver,base_dir,to_f");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      (function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Reader");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.file = $proto.lines = $proto.look_ahead = $proto.unescape_next_line = $proto.lineno = $proto.process_lines = $proto.dir = $proto.path = $proto.mark = $proto.source_lines = $proto.saved = nil;
        self2.$include($$2("Logging"));
        (function($base3, $super2) {
          var self3 = $klass($base3, $super2, "Cursor");
          var $proto2 = self3.$$prototype;
          $proto2.lineno = $proto2.path = nil;
          self3.$attr_reader("file", "dir", "path", "lineno");
          $def(self3, "$initialize", function $$initialize(file, dir, path, lineno) {
            var $a, self4 = this;
            if (dir == null)
              dir = nil;
            if (path == null)
              path = nil;
            if (lineno == null)
              lineno = 1;
            return $a = [file, dir, path, lineno], self4.file = $a[0], self4.dir = $a[1], self4.path = $a[2], self4.lineno = $a[3], $a;
          }, -2);
          $def(self3, "$advance", function $$advance(num) {
            var self4 = this;
            return self4.lineno = $rb_plus(self4.lineno, num);
          });
          $def(self3, "$line_info", function $$line_info() {
            var self4 = this;
            return "" + self4.path + ": line " + self4.lineno;
          });
          return $alias(self3, "to_s", "line_info");
        })($nesting3[0], null);
        self2.$attr_reader("file");
        self2.$attr_reader("dir");
        self2.$attr_reader("path");
        self2.$attr_reader("lineno");
        self2.$attr_reader("source_lines");
        self2.$attr_accessor("process_lines");
        self2.$attr_accessor("unterminated");
        $def(self2, "$initialize", function $$initialize(data, cursor, opts) {
          var $a, $b, self3 = this, $ret_or_1 = nil;
          if (data == null)
            data = nil;
          if (cursor == null)
            cursor = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($not(cursor)) {
            self3.file = nil;
            self3.dir = ".";
            self3.path = "<stdin>";
            self3.lineno = 1;
          } else if ($eqeqeq($$$("String"), cursor)) {
            self3.file = cursor;
            $b = $$$("File").$split(self3.file), $a = $to_ary($b), self3.dir = $a[0] == null ? nil : $a[0], self3.path = $a[1] == null ? nil : $a[1], $b;
            self3.lineno = 1;
          } else {
            if ($truthy(self3.file = cursor.$file())) {
              self3.dir = $truthy($ret_or_1 = cursor.$dir()) ? $ret_or_1 : $$$("File").$dirname(self3.file);
              self3.path = $truthy($ret_or_1 = cursor.$path()) ? $ret_or_1 : $$$("File").$basename(self3.file);
            } else {
              self3.dir = $truthy($ret_or_1 = cursor.$dir()) ? $ret_or_1 : ".";
              self3.path = $truthy($ret_or_1 = cursor.$path()) ? $ret_or_1 : "<stdin>";
            }
            ;
            self3.lineno = $truthy($ret_or_1 = cursor.$lineno()) ? $ret_or_1 : 1;
          }
          ;
          self3.lines = (self3.source_lines = self3.$prepare_lines(data, opts)).$reverse();
          self3.mark = nil;
          self3.look_ahead = 0;
          self3.process_lines = true;
          self3.unescape_next_line = false;
          self3.unterminated = nil;
          return self3.saved = nil;
        }, -1);
        $def(self2, "$has_more_lines?", function $Reader_has_more_lines$ques$1() {
          var self3 = this;
          if ($truthy(self3.lines["$empty?"]())) {
            self3.look_ahead = 0;
            return false;
          } else {
            return true;
          }
        });
        $def(self2, "$empty?", function $Reader_empty$ques$2() {
          var self3 = this;
          if ($truthy(self3.lines["$empty?"]())) {
            self3.look_ahead = 0;
            return true;
          } else {
            return false;
          }
        });
        $alias(self2, "eof?", "empty?");
        $def(self2, "$next_line_empty?", function $Reader_next_line_empty$ques$3() {
          var self3 = this;
          return self3.$peek_line()["$nil_or_empty?"]();
        });
        $def(self2, "$peek_line", function $$peek_line(direct) {
          var self3 = this, next_line = nil, line = nil;
          if (direct == null)
            direct = false;
          while ($truthy(true)) {
            next_line = self3.lines["$[]"](-1);
            if ($truthy(direct) || $truthy($rb_gt(self3.look_ahead, 0))) {
              return $truthy(self3.unescape_next_line) ? next_line.$slice(1, next_line.$length()) : next_line;
            } else if ($truthy(next_line)) {
              if ($truthy(line = self3.$process_line(next_line))) {
                return line;
              }
            } else {
              self3.look_ahead = 0;
              return nil;
            }
            ;
          }
          ;
        }, -1);
        $def(self2, "$peek_lines", function $$peek_lines(num, direct) {
          var self3 = this, old_look_ahead = nil, result = nil, $ret_or_1 = nil;
          if (num == null)
            num = nil;
          if (direct == null)
            direct = false;
          old_look_ahead = self3.look_ahead;
          result = [];
          (function() {
            try {
              var $t_break = $thrower("break");
              return $send($truthy($ret_or_1 = num) ? $ret_or_1 : $$2("MAX_INT"), "times", [], function $$4() {
                var self4 = $$4.$$s == null ? this : $$4.$$s, line = nil;
                if (self4.lineno == null)
                  self4.lineno = nil;
                if ($truthy(line = $truthy(direct) ? self4.$shift() : self4.$read_line())) {
                  return result["$<<"](line);
                } else {
                  if ($truthy(direct)) {
                    self4.lineno = $rb_minus(self4.lineno, 1);
                  }
                  ;
                  $t_break.$throw();
                }
              }, { $$s: self3 });
            } catch ($e) {
              if ($e === $t_break)
                return $e.$v;
              throw $e;
            }
          })();
          if (!$truthy(result["$empty?"]())) {
            self3.$unshift_all(result);
            if ($truthy(direct)) {
              self3.look_ahead = old_look_ahead;
            }
            ;
          }
          ;
          return result;
        }, -1);
        $def(self2, "$read_line", function $$read_line() {
          var self3 = this;
          if ($truthy($rb_gt(self3.look_ahead, 0)) || $truthy(self3["$has_more_lines?"]())) {
            return self3.$shift();
          } else {
            return nil;
          }
        });
        $def(self2, "$read_lines", function $$read_lines() {
          var self3 = this, lines = nil;
          lines = [];
          while ($truthy(self3["$has_more_lines?"]())) {
            lines["$<<"](self3.$shift());
          }
          ;
          return lines;
        });
        $alias(self2, "readlines", "read_lines");
        $def(self2, "$read", function $$read() {
          var self3 = this;
          return self3.$read_lines().$join($$2("LF"));
        });
        $def(self2, "$advance", function $$advance() {
          var self3 = this;
          if ($truthy(self3.$shift())) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$unshift_line", function $$unshift_line(line_to_restore) {
          var self3 = this;
          self3.$unshift(line_to_restore);
          return nil;
        });
        $alias(self2, "restore_line", "unshift_line");
        $def(self2, "$unshift_lines", function $$unshift_lines(lines_to_restore) {
          var self3 = this;
          return self3.$unshift_all(lines_to_restore);
        });
        $alias(self2, "restore_lines", "unshift_lines");
        $def(self2, "$replace_next_line", function $$replace_next_line(replacement) {
          var self3 = this;
          self3.$shift();
          self3.$unshift(replacement);
          return true;
        });
        $alias(self2, "replace_line", "replace_next_line");
        $def(self2, "$skip_blank_lines", function $$skip_blank_lines() {
          var self3 = this, num_skipped = nil, next_line = nil;
          if ($truthy(self3["$empty?"]())) {
            return nil;
          }
          ;
          num_skipped = 0;
          while ($truthy(next_line = self3.$peek_line())) {
            if ($truthy(next_line["$empty?"]())) {
              self3.$shift();
              num_skipped = $rb_plus(num_skipped, 1);
            } else {
              return num_skipped;
            }
          }
          ;
        });
        $def(self2, "$skip_comment_lines", function $$skip_comment_lines() {
          var self3 = this, $ret_or_1 = nil, next_line = nil, ll = nil;
          if ($truthy(self3["$empty?"]())) {
            return nil;
          }
          ;
          while ($truthy($truthy($ret_or_1 = next_line = self3.$peek_line()) ? next_line["$empty?"]()["$!"]() : $ret_or_1)) {
            if ($truthy(next_line["$start_with?"]("//"))) {
              if ($truthy(next_line["$start_with?"]("///"))) {
                if ($truthy($rb_gt(ll = next_line.$length(), 3)) && $eqeq(next_line, $rb_times("/", ll))) {
                  self3.$read_lines_until($hash2(["terminator", "skip_first_line", "read_last_line", "skip_processing", "context"], { "terminator": next_line, "skip_first_line": true, "read_last_line": true, "skip_processing": true, "context": "comment" }));
                } else {
                  break;
                }
              } else {
                self3.$shift();
              }
            } else {
              break;
            }
          }
          ;
          return nil;
        });
        $def(self2, "$skip_line_comments", function $$skip_line_comments() {
          var self3 = this, comment_lines = nil, $ret_or_1 = nil, next_line = nil;
          if ($truthy(self3["$empty?"]())) {
            return [];
          }
          ;
          comment_lines = [];
          while ($truthy($truthy($ret_or_1 = next_line = self3.$peek_line()) ? next_line["$empty?"]()["$!"]() : $ret_or_1)) {
            if ($truthy(next_line["$start_with?"]("//"))) {
              comment_lines["$<<"](self3.$shift());
            } else {
              break;
            }
          }
          ;
          return comment_lines;
        });
        $def(self2, "$terminate", function $$terminate() {
          var self3 = this;
          self3.lineno = $rb_plus(self3.lineno, self3.lines.$size());
          self3.lines.$clear();
          self3.look_ahead = 0;
          return nil;
        });
        $def(self2, "$read_lines_until", function $$read_lines_until(options) {
          var $a, $yield = $$read_lines_until.$$p || nil, self3 = this, result = nil, restore_process_lines = nil, terminator = nil, start_cursor = nil, $ret_or_1 = nil, break_on_blank_lines = nil, break_on_list_continuation = nil, skip_comments = nil, line_read = nil, line_restored = nil, line = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, context = nil;
          $$read_lines_until.$$p = null;
          if (options == null)
            options = $hash2([], {});
          result = [];
          if ($truthy(self3.process_lines) && $truthy(options["$[]"]("skip_processing"))) {
            self3.process_lines = false;
            restore_process_lines = true;
          }
          ;
          if ($truthy(terminator = options["$[]"]("terminator"))) {
            start_cursor = $truthy($ret_or_1 = options["$[]"]("cursor")) ? $ret_or_1 : self3.$cursor();
            break_on_blank_lines = false;
            break_on_list_continuation = false;
          } else {
            break_on_blank_lines = options["$[]"]("break_on_blank_lines");
            break_on_list_continuation = options["$[]"]("break_on_list_continuation");
          }
          ;
          skip_comments = options["$[]"]("skip_line_comments");
          line_read = line_restored = nil;
          if ($truthy(options["$[]"]("skip_first_line"))) {
            self3.$shift();
          }
          ;
          while ($truthy(line = self3.$read_line())) {
            if ($truthy($truthy(terminator) ? line["$=="](terminator) : $truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = break_on_blank_lines) ? line["$empty?"]() : $ret_or_3) ? $ret_or_2 : $truthy($ret_or_3 = $truthy($ret_or_4 = $truthy($ret_or_5 = break_on_list_continuation) ? line_read : $ret_or_5) ? line["$=="]($$2("LIST_CONTINUATION")) : $ret_or_4) ? ($a = ["preserve_last_line", true], $send(options, "[]=", $a), $a[$a.length - 1]) : $ret_or_3) ? $ret_or_1 : $truthy($ret_or_2 = $yield !== nil) ? Opal2.yield1($yield, line) : $ret_or_2)) {
              if ($truthy(options["$[]"]("read_last_line"))) {
                result["$<<"](line);
              }
              ;
              if ($truthy(options["$[]"]("preserve_last_line"))) {
                self3.$unshift(line);
                line_restored = true;
              }
              ;
              break;
            }
            ;
            if (!($truthy(skip_comments) && $truthy(line["$start_with?"]("//")) && $not(line["$start_with?"]("///")))) {
              result["$<<"](line);
              line_read = true;
            }
            ;
          }
          ;
          if ($truthy(restore_process_lines)) {
            self3.process_lines = true;
            if ($truthy(line_restored) && $not(terminator)) {
              self3.look_ahead = $rb_minus(self3.look_ahead, 1);
            }
            ;
          }
          ;
          if ($truthy(terminator) && $neqeq(terminator, line) && $truthy(context = options.$fetch("context", terminator))) {
            if ($eqeq(start_cursor, "at_mark")) {
              start_cursor = self3.$cursor_at_mark();
            }
            ;
            self3.$logger().$warn(self3.$message_with_context("unterminated " + context + " block", $hash2(["source_location"], { "source_location": start_cursor })));
            self3.unterminated = true;
          }
          ;
          return result;
        }, -1);
        $def(self2, "$shift", function $$shift() {
          var self3 = this;
          self3.lineno = $rb_plus(self3.lineno, 1);
          if (!$eqeq(self3.look_ahead, 0)) {
            self3.look_ahead = $rb_minus(self3.look_ahead, 1);
          }
          ;
          return self3.lines.$pop();
        });
        $def(self2, "$unshift", function $$unshift(line) {
          var self3 = this;
          self3.lineno = $rb_minus(self3.lineno, 1);
          self3.look_ahead = $rb_plus(self3.look_ahead, 1);
          self3.lines.$push(line);
          return nil;
        });
        if ($eqeq($$$("RUBY_ENGINE"), "jruby")) {
          $def(self2, "$unshift_all", function $$unshift_all(lines_to_restore) {
            var self3 = this;
            self3.lineno = $rb_minus(self3.lineno, lines_to_restore.$size());
            self3.look_ahead = $rb_plus(self3.look_ahead, lines_to_restore.$size());
            if ($truthy(lines_to_restore["$respond_to?"]("reverse"))) {
              $send(self3.lines, "push", $to_a(lines_to_restore.$reverse()));
            } else {
              $send(lines_to_restore, "reverse_each", [], function $$5(it) {
                var self4 = $$5.$$s == null ? this : $$5.$$s;
                if (self4.lines == null)
                  self4.lines = nil;
                if (it == null)
                  it = nil;
                return self4.lines.$push(it);
              }, { $$s: self3 });
            }
            ;
            return nil;
          });
        } else {
          $def(self2, "$unshift_all", function $$unshift_all(lines_to_restore) {
            var self3 = this;
            self3.lineno = $rb_minus(self3.lineno, lines_to_restore.$size());
            self3.look_ahead = $rb_plus(self3.look_ahead, lines_to_restore.$size());
            $send(self3.lines, "push", $to_a(lines_to_restore.$reverse()));
            return nil;
          });
        }
        ;
        $def(self2, "$cursor", function $$cursor() {
          var self3 = this;
          return $$2("Cursor").$new(self3.file, self3.dir, self3.path, self3.lineno);
        });
        $def(self2, "$cursor_at_line", function $$cursor_at_line(lineno) {
          var self3 = this;
          return $$2("Cursor").$new(self3.file, self3.dir, self3.path, lineno);
        });
        $def(self2, "$cursor_at_mark", function $$cursor_at_mark() {
          var self3 = this;
          if ($truthy(self3.mark)) {
            return $send($$2("Cursor"), "new", $to_a(self3.mark));
          } else {
            return self3.$cursor();
          }
        });
        $def(self2, "$cursor_before_mark", function $$cursor_before_mark() {
          var $a, $b, self3 = this, m_file = nil, m_dir = nil, m_path = nil, m_lineno = nil;
          if ($truthy(self3.mark)) {
            $b = self3.mark, $a = $to_ary($b), m_file = $a[0] == null ? nil : $a[0], m_dir = $a[1] == null ? nil : $a[1], m_path = $a[2] == null ? nil : $a[2], m_lineno = $a[3] == null ? nil : $a[3], $b;
            return $$2("Cursor").$new(m_file, m_dir, m_path, $rb_minus(m_lineno, 1));
          } else {
            return $$2("Cursor").$new(self3.file, self3.dir, self3.path, $rb_minus(self3.lineno, 1));
          }
        });
        $def(self2, "$cursor_at_prev_line", function $$cursor_at_prev_line() {
          var self3 = this;
          return $$2("Cursor").$new(self3.file, self3.dir, self3.path, $rb_minus(self3.lineno, 1));
        });
        $def(self2, "$mark", function $$mark() {
          var self3 = this;
          return self3.mark = [self3.file, self3.dir, self3.path, self3.lineno];
        });
        $def(self2, "$line_info", function $$line_info() {
          var self3 = this;
          return "" + self3.path + ": line " + self3.lineno;
        });
        $def(self2, "$lines", function $$lines() {
          var self3 = this;
          return self3.lines.$reverse();
        });
        $def(self2, "$string", function $$string() {
          var self3 = this;
          return self3.lines.$reverse().$join($$2("LF"));
        });
        $def(self2, "$source", function $$source() {
          var self3 = this;
          return self3.source_lines.$join($$2("LF"));
        });
        $def(self2, "$save", function $$save() {
          var self3 = this;
          self3.saved = $send($hash2([], {}), "tap", [], function $$6(accum) {
            var self4 = $$6.$$s == null ? this : $$6.$$s;
            if (accum == null)
              accum = nil;
            return $send(self4.$instance_variables(), "each", [], function $$7(name) {
              var $a, self5 = $$7.$$s == null ? this : $$7.$$s, val = nil;
              if (name == null)
                name = nil;
              if ($eqeq(name, "@saved") || $eqeq(name, "@source_lines")) {
                return nil;
              } else {
                return $a = [name, $eqeqeq($$$("Array"), val = self5.$instance_variable_get(name)) ? val.$drop(0) : val], $send(accum, "[]=", $a), $a[$a.length - 1];
              }
              ;
            }, { $$s: self4 });
          }, { $$s: self3 });
          return nil;
        });
        $def(self2, "$restore_save", function $$restore_save() {
          var self3 = this;
          if ($truthy(self3.saved)) {
            $send(self3.saved, "each", [], function $$8(name, val) {
              var self4 = $$8.$$s == null ? this : $$8.$$s;
              if (name == null)
                name = nil;
              if (val == null)
                val = nil;
              return self4.$instance_variable_set(name, val);
            }, { $$s: self3 });
            return self3.saved = nil;
          } else {
            return nil;
          }
        });
        $def(self2, "$discard_save", $assign_ivar_val("saved", nil));
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this;
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {path: " + self3.path.$inspect() + ", line: " + self3.lineno + "}>";
        });
        self2.$private();
        $def(self2, "$prepare_lines", function $$prepare_lines(data, opts) {
          var self3 = this, normalize = nil;
          if (opts == null)
            opts = $hash2([], {});
          try {
            if ($truthy(normalize = opts["$[]"]("normalize"))) {
              if ($eqeqeq($$$("Array"), data)) {
                return $$2("Helpers").$prepare_source_array(data, normalize["$!="]("chomp"));
              } else {
                return $$2("Helpers").$prepare_source_string(data, normalize["$!="]("chomp"));
              }
            } else if ($eqeqeq($$$("Array"), data)) {
              return data.$drop(0);
            } else if ($truthy(data)) {
              return data.$chomp().$split($$2("LF"), -1);
            } else {
              return [];
            }
          } catch ($err) {
            if (Opal2.rescue($err, [$$2("StandardError")])) {
              try {
                if ($truthy(($eqeqeq($$$("Array"), data) ? data.$join() : data.$to_s())["$valid_encoding?"]())) {
                  return self3.$raise();
                } else {
                  return self3.$raise($$$("ArgumentError"), "source is either binary or contains invalid Unicode data");
                }
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
        }, -2);
        return $def(self2, "$process_line", function $$process_line(line) {
          var self3 = this;
          if ($truthy(self3.process_lines)) {
            self3.look_ahead = $rb_plus(self3.look_ahead, 1);
          }
          ;
          return line;
        });
      })($nesting2[0], null, $nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "PreprocessorReader");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.include_stack = $proto.lines = $proto.file = $proto.dir = $proto.path = $proto.lineno = $proto.maxdepth = $proto.process_lines = $proto.includes = $proto.document = $proto.unescape_next_line = $proto.include_processor_extensions = $proto.look_ahead = $proto.skipping = $proto.conditional_stack = nil;
        self2.$attr_reader("include_stack");
        $def(self2, "$initialize", function $$initialize(document2, data, cursor, opts) {
          var $yield = $$initialize.$$p || nil, self3 = this, default_include_depth = nil, $ret_or_1 = nil;
          $$initialize.$$p = null;
          if (data == null)
            data = nil;
          if (cursor == null)
            cursor = nil;
          if (opts == null)
            opts = $hash2([], {});
          self3.document = document2;
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [data, cursor, opts], null);
          if ($truthy($rb_gt(default_include_depth = ($truthy($ret_or_1 = document2.$attributes()["$[]"]("max-include-depth")) ? $ret_or_1 : 64).$to_i(), 0))) {
            self3.maxdepth = $hash2(["abs", "curr", "rel"], { "abs": default_include_depth, "curr": default_include_depth, "rel": default_include_depth });
          } else {
            self3.maxdepth = nil;
          }
          ;
          self3.include_stack = [];
          self3.includes = document2.$catalog()["$[]"]("includes");
          self3.skipping = false;
          self3.conditional_stack = [];
          return self3.include_processor_extensions = nil;
        }, -2);
        $def(self2, "$has_more_lines?", function $PreprocessorReader_has_more_lines$ques$9() {
          var self3 = this;
          if ($truthy(self3.$peek_line())) {
            return true;
          } else {
            return false;
          }
        });
        $def(self2, "$empty?", function $PreprocessorReader_empty$ques$10() {
          var self3 = this;
          if ($truthy(self3.$peek_line())) {
            return false;
          } else {
            return true;
          }
        });
        $alias(self2, "eof?", "empty?");
        $def(self2, "$peek_line", function $$peek_line(direct) {
          var $yield = $$peek_line.$$p || nil, self3 = this, line = nil;
          $$peek_line.$$p = null;
          if (direct == null)
            direct = false;
          if ($truthy(line = $send2(self3, $find_super(self3, "peek_line", $$peek_line, false, true), "peek_line", [direct], $yield))) {
            return line;
          } else if ($truthy(self3.include_stack["$empty?"]())) {
            return nil;
          } else {
            self3.$pop_include();
            return self3.$peek_line(direct);
          }
          ;
        }, -1);
        $def(self2, "$push_include", function $$push_include(data, file, path, lineno, attributes) {
          var self3 = this, dir = nil, $ret_or_1 = nil, rel_maxdepth = nil, curr_maxdepth = nil, abs_maxdepth = nil, leveloffset = nil;
          if (file == null)
            file = nil;
          if (path == null)
            path = nil;
          if (lineno == null)
            lineno = 1;
          if (attributes == null)
            attributes = $hash2([], {});
          self3.include_stack["$<<"]([self3.lines, self3.file, self3.dir, self3.path, self3.lineno, self3.maxdepth, self3.process_lines]);
          if ($truthy(self3.file = file)) {
            if ($eqeqeq($$$("String"), file)) {
              self3.dir = $$$("File").$dirname(file);
            } else if ($truthy($$2("RUBY_ENGINE_OPAL"))) {
              self3.dir = $$$("URI").$parse($$$("File").$dirname(file = file.$to_s()));
            } else {
              (self3.dir = file.$dup())["$path="]($eqeq(dir = $$$("File").$dirname(file.$path()), "/") ? "" : dir);
              file = file.$to_s();
            }
            ;
            self3.path = path = $truthy($ret_or_1 = path) ? $ret_or_1 : $$$("File").$basename(file);
            if ($truthy(self3.process_lines = $send(file, "end_with?", $to_a($$2("ASCIIDOC_EXTENSIONS").$keys())))) {
              if ($truthy($ret_or_1 = self3.includes["$[]"](path.$slice(0, path.$rindex("."))))) {
                $ret_or_1;
              } else {
                self3.includes["$[]="](path.$slice(0, path.$rindex(".")), $truthy(attributes["$[]"]("partial-option")) ? nil : true);
              }
            }
            ;
          } else {
            self3.dir = ".";
            self3.process_lines = true;
            if ($truthy(self3.path = path)) {
              if ($truthy($ret_or_1 = self3.includes["$[]"]($$2("Helpers").$rootname(path)))) {
                $ret_or_1;
              } else {
                self3.includes["$[]="]($$2("Helpers").$rootname(path), $truthy(attributes["$[]"]("partial-option")) ? nil : true);
              }
            } else {
              self3.path = "<stdin>";
            }
            ;
          }
          ;
          self3.lineno = lineno;
          if ($truthy(self3.maxdepth) && $truthy(attributes["$key?"]("depth"))) {
            if ($truthy($rb_gt(rel_maxdepth = attributes["$[]"]("depth").$to_i(), 0))) {
              if ($truthy($rb_gt(curr_maxdepth = $rb_plus(self3.include_stack.$size(), rel_maxdepth), abs_maxdepth = self3.maxdepth["$[]"]("abs")))) {
                curr_maxdepth = rel_maxdepth = abs_maxdepth;
              }
              ;
              self3.maxdepth = $hash2(["abs", "curr", "rel"], { "abs": abs_maxdepth, "curr": curr_maxdepth, "rel": rel_maxdepth });
            } else {
              self3.maxdepth = $hash2(["abs", "curr", "rel"], { "abs": self3.maxdepth["$[]"]("abs"), "curr": self3.include_stack.$size(), "rel": 0 });
            }
          }
          ;
          if ($truthy((self3.lines = self3.$prepare_lines(data, $hash2(["normalize", "condense", "indent"], { "normalize": $truthy($ret_or_1 = self3.process_lines) ? $ret_or_1 : "chomp", "condense": false, "indent": attributes["$[]"]("indent") })))["$empty?"]())) {
            self3.$pop_include();
          } else {
            if ($truthy(attributes["$key?"]("leveloffset"))) {
              self3.lines = $rb_plus($rb_plus([$truthy(leveloffset = self3.document.$attr("leveloffset")) ? ":leveloffset: " + leveloffset : ":leveloffset!:", ""], self3.lines.$reverse()), ["", ":leveloffset: " + attributes["$[]"]("leveloffset")]);
              self3.lineno = $rb_minus(self3.lineno, 2);
            } else {
              self3.lines["$reverse!"]();
            }
            ;
            self3.look_ahead = 0;
          }
          ;
          return self3;
        }, -2);
        $def(self2, "$include_depth", function $$include_depth() {
          var self3 = this;
          return self3.include_stack.$size();
        });
        $def(self2, "$exceeds_max_depth?", function $PreprocessorReader_exceeds_max_depth$ques$11() {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = self3.maxdepth) ? $rb_ge(self3.include_stack.$size(), self3.maxdepth["$[]"]("curr")) : $ret_or_2)) {
            return self3.maxdepth["$[]"]("rel");
          } else {
            return $ret_or_1;
          }
        });
        $alias(self2, "exceeded_max_depth?", "exceeds_max_depth?");
        $def(self2, "$shift", function $$shift() {
          var $yield = $$shift.$$p || nil, self3 = this, line = nil;
          $$shift.$$p = null;
          if ($truthy(self3.unescape_next_line)) {
            self3.unescape_next_line = false;
            return (line = $send2(self3, $find_super(self3, "shift", $$shift, false, true), "shift", [], $yield)).$slice(1, line.$length());
          } else {
            return $send2(self3, $find_super(self3, "shift", $$shift, false, true), "shift", [], $yield);
          }
        });
        $def(self2, "$include_processors?", function $PreprocessorReader_include_processors$ques$12() {
          var self3 = this;
          if ($truthy(self3.include_processor_extensions["$nil?"]())) {
            if ($truthy(self3.document["$extensions?"]()) && $truthy(self3.document.$extensions()["$include_processors?"]())) {
              return (self3.include_processor_extensions = self3.document.$extensions().$include_processors())["$!"]()["$!"]();
            } else {
              return self3.include_processor_extensions = false;
            }
          } else {
            return self3.include_processor_extensions["$!="](false);
          }
        });
        $def(self2, "$create_include_cursor", function $$create_include_cursor(file, path, lineno) {
          var dir = nil;
          if ($eqeqeq($$$("String"), file)) {
            dir = $$$("File").$dirname(file);
          } else if ($truthy($$2("RUBY_ENGINE_OPAL"))) {
            dir = $$$("File").$dirname(file = file.$to_s());
          } else {
            dir = $eqeq(dir = $$$("File").$dirname(file.$path()), "") ? "/" : dir;
            file = file.$to_s();
          }
          ;
          return $$2("Cursor").$new(file, dir, path, lineno);
        });
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this;
          return "#<" + self3.$class() + "@" + self3.$object_id() + " {path: " + self3.path.$inspect() + ", line: " + self3.lineno + ", include depth: " + self3.include_stack.$size() + ", include stack: [" + $send(self3.include_stack, "map", [], function $$13(inc) {
            if (inc == null)
              inc = nil;
            return inc.$to_s();
          }).$join(", ") + "]}>";
        });
        self2.$private();
        $def(self2, "$prepare_lines", function $$prepare_lines(data, opts) {
          var $yield = $$prepare_lines.$$p || nil, self3 = this, result = nil, front_matter = nil, $ret_or_1 = nil, last = nil;
          $$prepare_lines.$$p = null;
          if (opts == null)
            opts = $hash2([], {});
          result = $send2(self3, $find_super(self3, "prepare_lines", $$prepare_lines, false, true), "prepare_lines", [data, opts], $yield);
          if ($truthy(self3.document) && $truthy(self3.document.$attributes()["$[]"]("skip-front-matter")) && $truthy(front_matter = self3["$skip_front_matter!"](result))) {
            self3.document.$attributes()["$[]="]("front-matter", front_matter.$join($$2("LF")));
          }
          ;
          if ($truthy(opts.$fetch("condense", true))) {
            while ($truthy($truthy($ret_or_1 = last = result["$[]"](-1)) ? last["$empty?"]() : $ret_or_1)) {
              result.$pop();
            }
          }
          ;
          if ($truthy(opts["$[]"]("indent"))) {
            $$2("Parser")["$adjust_indentation!"](result, opts["$[]"]("indent").$to_i(), self3.document.$attr("tabsize").$to_i());
          }
          ;
          return result;
        }, -2);
        $def(self2, "$process_line", function $$process_line(line) {
          var $a, self3 = this;
          if (!$truthy(self3.process_lines)) {
            return line;
          }
          ;
          if ($truthy(line["$empty?"]())) {
            self3.look_ahead = $rb_plus(self3.look_ahead, 1);
            return line;
          }
          ;
          if ($truthy(line["$end_with?"]("]")) && $not(line["$start_with?"]("[")) && $truthy(line["$include?"]("::"))) {
            if ($truthy(line["$include?"]("if")) && $truthy($$2("ConditionalDirectiveRx")["$=~"](line))) {
              if ($eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), "\\")) {
                self3.unescape_next_line = true;
                self3.look_ahead = $rb_plus(self3.look_ahead, 1);
                return line.$slice(1, line.$length());
              } else if ($truthy(self3.$preprocess_conditional_directive(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](4), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](5)))) {
                self3.$shift();
                return nil;
              } else {
                self3.look_ahead = $rb_plus(self3.look_ahead, 1);
                return line;
              }
            } else if ($truthy(self3.skipping)) {
              self3.$shift();
              return nil;
            } else if ($truthy(line["$start_with?"]("inc", "\\inc")) && $truthy($$2("IncludeDirectiveRx")["$=~"](line))) {
              if ($eqeq(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), "\\")) {
                self3.unescape_next_line = true;
                self3.look_ahead = $rb_plus(self3.look_ahead, 1);
                return line.$slice(1, line.$length());
              } else if ($truthy(self3.$preprocess_include_directive(($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3)))) {
                return nil;
              } else {
                self3.look_ahead = $rb_plus(self3.look_ahead, 1);
                return line;
              }
            } else {
              self3.look_ahead = $rb_plus(self3.look_ahead, 1);
              return line;
            }
          } else if ($truthy(self3.skipping)) {
            self3.$shift();
            return nil;
          } else {
            self3.look_ahead = $rb_plus(self3.look_ahead, 1);
            return line;
          }
          ;
        });
        $def(self2, "$preprocess_conditional_directive", function $$preprocess_conditional_directive(keyword, target, delimiter, text) {
          var $a, self3 = this, no_target = nil, pair = nil, skip = nil, lhs = nil, op = nil, rhs = nil;
          if (!$truthy(no_target = target["$empty?"]())) {
            target = target.$downcase();
          }
          ;
          if ($eqeq(keyword, "endif")) {
            if ($truthy(text)) {
              self3.$logger().$error(self3.$message_with_context("malformed preprocessor directive - text not permitted: endif::" + target + "[" + text + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
            } else if ($truthy(self3.conditional_stack["$empty?"]())) {
              self3.$logger().$error(self3.$message_with_context("unmatched preprocessor directive: endif::" + target + "[]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
            } else if ($truthy(no_target) || $eqeq(target, (pair = self3.conditional_stack["$[]"](-1))["$[]"]("target"))) {
              self3.conditional_stack.$pop();
              self3.skipping = $truthy(self3.conditional_stack["$empty?"]()) ? false : self3.conditional_stack["$[]"](-1)["$[]"]("skipping");
            } else {
              self3.$logger().$error(self3.$message_with_context("mismatched preprocessor directive: endif::" + target + "[], expected endif::" + pair["$[]"]("target") + "[]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
            }
            ;
            return true;
          } else if ($truthy(self3.skipping)) {
            skip = false;
          } else
            switch (keyword) {
              case "ifdef":
                if ($truthy(no_target)) {
                  self3.$logger().$error(self3.$message_with_context("malformed preprocessor directive - missing target: ifdef::[" + text + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
                  return true;
                }
                ;
                switch (delimiter) {
                  case ",":
                    skip = $send(target.$split(",", -1), "none?", [], function $$14(name) {
                      var self4 = $$14.$$s == null ? this : $$14.$$s;
                      if (self4.document == null)
                        self4.document = nil;
                      if (name == null)
                        name = nil;
                      return self4.document.$attributes()["$key?"](name);
                    }, { $$s: self3 });
                    break;
                  case "+":
                    skip = $send(target.$split("+", -1), "any?", [], function $$15(name) {
                      var self4 = $$15.$$s == null ? this : $$15.$$s;
                      if (self4.document == null)
                        self4.document = nil;
                      if (name == null)
                        name = nil;
                      return self4.document.$attributes()["$key?"](name)["$!"]();
                    }, { $$s: self3 });
                    break;
                  default:
                    skip = self3.document.$attributes()["$key?"](target)["$!"]();
                }
                ;
                break;
              case "ifndef":
                if ($truthy(no_target)) {
                  self3.$logger().$error(self3.$message_with_context("malformed preprocessor directive - missing target: ifndef::[" + text + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
                  return true;
                }
                ;
                switch (delimiter) {
                  case ",":
                    skip = $send(target.$split(",", -1), "any?", [], function $$16(name) {
                      var self4 = $$16.$$s == null ? this : $$16.$$s;
                      if (self4.document == null)
                        self4.document = nil;
                      if (name == null)
                        name = nil;
                      return self4.document.$attributes()["$key?"](name);
                    }, { $$s: self3 });
                    break;
                  case "+":
                    skip = $send(target.$split("+", -1), "all?", [], function $$17(name) {
                      var self4 = $$17.$$s == null ? this : $$17.$$s;
                      if (self4.document == null)
                        self4.document = nil;
                      if (name == null)
                        name = nil;
                      return self4.document.$attributes()["$key?"](name);
                    }, { $$s: self3 });
                    break;
                  default:
                    skip = self3.document.$attributes()["$key?"](target);
                }
                ;
                break;
              case "ifeval":
                if ($truthy(no_target)) {
                  if ($truthy(text) && $truthy($$2("EvalExpressionRx")["$=~"](text.$strip()))) {
                    lhs = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](1);
                    op = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2);
                    rhs = ($a = $gvars["~"]) === nil ? nil : $a["$[]"](3);
                    skip = function() {
                      try {
                        if ($truthy(self3.$resolve_expr_val(lhs).$send(op, self3.$resolve_expr_val(rhs)))) {
                          return false;
                        } else {
                          return true;
                        }
                      } catch ($err) {
                        if (Opal2.rescue($err, [$$2("StandardError")])) {
                          try {
                            return true;
                          } finally {
                            Opal2.pop_exception();
                          }
                        } else {
                          throw $err;
                        }
                      }
                    }();
                  } else {
                    self3.$logger().$error(self3.$message_with_context("malformed preprocessor directive - " + ($truthy(text) ? "invalid expression" : "missing expression") + ": ifeval::[" + text + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
                    return true;
                  }
                } else {
                  self3.$logger().$error(self3.$message_with_context("malformed preprocessor directive - target not permitted: ifeval::" + target + "[" + text + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
                  return true;
                }
                break;
              default:
                nil;
            }
          ;
          if ($eqeq(keyword, "ifeval") || $not(text)) {
            if ($truthy(skip)) {
              self3.skipping = true;
            }
            ;
            self3.conditional_stack["$<<"]($hash2(["target", "skip", "skipping"], { "target": target, "skip": skip, "skipping": self3.skipping }));
          } else if (!($truthy(self3.skipping) || $truthy(skip))) {
            self3.$replace_next_line(text.$rstrip());
            self3.$unshift("");
            if ($truthy(text["$start_with?"]("include::"))) {
              self3.look_ahead = $rb_minus(self3.look_ahead, 1);
            }
            ;
          }
          ;
          return true;
        });
        $def(self2, "$preprocess_include_directive", function $$preprocess_include_directive(target, attrlist) {
          var $a, $b, self3 = this, doc = nil, expanded_target = nil, attr_missing = nil, $ret_or_1 = nil, ext = nil, parsed_attrs = nil, inc_path = nil, target_type = nil, relpath = nil, reader = nil, read_mode = nil, enc = nil, read_mode_params = nil, inc_linenos = nil, inc_tags = nil, tag = nil, inc_lines = nil, inc_offset = nil, inc_lineno = nil, tag_stack = nil, tags_selected = nil, active_tag = nil, select = nil, base_select = nil, wildcard = nil, missing_tags = nil, inc_content = nil;
          doc = self3.document;
          if ($truthy((expanded_target = target)["$include?"]($$2("ATTR_REF_HEAD"))) && $truthy((expanded_target = doc.$sub_attributes(target, $hash2(["attribute_missing"], { "attribute_missing": $eqeq(attr_missing = $truthy($ret_or_1 = doc.$attributes()["$[]"]("attribute-missing")) ? $ret_or_1 : $$2("Compliance").$attribute_missing(), "warn") ? "drop-line" : attr_missing })))["$empty?"]())) {
            if ($eqeq(attr_missing, "drop-line") && $truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], { "attribute_missing": "drop-line", "drop_line_severity": "ignore" }))["$empty?"]())) {
              $send(self3.$logger(), "info", [], function $$18() {
                var self4 = $$18.$$s == null ? this : $$18.$$s;
                return self4.$message_with_context("include dropped due to missing attribute: include::" + target + "[" + attrlist + "]", $hash2(["source_location"], { "source_location": self4.$cursor() }));
              }, { $$s: self3 });
              self3.$shift();
              return true;
            } else if ($truthy(doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], { "sub_input": true }))["$[]"]("optional-option"))) {
              $send(self3.$logger(), "info", [], function $$19() {
                var self4 = $$19.$$s == null ? this : $$19.$$s;
                return self4.$message_with_context("optional include dropped " + ($eqeq(attr_missing, "warn") && $truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], { "attribute_missing": "drop-line", "drop_line_severity": "ignore" }))["$empty?"]()) ? "due to missing attribute" : "because resolved target is blank") + ": include::" + target + "[" + attrlist + "]", $hash2(["source_location"], { "source_location": self4.$cursor() }));
              }, { $$s: self3 });
              self3.$shift();
              return true;
            } else {
              self3.$logger().$warn(self3.$message_with_context("include dropped " + ($eqeq(attr_missing, "warn") && $truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], { "attribute_missing": "drop-line", "drop_line_severity": "ignore" }))["$empty?"]()) ? "due to missing attribute" : "because resolved target is blank") + ": include::" + target + "[" + attrlist + "]", $hash2(["source_location"], { "source_location": self3.$cursor() })));
              return self3.$replace_next_line("Unresolved directive in " + self3.path + " - include::" + target + "[" + attrlist + "]");
            }
          } else if ($truthy(self3["$include_processors?"]()) && $truthy(ext = $send(self3.include_processor_extensions, "find", [], function $$20(candidate) {
            if (candidate == null)
              candidate = nil;
            return candidate.$instance()["$handles?"](expanded_target);
          }))) {
            self3.$shift();
            ext.$process_method()["$[]"](doc, self3, expanded_target, doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], { "sub_input": true })));
            return true;
          } else if ($truthy($rb_ge(doc.$safe(), $$$($$2("SafeMode"), "SECURE")))) {
            return self3.$replace_next_line("link:" + expanded_target + "[role=include]");
          } else if ($truthy(self3.maxdepth)) {
            if ($truthy($rb_ge(self3.include_stack.$size(), self3.maxdepth["$[]"]("curr")))) {
              self3.$logger().$error(self3.$message_with_context("maximum include depth of " + self3.maxdepth["$[]"]("rel") + " exceeded", $hash2(["source_location"], { "source_location": self3.$cursor() })));
              return nil;
            }
            ;
            parsed_attrs = doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], { "sub_input": true }));
            $b = self3.$resolve_include_path(expanded_target, attrlist, parsed_attrs), $a = $to_ary($b), inc_path = $a[0] == null ? nil : $a[0], target_type = $a[1] == null ? nil : $a[1], relpath = $a[2] == null ? nil : $a[2], $b;
            switch (target_type) {
              case "file":
                reader = $$$("File").$method("open");
                read_mode = $$2("FILE_READ_MODE");
                break;
              case "uri":
                reader = $$$("OpenURI").$method("open_uri");
                read_mode = $$2("URI_READ_MODE");
                break;
              default:
                return inc_path;
            }
            ;
            if (!$truthy($$2("RUBY_ENGINE_OPAL"))) {
              if ($truthy(enc = parsed_attrs["$[]"]("encoding")) && $truthy(function() {
                try {
                  return $$$("Encoding").$find(enc);
                } catch ($err) {
                  if (Opal2.rescue($err, [$$2("StandardError")])) {
                    try {
                      return nil;
                    } finally {
                      Opal2.pop_exception();
                    }
                  } else {
                    throw $err;
                  }
                }
              }())) {
                (read_mode_params = read_mode.$split(":"))["$[]="](1, enc);
                read_mode = read_mode_params.$join(":");
              }
            }
            ;
            inc_linenos = inc_tags = nil;
            if ($truthy(attrlist)) {
              if ($truthy(parsed_attrs["$key?"]("lines"))) {
                inc_linenos = [];
                $send(self3.$split_delimited_value(parsed_attrs["$[]"]("lines")), "each", [], function $$21(linedef) {
                  var $c, $d, from = nil, _ = nil, to = nil;
                  if (linedef == null)
                    linedef = nil;
                  if ($truthy(linedef["$include?"](".."))) {
                    $d = linedef.$partition(".."), $c = $to_ary($d), from = $c[0] == null ? nil : $c[0], _ = $c[1] == null ? nil : $c[1], to = $c[2] == null ? nil : $c[2], $d;
                    return inc_linenos = $rb_plus(inc_linenos, $truthy(to["$empty?"]()) || $truthy($rb_lt(to = to.$to_i(), 0)) ? [from.$to_i(), $$$($$$("Float"), "INFINITY")] : Opal2.Range.$new(from.$to_i(), to, false).$to_a());
                  } else {
                    return inc_linenos["$<<"](linedef.$to_i());
                  }
                  ;
                });
                inc_linenos = $truthy(inc_linenos["$empty?"]()) ? nil : inc_linenos.$sort().$uniq();
              } else if ($truthy(parsed_attrs["$key?"]("tag"))) {
                if (!($truthy((tag = parsed_attrs["$[]"]("tag"))["$empty?"]()) || $eqeq(tag, "!"))) {
                  inc_tags = $truthy(tag["$start_with?"]("!")) ? $hash(tag.$slice(1, tag.$length()), false) : $hash(tag, true);
                }
              } else if ($truthy(parsed_attrs["$key?"]("tags"))) {
                inc_tags = $hash2([], {});
                $send(self3.$split_delimited_value(parsed_attrs["$[]"]("tags")), "each", [], function $$22(tagdef) {
                  var $c;
                  if (tagdef == null)
                    tagdef = nil;
                  if ($truthy(tagdef["$empty?"]()) || $eqeq(tagdef, "!")) {
                    return nil;
                  } else if ($truthy(tagdef["$start_with?"]("!"))) {
                    return $c = [tagdef.$slice(1, tagdef.$length()), false], $send(inc_tags, "[]=", $c), $c[$c.length - 1];
                  } else {
                    return $c = [tagdef, true], $send(inc_tags, "[]=", $c), $c[$c.length - 1];
                  }
                  ;
                });
                if ($truthy(inc_tags["$empty?"]())) {
                  inc_tags = nil;
                }
                ;
              }
            }
            ;
            if ($truthy(inc_linenos)) {
              $a = [[], nil, 0], inc_lines = $a[0], inc_offset = $a[1], inc_lineno = $a[2], $a;
              try {
                $send(reader, "call", [inc_path, read_mode], function $$23(f) {
                  var select_remaining = nil;
                  if (f == null)
                    f = nil;
                  select_remaining = nil;
                  return function() {
                    try {
                      var $t_break = $thrower("break");
                      return $send(f, "each_line", [], function $$24(l) {
                        var select2 = nil;
                        if (l == null)
                          l = nil;
                        inc_lineno = $rb_plus(inc_lineno, 1);
                        if ($truthy(select_remaining) || $eqeqeq($$$("Float"), select2 = inc_linenos["$[]"](0)) && $truthy(select_remaining = select2["$infinite?"]())) {
                          inc_offset = $truthy($ret_or_1 = inc_offset) ? $ret_or_1 : inc_lineno;
                          return inc_lines["$<<"](l);
                        } else {
                          if ($eqeq(select2, inc_lineno)) {
                            inc_offset = $truthy($ret_or_1 = inc_offset) ? $ret_or_1 : inc_lineno;
                            inc_lines["$<<"](l);
                            inc_linenos.$shift();
                          }
                          ;
                          if ($truthy(inc_linenos["$empty?"]())) {
                            $t_break.$throw();
                          } else {
                            return nil;
                          }
                          ;
                        }
                        ;
                      });
                    } catch ($e) {
                      if ($e === $t_break)
                        return $e.$v;
                      throw $e;
                    }
                  }();
                });
              } catch ($err) {
                if (Opal2.rescue($err, [$$2("StandardError")])) {
                  try {
                    self3.$logger().$error(self3.$message_with_context("include " + target_type + " not readable: " + inc_path, $hash2(["source_location"], { "source_location": self3.$cursor() })));
                    return self3.$replace_next_line("Unresolved directive in " + self3.path + " - include::" + expanded_target + "[" + attrlist + "]");
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
              ;
              self3.$shift();
              if ($truthy(inc_offset)) {
                parsed_attrs["$[]="]("partial-option", "");
                self3.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);
              }
              ;
            } else if ($truthy(inc_tags)) {
              $a = [[], nil, 0, [], $$$("Set").$new(), nil], inc_lines = $a[0], inc_offset = $a[1], inc_lineno = $a[2], tag_stack = $a[3], tags_selected = $a[4], active_tag = $a[5], $a;
              if ($truthy(inc_tags["$key?"]("**"))) {
                select = base_select = inc_tags.$delete("**");
                if ($truthy(inc_tags["$key?"]("*"))) {
                  wildcard = inc_tags.$delete("*");
                } else if ($not(select) && $eqeq(inc_tags.$values().$first(), false)) {
                  wildcard = true;
                }
                ;
              } else if ($truthy(inc_tags["$key?"]("*"))) {
                if ($eqeq(inc_tags.$keys().$first(), "*")) {
                  select = base_select = (wildcard = inc_tags.$delete("*"))["$!"]();
                } else {
                  select = base_select = false;
                  wildcard = inc_tags.$delete("*");
                }
              } else {
                select = base_select = inc_tags["$value?"](true)["$!"]();
              }
              ;
              try {
                $send(reader, "call", [inc_path, read_mode], function $$25(f) {
                  var $c, self4 = $$25.$$s == null ? this : $$25.$$s, dbl_co = nil, dbl_sb = nil;
                  if (f == null)
                    f = nil;
                  $c = ["::", "[]"], dbl_co = $c[0], dbl_sb = $c[1], $c;
                  return $send(f, "each_line", [], function $$26(l) {
                    var $d, $e, self5 = $$26.$$s == null ? this : $$26.$$s, this_tag = nil, include_cursor = nil, idx = nil;
                    if (l == null)
                      l = nil;
                    inc_lineno = $rb_plus(inc_lineno, 1);
                    if ($truthy(l["$include?"](dbl_co)) && $truthy(l["$include?"](dbl_sb)) && $truthy($$2("TagDirectiveRx")["$=~"](l))) {
                      this_tag = ($d = $gvars["~"]) === nil ? nil : $d["$[]"](2);
                      if ($truthy(($d = $gvars["~"]) === nil ? nil : $d["$[]"](1))) {
                        if ($eqeq(this_tag, active_tag)) {
                          tag_stack.$pop();
                          return $e = $truthy(tag_stack["$empty?"]()) ? [nil, base_select] : tag_stack["$[]"](-1), $d = $to_ary($e), active_tag = $d[0] == null ? nil : $d[0], select = $d[1] == null ? nil : $d[1], $e;
                        } else if ($truthy(inc_tags["$key?"](this_tag))) {
                          include_cursor = self5.$create_include_cursor(inc_path, expanded_target, inc_lineno);
                          if ($truthy(idx = $send(tag_stack, "rindex", [], function $$27(key) {
                            if (key == null)
                              key = nil;
                            return key["$=="](this_tag);
                          }, { $$has_trailing_comma_in_args: true }))) {
                            if ($eqeq(idx, 0)) {
                              tag_stack.$shift();
                            } else {
                              tag_stack.$delete_at(idx);
                            }
                            ;
                            return self5.$logger().$warn(self5.$message_with_context("mismatched end tag (expected '" + active_tag + "' but found '" + this_tag + "') at line " + inc_lineno + " of include " + target_type + ": " + inc_path, $hash2(["source_location", "include_location"], { "source_location": self5.$cursor(), "include_location": include_cursor })));
                          } else {
                            return self5.$logger().$warn(self5.$message_with_context("unexpected end tag '" + this_tag + "' at line " + inc_lineno + " of include " + target_type + ": " + inc_path, $hash2(["source_location", "include_location"], { "source_location": self5.$cursor(), "include_location": include_cursor })));
                          }
                          ;
                        } else {
                          return nil;
                        }
                      } else if ($truthy(inc_tags["$key?"](this_tag))) {
                        if ($truthy(select = inc_tags["$[]"](this_tag))) {
                          tags_selected["$<<"](this_tag);
                        }
                        ;
                        return tag_stack["$<<"]([active_tag = this_tag, select, inc_lineno]);
                      } else if ($not(wildcard["$nil?"]())) {
                        select = $truthy(active_tag) && $not(select) ? false : wildcard;
                        return tag_stack["$<<"]([active_tag = this_tag, select, inc_lineno]);
                      } else {
                        return nil;
                      }
                      ;
                    } else if ($truthy(select)) {
                      inc_offset = $truthy($ret_or_1 = inc_offset) ? $ret_or_1 : inc_lineno;
                      return inc_lines["$<<"](l);
                    } else {
                      return nil;
                    }
                    ;
                  }, { $$s: self4 });
                }, { $$s: self3 });
              } catch ($err) {
                if (Opal2.rescue($err, [$$2("StandardError")])) {
                  try {
                    self3.$logger().$error(self3.$message_with_context("include " + target_type + " not readable: " + inc_path, $hash2(["source_location"], { "source_location": self3.$cursor() })));
                    return self3.$replace_next_line("Unresolved directive in " + self3.path + " - include::" + expanded_target + "[" + attrlist + "]");
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
              ;
              if (!$truthy(tag_stack["$empty?"]())) {
                $send(tag_stack, "each", [], function $$28(tag_name, _, tag_lineno) {
                  var self4 = $$28.$$s == null ? this : $$28.$$s;
                  if (tag_name == null)
                    tag_name = nil;
                  if (_ == null)
                    _ = nil;
                  if (tag_lineno == null)
                    tag_lineno = nil;
                  return self4.$logger().$warn(self4.$message_with_context("detected unclosed tag '" + tag_name + "' starting at line " + tag_lineno + " of include " + target_type + ": " + inc_path, $hash2(["source_location", "include_location"], { "source_location": self4.$cursor(), "include_location": self4.$create_include_cursor(inc_path, expanded_target, tag_lineno) })));
                }, { $$s: self3 });
              }
              ;
              if (!$truthy((missing_tags = $rb_minus($send(inc_tags, "keep_if", [], function $$29(_, v) {
                if (_ == null)
                  _ = nil;
                if (v == null)
                  v = nil;
                return v;
              }).$keys(), tags_selected.$to_a()))["$empty?"]())) {
                self3.$logger().$warn(self3.$message_with_context("tag" + ($truthy($rb_gt(missing_tags.$size(), 1)) ? "s" : "") + " '" + missing_tags.$join(", ") + "' not found in include " + target_type + ": " + inc_path, $hash2(["source_location"], { "source_location": self3.$cursor() })));
              }
              ;
              self3.$shift();
              if ($truthy(inc_offset)) {
                if (!($truthy(base_select) && $neqeq(wildcard, false) && $truthy(inc_tags["$empty?"]()))) {
                  parsed_attrs["$[]="]("partial-option", "");
                }
                ;
                self3.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);
              }
              ;
            } else {
              inc_content = nil;
              try {
                inc_content = $send(reader, "call", [inc_path, read_mode], function $$30(f) {
                  if (f == null)
                    f = nil;
                  return f.$read();
                });
                self3.$shift();
              } catch ($err) {
                if (Opal2.rescue($err, [$$2("StandardError")])) {
                  try {
                    self3.$logger().$error(self3.$message_with_context("include " + target_type + " not readable: " + inc_path, $hash2(["source_location"], { "source_location": self3.$cursor() })));
                    return self3.$replace_next_line("Unresolved directive in " + self3.path + " - include::" + expanded_target + "[" + attrlist + "]");
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
              ;
              self3.$push_include(inc_content, inc_path, relpath, 1, parsed_attrs);
            }
            ;
            return true;
          } else {
            return nil;
          }
          ;
        });
        $def(self2, "$resolve_include_path", function $$resolve_include_path(target, attrlist, attributes) {
          var $a, $b, self3 = this, doc = nil, inc_path = nil, relpath = nil;
          doc = self3.document;
          if ($truthy($$2("Helpers")["$uriish?"](target)) || $truthy($eqeqeq($$$("String"), self3.dir) ? nil : target = "" + self3.dir + "/" + target)) {
            if (!$truthy(doc["$attr?"]("allow-uri-read"))) {
              return self3.$replace_next_line("link:" + target + "[role=include]");
            }
            ;
            if ($truthy(doc["$attr?"]("cache-uri"))) {
              if (!$truthy(($b = $$$("::", "OpenURI", "skip_raise")) && ($a = $$$($b, "Cache", "skip_raise")) ? "constant" : nil)) {
                $$2("Helpers").$require_library("open-uri/cached", "open-uri-cached");
              }
            } else if ($not($$2("RUBY_ENGINE_OPAL"))) {
              $$$("OpenURI");
            }
            ;
            return [$$$("URI").$parse(target), "uri", target];
          } else {
            inc_path = doc.$normalize_system_path(target, self3.dir, nil, $hash2(["target_name"], { "target_name": "include file" }));
            if (!$truthy($$$("File")["$file?"](inc_path))) {
              if ($truthy(attributes["$[]"]("optional-option"))) {
                $send(self3.$logger(), "info", [], function $$31() {
                  var self4 = $$31.$$s == null ? this : $$31.$$s;
                  return self4.$message_with_context("optional include dropped because include file not found: " + inc_path, $hash2(["source_location"], { "source_location": self4.$cursor() }));
                }, { $$s: self3 });
                self3.$shift();
                return true;
              } else {
                self3.$logger().$error(self3.$message_with_context("include file not found: " + inc_path, $hash2(["source_location"], { "source_location": self3.$cursor() })));
                return self3.$replace_next_line("Unresolved directive in " + self3.path + " - include::" + target + "[" + attrlist + "]");
              }
            }
            ;
            relpath = doc.$path_resolver().$relative_path(inc_path, doc.$base_dir());
            return [inc_path, "file", relpath];
          }
          ;
        });
        $def(self2, "$pop_include", function $$pop_include() {
          var $a, $b, self3 = this;
          if ($truthy(self3.include_stack["$empty?"]())) {
            return nil;
          } else {
            $b = self3.include_stack.$pop(), $a = $to_ary($b), self3.lines = $a[0] == null ? nil : $a[0], self3.file = $a[1] == null ? nil : $a[1], self3.dir = $a[2] == null ? nil : $a[2], self3.path = $a[3] == null ? nil : $a[3], self3.lineno = $a[4] == null ? nil : $a[4], self3.maxdepth = $a[5] == null ? nil : $a[5], self3.process_lines = $a[6] == null ? nil : $a[6], $b;
            self3.look_ahead = 0;
            return nil;
          }
        });
        $def(self2, "$split_delimited_value", function $$split_delimited_value(val) {
          if ($truthy(val["$include?"](","))) {
            return val.$split(",");
          } else {
            return val.$split(";");
          }
        });
        $def(self2, "$skip_front_matter!", function $PreprocessorReader_skip_front_matter$excl$32(data, increment_linenos) {
          var self3 = this, delim = nil, original_data = nil, front_matter = nil, $ret_or_1 = nil, eof = nil;
          if (increment_linenos == null)
            increment_linenos = true;
          if (!$eqeq(delim = data["$[]"](0), "---")) {
            return nil;
          }
          ;
          original_data = data.$drop(0);
          data.$shift();
          front_matter = [];
          if ($truthy(increment_linenos)) {
            self3.lineno = $rb_plus(self3.lineno, 1);
          }
          ;
          while (!$truthy($truthy($ret_or_1 = eof = data["$empty?"]()) ? $ret_or_1 : data["$[]"](0)["$=="](delim))) {
            front_matter["$<<"](data.$shift());
            if ($truthy(increment_linenos)) {
              self3.lineno = $rb_plus(self3.lineno, 1);
            }
            ;
          }
          ;
          if ($truthy(eof)) {
            $send(data, "unshift", $to_a(original_data));
            if ($truthy(increment_linenos)) {
              self3.lineno = $rb_minus(self3.lineno, original_data.$size());
            }
            ;
            return nil;
          }
          ;
          data.$shift();
          if ($truthy(increment_linenos)) {
            self3.lineno = $rb_plus(self3.lineno, 1);
          }
          ;
          return front_matter;
        }, -2);
        return $def(self2, "$resolve_expr_val", function $$resolve_expr_val(val) {
          var self3 = this, quoted = nil;
          if ($truthy(val["$start_with?"]('"')) && $truthy(val["$end_with?"]('"')) || $truthy(val["$start_with?"]("'")) && $truthy(val["$end_with?"]("'"))) {
            quoted = true;
            val = val.$slice(1, $rb_minus(val.$length(), 1));
          } else {
            quoted = false;
          }
          ;
          if ($truthy(val["$include?"]($$2("ATTR_REF_HEAD")))) {
            val = self3.document.$sub_attributes(val, $hash2(["attribute_missing"], { "attribute_missing": "drop" }));
          }
          ;
          if ($truthy(quoted)) {
            return val;
          } else if ($truthy(val["$empty?"]())) {
            return nil;
          } else if ($eqeq(val, "true")) {
            return true;
          } else if ($eqeq(val, "false")) {
            return false;
          } else if ($truthy(val.$rstrip()["$empty?"]())) {
            return " ";
          } else if ($truthy(val["$include?"]("."))) {
            return val.$to_f();
          } else {
            return val.$to_i();
          }
          ;
        });
      }($nesting2[0], $$("Reader"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/section"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $eqeqeq = Opal2.eqeqeq, $truthy = Opal2.truthy, $rb_plus = Opal2.rb_plus, $def = Opal2.def, $alias = Opal2.alias, $rb_gt = Opal2.rb_gt, $eqeq = Opal2.eqeq, $not = Opal2.not, $send = Opal2.send, $defs = Opal2.defs, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("attr_accessor,attr_reader,===,+,level,special,title,generate_id,>,==,sectnum,!,empty?,reftext,sub_placeholder,sub_quotes,compat_mode,[],attributes,context,assign_numeral,class,object_id,inspect,size,[]=,chr,length,gsub,downcase,delete,tr_s,end_with?,chop,start_with?,slice,key?,catalog,unique_id_start_index");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Section");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.document = $proto.next_section_index = $proto.parent = $proto.level = $proto.numeral = $proto.numbered = $proto.sectname = $proto.title = $proto.blocks = nil;
        self2.$attr_accessor("index");
        self2.$attr_accessor("sectname");
        self2.$attr_accessor("special");
        self2.$attr_accessor("numbered");
        self2.$attr_reader("caption");
        $def(self2, "$initialize", function $$initialize(parent, level, numbered, opts) {
          var $a, $yield = $$initialize.$$p || nil, self3 = this, $ret_or_1 = nil;
          $$initialize.$$p = null;
          if (parent == null)
            parent = nil;
          if (level == null)
            level = nil;
          if (numbered == null)
            numbered = false;
          if (opts == null)
            opts = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, "section", opts], null);
          if ($eqeqeq($$2("Section"), parent)) {
            $a = [$truthy($ret_or_1 = level) ? $ret_or_1 : $rb_plus(parent.$level(), 1), parent.$special()], self3.level = $a[0], self3.special = $a[1], $a;
          } else {
            $a = [$truthy($ret_or_1 = level) ? $ret_or_1 : 1, false], self3.level = $a[0], self3.special = $a[1], $a;
          }
          ;
          self3.numbered = numbered;
          return self3.index = 0;
        }, -1);
        $alias(self2, "name", "title");
        $def(self2, "$generate_id", function $$generate_id() {
          var self3 = this;
          return $$2("Section").$generate_id(self3.$title(), self3.document);
        });
        $def(self2, "$sections?", function $Section_sections$ques$1() {
          var self3 = this;
          return $rb_gt(self3.next_section_index, 0);
        });
        $def(self2, "$sectnum", function $$sectnum(delimiter, append) {
          var self3 = this, $ret_or_1 = nil;
          if (delimiter == null)
            delimiter = ".";
          if (append == null)
            append = nil;
          append = $truthy($ret_or_1 = append) ? $ret_or_1 : $eqeq(append, false) ? "" : delimiter;
          if ($truthy($rb_gt(self3.level, 1)) && $eqeqeq($$2("Section"), self3.parent)) {
            return "" + self3.parent.$sectnum(delimiter, delimiter) + self3.numeral + append;
          } else {
            return "" + self3.numeral + append;
          }
          ;
        }, -1);
        $def(self2, "$xreftext", function $$xreftext(xrefstyle) {
          var self3 = this, val = nil, type = nil, quoted_title = nil, signifier = nil;
          if (xrefstyle == null)
            xrefstyle = nil;
          if ($truthy(val = self3.$reftext()) && $not(val["$empty?"]())) {
            return val;
          } else if ($truthy(xrefstyle)) {
            if ($truthy(self3.numbered)) {
              switch (xrefstyle) {
                case "full":
                  if ($eqeq(type = self3.sectname, "chapter") || $eqeq(type, "appendix")) {
                    quoted_title = self3.$sub_placeholder(self3.$sub_quotes("_%s_"), self3.$title());
                  } else {
                    quoted_title = self3.$sub_placeholder(self3.$sub_quotes($truthy(self3.document.$compat_mode()) ? "``%s''" : '"`%s`"'), self3.$title());
                  }
                  ;
                  if ($truthy(signifier = self3.document.$attributes()["$[]"]("" + type + "-refsig"))) {
                    return "" + signifier + " " + self3.$sectnum(".", ",") + " " + quoted_title;
                  } else {
                    return "" + self3.$sectnum(".", ",") + " " + quoted_title;
                  }
                  ;
                  break;
                case "short":
                  if ($truthy(signifier = self3.document.$attributes()["$[]"]("" + self3.sectname + "-refsig"))) {
                    return "" + signifier + " " + self3.$sectnum(".", "");
                  } else {
                    return self3.$sectnum(".", "");
                  }
                  break;
                default:
                  if ($eqeq(type = self3.sectname, "chapter") || $eqeq(type, "appendix")) {
                    return self3.$sub_placeholder(self3.$sub_quotes("_%s_"), self3.$title());
                  } else {
                    return self3.$title();
                  }
              }
            } else if ($eqeq(type = self3.sectname, "chapter") || $eqeq(type, "appendix")) {
              return self3.$sub_placeholder(self3.$sub_quotes("_%s_"), self3.$title());
            } else {
              return self3.$title();
            }
          } else {
            return self3.$title();
          }
          ;
        }, -1);
        $def(self2, "$<<", function $Section_$lt$lt$2(block) {
          var $yield = $Section_$lt$lt$2.$$p || nil, self3 = this;
          $Section_$lt$lt$2.$$p = null;
          if ($eqeq(block.$context(), "section")) {
            self3.$assign_numeral(block);
          }
          ;
          return $send2(self3, $find_super(self3, "<<", $Section_$lt$lt$2, false, true), "<<", [block], $yield);
        });
        $def(self2, "$to_s", function $$to_s() {
          var $yield = $$to_s.$$p || nil, self3 = this, formal_title = nil;
          $$to_s.$$p = null;
          if ($truthy(self3.title)) {
            formal_title = $truthy(self3.numbered) ? "" + self3.$sectnum() + " " + self3.title : self3.title;
            return "#<" + self3.$class() + "@" + self3.$object_id() + " {level: " + self3.level + ", title: " + formal_title.$inspect() + ", blocks: " + self3.blocks.$size() + "}>";
          } else {
            return $send2(self3, $find_super(self3, "to_s", $$to_s, false, true), "to_s", [], $yield);
          }
        });
        return $defs(self2, "$generate_id", function $$generate_id(title, document2) {
          var $a, attrs = nil, pre = nil, $ret_or_1 = nil, sep = nil, no_sep = nil, sep_sub = nil, gen_id = nil, ids = nil, cnt = nil, candidate_id = nil;
          attrs = document2.$attributes();
          pre = $truthy($ret_or_1 = attrs["$[]"]("idprefix")) ? $ret_or_1 : "_";
          if ($truthy(sep = attrs["$[]"]("idseparator"))) {
            if ($eqeq(sep.$length(), 1) || $not(no_sep = sep["$empty?"]()) && $truthy(sep = ($a = ["idseparator", sep.$chr()], $send(attrs, "[]=", $a), $a[$a.length - 1]))) {
              sep_sub = $eqeq(sep, "-") || $eqeq(sep, ".") ? " .-" : " " + sep + ".-";
            }
          } else {
            $a = ["_", " _.-"], sep = $a[0], sep_sub = $a[1], $a;
          }
          ;
          gen_id = "" + pre + title.$downcase().$gsub($$2("InvalidSectionIdCharsRx"), "");
          if ($truthy(no_sep)) {
            gen_id = gen_id.$delete(" ");
          } else {
            gen_id = gen_id.$tr_s(sep_sub, sep);
            if ($truthy(gen_id["$end_with?"](sep))) {
              gen_id = gen_id.$chop();
            }
            ;
            if ($truthy(pre["$empty?"]()) && $truthy(gen_id["$start_with?"](sep))) {
              gen_id = gen_id.$slice(1, gen_id.$length());
            }
            ;
          }
          ;
          if ($truthy(document2.$catalog()["$[]"]("refs")["$key?"](gen_id))) {
            ids = document2.$catalog()["$[]"]("refs");
            cnt = $$2("Compliance").$unique_id_start_index();
            while ($truthy(ids["$[]"](candidate_id = "" + gen_id + sep + cnt))) {
              cnt = $rb_plus(cnt, 1);
            }
            ;
            return candidate_id;
          } else {
            return gen_id;
          }
          ;
        });
      }($nesting2[0], $$("AbstractBlock"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/stylesheets"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $return_ivar = Opal2.return_ivar, $defs = Opal2.defs, $def = Opal2.def, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("join,new,rstrip,read,primary_stylesheet_data,write,primary_stylesheet_name,stylesheet_basename,for,read_stylesheet,coderay_stylesheet_data,coderay_stylesheet_name,pygments_stylesheet_data,pygments_stylesheet_name");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Stylesheets");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.primary_stylesheet_data = nil;
        $const_set($nesting3[0], "DEFAULT_STYLESHEET_NAME", "asciidoctor.css");
        $const_set($nesting3[0], "STYLESHEETS_DIR", $$$("File").$join($$("DATA_DIR"), "stylesheets"));
        self2.__instance__ = self2.$new();
        $defs(self2, "$instance", $return_ivar("__instance__"));
        $def(self2, "$primary_stylesheet_name", function $$primary_stylesheet_name() {
          return $$("DEFAULT_STYLESHEET_NAME");
        });
        $def(self2, "$primary_stylesheet_data", function $$primary_stylesheet_data() {
          var self3 = this, $ret_or_1 = nil;
          return self3.primary_stylesheet_data = $truthy($ret_or_1 = self3.primary_stylesheet_data) ? $ret_or_1 : $$$("File").$read($$$("File").$join($$("STYLESHEETS_DIR"), "asciidoctor-default.css"), $hash2(["mode"], { "mode": $$("FILE_READ_MODE") })).$rstrip();
        });
        $def(self2, "$embed_primary_stylesheet", function $$embed_primary_stylesheet() {
          var self3 = this;
          return "<style>\n" + self3.$primary_stylesheet_data() + "\n</style>";
        });
        $def(self2, "$write_primary_stylesheet", function $$write_primary_stylesheet(target_dir) {
          var self3 = this;
          if (target_dir == null)
            target_dir = ".";
          return $$$("File").$write($$$("File").$join(target_dir, self3.$primary_stylesheet_name()), self3.$primary_stylesheet_data(), $hash2(["mode"], { "mode": $$("FILE_WRITE_MODE") }));
        }, -1);
        $def(self2, "$coderay_stylesheet_name", function $$coderay_stylesheet_name() {
          return $$("SyntaxHighlighter").$for("coderay").$stylesheet_basename();
        });
        $def(self2, "$coderay_stylesheet_data", function $$coderay_stylesheet_data() {
          return $$("SyntaxHighlighter").$for("coderay").$read_stylesheet();
        });
        $def(self2, "$embed_coderay_stylesheet", function $$embed_coderay_stylesheet() {
          var self3 = this;
          return "<style>\n" + self3.$coderay_stylesheet_data() + "\n</style>";
        });
        $def(self2, "$write_coderay_stylesheet", function $$write_coderay_stylesheet(target_dir) {
          var self3 = this;
          if (target_dir == null)
            target_dir = ".";
          return $$$("File").$write($$$("File").$join(target_dir, self3.$coderay_stylesheet_name()), self3.$coderay_stylesheet_data(), $hash2(["mode"], { "mode": $$("FILE_WRITE_MODE") }));
        }, -1);
        $def(self2, "$pygments_stylesheet_name", function $$pygments_stylesheet_name(style) {
          if (style == null)
            style = nil;
          return $$("SyntaxHighlighter").$for("pygments").$stylesheet_basename(style);
        }, -1);
        $def(self2, "$pygments_stylesheet_data", function $$pygments_stylesheet_data(style) {
          if (style == null)
            style = nil;
          return $$("SyntaxHighlighter").$for("pygments").$read_stylesheet(style);
        }, -1);
        $def(self2, "$embed_pygments_stylesheet", function $$embed_pygments_stylesheet(style) {
          var self3 = this;
          if (style == null)
            style = nil;
          return "<style>\n" + self3.$pygments_stylesheet_data(style) + "\n</style>";
        }, -1);
        return $def(self2, "$write_pygments_stylesheet", function $$write_pygments_stylesheet(target_dir, style) {
          var self3 = this;
          if (target_dir == null)
            target_dir = ".";
          if (style == null)
            style = nil;
          return $$$("File").$write($$$("File").$join(target_dir, self3.$pygments_stylesheet_name(style)), self3.$pygments_stylesheet_data(style), $hash2(["mode"], { "mode": $$("FILE_WRITE_MODE") }));
        }, -1);
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/table"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $def = Opal2.def, $alias = Opal2.alias, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $truthy = Opal2.truthy, $rb_lt = Opal2.rb_lt, $rb_gt = Opal2.rb_gt, $eqeq = Opal2.eqeq, $rb_times = Opal2.rb_times, $rb_divide = Opal2.rb_divide, $send = Opal2.send, $rb_plus = Opal2.rb_plus, $rb_minus = Opal2.rb_minus, $return_val = Opal2.return_val, $to_a = Opal2.to_a, $gvars = Opal2.gvars, $neqeq = Opal2.neqeq, $return_ivar = Opal2.return_ivar, $to_ary = Opal2.to_ary, $regexp = Opal2.regexp, $not = Opal2.not, $thrower = Opal2.thrower, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("attr_accessor,send,attr_reader,new,[],<,>,to_i,==,[]=,attributes,truncate,*,/,to_f,empty?,body,each,<<,size,+,assign_column_widths,warn,logger,-,update_attributes,assign_width,round,head=,map,shift,reinitialize,nil?,unshift,foot=,pop,parent,sourcemap,dup,header_row?,table,style,merge,delete,start_with?,rstrip,slice,length,advance,lstrip,strip,split,include?,readlines,catalog_inline_anchor,=~,apply_subs,attr_writer,convert,text,!=,file,lineno,include,to_set,mark,key?,nested?,document,error,message_with_context,cursor_at_prev_line,nil_or_empty?,escape,columns,match,chop,end_with?,gsub,!,push_cellspec,cell_open?,close_cell,take_cellspec,squeeze,upto,times,cursor_before_mark,rowspan,activate_rowspan,colspan,end_of_row?,close_row,private,rows,effective_column_visits");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      (function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Table");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.attributes = $proto.document = $proto.rows = $proto.has_header_option = $proto.columns = nil;
        $const_set($nesting3[0], "DEFAULT_PRECISION", 4);
        (function($base3, $super2) {
          var self3 = $klass($base3, $super2, "Rows");
          var $proto2 = self3.$$prototype;
          $proto2.head = $proto2.body = $proto2.foot = nil;
          self3.$attr_accessor("head", "foot", "body");
          $def(self3, "$initialize", function $$initialize(head, foot, body) {
            var self4 = this;
            if (head == null)
              head = [];
            if (foot == null)
              foot = [];
            if (body == null)
              body = [];
            self4.head = head;
            self4.foot = foot;
            return self4.body = body;
          }, -1);
          $alias(self3, "[]", "send");
          $def(self3, "$by_section", function $$by_section() {
            var self4 = this;
            return [["head", self4.head], ["body", self4.body], ["foot", self4.foot]];
          });
          return $def(self3, "$to_h", function $$to_h() {
            var self4 = this;
            return $hash2(["head", "body", "foot"], { "head": self4.head, "body": self4.body, "foot": self4.foot });
          });
        })($nesting3[0], null);
        self2.$attr_accessor("columns");
        self2.$attr_accessor("rows");
        self2.$attr_accessor("has_header_option");
        self2.$attr_reader("caption");
        $def(self2, "$initialize", function $$initialize(parent, attributes) {
          var $a, $yield = $$initialize.$$p || nil, self3 = this, pcwidth = nil, pcwidth_intval = nil, abswidth_val = nil;
          $$initialize.$$p = null;
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [parent, "table"], null);
          self3.rows = $$2("Rows").$new();
          self3.columns = [];
          self3.has_header_option = false;
          if ($truthy(pcwidth = attributes["$[]"]("width"))) {
            if ($truthy($rb_gt(pcwidth_intval = pcwidth.$to_i(), 100)) || $truthy($rb_lt(pcwidth_intval, 1))) {
              if (!($eqeq(pcwidth_intval, 0) && ($eqeq(pcwidth, "0") || $eqeq(pcwidth, "0%")))) {
                pcwidth_intval = 100;
              }
            }
          } else {
            pcwidth_intval = 100;
          }
          ;
          self3.attributes["$[]="]("tablepcwidth", pcwidth_intval);
          if ($truthy(self3.document.$attributes()["$[]"]("pagewidth"))) {
            self3.attributes["$[]="]("tableabswidth", $eqeq(abswidth_val = $rb_times($rb_divide(pcwidth_intval, 100), self3.document.$attributes()["$[]"]("pagewidth").$to_f()).$truncate($$2("DEFAULT_PRECISION")), abswidth_val.$to_i()) ? abswidth_val.$to_i() : abswidth_val);
          }
          ;
          if ($truthy(attributes["$[]"]("rotate-option"))) {
            return $a = ["orientation", "landscape"], $send(self3.attributes, "[]=", $a), $a[$a.length - 1];
          } else {
            return nil;
          }
          ;
        });
        $def(self2, "$header_row?", function $Table_header_row$ques$1() {
          var self3 = this, val = nil;
          if ($truthy(val = self3.has_header_option) && $truthy(self3.rows.$body()["$empty?"]())) {
            return val;
          } else {
            return nil;
          }
        });
        $def(self2, "$create_columns", function $$create_columns(colspecs) {
          var self3 = this, cols = nil, autowidth_cols = nil, width_base = nil, num_cols = nil;
          cols = [];
          autowidth_cols = nil;
          width_base = 0;
          $send(colspecs, "each", [], function $$22(colspec) {
            var self4 = $$22.$$s == null ? this : $$22.$$s, colwidth = nil, $ret_or_1 = nil;
            if (colspec == null)
              colspec = nil;
            colwidth = colspec["$[]"]("width");
            cols["$<<"]($$2("Column").$new(self4, cols.$size(), colspec));
            if ($truthy($rb_lt(colwidth, 0))) {
              return (autowidth_cols = $truthy($ret_or_1 = autowidth_cols) ? $ret_or_1 : [])["$<<"](cols["$[]"](-1));
            } else {
              return width_base = $rb_plus(width_base, colwidth);
            }
            ;
          }, { $$s: self3 });
          if ($truthy($rb_gt(num_cols = (self3.columns = cols).$size(), 0))) {
            self3.attributes["$[]="]("colcount", num_cols);
            if (!($truthy($rb_gt(width_base, 0)) || $truthy(autowidth_cols))) {
              width_base = nil;
            }
            ;
            self3.$assign_column_widths(width_base, autowidth_cols);
          }
          ;
          return nil;
        });
        $def(self2, "$assign_column_widths", function $$assign_column_widths(width_base, autowidth_cols) {
          var self3 = this, precision = nil, total_width = nil, col_pcwidth = nil, autowidth = nil, autowidth_attrs = nil;
          if (width_base == null)
            width_base = nil;
          if (autowidth_cols == null)
            autowidth_cols = nil;
          precision = $$2("DEFAULT_PRECISION");
          total_width = col_pcwidth = 0;
          if ($truthy(width_base)) {
            if ($truthy(autowidth_cols)) {
              if ($truthy($rb_gt(width_base, 100))) {
                autowidth = 0;
                self3.$logger().$warn("total column width must not exceed 100% when using autowidth columns; got " + width_base + "%");
              } else {
                autowidth = $rb_divide($rb_minus(100, width_base), autowidth_cols.$size()).$truncate(precision);
                if ($eqeq(autowidth.$to_i(), autowidth)) {
                  autowidth = autowidth.$to_i();
                }
                ;
                width_base = 100;
              }
              ;
              autowidth_attrs = $hash2(["width", "autowidth-option"], { "width": autowidth, "autowidth-option": "" });
              $send(autowidth_cols, "each", [], function $$3(col) {
                if (col == null)
                  col = nil;
                return col.$update_attributes(autowidth_attrs);
              });
            }
            ;
            $send(self3.columns, "each", [], function $$4(col) {
              if (col == null)
                col = nil;
              return total_width = $rb_plus(total_width, col_pcwidth = col.$assign_width(nil, width_base, precision));
            });
          } else {
            col_pcwidth = $rb_divide(100, self3.columns.$size()).$truncate(precision);
            if ($eqeq(col_pcwidth.$to_i(), col_pcwidth)) {
              col_pcwidth = col_pcwidth.$to_i();
            }
            ;
            $send(self3.columns, "each", [], function $$5(col) {
              if (col == null)
                col = nil;
              return total_width = $rb_plus(total_width, col.$assign_width(col_pcwidth, nil, precision));
            });
          }
          ;
          if (!$eqeq(total_width, 100)) {
            self3.columns["$[]"](-1).$assign_width($rb_plus($rb_minus(100, total_width), col_pcwidth).$round(precision), nil, precision);
          }
          ;
          return nil;
        }, -1);
        return $def(self2, "$partition_header_footer", function $$partition_header_footer(attrs) {
          var $a, self3 = this, num_body_rows = nil, body = nil;
          num_body_rows = ($a = ["rowcount", (body = self3.rows.$body()).$size()], $send(self3.attributes, "[]=", $a), $a[$a.length - 1]);
          if ($truthy($rb_gt(num_body_rows, 0))) {
            if ($truthy(self3.has_header_option)) {
              self3.rows["$head="]([$send(body.$shift(), "map", [], function $$6(cell) {
                if (cell == null)
                  cell = nil;
                return cell.$reinitialize(true);
              })]);
              num_body_rows = $rb_minus(num_body_rows, 1);
            } else if ($truthy(self3.has_header_option["$nil?"]())) {
              self3.has_header_option = false;
              body.$unshift($send(body.$shift(), "map", [], function $$7(cell) {
                if (cell == null)
                  cell = nil;
                return cell.$reinitialize(false);
              }));
            }
          }
          ;
          if ($truthy($rb_gt(num_body_rows, 0)) && $truthy(attrs["$[]"]("footer-option"))) {
            self3.rows["$foot="]([body.$pop()]);
          }
          ;
          return nil;
        });
      })($nesting2[0], $$("AbstractBlock"), $nesting2);
      (function($base2, $super) {
        var self2 = $klass($base2, $super, "Column");
        var $proto = self2.$$prototype;
        $proto.attributes = nil;
        self2.$attr_accessor("style");
        $def(self2, "$initialize", function $$initialize(table, index, attributes) {
          var $yield = $$initialize.$$p || nil, self3 = this, $ret_or_1 = nil;
          $$initialize.$$p = null;
          if (attributes == null)
            attributes = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [table, "table_column"], null);
          self3.style = attributes["$[]"]("style");
          attributes["$[]="]("colnumber", $rb_plus(index, 1));
          if ($truthy($ret_or_1 = attributes["$[]"]("width"))) {
            $ret_or_1;
          } else {
            attributes["$[]="]("width", 1);
          }
          ;
          if ($truthy($ret_or_1 = attributes["$[]"]("halign"))) {
            $ret_or_1;
          } else {
            attributes["$[]="]("halign", "left");
          }
          ;
          if ($truthy($ret_or_1 = attributes["$[]"]("valign"))) {
            $ret_or_1;
          } else {
            attributes["$[]="]("valign", "top");
          }
          ;
          return self3.$update_attributes(attributes);
        }, -3);
        $alias(self2, "table", "parent");
        $def(self2, "$assign_width", function $$assign_width(col_pcwidth, width_base, precision) {
          var $a, self3 = this, col_abswidth = nil;
          if ($truthy(width_base)) {
            col_pcwidth = $rb_divide($rb_times(self3.attributes["$[]"]("width").$to_f(), 100), width_base).$truncate(precision);
            if ($eqeq(col_pcwidth.$to_i(), col_pcwidth)) {
              col_pcwidth = col_pcwidth.$to_i();
            }
            ;
          }
          ;
          if ($truthy(self3.$parent().$attributes()["$[]"]("tableabswidth"))) {
            self3.attributes["$[]="]("colabswidth", $eqeq(col_abswidth = $rb_times($rb_divide(col_pcwidth, 100), self3.$parent().$attributes()["$[]"]("tableabswidth")).$truncate(precision), col_abswidth.$to_i()) ? col_abswidth.$to_i() : col_abswidth);
          }
          ;
          return $a = ["colpcwidth", col_pcwidth], $send(self3.attributes, "[]=", $a), $a[$a.length - 1];
        });
        $def(self2, "$block?", $return_val(false));
        return $def(self2, "$inline?", $return_val(false));
      })($$("Table"), $$("AbstractNode"));
      (function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Cell");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.document = $proto.reinitialize_args = $proto.attributes = $proto.cursor = $proto.text = $proto.subs = $proto.style = $proto.inner_document = $proto.source_location = $proto.colspan = $proto.rowspan = nil;
        $const_set($nesting3[0], "DOUBLE_LF", $rb_times($$2("LF"), 2));
        self2.$attr_accessor("colspan");
        self2.$attr_accessor("rowspan");
        $alias(self2, "column", "parent");
        self2.$attr_reader("inner_document");
        $def(self2, "$initialize", function $$initialize(column, cell_text, attributes, opts) {
          var $a, $yield = $$initialize.$$p || nil, self3 = this, in_header_row = nil, cell_style = nil, $ret_or_1 = nil, $ret_or_2 = nil, asciidoc2 = nil, inner_document_cursor = nil, lines_advanced = nil, literal = nil, normal_psv = nil, parent_doctitle = nil, inner_document_lines = nil, unprocessed_line1 = nil, preprocessed_lines = nil;
          $$initialize.$$p = null;
          if (attributes == null)
            attributes = $hash2([], {});
          if (opts == null)
            opts = $hash2([], {});
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [column, "table_cell"], null);
          self3.cursor = self3.reinitialize_args = nil;
          if ($truthy(self3.document.$sourcemap())) {
            self3.source_location = opts["$[]"]("cursor").$dup();
          }
          ;
          if ($truthy(column)) {
            if ($truthy(in_header_row = column.$table()["$header_row?"]())) {
              if ($eqeq(in_header_row, "implicit") && $truthy(cell_style = $truthy($ret_or_1 = column.$style()) ? $ret_or_1 : $truthy($ret_or_2 = attributes) ? attributes["$[]"]("style") : $ret_or_2)) {
                if ($eqeq(cell_style, "asciidoc") || $eqeq(cell_style, "literal")) {
                  self3.reinitialize_args = [column, cell_text, $truthy($ret_or_1 = attributes) ? attributes.$merge() : $ret_or_1, opts];
                }
                ;
                cell_style = nil;
              }
            } else {
              cell_style = column.$style();
            }
            ;
            self3.$update_attributes(column.$attributes());
          }
          ;
          if ($truthy(attributes)) {
            if ($truthy(attributes["$empty?"]())) {
              self3.colspan = self3.rowspan = nil;
            } else {
              $a = [attributes.$delete("colspan"), attributes.$delete("rowspan")], self3.colspan = $a[0], self3.rowspan = $a[1], $a;
              if (!$truthy(in_header_row)) {
                cell_style = $truthy($ret_or_1 = attributes["$[]"]("style")) ? $ret_or_1 : cell_style;
              }
              ;
              self3.$update_attributes(attributes);
            }
            ;
            switch (cell_style) {
              case "asciidoc":
                asciidoc2 = true;
                inner_document_cursor = opts["$[]"]("cursor");
                if ($truthy((cell_text = cell_text.$rstrip())["$start_with?"]($$2("LF")))) {
                  lines_advanced = 1;
                  while ($truthy((cell_text = cell_text.$slice(1, cell_text.$length()))["$start_with?"]($$2("LF")))) {
                    lines_advanced = $rb_plus(lines_advanced, 1);
                  }
                  ;
                  inner_document_cursor.$advance(lines_advanced);
                } else {
                  cell_text = cell_text.$lstrip();
                }
                ;
                break;
              case "literal":
                literal = true;
                cell_text = cell_text.$rstrip();
                while ($truthy(cell_text["$start_with?"]($$2("LF")))) {
                  cell_text = cell_text.$slice(1, cell_text.$length());
                }
                ;
                break;
              default:
                normal_psv = true;
                cell_text = $truthy(cell_text) ? cell_text.$strip() : "";
            }
            ;
          } else {
            self3.colspan = self3.rowspan = nil;
            if ($eqeq(cell_style, "asciidoc")) {
              asciidoc2 = true;
              inner_document_cursor = opts["$[]"]("cursor");
            }
            ;
          }
          ;
          if ($truthy(asciidoc2)) {
            parent_doctitle = self3.document.$attributes().$delete("doctitle");
            inner_document_lines = cell_text.$split($$2("LF"), -1);
            if (!$truthy(inner_document_lines["$empty?"]())) {
              if ($truthy((unprocessed_line1 = inner_document_lines["$[]"](0))["$include?"]("::"))) {
                preprocessed_lines = $$2("PreprocessorReader").$new(self3.document, [unprocessed_line1]).$readlines();
                if (!($eqeq(unprocessed_line1, preprocessed_lines["$[]"](0)) && $truthy($rb_lt(preprocessed_lines.$size(), 2)))) {
                  inner_document_lines.$shift();
                  if (!$truthy(preprocessed_lines["$empty?"]())) {
                    $send(inner_document_lines, "unshift", $to_a(preprocessed_lines));
                  }
                  ;
                }
                ;
              }
            }
            ;
            self3.inner_document = $$2("Document").$new(inner_document_lines, $hash2(["standalone", "parent", "cursor"], { "standalone": false, "parent": self3.document, "cursor": inner_document_cursor }));
            if (!$truthy(parent_doctitle["$nil?"]())) {
              self3.document.$attributes()["$[]="]("doctitle", parent_doctitle);
            }
            ;
            self3.subs = nil;
          } else if ($truthy(literal)) {
            self3.content_model = "verbatim";
            self3.subs = $$2("BASIC_SUBS");
          } else {
            if ($truthy(normal_psv)) {
              if ($truthy(in_header_row)) {
                self3.cursor = opts["$[]"]("cursor");
              } else {
                self3.$catalog_inline_anchor(cell_text, opts["$[]"]("cursor"));
              }
            }
            ;
            self3.content_model = "simple";
            self3.subs = $$2("NORMAL_SUBS");
          }
          ;
          self3.text = cell_text;
          return self3.style = cell_style;
        }, -3);
        $def(self2, "$reinitialize", function $$reinitialize(has_header) {
          var self3 = this;
          if ($truthy(has_header)) {
            self3.reinitialize_args = nil;
          } else if ($truthy(self3.reinitialize_args)) {
            return $send($$$($$2("Table"), "Cell"), "new", $to_a(self3.reinitialize_args));
          } else {
            self3.style = self3.attributes["$[]"]("style");
          }
          ;
          if ($truthy(self3.cursor)) {
            self3.$catalog_inline_anchor();
          }
          ;
          return self3;
        });
        $def(self2, "$catalog_inline_anchor", function $$catalog_inline_anchor(cell_text, cursor) {
          var $a, self3 = this;
          if (cell_text == null)
            cell_text = self3.text;
          if (cursor == null)
            cursor = nil;
          if (!$truthy(cursor)) {
            $a = [self3.cursor, nil], cursor = $a[0], self3.cursor = $a[1], $a;
          }
          ;
          if ($truthy(cell_text["$start_with?"]("[[")) && $truthy($$2("LeadingInlineAnchorRx")["$=~"](cell_text))) {
            return $$2("Parser").$catalog_inline_anchor(($a = $gvars["~"]) === nil ? nil : $a["$[]"](1), ($a = $gvars["~"]) === nil ? nil : $a["$[]"](2), self3, cursor, self3.document);
          } else {
            return nil;
          }
          ;
        }, -1);
        $def(self2, "$text", function $$text() {
          var self3 = this;
          return self3.$apply_subs(self3.text, self3.subs);
        });
        self2.$attr_writer("text");
        $def(self2, "$content", function $$content() {
          var self3 = this, cell_style = nil, subbed_text = nil;
          if ($eqeq(cell_style = self3.style, "asciidoc")) {
            return self3.inner_document.$convert();
          } else if ($truthy(self3.text["$include?"]($$2("DOUBLE_LF")))) {
            return $send(self3.$text().$split($$2("BlankLineRx")), "map", [], function $$8(para) {
              var self4 = $$8.$$s == null ? this : $$8.$$s;
              if (para == null)
                para = nil;
              if ($truthy(cell_style) && $neqeq(cell_style, "header")) {
                return $$2("Inline").$new(self4.$parent(), "quoted", para, $hash2(["type"], { "type": cell_style })).$convert();
              } else {
                return para;
              }
              ;
            }, { $$s: self3 });
          } else if ($truthy((subbed_text = self3.$text())["$empty?"]())) {
            return [];
          } else if ($truthy(cell_style) && $neqeq(cell_style, "header")) {
            return [$$2("Inline").$new(self3.$parent(), "quoted", subbed_text, $hash2(["type"], { "type": cell_style })).$convert()];
          } else {
            return [subbed_text];
          }
        });
        $def(self2, "$lines", function $$lines() {
          var self3 = this;
          return self3.text.$split($$2("LF"));
        });
        $def(self2, "$source", $return_ivar("text"));
        $def(self2, "$file", function $$file() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.source_location)) {
            return self3.source_location.$file();
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$lineno", function $$lineno() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.source_location)) {
            return self3.source_location.$lineno();
          } else {
            return $ret_or_1;
          }
        });
        return $def(self2, "$to_s", function $$to_s() {
          var $yield = $$to_s.$$p || nil, self3 = this, $ret_or_1 = nil;
          $$to_s.$$p = null;
          return "" + $send2(self3, $find_super(self3, "to_s", $$to_s, false, true), "to_s", [], $yield) + " - [text: " + self3.text + ", colspan: " + ($truthy($ret_or_1 = self3.colspan) ? $ret_or_1 : 1) + ", rowspan: " + ($truthy($ret_or_1 = self3.rowspan) ? $ret_or_1 : 1) + ", attributes: " + self3.attributes + "]";
        });
      })($$("Table"), $$("AbstractBlock"), $nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "ParserContext");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.delimiter = $proto.delimiter_rx = $proto.buffer = $proto.cellspecs = $proto.cell_open = $proto.format = $proto.start_cursor_data = $proto.reader = $proto.table = $proto.current_row = $proto.colcount = $proto.column_visits = $proto.active_rowspans = $proto.linenum = nil;
        self2.$include($$2("Logging"));
        $const_set($nesting3[0], "FORMATS", ["psv", "csv", "dsv", "tsv"].$to_set());
        $const_set($nesting3[0], "DELIMITERS", $hash2(["psv", "csv", "dsv", "tsv", "!sv"], { "psv": ["|", /\|/], "csv": [",", /,/], "dsv": [":", /:/], "tsv": ["	", /\t/], "!sv": ["!", /!/] }));
        self2.$attr_accessor("table");
        self2.$attr_accessor("format");
        self2.$attr_reader("colcount");
        self2.$attr_accessor("buffer");
        self2.$attr_reader("delimiter");
        self2.$attr_reader("delimiter_re");
        $def(self2, "$initialize", function $$initialize(reader, table, attributes) {
          var $a, $b, self3 = this, xsv = nil, sep = nil;
          if (attributes == null)
            attributes = $hash2([], {});
          self3.start_cursor_data = (self3.reader = reader).$mark();
          self3.table = table;
          if ($truthy(attributes["$key?"]("format"))) {
            if ($truthy($$2("FORMATS")["$include?"](xsv = attributes["$[]"]("format")))) {
              if ($eqeq(xsv, "tsv")) {
                self3.format = "csv";
              } else if ($eqeq(self3.format = xsv, "psv") && $truthy(table.$document()["$nested?"]())) {
                xsv = "!sv";
              }
            } else {
              self3.$logger().$error(self3.$message_with_context("illegal table format: " + xsv, $hash2(["source_location"], { "source_location": reader.$cursor_at_prev_line() })));
              $a = ["psv", $truthy(table.$document()["$nested?"]()) ? "!sv" : "psv"], self3.format = $a[0], xsv = $a[1], $a;
            }
          } else {
            $a = ["psv", $truthy(table.$document()["$nested?"]()) ? "!sv" : "psv"], self3.format = $a[0], xsv = $a[1], $a;
          }
          ;
          if ($truthy(attributes["$key?"]("separator"))) {
            if ($truthy((sep = attributes["$[]"]("separator"))["$nil_or_empty?"]())) {
              $b = $$2("DELIMITERS")["$[]"](xsv), $a = $to_ary($b), self3.delimiter = $a[0] == null ? nil : $a[0], self3.delimiter_rx = $a[1] == null ? nil : $a[1], $b;
            } else if ($eqeq(sep, "\\t")) {
              $b = $$2("DELIMITERS")["$[]"]("tsv"), $a = $to_ary($b), self3.delimiter = $a[0] == null ? nil : $a[0], self3.delimiter_rx = $a[1] == null ? nil : $a[1], $b;
            } else {
              $a = [sep, $regexp([$$$("Regexp").$escape(sep)])], self3.delimiter = $a[0], self3.delimiter_rx = $a[1], $a;
            }
          } else {
            $b = $$2("DELIMITERS")["$[]"](xsv), $a = $to_ary($b), self3.delimiter = $a[0] == null ? nil : $a[0], self3.delimiter_rx = $a[1] == null ? nil : $a[1], $b;
          }
          ;
          self3.colcount = $truthy(table.$columns()["$empty?"]()) ? -1 : table.$columns().$size();
          self3.buffer = "";
          self3.cellspecs = [];
          self3.cell_open = false;
          self3.active_rowspans = [0];
          self3.column_visits = 0;
          self3.current_row = [];
          return self3.linenum = -1;
        }, -3);
        $def(self2, "$starts_with_delimiter?", function $ParserContext_starts_with_delimiter$ques$9(line) {
          var self3 = this;
          return line["$start_with?"](self3.delimiter);
        });
        $def(self2, "$match_delimiter", function $$match_delimiter(line) {
          var self3 = this;
          return self3.delimiter_rx.$match(line);
        });
        $def(self2, "$skip_past_delimiter", function $$skip_past_delimiter(pre) {
          var self3 = this;
          self3.buffer = "" + self3.buffer + pre + self3.delimiter;
          return nil;
        });
        $def(self2, "$skip_past_escaped_delimiter", function $$skip_past_escaped_delimiter(pre) {
          var self3 = this;
          self3.buffer = "" + self3.buffer + pre.$chop() + self3.delimiter;
          return nil;
        });
        $def(self2, "$buffer_has_unclosed_quotes?", function $ParserContext_buffer_has_unclosed_quotes$ques$10(append, q) {
          var self3 = this, record = nil, qq = nil, trailing_quote = nil, $ret_or_1 = nil;
          if (append == null)
            append = nil;
          if (q == null)
            q = '"';
          if ($eqeq(record = $truthy(append) ? $rb_plus(self3.buffer, append).$strip() : self3.buffer.$strip(), q)) {
            return true;
          } else if ($truthy(record["$start_with?"](q))) {
            qq = $rb_plus(q, q);
            if ($truthy(trailing_quote = record["$end_with?"](q)) && $truthy(record["$end_with?"](qq)) || $truthy(record["$start_with?"](qq))) {
              if ($truthy($ret_or_1 = (record = record.$gsub(qq, ""))["$start_with?"](q))) {
                return record["$end_with?"](q)["$!"]();
              } else {
                return $ret_or_1;
              }
            } else {
              return trailing_quote["$!"]();
            }
            ;
          } else {
            return false;
          }
          ;
        }, -1);
        $def(self2, "$take_cellspec", function $$take_cellspec() {
          var self3 = this;
          return self3.cellspecs.$shift();
        });
        $def(self2, "$push_cellspec", function $$push_cellspec(cellspec) {
          var self3 = this, $ret_or_1 = nil;
          if (cellspec == null)
            cellspec = $hash2([], {});
          self3.cellspecs["$<<"]($truthy($ret_or_1 = cellspec) ? $ret_or_1 : $hash2([], {}));
          return nil;
        }, -1);
        $def(self2, "$keep_cell_open", function $$keep_cell_open() {
          var self3 = this;
          self3.cell_open = true;
          return nil;
        });
        $def(self2, "$mark_cell_closed", function $$mark_cell_closed() {
          var self3 = this;
          self3.cell_open = false;
          return nil;
        });
        $def(self2, "$cell_open?", $return_ivar("cell_open"));
        $def(self2, "$cell_closed?", function $ParserContext_cell_closed$ques$11() {
          var self3 = this;
          return self3.cell_open["$!"]();
        });
        $def(self2, "$close_open_cell", function $$close_open_cell(next_cellspec) {
          var self3 = this;
          if (next_cellspec == null)
            next_cellspec = $hash2([], {});
          self3.$push_cellspec(next_cellspec);
          if ($truthy(self3["$cell_open?"]())) {
            self3.$close_cell(true);
          }
          ;
          self3.$advance();
          return nil;
        }, -1);
        $def(self2, "$close_cell", function $$close_cell(eol) {
          try {
            var $t_return = $thrower("return");
            var self3 = this, cell_text = nil, cellspec = nil, repeat = nil, $ret_or_1 = nil, q = nil;
            if (eol == null)
              eol = false;
            if ($eqeq(self3.format, "psv")) {
              cell_text = self3.buffer;
              self3.buffer = "";
              if ($truthy(cellspec = self3.$take_cellspec())) {
                repeat = $truthy($ret_or_1 = cellspec.$delete("repeatcol")) ? $ret_or_1 : 1;
              } else {
                self3.$logger().$error(self3.$message_with_context("table missing leading separator; recovering automatically", $hash2(["source_location"], { "source_location": $send($$$($$2("Reader"), "Cursor"), "new", $to_a(self3.start_cursor_data)) })));
                cellspec = $hash2([], {});
                repeat = 1;
              }
              ;
            } else {
              cell_text = self3.buffer.$strip();
              self3.buffer = "";
              cellspec = nil;
              repeat = 1;
              if ($eqeq(self3.format, "csv") && $not(cell_text["$empty?"]()) && $truthy(cell_text["$include?"](q = '"'))) {
                if ($truthy(cell_text["$start_with?"](q)) && $truthy(cell_text["$end_with?"](q))) {
                  if ($truthy(cell_text = cell_text.$slice(1, $rb_minus(cell_text.$length(), 2)))) {
                    cell_text = cell_text.$strip().$squeeze(q);
                  } else {
                    self3.$logger().$error(self3.$message_with_context("unclosed quote in CSV data; setting cell to empty", $hash2(["source_location"], { "source_location": self3.reader.$cursor_at_prev_line() })));
                    cell_text = "";
                  }
                } else {
                  cell_text = cell_text.$squeeze(q);
                }
              }
              ;
            }
            ;
            $send(1, "upto", [repeat], function $$12(i) {
              var self4 = $$12.$$s == null ? this : $$12.$$s, column = nil, extra_cols = nil, offset = nil, cell = nil;
              if (self4.colcount == null)
                self4.colcount = nil;
              if (self4.table == null)
                self4.table = nil;
              if (self4.current_row == null)
                self4.current_row = nil;
              if (self4.reader == null)
                self4.reader = nil;
              if (self4.column_visits == null)
                self4.column_visits = nil;
              if (self4.linenum == null)
                self4.linenum = nil;
              if (i == null)
                i = nil;
              if ($eqeq(self4.colcount, -1)) {
                self4.table.$columns()["$<<"](column = $$$($$2("Table"), "Column").$new(self4.table, $rb_minus($rb_plus(self4.table.$columns().$size(), i), 1)));
                if ($truthy(cellspec) && $truthy(cellspec["$key?"]("colspan")) && $truthy($rb_gt(extra_cols = $rb_minus(cellspec["$[]"]("colspan").$to_i(), 1), 0))) {
                  offset = self4.table.$columns().$size();
                  $send(extra_cols, "times", [], function $$13(j) {
                    var self5 = $$13.$$s == null ? this : $$13.$$s;
                    if (self5.table == null)
                      self5.table = nil;
                    if (j == null)
                      j = nil;
                    return self5.table.$columns()["$<<"]($$$($$2("Table"), "Column").$new(self5.table, $rb_plus(offset, j)));
                  }, { $$s: self4 });
                }
                ;
              } else if (!$truthy(column = self4.table.$columns()["$[]"](self4.current_row.$size()))) {
                self4.$logger().$error(self4.$message_with_context("dropping cell because it exceeds specified number of columns", $hash2(["source_location"], { "source_location": self4.reader.$cursor_before_mark() })));
                $t_return.$throw();
              }
              ;
              cell = $$$($$2("Table"), "Cell").$new(column, cell_text, cellspec, $hash2(["cursor"], { "cursor": self4.reader.$cursor_before_mark() }));
              self4.reader.$mark();
              if (!($not(cell.$rowspan()) || $eqeq(cell.$rowspan(), 1))) {
                self4.$activate_rowspan(cell.$rowspan(), $truthy($ret_or_1 = cell.$colspan()) ? $ret_or_1 : 1);
              }
              ;
              self4.column_visits = $rb_plus(self4.column_visits, $truthy($ret_or_1 = cell.$colspan()) ? $ret_or_1 : 1);
              self4.current_row["$<<"](cell);
              if ($truthy(self4["$end_of_row?"]()) && ($neqeq(self4.colcount, -1) || $truthy($rb_gt(self4.linenum, 0)) || $truthy(eol) && $eqeq(i, repeat))) {
                return self4.$close_row();
              } else {
                return nil;
              }
              ;
            }, { $$s: self3, $$ret: $t_return });
            self3.cell_open = false;
            return nil;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        self2.$private();
        $def(self2, "$close_row", function $$close_row() {
          var self3 = this, $ret_or_1 = nil;
          self3.table.$rows().$body()["$<<"](self3.current_row);
          if ($eqeq(self3.colcount, -1)) {
            self3.colcount = self3.column_visits;
          }
          ;
          self3.column_visits = 0;
          self3.current_row = [];
          self3.active_rowspans.$shift();
          if ($truthy($ret_or_1 = self3.active_rowspans["$[]"](0))) {
            $ret_or_1;
          } else {
            self3.active_rowspans["$[]="](0, 0);
          }
          ;
          return nil;
        });
        $def(self2, "$activate_rowspan", function $$activate_rowspan(rowspan, colspan) {
          var self3 = this;
          $send(1, "upto", [$rb_minus(rowspan, 1)], function $$14(i) {
            var $a, self4 = $$14.$$s == null ? this : $$14.$$s, $ret_or_1 = nil;
            if (self4.active_rowspans == null)
              self4.active_rowspans = nil;
            if (i == null)
              i = nil;
            return $a = [i, $rb_plus($truthy($ret_or_1 = self4.active_rowspans["$[]"](i)) ? $ret_or_1 : 0, colspan)], $send(self4.active_rowspans, "[]=", $a), $a[$a.length - 1];
          }, { $$s: self3 });
          return nil;
        });
        $def(self2, "$end_of_row?", function $ParserContext_end_of_row$ques$15() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.colcount["$=="](-1))) {
            return $ret_or_1;
          } else {
            return self3.$effective_column_visits()["$=="](self3.colcount);
          }
        });
        $def(self2, "$effective_column_visits", function $$effective_column_visits() {
          var self3 = this;
          return $rb_plus(self3.column_visits, self3.active_rowspans["$[]"](0));
        });
        return $def(self2, "$advance", function $$advance() {
          var self3 = this;
          return self3.linenum = $rb_plus(self3.linenum, 1);
        });
      }($$("Table"), null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/writer"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $truthy = Opal2.truthy, $rb_plus = Opal2.rb_plus, $hash2 = Opal2.hash2, $def = Opal2.def, $return_val = Opal2.return_val, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("respond_to?,write,+,chomp,include");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      (function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Writer");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        return $def(self2, "$write", function $$write(output, target) {
          if ($truthy(target["$respond_to?"]("write"))) {
            target.$write($rb_plus(output.$chomp(), $$("LF")));
          } else {
            $$$("File").$write(target, output, $hash2(["mode"], { "mode": $$("FILE_WRITE_MODE") }));
          }
          ;
          return nil;
        });
      })($nesting2[0], $nesting2);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "VoidWriter");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self2.$include($$("Writer"));
        return $def(self2, "$write", $return_val(nil));
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/load"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $hash2 = Opal2.hash2, $truthy = Opal2.truthy, $neqeq = Opal2.neqeq, $not = Opal2.not, $eqeqeq = Opal2.eqeqeq, $send = Opal2.send, $to_ary = Opal2.to_ary, $rb_plus = Opal2.rb_plus, $eqeq = Opal2.eqeq, $def = Opal2.def, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("merge,[],start,!=,logger,key?,logger=,new,!,===,dup,tap,each,partition,[]=,split,gsub,+,respond_to?,keys,raise,join,ancestors,class,==,at,to_i,mtime,absolute_path,path,dirname,basename,extname,read,rewind,drop,record,parse,exception,message,set_backtrace,backtrace,stack_trace=,stack_trace,open,load");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function(self2, $parent_nesting2) {
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        $def(self2, "$load", function $$load(input, options) {
          var $a, $b, $c, $d, self3 = this, timings = nil, logger = nil, $ret_or_1 = nil, attrs = nil, input_path = nil, source = nil, doc = nil, e = nil, context = nil, wrapped_e = nil;
          if (options == null)
            options = $hash2([], {});
          try {
            options = options.$merge();
            if ($truthy(timings = options["$[]"]("timings"))) {
              timings.$start("read");
            }
            ;
            if ($truthy(options["$key?"]("logger")) && $neqeq(logger = options["$[]"]("logger"), $$("LoggerManager").$logger())) {
              $$("LoggerManager")["$logger="]($truthy($ret_or_1 = logger) ? $ret_or_1 : $$("NullLogger").$new());
            }
            ;
            if ($not(attrs = options["$[]"]("attributes"))) {
              attrs = $hash2([], {});
            } else if ($eqeqeq($$$("Hash"), attrs)) {
              attrs = attrs.$merge();
            } else if ($truthy(($c = $$$("::", "Java", "skip_raise")) && ($b = $$$($c, "JavaUtil", "skip_raise")) && ($a = $$$($b, "Map", "skip_raise")) ? "constant" : nil) && $eqeqeq($$$($$$($$$("Java"), "JavaUtil"), "Map"), attrs)) {
              attrs = attrs.$dup();
            } else if ($eqeqeq($$$("Array"), attrs)) {
              attrs = $send($hash2([], {}), "tap", [], function $$1(accum) {
                if (accum == null)
                  accum = nil;
                return $send(attrs, "each", [], function $$2(entry) {
                  var $d2, $e, k = nil, _ = nil, v = nil;
                  if (entry == null)
                    entry = nil;
                  $e = entry.$partition("="), $d2 = $to_ary($e), k = $d2[0] == null ? nil : $d2[0], _ = $d2[1] == null ? nil : $d2[1], v = $d2[2] == null ? nil : $d2[2], $e;
                  return $d2 = [k, v], $send(accum, "[]=", $d2), $d2[$d2.length - 1];
                });
              });
            } else if ($eqeqeq($$$("String"), attrs)) {
              attrs = $send($hash2([], {}), "tap", [], function $$3(accum) {
                if (accum == null)
                  accum = nil;
                return $send(attrs.$gsub($$("SpaceDelimiterRx"), $rb_plus("\\1", $$("NULL"))).$gsub($$("EscapedSpaceRx"), "\\1").$split($$("NULL")), "each", [], function $$4(entry) {
                  var $d2, $e, k = nil, _ = nil, v = nil;
                  if (entry == null)
                    entry = nil;
                  $e = entry.$partition("="), $d2 = $to_ary($e), k = $d2[0] == null ? nil : $d2[0], _ = $d2[1] == null ? nil : $d2[1], v = $d2[2] == null ? nil : $d2[2], $e;
                  return $d2 = [k, v], $send(accum, "[]=", $d2), $d2[$d2.length - 1];
                });
              });
            } else if ($truthy(attrs["$respond_to?"]("keys")) && $truthy(attrs["$respond_to?"]("[]"))) {
              attrs = $send($hash2([], {}), "tap", [], function $$5(accum) {
                if (accum == null)
                  accum = nil;
                return $send(attrs.$keys(), "each", [], function $$6(k) {
                  var $d2;
                  if (k == null)
                    k = nil;
                  return $d2 = [k, attrs["$[]"](k)], $send(accum, "[]=", $d2), $d2[$d2.length - 1];
                });
              });
            } else {
              self3.$raise($$$("ArgumentError"), "illegal type for attributes option: " + attrs.$class().$ancestors().$join(" < "));
            }
            ;
            if ($eqeqeq($$$("File"), input)) {
              options["$[]="]("input_mtime", $eqeq($$("RUBY_ENGINE"), "jruby") ? $$$("Time").$at(input.$mtime().$to_i()) : input.$mtime());
              attrs["$[]="]("docfile", input_path = $$$("File").$absolute_path(input.$path()));
              attrs["$[]="]("docdir", $$$("File").$dirname(input_path));
              attrs["$[]="]("docname", $$("Helpers").$basename(input_path, ($d = ["docfilesuffix", $$("Helpers").$extname(input_path)], $send(attrs, "[]=", $d), $d[$d.length - 1])));
              source = input.$read();
            } else if ($truthy(input["$respond_to?"]("read"))) {
              try {
                input.$rewind();
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StandardError")])) {
                  try {
                    nil;
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
              source = input.$read();
            } else if ($eqeqeq($$$("String"), input)) {
              source = input;
            } else if ($eqeqeq($$$("Array"), input)) {
              source = input.$drop(0);
            } else if ($truthy(input)) {
              self3.$raise($$$("ArgumentError"), "unsupported input type: " + input.$class());
            }
            ;
            if ($truthy(timings)) {
              timings.$record("read");
              timings.$start("parse");
            }
            ;
            options["$[]="]("attributes", attrs);
            doc = $eqeq(options["$[]"]("parse"), false) ? $$("Document").$new(source, options) : $$("Document").$new(source, options).$parse();
            if ($truthy(timings)) {
              timings.$record("parse");
            }
            ;
            return doc;
          } catch ($err) {
            if (Opal2.rescue($err, [$$("StandardError")])) {
              e = $err;
              try {
                try {
                  context = "asciidoctor: FAILED: " + ($truthy($ret_or_1 = attrs["$[]"]("docfile")) ? $ret_or_1 : "<stdin>") + ": Failed to load AsciiDoc document";
                  if ($truthy(e["$respond_to?"]("exception"))) {
                    wrapped_e = e.$exception("" + context + " - " + e.$message());
                    wrapped_e.$set_backtrace(e.$backtrace());
                  } else {
                    wrapped_e = e.$class().$new(context, e);
                    wrapped_e["$stack_trace="](e.$stack_trace());
                  }
                  ;
                } catch ($err2) {
                  if (Opal2.rescue($err2, [$$("StandardError")])) {
                    try {
                      wrapped_e = e;
                    } finally {
                      Opal2.pop_exception();
                    }
                  } else {
                    throw $err2;
                  }
                }
                ;
                ;
                return self3.$raise(wrapped_e);
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
        }, -2);
        return $def(self2, "$load_file", function $$load_file(filename, options) {
          var self3 = this;
          if (options == null)
            options = $hash2([], {});
          return $send($$$("File"), "open", [filename, $$("FILE_READ_MODE")], function $$7(file) {
            var self4 = $$7.$$s == null ? this : $$7.$$s;
            if (file == null)
              file = nil;
            return self4.$load(file, options);
          }, { $$s: self3 });
        }, -2);
      }(Opal2.get_singleton_class(self), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/convert"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $hash2 = Opal2.hash2, $eqeqeq = Opal2.eqeqeq, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $rb_ge = Opal2.rb_ge, $not = Opal2.not, $rb_lt = Opal2.rb_lt, $neqeq = Opal2.neqeq, $def = Opal2.def, $send = Opal2.send, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("delete,merge,===,absolute_path,path,load,respond_to?,[]=,key?,fetch,[],dirname,expand_path,join,attributes,outfilesuffix,==,raise,pwd,>=,safe,normalize_system_path,mkdir_p,directory?,!,convert,write,attr,uriish?,basebackend?,attr?,<,include?,syntax_highlighter,write_stylesheet?,write_primary_stylesheet,instance,to_s,read_asset,file?,!=,write_stylesheet,open,convert_file");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function(self2, $parent_nesting2) {
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        $def(self2, "$convert", function $$convert(input, options) {
          var self3 = this, to_dir = nil, mkdirs = nil, $ret_or_1 = nil, to_file = nil, write_to_target = nil, sibling_path = nil, stream_output = nil, outdir = nil, doc = nil, outfile = nil, working_dir = nil, jail = nil, output = nil, stylesdir = nil, stylesheet = nil, copy_asciidoctor_stylesheet = nil, copy_user_stylesheet = nil, copy_syntax_hl_stylesheet = nil, syntax_hl = nil, stylesoutdir = nil, stylesheet_src = nil, stylesheet_dest = nil, stylesheet_data = nil, stylesheet_outdir = nil;
          if (options == null)
            options = $hash2([], {});
          (options = options.$merge()).$delete("parse");
          to_dir = options.$delete("to_dir");
          mkdirs = options.$delete("mkdirs");
          if ($eqeqeq(true, $ret_or_1 = to_file = options.$delete("to_file")) || $eqeqeq(nil, $ret_or_1)) {
            if (!$truthy(write_to_target = to_dir)) {
              if ($eqeqeq($$$("File"), input)) {
                sibling_path = $$$("File").$absolute_path(input.$path());
              }
            }
            ;
            to_file = nil;
          } else if ($eqeqeq(false, $ret_or_1)) {
            to_file = nil;
          } else if ($eqeqeq("/dev/null", $ret_or_1)) {
            return self3.$load(input, options);
          } else if (!$truthy(stream_output = to_file["$respond_to?"]("write"))) {
            options["$[]="]("to_file", write_to_target = to_file);
          }
          ;
          if (!$truthy(options["$key?"]("standalone"))) {
            if ($truthy(sibling_path) || $truthy(write_to_target)) {
              options["$[]="]("standalone", options.$fetch("header_footer", true));
            } else if ($truthy(options["$key?"]("header_footer"))) {
              options["$[]="]("standalone", options["$[]"]("header_footer"));
            }
          }
          ;
          if ($truthy(sibling_path)) {
            options["$[]="]("to_dir", outdir = $$$("File").$dirname(sibling_path));
          } else if ($truthy(write_to_target)) {
            if ($truthy(to_dir)) {
              if ($truthy(to_file)) {
                options["$[]="]("to_dir", $$$("File").$dirname($$$("File").$expand_path(to_file, to_dir)));
              } else {
                options["$[]="]("to_dir", $$$("File").$expand_path(to_dir));
              }
            } else if ($truthy(to_file)) {
              options["$[]="]("to_dir", $$$("File").$dirname($$$("File").$expand_path(to_file)));
            }
          }
          ;
          doc = self3.$load(input, options);
          if ($truthy(sibling_path)) {
            outfile = $$$("File").$join(outdir, "" + doc.$attributes()["$[]"]("docname") + doc.$outfilesuffix());
            if ($eqeq(outfile, sibling_path)) {
              self3.$raise($$$("IOError"), "input file and output file cannot be the same: " + outfile);
            }
            ;
          } else if ($truthy(write_to_target)) {
            working_dir = $truthy(options["$key?"]("base_dir")) ? $$$("File").$expand_path(options["$[]"]("base_dir")) : $$$("Dir").$pwd();
            jail = $truthy($rb_ge(doc.$safe(), $$$($$("SafeMode"), "SAFE"))) ? working_dir : nil;
            if ($truthy(to_dir)) {
              outdir = doc.$normalize_system_path(to_dir, working_dir, jail, $hash2(["target_name", "recover"], { "target_name": "to_dir", "recover": false }));
              if ($truthy(to_file)) {
                outfile = doc.$normalize_system_path(to_file, outdir, nil, $hash2(["target_name", "recover"], { "target_name": "to_dir", "recover": false }));
                outdir = $$$("File").$dirname(outfile);
              } else {
                outfile = $$$("File").$join(outdir, "" + doc.$attributes()["$[]"]("docname") + doc.$outfilesuffix());
              }
              ;
            } else if ($truthy(to_file)) {
              outfile = doc.$normalize_system_path(to_file, working_dir, jail, $hash2(["target_name", "recover"], { "target_name": "to_dir", "recover": false }));
              outdir = $$$("File").$dirname(outfile);
            }
            ;
            if ($eqeqeq($$$("File"), input) && $eqeq(outfile, $$$("File").$absolute_path(input.$path()))) {
              self3.$raise($$$("IOError"), "input file and output file cannot be the same: " + outfile);
            }
            ;
            if ($truthy(mkdirs)) {
              $$("Helpers").$mkdir_p(outdir);
            } else if (!$truthy($$$("File")["$directory?"](outdir))) {
              self3.$raise($$$("IOError"), "target directory does not exist: " + to_dir + " (hint: set :mkdirs option)");
            }
            ;
          } else {
            outfile = to_file;
            outdir = nil;
          }
          ;
          if ($truthy(outfile) && $not(stream_output)) {
            output = doc.$convert($hash2(["outfile", "outdir"], { "outfile": outfile, "outdir": outdir }));
          } else {
            output = doc.$convert();
          }
          ;
          if ($truthy(outfile)) {
            doc.$write(output, outfile);
            if ($not(stream_output) && $truthy($rb_lt(doc.$safe(), $$$($$("SafeMode"), "SECURE"))) && $truthy(doc["$attr?"]("linkcss")) && $truthy(doc["$attr?"]("copycss")) && $truthy(doc["$basebackend?"]("html")) && $not($truthy($ret_or_1 = stylesdir = doc.$attr("stylesdir")) ? $$("Helpers")["$uriish?"](stylesdir) : $ret_or_1)) {
              if ($truthy(stylesheet = doc.$attr("stylesheet"))) {
                if ($truthy($$("DEFAULT_STYLESHEET_KEYS")["$include?"](stylesheet))) {
                  copy_asciidoctor_stylesheet = true;
                } else if ($not($$("Helpers")["$uriish?"](stylesheet))) {
                  copy_user_stylesheet = true;
                }
              }
              ;
              copy_syntax_hl_stylesheet = $truthy($ret_or_1 = syntax_hl = doc.$syntax_highlighter()) ? syntax_hl["$write_stylesheet?"](doc) : $ret_or_1;
              if ($truthy(copy_asciidoctor_stylesheet) || $truthy(copy_user_stylesheet) || $truthy(copy_syntax_hl_stylesheet)) {
                stylesoutdir = doc.$normalize_system_path(stylesdir, outdir, $truthy($rb_ge(doc.$safe(), $$$($$("SafeMode"), "SAFE"))) ? outdir : nil);
                if ($truthy(mkdirs)) {
                  $$("Helpers").$mkdir_p(stylesoutdir);
                } else if (!$truthy($$$("File")["$directory?"](stylesoutdir))) {
                  self3.$raise($$$("IOError"), "target stylesheet directory does not exist: " + stylesoutdir + " (hint: set :mkdirs option)");
                }
                ;
                if ($truthy(copy_asciidoctor_stylesheet)) {
                  $$("Stylesheets").$instance().$write_primary_stylesheet(stylesoutdir);
                } else if ($truthy(copy_user_stylesheet)) {
                  if ($eqeq(stylesheet_src = doc.$attr("copycss"), "") || $eqeq(stylesheet_src, true)) {
                    stylesheet_src = doc.$normalize_system_path(stylesheet);
                  } else {
                    stylesheet_src = doc.$normalize_system_path(stylesheet_src.$to_s());
                  }
                  ;
                  stylesheet_dest = doc.$normalize_system_path(stylesheet, stylesoutdir, $truthy($rb_ge(doc.$safe(), $$$($$("SafeMode"), "SAFE"))) ? outdir : nil);
                  if ($neqeq(stylesheet_src, stylesheet_dest) && $truthy(stylesheet_data = doc.$read_asset(stylesheet_src, $hash2(["warn_on_failure", "label"], { "warn_on_failure": $$$("File")["$file?"](stylesheet_dest)["$!"](), "label": "stylesheet" })))) {
                    if ($neqeq(stylesheet_outdir = $$$("File").$dirname(stylesheet_dest), stylesoutdir) && $not($$$("File")["$directory?"](stylesheet_outdir))) {
                      if ($truthy(mkdirs)) {
                        $$("Helpers").$mkdir_p(stylesheet_outdir);
                      } else {
                        self3.$raise($$$("IOError"), "target stylesheet directory does not exist: " + stylesheet_outdir + " (hint: set :mkdirs option)");
                      }
                    }
                    ;
                    $$$("File").$write(stylesheet_dest, stylesheet_data, $hash2(["mode"], { "mode": $$("FILE_WRITE_MODE") }));
                  }
                  ;
                }
                ;
                if ($truthy(copy_syntax_hl_stylesheet)) {
                  syntax_hl.$write_stylesheet(doc, stylesoutdir);
                }
                ;
              }
              ;
            }
            ;
            return doc;
          } else {
            return output;
          }
          ;
        }, -2);
        $def(self2, "$convert_file", function $$convert_file(filename, options) {
          var self3 = this;
          if (options == null)
            options = $hash2([], {});
          return $send($$$("File"), "open", [filename, $$("FILE_READ_MODE")], function $$1(file) {
            var self4 = $$1.$$s == null ? this : $$1.$$s;
            if (file == null)
              file = nil;
            return self4.$convert(file, options);
          }, { $$s: self3 });
        }, -2);
        $alias(self2, "render", "convert");
        return $alias(self2, "render_file", "convert_file");
      }(Opal2.get_singleton_class(self), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/syntax_highlighter/highlightjs"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $slice = Opal2.slice, $send2 = Opal2.send2, $find_super = Opal2.find_super, $to_a = Opal2.to_a, $def = Opal2.def, $hash2 = Opal2.hash2, $send = Opal2.send, $truthy = Opal2.truthy, $return_val = Opal2.return_val, $eqeq = Opal2.eqeq, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("register_for,merge,proc,[]=,attr,[],==,attr?,join,map,split,lstrip");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "HighlightJsAdapter");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3);
        self2.$register_for("highlightjs", "highlight.js");
        $def(self2, "$initialize", function $$initialize($a) {
          var $post_args, args, $yield = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", $to_a(args), $yield);
          return self3.name = self3.pre_class = "highlightjs";
        }, -1);
        $def(self2, "$format", function $$format(node, lang, opts) {
          var $yield = $$format.$$p || nil, self3 = this;
          $$format.$$p = null;
          return $send2(self3, $find_super(self3, "format", $$format, false, true), "format", [node, lang, opts.$merge($hash2(["transform"], { "transform": $send(self3, "proc", [], function $$1(_, code) {
            var $a, $ret_or_1 = nil;
            if (_ == null)
              _ = nil;
            if (code == null)
              code = nil;
            return $a = ["class", "language-" + ($truthy($ret_or_1 = lang) ? $ret_or_1 : "none") + " hljs"], $send(code, "[]=", $a), $a[$a.length - 1];
          }) }))], null);
        });
        $def(self2, "$docinfo?", $return_val(true));
        return $def(self2, "$docinfo", function $$docinfo(location, doc, opts) {
          var base_url = nil;
          base_url = doc.$attr("highlightjsdir", "" + opts["$[]"]("cdn_base_url") + "/highlight.js/" + $$2("HIGHLIGHT_JS_VERSION"));
          if ($eqeq(location, "head")) {
            return '<link rel="stylesheet" href="' + base_url + "/styles/" + doc.$attr("highlightjs-theme", "github") + '.min.css"' + opts["$[]"]("self_closing_tag_slash") + ">";
          } else {
            return '<script src="' + base_url + '/highlight.min.js"><\/script>\n' + ($truthy(doc["$attr?"]("highlightjs-languages")) ? $send(doc.$attr("highlightjs-languages").$split(","), "map", [], function $$22(lang) {
              if (lang == null)
                lang = nil;
              return '<script src="' + base_url + "/languages/" + lang.$lstrip() + '.min.js"><\/script>\n';
            }).$join() : "") + "<script>\nif (!hljs.initHighlighting.called) {\n  hljs.initHighlighting.called = true\n  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })\n}\n<\/script>";
          }
          ;
        });
      }($$("SyntaxHighlighter"), $$$($$("SyntaxHighlighter"), "Base"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/syntax_highlighter"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $hash2 = Opal2.hash2, $def = Opal2.def, $return_val = Opal2.return_val, $defs = Opal2.defs, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $truthy = Opal2.truthy, $eqeqeq = Opal2.eqeqeq, $Class = Opal2.Class, $klass = Opal2.klass, $class_variable_set = Opal2.class_variable_set, $class_variable_get = Opal2.class_variable_get, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("attr_reader,raise,class,extend,private_class_method,register,map,to_s,each,[]=,registry,[],for,===,new,name,private,include,delete,join,content");
    (function($base, $parent_nesting) {
      var self2 = $module($base, "Asciidoctor");
      var $nesting2 = [self2].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self3 = $module($base2, "SyntaxHighlighter");
        var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        self3.$attr_reader("name");
        $def(self3, "$initialize", function $$initialize(name, backend, opts) {
          var self4 = this;
          if (backend == null)
            backend = "html5";
          if (opts == null)
            opts = $hash2([], {});
          return self4.name = self4.pre_class = name;
        }, -2);
        $def(self3, "$docinfo?", $return_val(nil));
        $def(self3, "$docinfo", function $$docinfo(location, doc, opts) {
          var self4 = this;
          return self4.$raise($$$("NotImplementedError"), "" + $$("SyntaxHighlighter") + " subclass " + self4.$class() + " must implement the #docinfo method since #docinfo? returns true");
        });
        $def(self3, "$highlight?", $return_val(nil));
        $def(self3, "$highlight", function $$highlight(node, source, lang, opts) {
          var self4 = this;
          return self4.$raise($$$("NotImplementedError"), "" + $$("SyntaxHighlighter") + " subclass " + self4.$class() + " must implement the #highlight method since #highlight? returns true");
        });
        $def(self3, "$format", function $$format(node, lang, opts) {
          var self4 = this;
          return self4.$raise($$$("NotImplementedError"), "" + $$("SyntaxHighlighter") + " subclass " + self4.$class() + " must implement the #format method");
        });
        $def(self3, "$write_stylesheet?", $return_val(nil));
        $def(self3, "$write_stylesheet", function $$write_stylesheet(doc, to_dir) {
          var self4 = this;
          return self4.$raise($$$("NotImplementedError"), "" + $$("SyntaxHighlighter") + " subclass " + self4.$class() + " must implement the #write_stylesheet method since #write_stylesheet? returns true");
        });
        $defs(self3, "$included", function $$included(into) {
          return into.$extend($$("Config"));
        });
        self3.$private_class_method("included");
        (function($base3, $parent_nesting3) {
          var self4 = $module($base3, "Config");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          return $def(self4, "$register_for", function $$register_for($a) {
            var $post_args, names, self5 = this;
            $post_args = $slice(arguments);
            names = $post_args;
            return $send($$2("SyntaxHighlighter"), "register", [self5].concat($to_a($send(names, "map", [], function $$1(name) {
              if (name == null)
                name = nil;
              return name.$to_s();
            }))));
          }, -1);
        })($nesting3[0], $nesting3);
        (function($base3, $parent_nesting3) {
          var self4 = $module($base3, "Factory");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $def(self4, "$register", function $$register(syntax_highlighter, $a) {
            var $post_args, names, self5 = this;
            $post_args = $slice(arguments, 1);
            names = $post_args;
            return $send(names, "each", [], function $$22(name) {
              var $b, self6 = $$22.$$s == null ? this : $$22.$$s;
              if (name == null)
                name = nil;
              return $b = [name, syntax_highlighter], $send(self6.$registry(), "[]=", $b), $b[$b.length - 1];
            }, { $$s: self5 });
          }, -2);
          $def(self4, "$for", function $Factory_for$3(name) {
            var self5 = this;
            return self5.$registry()["$[]"](name);
          });
          $def(self4, "$create", function $$create(name, backend, opts) {
            var self5 = this, syntax_hl = nil;
            if (backend == null)
              backend = "html5";
            if (opts == null)
              opts = $hash2([], {});
            if ($truthy(syntax_hl = self5.$for(name))) {
              if ($eqeqeq($Class, syntax_hl)) {
                syntax_hl = syntax_hl.$new(name, backend, opts);
              }
              ;
              if (!$truthy(syntax_hl.$name())) {
                self5.$raise($$$("NameError"), "" + syntax_hl.$class() + " must specify a value for `name'");
              }
              ;
              return syntax_hl;
            } else {
              return nil;
            }
            ;
          }, -2);
          self4.$private();
          return $def(self4, "$registry", function $$registry() {
            var self5 = this;
            return self5.$raise($$$("NotImplementedError"), "" + $$2("Factory") + " subclass " + self5.$class() + " must implement the #registry method");
          });
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self4 = $klass($base3, $super, "CustomFactory");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self4.$include($$2("Factory"));
          $def(self4, "$initialize", function $$initialize(seed_registry) {
            var self5 = this, $ret_or_1 = nil;
            if (seed_registry == null)
              seed_registry = nil;
            return self5.registry = $truthy($ret_or_1 = seed_registry) ? $ret_or_1 : $hash2([], {});
          }, -1);
          self4.$private();
          return self4.$attr_reader("registry");
        })($nesting3[0], null, $nesting3);
        (function($base3, $parent_nesting3) {
          var self4 = $module($base3, "DefaultFactory");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self4.$include($$2("Factory"));
          $class_variable_set($nesting4[0], "@@registry", $hash2([], {}));
          self4.$private();
          $def(self4, "$registry", function $$registry() {
            return $class_variable_get($nesting4[0], "@@registry", false);
          });
          return nil;
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self4 = $klass($base3, $super, "DefaultFactoryProxy");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self4.$include($$2("DefaultFactory"));
          return nil;
        })($nesting3[0], $$("CustomFactory"), $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self4 = $klass($base3, $super, "Base");
          var $nesting4 = [self4].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self4.$$prototype;
          $proto.pre_class = nil;
          self4.$include($$2("SyntaxHighlighter"));
          return $def(self4, "$format", function $$format(node, lang, opts) {
            var self5 = this, class_attr_val = nil, transform = nil, pre = nil, code = nil;
            class_attr_val = $truthy(opts["$[]"]("nowrap")) ? "" + self5.pre_class + " highlight nowrap" : "" + self5.pre_class + " highlight";
            if ($truthy(transform = opts["$[]"]("transform"))) {
              transform["$[]"](pre = $hash2(["class"], { "class": class_attr_val }), code = $truthy(lang) ? $hash2(["data-lang"], { "data-lang": lang }) : $hash2([], {}));
              if ($truthy(lang = code.$delete("data-lang"))) {
                code["$[]="]("data-lang", lang);
              }
              ;
              return "<pre" + $send(pre, "map", [], function $$4(k, v) {
                if (k == null)
                  k = nil;
                if (v == null)
                  v = nil;
                return " " + k + '="' + v + '"';
              }).$join() + "><code" + $send(code, "map", [], function $$5(k, v) {
                if (k == null)
                  k = nil;
                if (v == null)
                  v = nil;
                return " " + k + '="' + v + '"';
              }).$join() + ">" + node.$content() + "</code></pre>";
            } else {
              return '<pre class="' + class_attr_val + '"><code' + ($truthy(lang) ? ' data-lang="' + lang + '"' : "") + ">" + node.$content() + "</code></pre>";
            }
            ;
          });
        })($nesting3[0], null, $nesting3);
        return self3.$extend($$("DefaultFactory"));
      }($nesting2[0], $nesting2);
    })($nesting[0], $nesting);
    self.$require("asciidoctor/syntax_highlighter.rb/../syntax_highlighter/highlightjs");
    return nil;
  };
  Opal.modules["asciidoctor/timings"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $hash2 = Opal2.hash2, $def = Opal2.def, $send = Opal2.send, $rb_minus = Opal2.rb_minus, $slice = Opal2.slice, $rb_plus = Opal2.rb_plus, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $gvars = Opal2.gvars, $eqeq = Opal2.eqeq, $const_set = Opal2.const_set, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("[]=,now,-,delete,reduce,+,[],>,time,puts,sprintf,to_f,read_parse,convert,read_parse_convert,private,==,const_defined?,clock_gettime");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Timings");
        var $a, $b, $c, $d, $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.timers = $proto.log = nil;
        $def(self2, "$initialize", function $$initialize() {
          var self3 = this;
          self3.log = $hash2([], {});
          return self3.timers = $hash2([], {});
        });
        $def(self2, "$start", function $$start(key) {
          var $a2, self3 = this;
          return $a2 = [key, self3.$now()], $send(self3.timers, "[]=", $a2), $a2[$a2.length - 1];
        });
        $def(self2, "$record", function $$record(key) {
          var $a2, self3 = this;
          return $a2 = [key, $rb_minus(self3.$now(), self3.timers.$delete(key))], $send(self3.log, "[]=", $a2), $a2[$a2.length - 1];
        });
        $def(self2, "$time", function $$time($a2) {
          var $post_args, keys, self3 = this, time = nil;
          $post_args = $slice(arguments);
          keys = $post_args;
          time = $send(keys, "reduce", [0], function $$1(sum, key) {
            var self4 = $$1.$$s == null ? this : $$1.$$s, $ret_or_1 = nil;
            if (self4.log == null)
              self4.log = nil;
            if (sum == null)
              sum = nil;
            if (key == null)
              key = nil;
            return $rb_plus(sum, $truthy($ret_or_1 = self4.log["$[]"](key)) ? $ret_or_1 : 0);
          }, { $$s: self3 });
          if ($truthy($rb_gt(time, 0))) {
            return time;
          } else {
            return nil;
          }
          ;
        }, -1);
        $def(self2, "$read", function $$read() {
          var self3 = this;
          return self3.$time("read");
        });
        $def(self2, "$parse", function $$parse() {
          var self3 = this;
          return self3.$time("parse");
        });
        $def(self2, "$read_parse", function $$read_parse() {
          var self3 = this;
          return self3.$time("read", "parse");
        });
        $def(self2, "$convert", function $$convert() {
          var self3 = this;
          return self3.$time("convert");
        });
        $def(self2, "$read_parse_convert", function $$read_parse_convert() {
          var self3 = this;
          return self3.$time("read", "parse", "convert");
        });
        $def(self2, "$write", function $$write() {
          var self3 = this;
          return self3.$time("write");
        });
        $def(self2, "$total", function $$total() {
          var self3 = this;
          return self3.$time("read", "parse", "convert", "write");
        });
        $def(self2, "$print_report", function $$print_report(to, subject) {
          var self3 = this;
          if ($gvars.stdout == null)
            $gvars.stdout = nil;
          if (to == null)
            to = $gvars.stdout;
          if (subject == null)
            subject = nil;
          if ($truthy(subject)) {
            to.$puts("Input file: " + subject);
          }
          ;
          to.$puts("  Time to read and parse source: " + self3.$sprintf("%05.5f", self3.$read_parse().$to_f()));
          to.$puts("  Time to convert document: " + self3.$sprintf("%05.5f", self3.$convert().$to_f()));
          return to.$puts("  Total time (read, parse and convert): " + self3.$sprintf("%05.5f", self3.$read_parse_convert().$to_f()));
        }, -1);
        self2.$private();
        if ($truthy($$$("Process")["$const_defined?"]("CLOCK_MONOTONIC", false)) && $eqeq(($a = $$$("::", "Process", "skip_raise")) && ($b = $a, $b) && ($c = $b) && (($d = $c.$clock_gettime) && !$d.$$stub || $c["$respond_to_missing?"]("clock_gettime")) ? "method" : nil, "method")) {
          $const_set($nesting3[0], "CLOCK_ID", $$$($$$("Process"), "CLOCK_MONOTONIC"));
          return $def(self2, "$now", function $$now() {
            return $$$("Process").$clock_gettime($$("CLOCK_ID"));
          });
        } else {
          return $def(self2, "$now", function $$now() {
            return $$$("Time").$now();
          });
        }
        ;
      }($nesting2[0], null, $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/converter/html5"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $const_set = Opal2.const_set, $hash2 = Opal2.hash2, $regexp = Opal2.regexp, $eqeq = Opal2.eqeq, $def = Opal2.def, $send2 = Opal2.send2, $find_super = Opal2.find_super, $truthy = Opal2.truthy, $send = Opal2.send, $rb_gt = Opal2.rb_gt, $rb_plus = Opal2.rb_plus, $not = Opal2.not, $neqeq = Opal2.neqeq, $rb_le = Opal2.rb_le, $rb_lt = Opal2.rb_lt, $to_ary = Opal2.to_ary, $rb_times = Opal2.rb_times, $rb_minus = Opal2.rb_minus, $gvars = Opal2.gvars, $return_val = Opal2.return_val, $alias = Opal2.alias, $eqeqeq = Opal2.eqeqeq, $slice = Opal2.slice, $to_a = Opal2.to_a, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("register_for,default=,==,[],init_backend_traits,node_name,convert_inline_quoted,convert_paragraph,convert_inline_anchor,convert_section,convert_listing,convert_literal,convert_ulist,convert_olist,convert_dlist,convert_admonition,convert_colist,convert_embedded,convert_example,convert_floating_title,convert_image,convert_inline_break,convert_inline_button,convert_inline_callout,convert_inline_footnote,convert_inline_image,convert_inline_indexterm,convert_inline_kbd,convert_inline_menu,convert_open,convert_page_break,convert_preamble,convert_quote,convert_sidebar,convert_stem,convert_table,convert_thematic_break,convert_verse,convert_video,convert_document,convert_toc,convert_pass,convert_audio,empty?,attr,attr?,<<,include?,sub_replacements,gsub,extname,slice,length,doctitle,normalize_web_path,primary_stylesheet_data,instance,read_contents,syntax_highlighter,size,docinfo,id,sections?,doctype,role?,role,join,noheader,convert,converter,generate_manname_section,header?,notitle,title,header,each,authors,>,name,email,sub_macros,+,downcase,concat,content,!,footnotes?,footnotes,index,text,nofooter,docinfo?,[]=,delete_at,inspect,!=,to_i,attributes,document,sections,level,caption,captioned_title,<=,numbered,<,sectname,sectnum,convert_outline,title?,icon_uri,compact,media_uri,option?,append_boolean_attribute,style,items,blocks?,text?,chomp,safe,read_svg_contents,alt,image_uri,encode_attribute_value,append_link_constraint_attrs,highlight?,to_sym,format,*,-,count,end_with?,start_with?,list_marker_keyword,parent,warn,logger,context,error,content_only,new,columns,to_h,rows,colspan,rowspan,unshift,shift,split,pop,nil_or_empty?,type,===,catalog,get_root_document,xreftext,target,reftext,chop,sub,match,private,upcase,nested?,parent_document,handles?,to_s,send");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super, $parent_nesting2) {
        var self2 = $klass($base2, $super, "Html5Converter");
        var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3), $proto = self2.$$prototype;
        $proto.void_element_slash = $proto.xml_mode = $proto.refs = $proto.resolving_xref = nil;
        self2.$register_for("html5");
        $const_set($nesting3[0], "QUOTE_TAGS", $hash2(["monospaced", "emphasis", "strong", "double", "single", "mark", "superscript", "subscript", "asciimath", "latexmath"], { "monospaced": ["<code>", "</code>", true], "emphasis": ["<em>", "</em>", true], "strong": ["<strong>", "</strong>", true], "double": ["&#8220;", "&#8221;"], "single": ["&#8216;", "&#8217;"], "mark": ["<mark>", "</mark>", true], "superscript": ["<sup>", "</sup>", true], "subscript": ["<sub>", "</sub>", true], "asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"] }))["$default="](["", ""]);
        $const_set($nesting3[0], "DropAnchorRx", /<(?:a\b[^>]*|\/a)>/);
        $const_set($nesting3[0], "StemBreakRx", / *\\\n(?:\\?\n)*|\n\n+/);
        $const_set($nesting3[0], "SvgPreambleRx", $regexp(["^", $$2("CC_ALL"), "*?(?=<svg[\\s>])"]));
        $const_set($nesting3[0], "SvgStartTagRx", /^<svg(?:\s[^>]*)?>/);
        ;
        $const_set($nesting3[0], "DimensionAttributeRx", $regexp([`\\s(?:width|height|style)=(["'])`, $$2("CC_ANY"), "*?\\1"]));
        $def(self2, "$initialize", function $$initialize(backend, opts) {
          var self3 = this, syntax = nil;
          if (opts == null)
            opts = $hash2([], {});
          self3.backend = backend;
          if ($eqeq(opts["$[]"]("htmlsyntax"), "xml")) {
            syntax = "xml";
            self3.xml_mode = true;
            self3.void_element_slash = "/";
          } else {
            syntax = "html";
            self3.xml_mode = nil;
            self3.void_element_slash = "";
          }
          ;
          return self3.$init_backend_traits($hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix", "supports_templates"], { "basebackend": "html", "filetype": "html", "htmlsyntax": syntax, "outfilesuffix": ".html", "supports_templates": true }));
        }, -2);
        $def(self2, "$convert", function $$convert(node, transform, opts) {
          var $yield = $$convert.$$p || nil, self3 = this;
          $$convert.$$p = null;
          if (transform == null)
            transform = node.$node_name();
          if (opts == null)
            opts = nil;
          switch (transform) {
            case "inline_quoted":
              return self3.$convert_inline_quoted(node);
            case "paragraph":
              return self3.$convert_paragraph(node);
            case "inline_anchor":
              return self3.$convert_inline_anchor(node);
            case "section":
              return self3.$convert_section(node);
            case "listing":
              return self3.$convert_listing(node);
            case "literal":
              return self3.$convert_literal(node);
            case "ulist":
              return self3.$convert_ulist(node);
            case "olist":
              return self3.$convert_olist(node);
            case "dlist":
              return self3.$convert_dlist(node);
            case "admonition":
              return self3.$convert_admonition(node);
            case "colist":
              return self3.$convert_colist(node);
            case "embedded":
              return self3.$convert_embedded(node);
            case "example":
              return self3.$convert_example(node);
            case "floating_title":
              return self3.$convert_floating_title(node);
            case "image":
              return self3.$convert_image(node);
            case "inline_break":
              return self3.$convert_inline_break(node);
            case "inline_button":
              return self3.$convert_inline_button(node);
            case "inline_callout":
              return self3.$convert_inline_callout(node);
            case "inline_footnote":
              return self3.$convert_inline_footnote(node);
            case "inline_image":
              return self3.$convert_inline_image(node);
            case "inline_indexterm":
              return self3.$convert_inline_indexterm(node);
            case "inline_kbd":
              return self3.$convert_inline_kbd(node);
            case "inline_menu":
              return self3.$convert_inline_menu(node);
            case "open":
              return self3.$convert_open(node);
            case "page_break":
              return self3.$convert_page_break(node);
            case "preamble":
              return self3.$convert_preamble(node);
            case "quote":
              return self3.$convert_quote(node);
            case "sidebar":
              return self3.$convert_sidebar(node);
            case "stem":
              return self3.$convert_stem(node);
            case "table":
              return self3.$convert_table(node);
            case "thematic_break":
              return self3.$convert_thematic_break(node);
            case "verse":
              return self3.$convert_verse(node);
            case "video":
              return self3.$convert_video(node);
            case "document":
              return self3.$convert_document(node);
            case "toc":
              return self3.$convert_toc(node);
            case "pass":
              return self3.$convert_pass(node);
            case "audio":
              return self3.$convert_audio(node);
            default:
              return $send2(self3, $find_super(self3, "convert", $$convert, false, true), "convert", [node, transform, opts], $yield);
          }
          ;
        }, -2);
        $def(self2, "$convert_document", function $$convert_document(node) {
          var self3 = this, br = nil, slash = nil, asset_uri_scheme = nil, cdn_base_url = nil, linkcss = nil, max_width_attr = nil, result = nil, lang_attribute = nil, authors = nil, icon_href = nil, icon_type = nil, icon_ext = nil, webfonts = nil, iconfont_stylesheet = nil, syntax_hl = nil, syntax_hl_docinfo_head_idx = nil, docinfo_content = nil, id_attr = nil, sectioned = nil, classes = nil, details = nil, idx = nil, $ret_or_1 = nil, eqnums_val = nil, eqnums_opt = nil;
          br = "<br" + (slash = self3.void_element_slash) + ">";
          if (!$truthy((asset_uri_scheme = node.$attr("asset-uri-scheme", "https"))["$empty?"]())) {
            asset_uri_scheme = "" + asset_uri_scheme + ":";
          }
          ;
          cdn_base_url = "" + asset_uri_scheme + "//cdnjs.cloudflare.com/ajax/libs";
          linkcss = node["$attr?"]("linkcss");
          max_width_attr = $truthy(node["$attr?"]("max-width")) ? ' style="max-width: ' + node.$attr("max-width") + ';"' : "";
          result = ["<!DOCTYPE html>"];
          lang_attribute = $truthy(node["$attr?"]("nolang")) ? "" : ' lang="' + node.$attr("lang", "en") + '"';
          result["$<<"]("<html" + ($truthy(self3.xml_mode) ? ' xmlns="http://www.w3.org/1999/xhtml"' : "") + lang_attribute + ">");
          result["$<<"]('<head>\n<meta charset="' + node.$attr("encoding", "UTF-8") + '"' + slash + '>\n<meta http-equiv="X-UA-Compatible" content="IE=edge"' + slash + '>\n<meta name="viewport" content="width=device-width, initial-scale=1.0"' + slash + '>\n<meta name="generator" content="Asciidoctor ' + node.$attr("asciidoctor-version") + '"' + slash + ">");
          if ($truthy(node["$attr?"]("app-name"))) {
            result["$<<"]('<meta name="application-name" content="' + node.$attr("app-name") + '"' + slash + ">");
          }
          ;
          if ($truthy(node["$attr?"]("description"))) {
            result["$<<"]('<meta name="description" content="' + node.$attr("description") + '"' + slash + ">");
          }
          ;
          if ($truthy(node["$attr?"]("keywords"))) {
            result["$<<"]('<meta name="keywords" content="' + node.$attr("keywords") + '"' + slash + ">");
          }
          ;
          if ($truthy(node["$attr?"]("authors"))) {
            result["$<<"]('<meta name="author" content="' + ($truthy((authors = node.$sub_replacements(node.$attr("authors")))["$include?"]("<")) ? authors.$gsub($$2("XmlSanitizeRx"), "") : authors) + '"' + slash + ">");
          }
          ;
          if ($truthy(node["$attr?"]("copyright"))) {
            result["$<<"]('<meta name="copyright" content="' + node.$attr("copyright") + '"' + slash + ">");
          }
          ;
          if ($truthy(node["$attr?"]("favicon"))) {
            if ($truthy((icon_href = node.$attr("favicon"))["$empty?"]())) {
              icon_href = "favicon.ico";
              icon_type = "image/x-icon";
            } else if ($truthy(icon_ext = $$2("Helpers").$extname(icon_href, nil))) {
              icon_type = $eqeq(icon_ext, ".ico") ? "image/x-icon" : "image/" + icon_ext.$slice(1, icon_ext.$length());
            } else {
              icon_type = "image/x-icon";
            }
            ;
            result["$<<"]('<link rel="icon" type="' + icon_type + '" href="' + icon_href + '"' + slash + ">");
          }
          ;
          result["$<<"]("<title>" + node.$doctitle($hash2(["sanitize", "use_fallback"], { "sanitize": true, "use_fallback": true })) + "</title>");
          if ($truthy($$2("DEFAULT_STYLESHEET_KEYS")["$include?"](node.$attr("stylesheet")))) {
            if ($truthy(webfonts = node.$attr("webfonts"))) {
              result["$<<"]('<link rel="stylesheet" href="' + asset_uri_scheme + "//fonts.googleapis.com/css?family=" + ($truthy(webfonts["$empty?"]()) ? "Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700" : webfonts) + '"' + slash + ">");
            }
            ;
            if ($truthy(linkcss)) {
              result["$<<"]('<link rel="stylesheet" href="' + node.$normalize_web_path($$2("DEFAULT_STYLESHEET_NAME"), node.$attr("stylesdir", ""), false) + '"' + slash + ">");
            } else {
              result["$<<"]("<style>\n" + $$2("Stylesheets").$instance().$primary_stylesheet_data() + "\n</style>");
            }
            ;
          } else if ($truthy(node["$attr?"]("stylesheet"))) {
            if ($truthy(linkcss)) {
              result["$<<"]('<link rel="stylesheet" href="' + node.$normalize_web_path(node.$attr("stylesheet"), node.$attr("stylesdir", "")) + '"' + slash + ">");
            } else {
              result["$<<"]("<style>\n" + node.$read_contents(node.$attr("stylesheet"), $hash2(["start", "warn_on_failure", "label"], { "start": node.$attr("stylesdir"), "warn_on_failure": true, "label": "stylesheet" })) + "\n</style>");
            }
          }
          ;
          if ($truthy(node["$attr?"]("icons", "font"))) {
            if ($truthy(node["$attr?"]("iconfont-remote"))) {
              result["$<<"]('<link rel="stylesheet" href="' + node.$attr("iconfont-cdn", "" + cdn_base_url + "/font-awesome/" + $$2("FONT_AWESOME_VERSION") + "/css/font-awesome.min.css") + '"' + slash + ">");
            } else {
              iconfont_stylesheet = "" + node.$attr("iconfont-name", "font-awesome") + ".css";
              result["$<<"]('<link rel="stylesheet" href="' + node.$normalize_web_path(iconfont_stylesheet, node.$attr("stylesdir", ""), false) + '"' + slash + ">");
            }
          }
          ;
          if ($truthy(syntax_hl = node.$syntax_highlighter())) {
            result["$<<"](syntax_hl_docinfo_head_idx = result.$size());
          }
          ;
          if (!$truthy((docinfo_content = node.$docinfo())["$empty?"]())) {
            result["$<<"](docinfo_content);
          }
          ;
          result["$<<"]("</head>");
          id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          if ($truthy(sectioned = node["$sections?"]()) && $truthy(node["$attr?"]("toc-class")) && $truthy(node["$attr?"]("toc")) && $truthy(node["$attr?"]("toc-placement", "auto"))) {
            classes = [node.$doctype(), node.$attr("toc-class"), "toc-" + node.$attr("toc-position", "header")];
          } else {
            classes = [node.$doctype()];
          }
          ;
          if ($truthy(node["$role?"]())) {
            classes["$<<"](node.$role());
          }
          ;
          result["$<<"]("<body" + id_attr + ' class="' + classes.$join(" ") + '">');
          if (!$truthy((docinfo_content = node.$docinfo("header"))["$empty?"]())) {
            result["$<<"](docinfo_content);
          }
          ;
          if (!$truthy(node.$noheader())) {
            result["$<<"]('<div id="header"' + max_width_attr + ">");
            if ($eqeq(node.$doctype(), "manpage")) {
              result["$<<"]("<h1>" + node.$doctitle() + " Manual Page</h1>");
              if ($truthy(sectioned) && $truthy(node["$attr?"]("toc")) && $truthy(node["$attr?"]("toc-placement", "auto"))) {
                result["$<<"]('<div id="toc" class="' + node.$attr("toc-class", "toc") + '">\n<div id="toctitle">' + node.$attr("toc-title") + "</div>\n" + node.$converter().$convert(node, "outline") + "\n</div>");
              }
              ;
              if ($truthy(node["$attr?"]("manpurpose"))) {
                result["$<<"](self3.$generate_manname_section(node));
              }
              ;
            } else {
              if ($truthy(node["$header?"]())) {
                if (!$truthy(node.$notitle())) {
                  result["$<<"]("<h1>" + node.$header().$title() + "</h1>");
                }
                ;
                details = [];
                idx = 1;
                $send(node.$authors(), "each", [], function $$1(author) {
                  if (author == null)
                    author = nil;
                  details["$<<"]('<span id="author' + ($truthy($rb_gt(idx, 1)) ? idx : "") + '" class="author">' + node.$sub_replacements(author.$name()) + "</span>" + br);
                  if ($truthy(author.$email())) {
                    details["$<<"]('<span id="email' + ($truthy($rb_gt(idx, 1)) ? idx : "") + '" class="email">' + node.$sub_macros(author.$email()) + "</span>" + br);
                  }
                  ;
                  return idx = $rb_plus(idx, 1);
                });
                if ($truthy(node["$attr?"]("revnumber"))) {
                  details["$<<"]('<span id="revnumber">' + ($truthy($ret_or_1 = node.$attr("version-label")) ? $ret_or_1 : "").$downcase() + " " + node.$attr("revnumber") + ($truthy(node["$attr?"]("revdate")) ? "," : "") + "</span>");
                }
                ;
                if ($truthy(node["$attr?"]("revdate"))) {
                  details["$<<"]('<span id="revdate">' + node.$attr("revdate") + "</span>");
                }
                ;
                if ($truthy(node["$attr?"]("revremark"))) {
                  details["$<<"]("" + br + '<span id="revremark">' + node.$attr("revremark") + "</span>");
                }
                ;
                if (!$truthy(details["$empty?"]())) {
                  result["$<<"]('<div class="details">');
                  result.$concat(details);
                  result["$<<"]("</div>");
                }
                ;
              }
              ;
              if ($truthy(sectioned) && $truthy(node["$attr?"]("toc")) && $truthy(node["$attr?"]("toc-placement", "auto"))) {
                result["$<<"]('<div id="toc" class="' + node.$attr("toc-class", "toc") + '">\n<div id="toctitle">' + node.$attr("toc-title") + "</div>\n" + node.$converter().$convert(node, "outline") + "\n</div>");
              }
              ;
            }
            ;
            result["$<<"]("</div>");
          }
          ;
          result["$<<"]('<div id="content"' + max_width_attr + ">\n" + node.$content() + "\n</div>");
          if ($truthy(node["$footnotes?"]()) && $not(node["$attr?"]("nofootnotes"))) {
            result["$<<"]('<div id="footnotes"' + max_width_attr + ">\n<hr" + slash + ">");
            $send(node.$footnotes(), "each", [], function $$22(footnote) {
              if (footnote == null)
                footnote = nil;
              return result["$<<"]('<div class="footnote" id="_footnotedef_' + footnote.$index() + '">\n<a href="#_footnoteref_' + footnote.$index() + '">' + footnote.$index() + "</a>. " + footnote.$text() + "\n</div>");
            });
            result["$<<"]("</div>");
          }
          ;
          if (!$truthy(node.$nofooter())) {
            result["$<<"]('<div id="footer"' + max_width_attr + ">");
            result["$<<"]('<div id="footer-text">');
            if ($truthy(node["$attr?"]("revnumber"))) {
              result["$<<"]("" + node.$attr("version-label") + " " + node.$attr("revnumber") + br);
            }
            ;
            if ($truthy(node["$attr?"]("last-update-label")) && $not(node["$attr?"]("reproducible"))) {
              result["$<<"]("" + node.$attr("last-update-label") + " " + node.$attr("docdatetime"));
            }
            ;
            result["$<<"]("</div>");
            result["$<<"]("</div>");
          }
          ;
          if ($truthy(syntax_hl)) {
            if ($truthy(syntax_hl["$docinfo?"]("head"))) {
              result["$[]="](syntax_hl_docinfo_head_idx, syntax_hl.$docinfo("head", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], { "cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash })));
            } else {
              result.$delete_at(syntax_hl_docinfo_head_idx);
            }
            ;
            if ($truthy(syntax_hl["$docinfo?"]("footer"))) {
              result["$<<"](syntax_hl.$docinfo("footer", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], { "cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash })));
            }
            ;
          }
          ;
          if ($truthy(node["$attr?"]("stem"))) {
            eqnums_val = node.$attr("eqnums", "none");
            if ($truthy(eqnums_val["$empty?"]())) {
              eqnums_val = "AMS";
            }
            ;
            eqnums_opt = ' equationNumbers: { autoNumber: "' + eqnums_val + '" } ';
            result["$<<"]('<script type="text/x-mathjax-config">\nMathJax.Hub.Config({\n  messageStyle: "none",\n  tex2jax: {\n    inlineMath: [' + $$2("INLINE_MATH_DELIMITERS")["$[]"]("latexmath").$inspect() + "],\n    displayMath: [" + $$2("BLOCK_MATH_DELIMITERS")["$[]"]("latexmath").$inspect() + '],\n    ignoreClass: "nostem|nolatexmath"\n  },\n  asciimath2jax: {\n    delimiters: [' + $$2("BLOCK_MATH_DELIMITERS")["$[]"]("asciimath").$inspect() + '],\n    ignoreClass: "nostem|noasciimath"\n  },\n  TeX: {' + eqnums_opt + '}\n})\nMathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {\n  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {\n    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {\n      data.math.root.display = "block"\n    }\n    return data\n  })\n})\n<\/script>\n<script src="' + cdn_base_url + "/mathjax/" + $$2("MATHJAX_VERSION") + '/MathJax.js?config=TeX-MML-AM_HTMLorMML"><\/script>');
          }
          ;
          if (!$truthy((docinfo_content = node.$docinfo("footer"))["$empty?"]())) {
            result["$<<"](docinfo_content);
          }
          ;
          result["$<<"]("</body>");
          result["$<<"]("</html>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_embedded", function $$convert_embedded(node) {
          var self3 = this, result = nil, id_attr = nil, toc_p = nil;
          result = [];
          if ($eqeq(node.$doctype(), "manpage")) {
            if (!$truthy(node.$notitle())) {
              id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
              result["$<<"]("<h1" + id_attr + ">" + node.$doctitle() + " Manual Page</h1>");
            }
            ;
            if ($truthy(node["$attr?"]("manpurpose"))) {
              result["$<<"](self3.$generate_manname_section(node));
            }
            ;
          } else if ($truthy(node["$header?"]()) && $not(node.$notitle())) {
            id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
            result["$<<"]("<h1" + id_attr + ">" + node.$header().$title() + "</h1>");
          }
          ;
          if ($truthy(node["$sections?"]()) && $truthy(node["$attr?"]("toc")) && $neqeq(toc_p = node.$attr("toc-placement"), "macro") && $neqeq(toc_p, "preamble")) {
            result["$<<"]('<div id="toc" class="toc">\n<div id="toctitle">' + node.$attr("toc-title") + "</div>\n" + node.$converter().$convert(node, "outline") + "\n</div>");
          }
          ;
          result["$<<"](node.$content());
          if ($truthy(node["$footnotes?"]()) && $not(node["$attr?"]("nofootnotes"))) {
            result["$<<"]('<div id="footnotes">\n<hr' + self3.void_element_slash + ">");
            $send(node.$footnotes(), "each", [], function $$3(footnote) {
              if (footnote == null)
                footnote = nil;
              return result["$<<"]('<div class="footnote" id="_footnotedef_' + footnote.$index() + '">\n<a href="#_footnoteref_' + footnote.$index() + '">' + footnote.$index() + "</a>. " + footnote.$text() + "\n</div>");
            });
            result["$<<"]("</div>");
          }
          ;
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_outline", function $$convert_outline(node, opts) {
          var self3 = this, sectnumlevels = nil, $ret_or_1 = nil, $ret_or_2 = nil, toclevels = nil, sections = nil, result = nil;
          if (opts == null)
            opts = $hash2([], {});
          if (!$truthy(node["$sections?"]())) {
            return nil;
          }
          ;
          sectnumlevels = $truthy($ret_or_1 = opts["$[]"]("sectnumlevels")) ? $ret_or_1 : ($truthy($ret_or_2 = node.$document().$attributes()["$[]"]("sectnumlevels")) ? $ret_or_2 : 3).$to_i();
          toclevels = $truthy($ret_or_1 = opts["$[]"]("toclevels")) ? $ret_or_1 : ($truthy($ret_or_2 = node.$document().$attributes()["$[]"]("toclevels")) ? $ret_or_2 : 2).$to_i();
          sections = node.$sections();
          result = ['<ul class="sectlevel' + sections["$[]"](0).$level() + '">'];
          $send(sections, "each", [], function $$4(section) {
            var self4 = $$4.$$s == null ? this : $$4.$$s, slevel = nil, stitle = nil, signifier = nil, child_toc_level = nil;
            if (section == null)
              section = nil;
            slevel = section.$level();
            if ($truthy(section.$caption())) {
              stitle = section.$captioned_title();
            } else if ($truthy(section.$numbered()) && $truthy($rb_le(slevel, sectnumlevels))) {
              if ($truthy($rb_lt(slevel, 2)) && $eqeq(node.$document().$doctype(), "book")) {
                switch (section.$sectname()) {
                  case "chapter":
                    stitle = ($truthy(signifier = node.$document().$attributes()["$[]"]("chapter-signifier")) ? "" + signifier + " " : "") + section.$sectnum() + " " + section.$title();
                    break;
                  case "part":
                    stitle = ($truthy(signifier = node.$document().$attributes()["$[]"]("part-signifier")) ? "" + signifier + " " : "") + section.$sectnum(nil, ":") + " " + section.$title();
                    break;
                  default:
                    stitle = "" + section.$sectnum() + " " + section.$title();
                }
              } else {
                stitle = "" + section.$sectnum() + " " + section.$title();
              }
            } else {
              stitle = section.$title();
            }
            ;
            if ($truthy(stitle["$include?"]("<a"))) {
              stitle = stitle.$gsub($$2("DropAnchorRx"), "");
            }
            ;
            if ($truthy($rb_lt(slevel, toclevels)) && $truthy(child_toc_level = self4.$convert_outline(section, $hash2(["toclevels", "sectnumlevels"], { "toclevels": toclevels, "sectnumlevels": sectnumlevels })))) {
              result["$<<"]('<li><a href="#' + section.$id() + '">' + stitle + "</a>");
              result["$<<"](child_toc_level);
              return result["$<<"]("</li>");
            } else {
              return result["$<<"]('<li><a href="#' + section.$id() + '">' + stitle + "</a></li>");
            }
            ;
          }, { $$s: self3 });
          result["$<<"]("</ul>");
          return result.$join($$2("LF"));
        }, -2);
        $def(self2, "$convert_section", function $$convert_section(node) {
          var doc_attrs = nil, level = nil, title = nil, $ret_or_1 = nil, signifier = nil, id_attr = nil, id = nil, role = nil;
          doc_attrs = node.$document().$attributes();
          level = node.$level();
          if ($truthy(node.$caption())) {
            title = node.$captioned_title();
          } else if ($truthy(node.$numbered()) && $truthy($rb_le(level, ($truthy($ret_or_1 = doc_attrs["$[]"]("sectnumlevels")) ? $ret_or_1 : 3).$to_i()))) {
            if ($truthy($rb_lt(level, 2)) && $eqeq(node.$document().$doctype(), "book")) {
              switch (node.$sectname()) {
                case "chapter":
                  title = ($truthy(signifier = doc_attrs["$[]"]("chapter-signifier")) ? "" + signifier + " " : "") + node.$sectnum() + " " + node.$title();
                  break;
                case "part":
                  title = ($truthy(signifier = doc_attrs["$[]"]("part-signifier")) ? "" + signifier + " " : "") + node.$sectnum(nil, ":") + " " + node.$title();
                  break;
                default:
                  title = "" + node.$sectnum() + " " + node.$title();
              }
            } else {
              title = "" + node.$sectnum() + " " + node.$title();
            }
          } else {
            title = node.$title();
          }
          ;
          if ($truthy(node.$id())) {
            id_attr = ' id="' + (id = node.$id()) + '"';
            if ($truthy(doc_attrs["$[]"]("sectlinks"))) {
              title = '<a class="link" href="#' + id + '">' + title + "</a>";
            }
            ;
            if ($truthy(doc_attrs["$[]"]("sectanchors"))) {
              if ($eqeq(doc_attrs["$[]"]("sectanchors"), "after")) {
                title = "" + title + '<a class="anchor" href="#' + id + '"></a>';
              } else {
                title = '<a class="anchor" href="#' + id + '"></a>' + title;
              }
            }
            ;
          } else {
            id_attr = "";
          }
          ;
          if ($eqeq(level, 0)) {
            return "<h1" + id_attr + ' class="sect0' + ($truthy(role = node.$role()) ? " " + role : "") + '">' + title + "</h1>\n" + node.$content();
          } else {
            return '<div class="sect' + level + ($truthy(role = node.$role()) ? " " + role : "") + '">\n<h' + $rb_plus(level, 1) + id_attr + ">" + title + "</h" + $rb_plus(level, 1) + ">\n" + ($eqeq(level, 1) ? '<div class="sectionbody">\n' + node.$content() + "\n</div>" : node.$content()) + "\n</div>";
          }
          ;
        });
        $def(self2, "$convert_admonition", function $$convert_admonition(node) {
          var self3 = this, id_attr = nil, name = nil, title_element = nil, label = nil, role = nil;
          id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          name = node.$attr("name");
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
          if ($truthy(node.$document()["$attr?"]("icons"))) {
            if ($truthy(node.$document()["$attr?"]("icons", "font")) && $not(node["$attr?"]("icon"))) {
              label = '<i class="fa icon-' + name + '" title="' + node.$attr("textlabel") + '"></i>';
            } else {
              label = '<img src="' + node.$icon_uri(name) + '" alt="' + node.$attr("textlabel") + '"' + self3.void_element_slash + ">";
            }
          } else {
            label = '<div class="title">' + node.$attr("textlabel") + "</div>";
          }
          ;
          return "<div" + id_attr + ' class="admonitionblock ' + name + ($truthy(role = node.$role()) ? " " + role : "") + '">\n<table>\n<tr>\n<td class="icon">\n' + label + '\n</td>\n<td class="content">\n' + title_element + node.$content() + "\n</td>\n</tr>\n</table>\n</div>";
        });
        $def(self2, "$convert_audio", function $$convert_audio(node) {
          var self3 = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, start_t = nil, end_t = nil, time_anchor = nil, $ret_or_1 = nil;
          xml = self3.xml_mode;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["audioblock", node.$role()].$compact();
          class_attribute = ' class="' + classes.$join(" ") + '"';
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
          start_t = node.$attr("start");
          end_t = node.$attr("end");
          time_anchor = $truthy(start_t) || $truthy(end_t) ? "#t=" + ($truthy($ret_or_1 = start_t) ? $ret_or_1 : "") + ($truthy(end_t) ? "," + end_t : "") : "";
          return "<div" + id_attribute + class_attribute + ">\n" + title_element + '<div class="content">\n<audio src="' + node.$media_uri(node.$attr("target")) + time_anchor + '"' + ($truthy(node["$option?"]("autoplay")) ? self3.$append_boolean_attribute("autoplay", xml) : "") + ($truthy(node["$option?"]("nocontrols")) ? "" : self3.$append_boolean_attribute("controls", xml)) + ($truthy(node["$option?"]("loop")) ? self3.$append_boolean_attribute("loop", xml) : "") + ">\nYour browser does not support the audio tag.\n</audio>\n</div>\n</div>";
        });
        $def(self2, "$convert_colist", function $$convert_colist(node) {
          var $a, self3 = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, font_icons = nil, num = nil;
          result = [];
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["colist", node.$style(), node.$role()].$compact();
          class_attribute = ' class="' + classes.$join(" ") + '"';
          result["$<<"]("<div" + id_attribute + class_attribute + ">");
          if ($truthy(node["$title?"]())) {
            result["$<<"]('<div class="title">' + node.$title() + "</div>");
          }
          ;
          if ($truthy(node.$document()["$attr?"]("icons"))) {
            result["$<<"]("<table>");
            $a = [node.$document()["$attr?"]("icons", "font"), 0], font_icons = $a[0], num = $a[1], $a;
            $send(node.$items(), "each", [], function $$5(item) {
              var self4 = $$5.$$s == null ? this : $$5.$$s, num_label = nil;
              if (self4.void_element_slash == null)
                self4.void_element_slash = nil;
              if (item == null)
                item = nil;
              num = $rb_plus(num, 1);
              if ($truthy(font_icons)) {
                num_label = '<i class="conum" data-value="' + num + '"></i><b>' + num + "</b>";
              } else {
                num_label = '<img src="' + node.$icon_uri("callouts/" + num) + '" alt="' + num + '"' + self4.void_element_slash + ">";
              }
              ;
              return result["$<<"]("<tr>\n<td>" + num_label + "</td>\n<td>" + item.$text() + ($truthy(item["$blocks?"]()) ? $rb_plus($$2("LF"), item.$content()) : "") + "</td>\n</tr>");
            }, { $$s: self3 });
            result["$<<"]("</table>");
          } else {
            result["$<<"]("<ol>");
            $send(node.$items(), "each", [], function $$6(item) {
              if (item == null)
                item = nil;
              return result["$<<"]("<li>\n<p>" + item.$text() + "</p>" + ($truthy(item["$blocks?"]()) ? $rb_plus($$2("LF"), item.$content()) : "") + "\n</li>");
            });
            result["$<<"]("</ol>");
          }
          ;
          result["$<<"]("</div>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_dlist", function $$convert_dlist(node) {
          var self3 = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, slash = nil, col_style_attribute = nil, dt_style_attribute = nil;
          result = [];
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          switch (node.$style()) {
            case "qanda":
              classes = ["qlist", "qanda", node.$role()];
              break;
            case "horizontal":
              classes = ["hdlist", node.$role()];
              break;
            default:
              classes = ["dlist", node.$style(), node.$role()];
          }
          ;
          class_attribute = ' class="' + classes.$compact().$join(" ") + '"';
          result["$<<"]("<div" + id_attribute + class_attribute + ">");
          if ($truthy(node["$title?"]())) {
            result["$<<"]('<div class="title">' + node.$title() + "</div>");
          }
          ;
          switch (node.$style()) {
            case "qanda":
              result["$<<"]("<ol>");
              $send(node.$items(), "each", [], function $$7(terms, dd) {
                if (terms == null)
                  terms = nil;
                if (dd == null)
                  dd = nil;
                result["$<<"]("<li>");
                $send(terms, "each", [], function $$8(dt) {
                  if (dt == null)
                    dt = nil;
                  return result["$<<"]("<p><em>" + dt.$text() + "</em></p>");
                });
                if ($truthy(dd)) {
                  if ($truthy(dd["$text?"]())) {
                    result["$<<"]("<p>" + dd.$text() + "</p>");
                  }
                  ;
                  if ($truthy(dd["$blocks?"]())) {
                    result["$<<"](dd.$content());
                  }
                  ;
                }
                ;
                return result["$<<"]("</li>");
              });
              result["$<<"]("</ol>");
              break;
            case "horizontal":
              slash = self3.void_element_slash;
              result["$<<"]("<table>");
              if ($truthy(node["$attr?"]("labelwidth")) || $truthy(node["$attr?"]("itemwidth"))) {
                result["$<<"]("<colgroup>");
                col_style_attribute = $truthy(node["$attr?"]("labelwidth")) ? ' style="width: ' + node.$attr("labelwidth").$chomp("%") + '%;"' : "";
                result["$<<"]("<col" + col_style_attribute + slash + ">");
                col_style_attribute = $truthy(node["$attr?"]("itemwidth")) ? ' style="width: ' + node.$attr("itemwidth").$chomp("%") + '%;"' : "";
                result["$<<"]("<col" + col_style_attribute + slash + ">");
                result["$<<"]("</colgroup>");
              }
              ;
              $send(node.$items(), "each", [], function $$9(terms, dd) {
                var first_term = nil;
                if (terms == null)
                  terms = nil;
                if (dd == null)
                  dd = nil;
                result["$<<"]("<tr>");
                result["$<<"]('<td class="hdlist1' + ($truthy(node["$option?"]("strong")) ? " strong" : "") + '">');
                first_term = true;
                $send(terms, "each", [], function $$10(dt) {
                  if (dt == null)
                    dt = nil;
                  if (!$truthy(first_term)) {
                    result["$<<"]("<br" + slash + ">");
                  }
                  ;
                  result["$<<"](dt.$text());
                  return first_term = nil;
                });
                result["$<<"]("</td>");
                result["$<<"]('<td class="hdlist2">');
                if ($truthy(dd)) {
                  if ($truthy(dd["$text?"]())) {
                    result["$<<"]("<p>" + dd.$text() + "</p>");
                  }
                  ;
                  if ($truthy(dd["$blocks?"]())) {
                    result["$<<"](dd.$content());
                  }
                  ;
                }
                ;
                result["$<<"]("</td>");
                return result["$<<"]("</tr>");
              });
              result["$<<"]("</table>");
              break;
            default:
              result["$<<"]("<dl>");
              dt_style_attribute = $truthy(node.$style()) ? "" : ' class="hdlist1"';
              $send(node.$items(), "each", [], function $$11(terms, dd) {
                if (terms == null)
                  terms = nil;
                if (dd == null)
                  dd = nil;
                $send(terms, "each", [], function $$12(dt) {
                  if (dt == null)
                    dt = nil;
                  return result["$<<"]("<dt" + dt_style_attribute + ">" + dt.$text() + "</dt>");
                });
                if (!$truthy(dd)) {
                  return nil;
                }
                ;
                result["$<<"]("<dd>");
                if ($truthy(dd["$text?"]())) {
                  result["$<<"]("<p>" + dd.$text() + "</p>");
                }
                ;
                if ($truthy(dd["$blocks?"]())) {
                  result["$<<"](dd.$content());
                }
                ;
                return result["$<<"]("</dd>");
              });
              result["$<<"]("</dl>");
          }
          ;
          result["$<<"]("</div>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_example", function $$convert_example(node) {
          var id_attribute = nil, class_attribute = nil, summary_element = nil, title_element = nil, role = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          if ($truthy(node["$option?"]("collapsible"))) {
            class_attribute = $truthy(node.$role()) ? ' class="' + node.$role() + '"' : "";
            summary_element = $truthy(node["$title?"]()) ? '<summary class="title">' + node.$title() + "</summary>" : '<summary class="title">Details</summary>';
            return "<details" + id_attribute + class_attribute + ($truthy(node["$option?"]("open")) ? " open" : "") + ">\n" + summary_element + '\n<div class="content">\n' + node.$content() + "\n</div>\n</details>";
          } else {
            title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$captioned_title() + "</div>\n" : "";
            return "<div" + id_attribute + ' class="exampleblock' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_element + '<div class="content">\n' + node.$content() + "\n</div>\n</div>";
          }
          ;
        });
        $def(self2, "$convert_floating_title", function $$convert_floating_title(node) {
          var tag_name = nil, id_attribute = nil, classes = nil;
          tag_name = "h" + $rb_plus(node.$level(), 1);
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = [node.$style(), node.$role()].$compact();
          return "<" + tag_name + id_attribute + ' class="' + classes.$join(" ") + '">' + node.$title() + "</" + tag_name + ">";
        });
        $def(self2, "$convert_image", function $$convert_image(node) {
          var self3 = this, target = nil, width_attr = nil, height_attr = nil, img = nil, $ret_or_1 = nil, fallback = nil, id_attr = nil, classes = nil, class_attr = nil, title_el = nil;
          target = node.$attr("target");
          width_attr = $truthy(node["$attr?"]("width")) ? ' width="' + node.$attr("width") + '"' : "";
          height_attr = $truthy(node["$attr?"]("height")) ? ' height="' + node.$attr("height") + '"' : "";
          if (($truthy(node["$attr?"]("format", "svg")) || $truthy(target["$include?"](".svg"))) && $truthy($rb_lt(node.$document().$safe(), $$$($$2("SafeMode"), "SECURE")))) {
            if ($truthy(node["$option?"]("inline"))) {
              img = $truthy($ret_or_1 = self3.$read_svg_contents(node, target)) ? $ret_or_1 : '<span class="alt">' + node.$alt() + "</span>";
            } else if ($truthy(node["$option?"]("interactive"))) {
              fallback = $truthy(node["$attr?"]("fallback")) ? '<img src="' + node.$image_uri(node.$attr("fallback")) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + width_attr + height_attr + self3.void_element_slash + ">" : '<span class="alt">' + node.$alt() + "</span>";
              img = '<object type="image/svg+xml" data="' + node.$image_uri(target) + '"' + width_attr + height_attr + ">" + fallback + "</object>";
            } else {
              img = '<img src="' + node.$image_uri(target) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + width_attr + height_attr + self3.void_element_slash + ">";
            }
          } else {
            img = '<img src="' + node.$image_uri(target) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + width_attr + height_attr + self3.void_element_slash + ">";
          }
          ;
          if ($truthy(node["$attr?"]("link"))) {
            img = '<a class="image" href="' + node.$attr("link") + '"' + self3.$append_link_constraint_attrs(node).$join() + ">" + img + "</a>";
          }
          ;
          id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["imageblock"];
          if ($truthy(node["$attr?"]("float"))) {
            classes["$<<"](node.$attr("float"));
          }
          ;
          if ($truthy(node["$attr?"]("align"))) {
            classes["$<<"]("text-" + node.$attr("align"));
          }
          ;
          if ($truthy(node.$role())) {
            classes["$<<"](node.$role());
          }
          ;
          class_attr = ' class="' + classes.$join(" ") + '"';
          title_el = $truthy(node["$title?"]()) ? '\n<div class="title">' + node.$captioned_title() + "</div>" : "";
          return "<div" + id_attr + class_attr + '>\n<div class="content">\n' + img + "\n</div>" + title_el + "\n</div>";
        });
        $def(self2, "$convert_listing", function $$convert_listing(node) {
          var nowrap = nil, $ret_or_1 = nil, lang = nil, syntax_hl = nil, opts = nil, doc_attrs = nil, pre_open = nil, pre_close = nil, id_attribute = nil, title_element = nil, role = nil;
          nowrap = $truthy($ret_or_1 = node["$option?"]("nowrap")) ? $ret_or_1 : node.$document()["$attr?"]("prewrap")["$!"]();
          if ($eqeq(node.$style(), "source")) {
            lang = node.$attr("language");
            if ($truthy(syntax_hl = node.$document().$syntax_highlighter())) {
              opts = $truthy(syntax_hl["$highlight?"]()) ? $hash2(["css_mode", "style"], { "css_mode": ($truthy($ret_or_1 = (doc_attrs = node.$document().$attributes())["$[]"]("" + syntax_hl.$name() + "-css")) ? $ret_or_1 : "class").$to_sym(), "style": doc_attrs["$[]"]("" + syntax_hl.$name() + "-style") }) : $hash2([], {});
              opts["$[]="]("nowrap", nowrap);
            } else {
              pre_open = '<pre class="highlight' + ($truthy(nowrap) ? " nowrap" : "") + '"><code' + ($truthy(lang) ? ' class="language-' + lang + '" data-lang="' + lang + '"' : "") + ">";
              pre_close = "</code></pre>";
            }
            ;
          } else {
            pre_open = "<pre" + ($truthy(nowrap) ? ' class="nowrap"' : "") + ">";
            pre_close = "</pre>";
          }
          ;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$captioned_title() + "</div>\n" : "";
          return "<div" + id_attribute + ' class="listingblock' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_element + '<div class="content">\n' + ($truthy(syntax_hl) ? syntax_hl.$format(node, lang, opts) : $rb_plus($rb_plus(pre_open, node.$content()), pre_close)) + "\n</div>\n</div>";
        });
        $def(self2, "$convert_literal", function $$convert_literal(node) {
          var id_attribute = nil, title_element = nil, nowrap = nil, $ret_or_1 = nil, role = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
          nowrap = $truthy($ret_or_1 = node.$document()["$attr?"]("prewrap")["$!"]()) ? $ret_or_1 : node["$option?"]("nowrap");
          return "<div" + id_attribute + ' class="literalblock' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_element + '<div class="content">\n<pre' + ($truthy(nowrap) ? ' class="nowrap"' : "") + ">" + node.$content() + "</pre>\n</div>\n</div>";
        });
        $def(self2, "$convert_stem", function $$convert_stem(node) {
          var $a, $b, self3 = this, id_attribute = nil, title_element = nil, style = nil, open = nil, close = nil, equation = nil, br = nil, role = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
          $b = $$2("BLOCK_MATH_DELIMITERS")["$[]"](style = node.$style().$to_sym()), $a = $to_ary($b), open = $a[0] == null ? nil : $a[0], close = $a[1] == null ? nil : $a[1], $b;
          if ($truthy(equation = node.$content())) {
            if ($eqeq(style, "asciimath") && $truthy(equation["$include?"]($$2("LF")))) {
              br = "" + $$2("LF") + "<br" + self3.void_element_slash + ">";
              equation = $send(equation, "gsub", [$$2("StemBreakRx")], function $$13() {
                var $c;
                return "" + close + $rb_times(br, $rb_minus((($c = $gvars["~"]) === nil ? nil : $c["$[]"](0)).$count($$2("LF")), 1)) + $$2("LF") + open;
              });
            }
            ;
            if (!($truthy(equation["$start_with?"](open)) && $truthy(equation["$end_with?"](close)))) {
              equation = "" + open + equation + close;
            }
            ;
          } else {
            equation = "";
          }
          ;
          return "<div" + id_attribute + ' class="stemblock' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_element + '<div class="content">\n' + equation + "\n</div>\n</div>";
        });
        $def(self2, "$convert_olist", function $$convert_olist(node) {
          var self3 = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, type_attribute = nil, keyword = nil, start_attribute = nil, reversed_attribute = nil;
          result = [];
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["olist", node.$style(), node.$role()].$compact();
          class_attribute = ' class="' + classes.$join(" ") + '"';
          result["$<<"]("<div" + id_attribute + class_attribute + ">");
          if ($truthy(node["$title?"]())) {
            result["$<<"]('<div class="title">' + node.$title() + "</div>");
          }
          ;
          type_attribute = $truthy(keyword = node.$list_marker_keyword()) ? ' type="' + keyword + '"' : "";
          start_attribute = $truthy(node["$attr?"]("start")) ? ' start="' + node.$attr("start") + '"' : "";
          reversed_attribute = $truthy(node["$option?"]("reversed")) ? self3.$append_boolean_attribute("reversed", self3.xml_mode) : "";
          result["$<<"]('<ol class="' + node.$style() + '"' + type_attribute + start_attribute + reversed_attribute + ">");
          $send(node.$items(), "each", [], function $$14(item) {
            if (item == null)
              item = nil;
            if ($truthy(item.$id())) {
              result["$<<"]('<li id="' + item.$id() + '"' + ($truthy(item.$role()) ? ' class="' + item.$role() + '"' : "") + ">");
            } else if ($truthy(item.$role())) {
              result["$<<"]('<li class="' + item.$role() + '">');
            } else {
              result["$<<"]("<li>");
            }
            ;
            result["$<<"]("<p>" + item.$text() + "</p>");
            if ($truthy(item["$blocks?"]())) {
              result["$<<"](item.$content());
            }
            ;
            return result["$<<"]("</li>");
          });
          result["$<<"]("</ol>");
          result["$<<"]("</div>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_open", function $$convert_open(node) {
          var self3 = this, style = nil, id_attr = nil, title_el = nil, role = nil;
          if ($eqeq(style = node.$style(), "abstract")) {
            if ($eqeq(node.$parent(), node.$document()) && $eqeq(node.$document().$doctype(), "book")) {
              self3.$logger().$warn("abstract block cannot be used in a document without a title when doctype is book. Excluding block content.");
              return "";
            } else {
              id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
              title_el = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
              return "<div" + id_attr + ' class="quoteblock abstract' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_el + "<blockquote>\n" + node.$content() + "\n</blockquote>\n</div>";
            }
          } else if ($eqeq(style, "partintro") && ($truthy($rb_gt(node.$level(), 0)) || $neqeq(node.$parent().$context(), "section") || $neqeq(node.$document().$doctype(), "book"))) {
            self3.$logger().$error("partintro block can only be used when doctype is book and must be a child of a book part. Excluding block content.");
            return "";
          } else {
            id_attr = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
            title_el = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
            return "<div" + id_attr + ' class="openblock' + ($truthy(style) && $neqeq(style, "open") ? " " + style : "") + ($truthy(role = node.$role()) ? " " + role : "") + '">\n' + title_el + '<div class="content">\n' + node.$content() + "\n</div>\n</div>";
          }
        });
        $def(self2, "$convert_page_break", $return_val('<div style="page-break-after: always;"></div>'));
        $def(self2, "$convert_paragraph", function $$convert_paragraph(node) {
          var attributes = nil;
          if ($truthy(node.$role())) {
            attributes = ($truthy(node.$id()) ? ' id="' + node.$id() + '"' : "") + ' class="paragraph ' + node.$role() + '"';
          } else if ($truthy(node.$id())) {
            attributes = ' id="' + node.$id() + '" class="paragraph"';
          } else {
            attributes = ' class="paragraph"';
          }
          ;
          if ($truthy(node["$title?"]())) {
            return "<div" + attributes + '>\n<div class="title">' + node.$title() + "</div>\n<p>" + node.$content() + "</p>\n</div>";
          } else {
            return "<div" + attributes + ">\n<p>" + node.$content() + "</p>\n</div>";
          }
          ;
        });
        $alias(self2, "convert_pass", "content_only");
        $def(self2, "$convert_preamble", function $$convert_preamble(node) {
          var doc = nil, toc = nil;
          if ($truthy((doc = node.$document())["$attr?"]("toc-placement", "preamble")) && $truthy(doc["$sections?"]()) && $truthy(doc["$attr?"]("toc"))) {
            toc = '\n<div id="toc" class="' + doc.$attr("toc-class", "toc") + '">\n<div id="toctitle">' + doc.$attr("toc-title") + "</div>\n" + doc.$converter().$convert(doc, "outline") + "\n</div>";
          } else {
            toc = "";
          }
          ;
          return '<div id="preamble">\n<div class="sectionbody">\n' + node.$content() + "\n</div>" + toc + "\n</div>";
        });
        $def(self2, "$convert_quote", function $$convert_quote(node) {
          var self3 = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["quoteblock", node.$role()].$compact();
          class_attribute = ' class="' + classes.$join(" ") + '"';
          title_element = $truthy(node["$title?"]()) ? '\n<div class="title">' + node.$title() + "</div>" : "";
          attribution = $truthy(node["$attr?"]("attribution")) ? node.$attr("attribution") : nil;
          citetitle = $truthy(node["$attr?"]("citetitle")) ? node.$attr("citetitle") : nil;
          if ($truthy(attribution) || $truthy(citetitle)) {
            cite_element = $truthy(citetitle) ? "<cite>" + citetitle + "</cite>" : "";
            attribution_text = $truthy(attribution) ? "&#8212; " + attribution + ($truthy(citetitle) ? "<br" + self3.void_element_slash + ">\n" : "") : "";
            attribution_element = '\n<div class="attribution">\n' + attribution_text + cite_element + "\n</div>";
          } else {
            attribution_element = "";
          }
          ;
          return "<div" + id_attribute + class_attribute + ">" + title_element + "\n<blockquote>\n" + node.$content() + "\n</blockquote>" + attribution_element + "\n</div>";
        });
        $def(self2, "$convert_thematic_break", function $$convert_thematic_break(node) {
          var self3 = this;
          return "<hr" + self3.void_element_slash + ">";
        });
        $def(self2, "$convert_sidebar", function $$convert_sidebar(node) {
          var id_attribute = nil, title_element = nil, role = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          title_element = $truthy(node["$title?"]()) ? '<div class="title">' + node.$title() + "</div>\n" : "";
          return "<div" + id_attribute + ' class="sidebarblock' + ($truthy(role = node.$role()) ? " " + role : "") + '">\n<div class="content">\n' + title_element + node.$content() + "\n</div>\n</div>";
        });
        $def(self2, "$convert_table", function $$convert_table(node) {
          var self3 = this, result = nil, id_attribute = nil, frame = nil, classes = nil, stripes = nil, style_attribute = nil, autowidth = nil, tablewidth = nil, role = nil, class_attribute = nil, slash = nil;
          result = [];
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          if ($eqeq(frame = node.$attr("frame", "all", "table-frame"), "topbot")) {
            frame = "ends";
          }
          ;
          classes = ["tableblock", "frame-" + frame, "grid-" + node.$attr("grid", "all", "table-grid")];
          if ($truthy(stripes = node.$attr("stripes", nil, "table-stripes"))) {
            classes["$<<"]("stripes-" + stripes);
          }
          ;
          style_attribute = "";
          if ($truthy(autowidth = node["$option?"]("autowidth")) && $not(node["$attr?"]("width"))) {
            classes["$<<"]("fit-content");
          } else if ($eqeq(tablewidth = node.$attr("tablepcwidth"), 100)) {
            classes["$<<"]("stretch");
          } else {
            style_attribute = ' style="width: ' + tablewidth + '%;"';
          }
          ;
          if ($truthy(node["$attr?"]("float"))) {
            classes["$<<"](node.$attr("float"));
          }
          ;
          if ($truthy(role = node.$role())) {
            classes["$<<"](role);
          }
          ;
          class_attribute = ' class="' + classes.$join(" ") + '"';
          result["$<<"]("<table" + id_attribute + class_attribute + style_attribute + ">");
          if ($truthy(node["$title?"]())) {
            result["$<<"]('<caption class="title">' + node.$captioned_title() + "</caption>");
          }
          ;
          if ($truthy($rb_gt(node.$attr("rowcount"), 0))) {
            slash = self3.void_element_slash;
            result["$<<"]("<colgroup>");
            if ($truthy(autowidth)) {
              result = $rb_plus(result, $$2("Array").$new(node.$columns().$size(), "<col" + slash + ">"));
            } else {
              $send(node.$columns(), "each", [], function $$15(col) {
                if (col == null)
                  col = nil;
                return result["$<<"]($truthy(col["$option?"]("autowidth")) ? "<col" + slash + ">" : '<col style="width: ' + col.$attr("colpcwidth") + '%;"' + slash + ">");
              });
            }
            ;
            result["$<<"]("</colgroup>");
            $send(node.$rows().$to_h(), "each", [], function $$16(tsec, rows) {
              if (tsec == null)
                tsec = nil;
              if (rows == null)
                rows = nil;
              if ($truthy(rows["$empty?"]())) {
                return nil;
              }
              ;
              result["$<<"]("<t" + tsec + ">");
              $send(rows, "each", [], function $$17(row) {
                if (row == null)
                  row = nil;
                result["$<<"]("<tr>");
                $send(row, "each", [], function $$18(cell) {
                  var cell_content = nil, cell_tag_name = nil, cell_class_attribute = nil, cell_colspan_attribute = nil, cell_rowspan_attribute = nil, cell_style_attribute = nil;
                  if (cell == null)
                    cell = nil;
                  if ($eqeq(tsec, "head")) {
                    cell_content = cell.$text();
                  } else
                    switch (cell.$style()) {
                      case "asciidoc":
                        cell_content = '<div class="content">' + cell.$content() + "</div>";
                        break;
                      case "literal":
                        cell_content = '<div class="literal"><pre>' + cell.$text() + "</pre></div>";
                        break;
                      default:
                        cell_content = $truthy((cell_content = cell.$content())["$empty?"]()) ? "" : '<p class="tableblock">' + cell_content.$join('</p>\n<p class="tableblock">') + "</p>";
                    }
                  ;
                  cell_tag_name = $eqeq(tsec, "head") || $eqeq(cell.$style(), "header") ? "th" : "td";
                  cell_class_attribute = ' class="tableblock halign-' + cell.$attr("halign") + " valign-" + cell.$attr("valign") + '"';
                  cell_colspan_attribute = $truthy(cell.$colspan()) ? ' colspan="' + cell.$colspan() + '"' : "";
                  cell_rowspan_attribute = $truthy(cell.$rowspan()) ? ' rowspan="' + cell.$rowspan() + '"' : "";
                  cell_style_attribute = $truthy(node.$document()["$attr?"]("cellbgcolor")) ? ' style="background-color: ' + node.$document().$attr("cellbgcolor") + ';"' : "";
                  return result["$<<"]("<" + cell_tag_name + cell_class_attribute + cell_colspan_attribute + cell_rowspan_attribute + cell_style_attribute + ">" + cell_content + "</" + cell_tag_name + ">");
                });
                return result["$<<"]("</tr>");
              });
              return result["$<<"]("</t" + tsec + ">");
            });
          }
          ;
          result["$<<"]("</table>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_toc", function $$convert_toc(node) {
          var doc = nil, id_attr = nil, title_id_attr = nil, title = nil, levels = nil, role = nil;
          if (!($truthy((doc = node.$document())["$attr?"]("toc-placement", "macro")) && $truthy(doc["$sections?"]()) && $truthy(doc["$attr?"]("toc")))) {
            return "<!-- toc disabled -->";
          }
          ;
          if ($truthy(node.$id())) {
            id_attr = ' id="' + node.$id() + '"';
            title_id_attr = ' id="' + node.$id() + 'title"';
          } else {
            id_attr = ' id="toc"';
            title_id_attr = ' id="toctitle"';
          }
          ;
          title = $truthy(node["$title?"]()) ? node.$title() : doc.$attr("toc-title");
          levels = $truthy(node["$attr?"]("levels")) ? node.$attr("levels").$to_i() : nil;
          role = $truthy(node["$role?"]()) ? node.$role() : doc.$attr("toc-class", "toc");
          return "<div" + id_attr + ' class="' + role + '">\n<div' + title_id_attr + ' class="title">' + title + "</div>\n" + doc.$converter().$convert(doc, "outline", $hash2(["toclevels"], { "toclevels": levels })) + "\n</div>";
        });
        $def(self2, "$convert_ulist", function $$convert_ulist(node) {
          var self3 = this, result = nil, id_attribute = nil, div_classes = nil, marker_checked = nil, marker_unchecked = nil, checklist = nil, ul_class_attribute = nil;
          result = [];
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          div_classes = ["ulist", node.$style(), node.$role()].$compact();
          marker_checked = marker_unchecked = "";
          if ($truthy(checklist = node["$option?"]("checklist"))) {
            div_classes.$unshift(div_classes.$shift(), "checklist");
            ul_class_attribute = ' class="checklist"';
            if ($truthy(node["$option?"]("interactive"))) {
              if ($truthy(self3.xml_mode)) {
                marker_checked = '<input type="checkbox" data-item-complete="1" checked="checked"/> ';
                marker_unchecked = '<input type="checkbox" data-item-complete="0"/> ';
              } else {
                marker_checked = '<input type="checkbox" data-item-complete="1" checked> ';
                marker_unchecked = '<input type="checkbox" data-item-complete="0"> ';
              }
            } else if ($truthy(node.$document()["$attr?"]("icons", "font"))) {
              marker_checked = '<i class="fa fa-check-square-o"></i> ';
              marker_unchecked = '<i class="fa fa-square-o"></i> ';
            } else {
              marker_checked = "&#10003; ";
              marker_unchecked = "&#10063; ";
            }
            ;
          } else {
            ul_class_attribute = $truthy(node.$style()) ? ' class="' + node.$style() + '"' : "";
          }
          ;
          result["$<<"]("<div" + id_attribute + ' class="' + div_classes.$join(" ") + '">');
          if ($truthy(node["$title?"]())) {
            result["$<<"]('<div class="title">' + node.$title() + "</div>");
          }
          ;
          result["$<<"]("<ul" + ul_class_attribute + ">");
          $send(node.$items(), "each", [], function $$19(item) {
            if (item == null)
              item = nil;
            if ($truthy(item.$id())) {
              result["$<<"]('<li id="' + item.$id() + '"' + ($truthy(item.$role()) ? ' class="' + item.$role() + '"' : "") + ">");
            } else if ($truthy(item.$role())) {
              result["$<<"]('<li class="' + item.$role() + '">');
            } else {
              result["$<<"]("<li>");
            }
            ;
            if ($truthy(checklist) && $truthy(item["$attr?"]("checkbox"))) {
              result["$<<"]("<p>" + ($truthy(item["$attr?"]("checked")) ? marker_checked : marker_unchecked) + item.$text() + "</p>");
            } else {
              result["$<<"]("<p>" + item.$text() + "</p>");
            }
            ;
            if ($truthy(item["$blocks?"]())) {
              result["$<<"](item.$content());
            }
            ;
            return result["$<<"]("</li>");
          });
          result["$<<"]("</ul>");
          result["$<<"]("</div>");
          return result.$join($$2("LF"));
        });
        $def(self2, "$convert_verse", function $$convert_verse(node) {
          var self3 = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["verseblock", node.$role()].$compact();
          class_attribute = ' class="' + classes.$join(" ") + '"';
          title_element = $truthy(node["$title?"]()) ? '\n<div class="title">' + node.$title() + "</div>" : "";
          attribution = $truthy(node["$attr?"]("attribution")) ? node.$attr("attribution") : nil;
          citetitle = $truthy(node["$attr?"]("citetitle")) ? node.$attr("citetitle") : nil;
          if ($truthy(attribution) || $truthy(citetitle)) {
            cite_element = $truthy(citetitle) ? "<cite>" + citetitle + "</cite>" : "";
            attribution_text = $truthy(attribution) ? "&#8212; " + attribution + ($truthy(citetitle) ? "<br" + self3.void_element_slash + ">\n" : "") : "";
            attribution_element = '\n<div class="attribution">\n' + attribution_text + cite_element + "\n</div>";
          } else {
            attribution_element = "";
          }
          ;
          return "<div" + id_attribute + class_attribute + ">" + title_element + '\n<pre class="content">' + node.$content() + "</pre>" + attribution_element + "\n</div>";
        });
        $def(self2, "$convert_video", function $$convert_video(node) {
          var $a, $b, self3 = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, width_attribute = nil, height_attribute = nil, asset_uri_scheme = nil, start_anchor = nil, delimiter = nil, target = nil, hash = nil, hash_param = nil, $ret_or_2 = nil, autoplay_param = nil, loop_param = nil, muted_param = nil, rel_param_val = nil, start_param = nil, end_param = nil, has_loop_param = nil, mute_param = nil, controls_param = nil, fs_param = nil, fs_attribute = nil, modest_param = nil, theme_param = nil, hl_param = nil, list = nil, list_param = nil, playlist = nil, poster_attribute = nil, val = nil, preload_attribute = nil, start_t = nil, end_t = nil, time_anchor = nil;
          xml = self3.xml_mode;
          id_attribute = $truthy(node.$id()) ? ' id="' + node.$id() + '"' : "";
          classes = ["videoblock"];
          if ($truthy(node["$attr?"]("float"))) {
            classes["$<<"](node.$attr("float"));
          }
          ;
          if ($truthy(node["$attr?"]("align"))) {
            classes["$<<"]("text-" + node.$attr("align"));
          }
          ;
          if ($truthy(node.$role())) {
            classes["$<<"](node.$role());
          }
          ;
          class_attribute = ' class="' + classes.$join(" ") + '"';
          title_element = $truthy(node["$title?"]()) ? '\n<div class="title">' + node.$title() + "</div>" : "";
          width_attribute = $truthy(node["$attr?"]("width")) ? ' width="' + node.$attr("width") + '"' : "";
          height_attribute = $truthy(node["$attr?"]("height")) ? ' height="' + node.$attr("height") + '"' : "";
          switch (node.$attr("poster")) {
            case "vimeo":
              if (!$truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))["$empty?"]())) {
                asset_uri_scheme = "" + asset_uri_scheme + ":";
              }
              ;
              start_anchor = $truthy(node["$attr?"]("start")) ? "#at=" + node.$attr("start") : "";
              delimiter = ["?"];
              $b = node.$attr("target").$split("/", 2), $a = $to_ary($b), target = $a[0] == null ? nil : $a[0], hash = $a[1] == null ? nil : $a[1], $b;
              hash_param = $truthy(hash = $truthy($ret_or_2 = hash) ? $ret_or_2 : node.$attr("hash")) ? "" + ($truthy($ret_or_2 = delimiter.$pop()) ? $ret_or_2 : "&amp;") + "h=" + hash : "";
              autoplay_param = $truthy(node["$option?"]("autoplay")) ? "" + ($truthy($ret_or_2 = delimiter.$pop()) ? $ret_or_2 : "&amp;") + "autoplay=1" : "";
              loop_param = $truthy(node["$option?"]("loop")) ? "" + ($truthy($ret_or_2 = delimiter.$pop()) ? $ret_or_2 : "&amp;") + "loop=1" : "";
              muted_param = $truthy(node["$option?"]("muted")) ? "" + ($truthy($ret_or_2 = delimiter.$pop()) ? $ret_or_2 : "&amp;") + "muted=1" : "";
              return "<div" + id_attribute + class_attribute + ">" + title_element + '\n<div class="content">\n<iframe' + width_attribute + height_attribute + ' src="' + asset_uri_scheme + "//player.vimeo.com/video/" + target + hash_param + autoplay_param + loop_param + muted_param + start_anchor + '" frameborder="0"' + ($truthy(node["$option?"]("nofullscreen")) ? "" : self3.$append_boolean_attribute("allowfullscreen", xml)) + "></iframe>\n</div>\n</div>";
            case "youtube":
              if (!$truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))["$empty?"]())) {
                asset_uri_scheme = "" + asset_uri_scheme + ":";
              }
              ;
              rel_param_val = $truthy(node["$option?"]("related")) ? 1 : 0;
              start_param = $truthy(node["$attr?"]("start")) ? "&amp;start=" + node.$attr("start") : "";
              end_param = $truthy(node["$attr?"]("end")) ? "&amp;end=" + node.$attr("end") : "";
              autoplay_param = $truthy(node["$option?"]("autoplay")) ? "&amp;autoplay=1" : "";
              loop_param = $truthy(has_loop_param = node["$option?"]("loop")) ? "&amp;loop=1" : "";
              mute_param = $truthy(node["$option?"]("muted")) ? "&amp;mute=1" : "";
              controls_param = $truthy(node["$option?"]("nocontrols")) ? "&amp;controls=0" : "";
              if ($truthy(node["$option?"]("nofullscreen"))) {
                fs_param = "&amp;fs=0";
                fs_attribute = "";
              } else {
                fs_param = "";
                fs_attribute = self3.$append_boolean_attribute("allowfullscreen", xml);
              }
              ;
              modest_param = $truthy(node["$option?"]("modest")) ? "&amp;modestbranding=1" : "";
              theme_param = $truthy(node["$attr?"]("theme")) ? "&amp;theme=" + node.$attr("theme") : "";
              hl_param = $truthy(node["$attr?"]("lang")) ? "&amp;hl=" + node.$attr("lang") : "";
              $b = node.$attr("target").$split("/", 2), $a = $to_ary($b), target = $a[0] == null ? nil : $a[0], list = $a[1] == null ? nil : $a[1], $b;
              if ($truthy(list = $truthy($ret_or_2 = list) ? $ret_or_2 : node.$attr("list"))) {
                list_param = "&amp;list=" + list;
              } else {
                $b = target.$split(",", 2), $a = $to_ary($b), target = $a[0] == null ? nil : $a[0], playlist = $a[1] == null ? nil : $a[1], $b;
                if ($truthy(playlist = $truthy($ret_or_2 = playlist) ? $ret_or_2 : node.$attr("playlist"))) {
                  list_param = "&amp;playlist=" + target + "," + playlist;
                } else {
                  list_param = $truthy(has_loop_param) ? "&amp;playlist=" + target : "";
                }
                ;
              }
              ;
              return "<div" + id_attribute + class_attribute + ">" + title_element + '\n<div class="content">\n<iframe' + width_attribute + height_attribute + ' src="' + asset_uri_scheme + "//www.youtube.com/embed/" + target + "?rel=" + rel_param_val + start_param + end_param + autoplay_param + loop_param + mute_param + controls_param + list_param + fs_param + modest_param + theme_param + hl_param + '" frameborder="0"' + fs_attribute + "></iframe>\n</div>\n</div>";
            default:
              poster_attribute = $truthy((val = node.$attr("poster"))["$nil_or_empty?"]()) ? "" : ' poster="' + node.$media_uri(val) + '"';
              preload_attribute = $truthy((val = node.$attr("preload"))["$nil_or_empty?"]()) ? "" : ' preload="' + val + '"';
              start_t = node.$attr("start");
              end_t = node.$attr("end");
              time_anchor = $truthy(start_t) || $truthy(end_t) ? "#t=" + ($truthy($ret_or_2 = start_t) ? $ret_or_2 : "") + ($truthy(end_t) ? "," + end_t : "") : "";
              return "<div" + id_attribute + class_attribute + ">" + title_element + '\n<div class="content">\n<video src="' + node.$media_uri(node.$attr("target")) + time_anchor + '"' + width_attribute + height_attribute + poster_attribute + ($truthy(node["$option?"]("autoplay")) ? self3.$append_boolean_attribute("autoplay", xml) : "") + ($truthy(node["$option?"]("muted")) ? self3.$append_boolean_attribute("muted", xml) : "") + ($truthy(node["$option?"]("nocontrols")) ? "" : self3.$append_boolean_attribute("controls", xml)) + ($truthy(node["$option?"]("loop")) ? self3.$append_boolean_attribute("loop", xml) : "") + preload_attribute + ">\nYour browser does not support the video tag.\n</video>\n</div>\n</div>";
          }
          ;
        });
        $def(self2, "$convert_inline_anchor", function $$convert_inline_anchor(node) {
          var self3 = this, path = nil, attrs = nil, text = nil, $ret_or_2 = nil, ref = nil, $ret_or_3 = nil, refid = nil, top = nil, outer = nil;
          switch (node.$type()) {
            case "xref":
              if ($truthy(path = node.$attributes()["$[]"]("path"))) {
                attrs = self3.$append_link_constraint_attrs(node, $truthy(node.$role()) ? [' class="' + node.$role() + '"'] : []).$join();
                text = $truthy($ret_or_2 = node.$text()) ? $ret_or_2 : path;
              } else {
                attrs = $truthy(node.$role()) ? ' class="' + node.$role() + '"' : "";
                if (!$truthy(text = node.$text())) {
                  if ($eqeqeq($$2("AbstractNode"), ref = $truthy($ret_or_2 = (self3.refs = $truthy($ret_or_3 = self3.refs) ? $ret_or_3 : node.$document().$catalog()["$[]"]("refs"))["$[]"](refid = node.$attributes()["$[]"]("refid"))) ? $ret_or_2 : $truthy(refid["$nil_or_empty?"]()) ? top = self3.$get_root_document(node) : nil)) {
                    if ($truthy(self3.resolving_xref = $truthy($ret_or_2 = self3.resolving_xref) ? $ret_or_2 : outer = true) && $truthy(outer)) {
                      if ($truthy(text = ref.$xreftext(node.$attr("xrefstyle", nil, true)))) {
                        if ($truthy(text["$include?"]("<a"))) {
                          text = text.$gsub($$2("DropAnchorRx"), "");
                        }
                      } else {
                        text = $truthy(top) ? "[^top]" : "[" + refid + "]";
                      }
                      ;
                      self3.resolving_xref = nil;
                    } else {
                      text = $truthy(top) ? "[^top]" : "[" + refid + "]";
                    }
                  } else {
                    text = "[" + refid + "]";
                  }
                }
                ;
              }
              ;
              return '<a href="' + node.$target() + '"' + attrs + ">" + text + "</a>";
            case "ref":
              return '<a id="' + node.$id() + '"></a>';
            case "link":
              attrs = $truthy(node.$id()) ? [' id="' + node.$id() + '"'] : [];
              if ($truthy(node.$role())) {
                attrs["$<<"](' class="' + node.$role() + '"');
              }
              ;
              if ($truthy(node["$attr?"]("title"))) {
                attrs["$<<"](' title="' + node.$attr("title") + '"');
              }
              ;
              return '<a href="' + node.$target() + '"' + self3.$append_link_constraint_attrs(node, attrs).$join() + ">" + node.$text() + "</a>";
            case "bibref":
              return '<a id="' + node.$id() + '"></a>[' + ($truthy($ret_or_2 = node.$reftext()) ? $ret_or_2 : node.$id()) + "]";
            default:
              self3.$logger().$warn("unknown anchor type: " + node.$type().$inspect());
              return nil;
          }
        });
        $def(self2, "$convert_inline_break", function $$convert_inline_break(node) {
          var self3 = this;
          return "" + node.$text() + "<br" + self3.void_element_slash + ">";
        });
        $def(self2, "$convert_inline_button", function $$convert_inline_button(node) {
          return '<b class="button">' + node.$text() + "</b>";
        });
        $def(self2, "$convert_inline_callout", function $$convert_inline_callout(node) {
          var self3 = this, src = nil, guard = nil;
          if ($truthy(node.$document()["$attr?"]("icons", "font"))) {
            return '<i class="conum" data-value="' + node.$text() + '"></i><b>(' + node.$text() + ")</b>";
          } else if ($truthy(node.$document()["$attr?"]("icons"))) {
            src = node.$icon_uri("callouts/" + node.$text());
            return '<img src="' + src + '" alt="' + node.$text() + '"' + self3.void_element_slash + ">";
          } else if ($eqeqeq($$$("Array"), guard = node.$attributes()["$[]"]("guard"))) {
            return '&lt;!--<b class="conum">(' + node.$text() + ")</b>--&gt;";
          } else {
            return "" + guard + '<b class="conum">(' + node.$text() + ")</b>";
          }
        });
        $def(self2, "$convert_inline_footnote", function $$convert_inline_footnote(node) {
          var index = nil, id_attr = nil;
          if ($truthy(index = node.$attr("index"))) {
            if ($eqeq(node.$type(), "xref")) {
              return '<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_' + index + '" title="View footnote.">' + index + "</a>]</sup>";
            } else {
              id_attr = $truthy(node.$id()) ? ' id="_footnote_' + node.$id() + '"' : "";
              return '<sup class="footnote"' + id_attr + '>[<a id="_footnoteref_' + index + '" class="footnote" href="#_footnotedef_' + index + '" title="View footnote.">' + index + "</a>]</sup>";
            }
          } else if ($eqeq(node.$type(), "xref")) {
            return '<sup class="footnoteref red" title="Unresolved footnote reference.">[' + node.$text() + "]</sup>";
          } else {
            return nil;
          }
        });
        $def(self2, "$convert_inline_image", function $$convert_inline_image(node) {
          var self3 = this, target = nil, type = nil, $ret_or_1 = nil, icons = nil, i_class_attr_val = nil, attrs = nil, img = nil, fallback = nil, class_attr_val = nil, role = nil;
          target = node.$target();
          if ($eqeq(type = $truthy($ret_or_1 = node.$type()) ? $ret_or_1 : "image", "icon")) {
            if ($eqeq(icons = node.$document().$attr("icons"), "font")) {
              i_class_attr_val = "fa fa-" + target;
              if ($truthy(node["$attr?"]("size"))) {
                i_class_attr_val = "" + i_class_attr_val + " fa-" + node.$attr("size");
              }
              ;
              if ($truthy(node["$attr?"]("flip"))) {
                i_class_attr_val = "" + i_class_attr_val + " fa-flip-" + node.$attr("flip");
              } else if ($truthy(node["$attr?"]("rotate"))) {
                i_class_attr_val = "" + i_class_attr_val + " fa-rotate-" + node.$attr("rotate");
              }
              ;
              attrs = $truthy(node["$attr?"]("title")) ? ' title="' + node.$attr("title") + '"' : "";
              img = '<i class="' + i_class_attr_val + '"' + attrs + "></i>";
            } else if ($truthy(icons)) {
              attrs = $truthy(node["$attr?"]("width")) ? ' width="' + node.$attr("width") + '"' : "";
              if ($truthy(node["$attr?"]("height"))) {
                attrs = "" + attrs + ' height="' + node.$attr("height") + '"';
              }
              ;
              if ($truthy(node["$attr?"]("title"))) {
                attrs = "" + attrs + ' title="' + node.$attr("title") + '"';
              }
              ;
              img = '<img src="' + node.$icon_uri(target) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + attrs + self3.void_element_slash + ">";
            } else {
              img = "[" + node.$alt() + "&#93;";
            }
          } else {
            attrs = $truthy(node["$attr?"]("width")) ? ' width="' + node.$attr("width") + '"' : "";
            if ($truthy(node["$attr?"]("height"))) {
              attrs = "" + attrs + ' height="' + node.$attr("height") + '"';
            }
            ;
            if ($truthy(node["$attr?"]("title"))) {
              attrs = "" + attrs + ' title="' + node.$attr("title") + '"';
            }
            ;
            if (($truthy(node["$attr?"]("format", "svg")) || $truthy(target["$include?"](".svg"))) && $truthy($rb_lt(node.$document().$safe(), $$$($$2("SafeMode"), "SECURE")))) {
              if ($truthy(node["$option?"]("inline"))) {
                img = $truthy($ret_or_1 = self3.$read_svg_contents(node, target)) ? $ret_or_1 : '<span class="alt">' + node.$alt() + "</span>";
              } else if ($truthy(node["$option?"]("interactive"))) {
                fallback = $truthy(node["$attr?"]("fallback")) ? '<img src="' + node.$image_uri(node.$attr("fallback")) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + attrs + self3.void_element_slash + ">" : '<span class="alt">' + node.$alt() + "</span>";
                img = '<object type="image/svg+xml" data="' + node.$image_uri(target) + '"' + attrs + ">" + fallback + "</object>";
              } else {
                img = '<img src="' + node.$image_uri(target) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + attrs + self3.void_element_slash + ">";
              }
            } else {
              img = '<img src="' + node.$image_uri(target) + '" alt="' + self3.$encode_attribute_value(node.$alt()) + '"' + attrs + self3.void_element_slash + ">";
            }
            ;
          }
          ;
          if ($truthy(node["$attr?"]("link"))) {
            img = '<a class="image" href="' + node.$attr("link") + '"' + self3.$append_link_constraint_attrs(node).$join() + ">" + img + "</a>";
          }
          ;
          class_attr_val = type;
          if ($truthy(role = node.$role())) {
            class_attr_val = $truthy(node["$attr?"]("float")) ? "" + class_attr_val + " " + node.$attr("float") + " " + role : "" + class_attr_val + " " + role;
          } else if ($truthy(node["$attr?"]("float"))) {
            class_attr_val = "" + class_attr_val + " " + node.$attr("float");
          }
          ;
          return '<span class="' + class_attr_val + '">' + img + "</span>";
        });
        $def(self2, "$convert_inline_indexterm", function $$convert_inline_indexterm(node) {
          if ($eqeq(node.$type(), "visible")) {
            return node.$text();
          } else {
            return "";
          }
        });
        $def(self2, "$convert_inline_kbd", function $$convert_inline_kbd(node) {
          var keys = nil;
          if ($eqeq((keys = node.$attr("keys")).$size(), 1)) {
            return "<kbd>" + keys["$[]"](0) + "</kbd>";
          } else {
            return '<span class="keyseq"><kbd>' + keys.$join("</kbd>+<kbd>") + "</kbd></span>";
          }
        });
        $def(self2, "$convert_inline_menu", function $$convert_inline_menu(node) {
          var caret = nil, submenu_joiner = nil, menu = nil, submenus = nil, menuitem = nil;
          caret = $truthy(node.$document()["$attr?"]("icons", "font")) ? '&#160;<i class="fa fa-angle-right caret"></i> ' : '&#160;<b class="caret">&#8250;</b> ';
          submenu_joiner = "</b>" + caret + '<b class="submenu">';
          menu = node.$attr("menu");
          if ($truthy((submenus = node.$attr("submenus"))["$empty?"]())) {
            if ($truthy(menuitem = node.$attr("menuitem"))) {
              return '<span class="menuseq"><b class="menu">' + menu + "</b>" + caret + '<b class="menuitem">' + menuitem + "</b></span>";
            } else {
              return '<b class="menuref">' + menu + "</b>";
            }
          } else {
            return '<span class="menuseq"><b class="menu">' + menu + "</b>" + caret + '<b class="submenu">' + submenus.$join(submenu_joiner) + "</b>" + caret + '<b class="menuitem">' + node.$attr("menuitem") + "</b></span>";
          }
          ;
        });
        $def(self2, "$convert_inline_quoted", function $$convert_inline_quoted(node) {
          var $a, $b, open = nil, close = nil, tag = nil, class_attr = nil;
          $b = $$2("QUOTE_TAGS")["$[]"](node.$type()), $a = $to_ary($b), open = $a[0] == null ? nil : $a[0], close = $a[1] == null ? nil : $a[1], tag = $a[2] == null ? nil : $a[2], $b;
          if ($truthy(node.$id())) {
            class_attr = $truthy(node.$role()) ? ' class="' + node.$role() + '"' : "";
            if ($truthy(tag)) {
              return "" + open.$chop() + ' id="' + node.$id() + '"' + class_attr + ">" + node.$text() + close;
            } else {
              return '<span id="' + node.$id() + '"' + class_attr + ">" + open + node.$text() + close + "</span>";
            }
            ;
          } else if ($truthy(node.$role())) {
            if ($truthy(tag)) {
              return "" + open.$chop() + ' class="' + node.$role() + '">' + node.$text() + close;
            } else {
              return '<span class="' + node.$role() + '">' + open + node.$text() + close + "</span>";
            }
          } else {
            return "" + open + node.$text() + close;
          }
          ;
        });
        $def(self2, "$read_svg_contents", function $$read_svg_contents(node, target) {
          var svg = nil, old_start_tag = nil, new_start_tag = nil, start_tag_match = nil;
          if ($truthy(svg = node.$read_contents(target, $hash2(["start", "normalize", "label", "warn_if_empty"], { "start": node.$document().$attr("imagesdir"), "normalize": true, "label": "SVG", "warn_if_empty": true })))) {
            if ($truthy(svg["$empty?"]())) {
              return nil;
            }
            ;
            if (!$truthy(svg["$start_with?"]("<svg"))) {
              svg = svg.$sub($$2("SvgPreambleRx"), "");
            }
            ;
            old_start_tag = new_start_tag = start_tag_match = nil;
            $send(["width", "height"], "each", [], function $$20(dim) {
              var $ret_or_1 = nil, $ret_or_2 = nil;
              if (dim == null)
                dim = nil;
              if (!$truthy(node["$attr?"](dim))) {
                return nil;
              }
              ;
              if (!$truthy(new_start_tag)) {
                if ($eqeq(start_tag_match = $truthy($ret_or_1 = start_tag_match) ? $ret_or_1 : $truthy($ret_or_2 = svg.$match($$2("SvgStartTagRx"))) ? $ret_or_2 : "no_match", "no_match")) {
                  return nil;
                }
                ;
                new_start_tag = (old_start_tag = start_tag_match["$[]"](0)).$gsub($$2("DimensionAttributeRx"), "");
              }
              ;
              return new_start_tag = "" + new_start_tag.$chop() + " " + dim + '="' + node.$attr(dim) + '">';
            });
            if ($truthy(new_start_tag)) {
              svg = "" + new_start_tag + svg["$[]"](Opal2.Range.$new(old_start_tag.$length(), -1, false));
            }
            ;
          }
          ;
          return svg;
        });
        self2.$private();
        $def(self2, "$append_boolean_attribute", function $$append_boolean_attribute(name, xml) {
          if ($truthy(xml)) {
            return " " + name + '="' + name + '"';
          } else {
            return " " + name;
          }
        });
        $def(self2, "$append_link_constraint_attrs", function $$append_link_constraint_attrs(node, attrs) {
          var rel = nil, window2 = nil;
          if (attrs == null)
            attrs = [];
          if ($truthy(node["$option?"]("nofollow"))) {
            rel = "nofollow";
          }
          ;
          if ($truthy(window2 = node.$attributes()["$[]"]("window"))) {
            attrs["$<<"](' target="' + window2 + '"');
            if ($eqeq(window2, "_blank") || $truthy(node["$option?"]("noopener"))) {
              attrs["$<<"]($truthy(rel) ? ' rel="' + rel + ' noopener"' : ' rel="noopener"');
            }
            ;
          } else if ($truthy(rel)) {
            attrs["$<<"](' rel="' + rel + '"');
          }
          ;
          return attrs;
        }, -2);
        $def(self2, "$encode_attribute_value", function $$encode_attribute_value(val) {
          if ($truthy(val["$include?"]('"'))) {
            return val.$gsub('"', "&quot;");
          } else {
            return val;
          }
        });
        $def(self2, "$generate_manname_section", function $$generate_manname_section(node) {
          var manname_title = nil, next_section_title = nil, next_section = nil, manname_id_attr = nil, manname_id = nil;
          manname_title = node.$attr("manname-title", "Name");
          if ($truthy(next_section = node.$sections()["$[]"](0)) && $eqeq(next_section_title = next_section.$title(), next_section_title.$upcase())) {
            manname_title = manname_title.$upcase();
          }
          ;
          manname_id_attr = $truthy(manname_id = node.$attr("manname-id")) ? ' id="' + manname_id + '"' : "";
          return "<h2" + manname_id_attr + ">" + manname_title + '</h2>\n<div class="sectionbody">\n<p>' + node.$attr("mannames").$join(", ") + " - " + node.$attr("manpurpose") + "</p>\n</div>";
        });
        $def(self2, "$get_root_document", function $$get_root_document(node) {
          while ($truthy((node = node.$document())["$nested?"]())) {
            node = node.$parent_document();
          }
          ;
          return node;
        });
        $def(self2, "$method_missing", function $$method_missing(id, $a) {
          var $post_args, args, $yield = $$method_missing.$$p || nil, self3 = this, name = nil;
          $$method_missing.$$p = null;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($not((name = id.$to_s())["$start_with?"]("convert_")) && $truthy(self3["$handles?"](name))) {
            return $send(self3, "send", ["convert_" + name].concat($to_a(args)));
          } else {
            return $send2(self3, $find_super(self3, "method_missing", $$method_missing, false, true), "method_missing", [id].concat($to_a(args)), $yield);
          }
          ;
        }, -2);
        return $def(self2, "$respond_to_missing?", function $Html5Converter_respond_to_missing$ques$21(id, $a) {
          var $post_args, options, self3 = this, $ret_or_1 = nil, name = nil;
          $post_args = $slice(arguments, 1);
          options = $post_args;
          if ($truthy($ret_or_1 = (name = id.$to_s())["$start_with?"]("convert_")["$!"]())) {
            return self3["$handles?"](name);
          } else {
            return $ret_or_1;
          }
          ;
        }, -2);
      }($$("Converter"), $$$($$("Converter"), "Base"), $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/extensions"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $def = Opal2.def, $send = Opal2.send, $alias = Opal2.alias, $slice = Opal2.slice, $rb_plus = Opal2.rb_plus, $eqeq = Opal2.eqeq, $rb_gt = Opal2.rb_gt, $not = Opal2.not, $eqeqeq = Opal2.eqeqeq, $to_a = Opal2.to_a, $to_ary = Opal2.to_ary, $const_set = Opal2.const_set, $return_val = Opal2.return_val, $send2 = Opal2.send2, $find_super = Opal2.find_super, $NilClass = Opal2.NilClass, $class_variable_set = Opal2.class_variable_set, $class_variable_get = Opal2.class_variable_get, $regexp = Opal2.regexp, $Class = Opal2.Class, $return_ivar = Opal2.return_ivar, $rb_lt = Opal2.rb_lt, $rb_minus = Opal2.rb_minus, $hash = Opal2.hash, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("[]=,config,const_defined?,singleton_class?,include,const_get,extend,enable_dsl,attr_reader,merge,class,update,raise,document,==,doctype,[],+,level,delete,>,casecmp,new,title=,sectname=,special=,fetch,numbered=,attr?,!,key?,special,numbered,id=,generate_id,title,update_attributes,tr,basename,create_block,assign_caption,===,parse_blocks,empty?,include?,sub_attributes,parse,each,define_method,unshift,shift,send,size,receiver,binding,define_singleton_method,instance_exec,to_proc,call,option,content_model,flatten,positional_attributes,default_attributes,respond_to?,to_s,partition,to_i,<<,compact,inspect,resolve_attributes,attr_accessor,to_set,contexts,match?,resolve_regexp,format,method,register,reset,values,groups,arity,activate,add_document_processor,tree_processor,tree_processors?,tree_processors,any?,select,add_syntax_processor,to_sym,instance_variable_get,kind,private,join,map,split,capitalize,instance_variable_set,resolve_args,singleton_class,process_block_given?,source_location,freeze,resolve_class,<,update_config,as_symbol,name,name=,pop,-,-@,next_auto_id,generate_name,each_with_object");
    nil;
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "Extensions");
        var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Processor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.config = nil;
          (function(self4, $parent_nesting4) {
            $def(self4, "$config", function $$config() {
              var self5 = this, $ret_or_1 = nil;
              if (self5.config == null)
                self5.config = nil;
              return self5.config = $truthy($ret_or_1 = self5.config) ? $ret_or_1 : $hash2([], {});
            });
            $def(self4, "$option", function $$option(key, default_value) {
              var $a, self5 = this;
              return $a = [key, default_value], $send(self5.$config(), "[]=", $a), $a[$a.length - 1];
            });
            $def(self4, "$enable_dsl", function $$enable_dsl() {
              var self5 = this;
              if ($truthy(self5["$const_defined?"]("DSL"))) {
                if ($truthy(self5["$singleton_class?"]())) {
                  return self5.$include(self5.$const_get("DSL"));
                } else {
                  return self5.$extend(self5.$const_get("DSL"));
                }
              } else {
                return nil;
              }
            });
            return $alias(self4, "use_dsl", "enable_dsl");
          })(Opal2.get_singleton_class(self3), $nesting4);
          self3.$attr_reader("config");
          $def(self3, "$initialize", function $$initialize(config) {
            var self4 = this;
            if (config == null)
              config = $hash2([], {});
            return self4.config = self4.$class().$config().$merge(config);
          }, -1);
          $def(self3, "$update_config", function $$update_config(config) {
            var self4 = this;
            return self4.config.$update(config);
          });
          $def(self3, "$process", function $$process($a) {
            var $post_args, args, self4 = this;
            $post_args = $slice(arguments);
            args = $post_args;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("Processor") + " subclass " + self4.$class() + " must implement the #process method");
          }, -1);
          $def(self3, "$create_section", function $$create_section(parent, title, attrs, opts) {
            var $a, $b, doc = nil, book = nil, doctype = nil, level = nil, $ret_or_1 = nil, style = nil, sectname = nil, special = nil, sect = nil, id = nil;
            if (opts == null)
              opts = $hash2([], {});
            doc = parent.$document();
            book = (doctype = doc.$doctype())["$=="]("book");
            level = $truthy($ret_or_1 = opts["$[]"]("level")) ? $ret_or_1 : $rb_plus(parent.$level(), 1);
            if ($truthy(style = attrs.$delete("style"))) {
              if ($truthy(book) && $eqeq(style, "abstract")) {
                $a = ["chapter", 1], sectname = $a[0], level = $a[1], $a;
              } else {
                $a = [style, true], sectname = $a[0], special = $a[1], $a;
                if ($eqeq(level, 0)) {
                  level = 1;
                }
                ;
              }
            } else if ($truthy(book)) {
              sectname = $eqeq(level, 0) ? "part" : $truthy($rb_gt(level, 1)) ? "section" : "chapter";
            } else if ($eqeq(doctype, "manpage") && $eqeq(title.$casecmp("synopsis"), 0)) {
              $a = ["synopsis", true], sectname = $a[0], special = $a[1], $a;
            } else {
              sectname = "section";
            }
            ;
            sect = $$2("Section").$new(parent, level);
            $a = [title, sectname], $b = [$a[0]], $send(sect, "title=", $b), $b[$b.length - 1], $b = [$a[1]], $send(sect, "sectname=", $b), $b[$b.length - 1], $a;
            if ($truthy(special)) {
              sect["$special="](true);
              if ($truthy(opts.$fetch("numbered", style["$=="]("appendix")))) {
                sect["$numbered="](true);
              } else if ($not(opts["$key?"]("numbered")) && $truthy(doc["$attr?"]("sectnums", "all"))) {
                sect["$numbered="]($truthy(book) && $eqeq(level, 1) ? "chapter" : true);
              }
              ;
            } else if ($truthy($rb_gt(level, 0))) {
              if ($truthy(opts.$fetch("numbered", doc["$attr?"]("sectnums")))) {
                sect["$numbered="]($truthy(sect.$special()) ? $truthy($ret_or_1 = parent.$numbered()) || $ret_or_1 : true);
              }
            } else if ($truthy(opts.$fetch("numbered", $truthy($ret_or_1 = book) ? doc["$attr?"]("partnums") : $ret_or_1))) {
              sect["$numbered="](true);
            }
            ;
            if ($eqeq(id = attrs["$[]"]("id"), false)) {
              attrs.$delete("id");
            } else {
              sect["$id="](($a = ["id", $truthy($ret_or_1 = id) ? $ret_or_1 : $truthy(doc["$attr?"]("sectids")) ? $$2("Section").$generate_id(sect.$title(), doc) : nil], $send(attrs, "[]=", $a), $a[$a.length - 1]));
            }
            ;
            sect.$update_attributes(attrs);
            return sect;
          }, -4);
          $def(self3, "$create_block", function $$create_block(parent, context, source, attrs, opts) {
            if (opts == null)
              opts = $hash2([], {});
            return $$2("Block").$new(parent, context, $hash2(["source", "attributes"], { "source": source, "attributes": attrs }).$merge(opts));
          }, -5);
          $def(self3, "$create_list", function $$create_list(parent, context, attrs) {
            var list = nil;
            if (attrs == null)
              attrs = nil;
            list = $$2("List").$new(parent, context);
            if ($truthy(attrs)) {
              list.$update_attributes(attrs);
            }
            ;
            return list;
          }, -3);
          $def(self3, "$create_list_item", function $$create_list_item(parent, text) {
            if (text == null)
              text = nil;
            return $$2("ListItem").$new(parent, text);
          }, -2);
          $def(self3, "$create_image_block", function $$create_image_block(parent, attrs, opts) {
            var $a, self4 = this, target = nil, $ret_or_1 = nil, title = nil, block = nil;
            if (opts == null)
              opts = $hash2([], {});
            if (!$truthy(target = attrs["$[]"]("target"))) {
              self4.$raise($$$("ArgumentError"), "Unable to create an image block, target attribute is required");
            }
            ;
            if ($truthy($ret_or_1 = attrs["$[]"]("alt"))) {
              $ret_or_1;
            } else {
              attrs["$[]="]("alt", ($a = ["default-alt", $$2("Helpers").$basename(target, true).$tr("_-", " ")], $send(attrs, "[]=", $a), $a[$a.length - 1]));
            }
            ;
            title = $truthy(attrs["$key?"]("title")) ? attrs.$delete("title") : nil;
            block = self4.$create_block(parent, "image", nil, attrs, opts);
            if ($truthy(title)) {
              block["$title="](title);
              block.$assign_caption(attrs.$delete("caption"), "figure");
            }
            ;
            return block;
          }, -3);
          $def(self3, "$create_inline", function $$create_inline(parent, context, text, opts) {
            if (opts == null)
              opts = $hash2([], {});
            return $$2("Inline").$new(parent, context, text, $eqeq(context, "quoted") ? $hash2(["type"], { "type": "unquoted" }).$merge(opts) : opts);
          }, -4);
          $def(self3, "$parse_content", function $$parse_content(parent, content, attributes) {
            var reader = nil;
            if (attributes == null)
              attributes = nil;
            reader = $eqeqeq($$2("Reader"), content) ? content : $$2("Reader").$new(content);
            $$2("Parser").$parse_blocks(reader, parent, attributes);
            return parent;
          }, -3);
          $def(self3, "$parse_attributes", function $$parse_attributes(block, attrlist, opts) {
            var $ret_or_1 = nil;
            if (opts == null)
              opts = $hash2([], {});
            if ($truthy($truthy(attrlist) ? attrlist["$empty?"]() : true)) {
              return $hash2([], {});
            }
            ;
            if ($truthy(opts["$[]"]("sub_attributes")) && $truthy(attrlist["$include?"]($$2("ATTR_REF_HEAD")))) {
              attrlist = block.$sub_attributes(attrlist);
            }
            ;
            return $$2("AttributeList").$new(attrlist).$parse($truthy($ret_or_1 = opts["$[]"]("positional_attributes")) ? $ret_or_1 : []);
          }, -3);
          return $send([["create_paragraph", "create_block", "paragraph"], ["create_open_block", "create_block", "open"], ["create_example_block", "create_block", "example"], ["create_pass_block", "create_block", "pass"], ["create_listing_block", "create_block", "listing"], ["create_literal_block", "create_block", "literal"], ["create_anchor", "create_inline", "anchor"], ["create_inline_pass", "create_inline", "quoted"]], "each", [], function $Processor$1(method_name, delegate_method_name, context) {
            var self4 = $Processor$1.$$s == null ? this : $Processor$1.$$s;
            if (method_name == null)
              method_name = nil;
            if (delegate_method_name == null)
              delegate_method_name = nil;
            if (context == null)
              context = nil;
            return $send(self4, "define_method", [method_name], function $$22($a) {
              var $post_args, args, self5 = $$22.$$s == null ? this : $$22.$$s;
              $post_args = $slice(arguments);
              args = $post_args;
              args.$unshift(args.$shift(), context);
              return $send(self5, "send", [delegate_method_name].concat($to_a(args)));
            }, { $$arity: -1, $$s: self4 });
          }, { $$s: self3 });
        })($nesting3[0], null, $nesting3);
        (function($base3) {
          var self3 = $module($base3, "ProcessorDsl");
          $def(self3, "$option", function $$option(key, value) {
            var $a, self4 = this;
            return $a = [key, value], $send(self4.$config(), "[]=", $a), $a[$a.length - 1];
          });
          $def(self3, "$process", function $$process($a) {
            var block = $$process.$$p || nil, $post_args, args, $b, self4 = this, context = nil;
            if (self4.process_block == null)
              self4.process_block = nil;
            $$process.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            if (block !== nil) {
              if (!$truthy(args["$empty?"]())) {
                self4.$raise($$$("ArgumentError"), "wrong number of arguments (given " + args.$size() + ", expected 0)");
              }
              ;
              if (!($truthy(block.$binding()) && $eqeq(self4, block.$binding().$receiver()))) {
                context = self4;
                $send(block, "define_singleton_method", ["call"], function $$3($b2) {
                  var $post_args2, m_args;
                  $post_args2 = $slice(arguments);
                  m_args = $post_args2;
                  return $send(context, "instance_exec", $to_a(m_args), block.$to_proc());
                }, -1);
              }
              ;
              return self4.process_block = block;
            } else if ($truthy(($b = self4["process_block"], $b != null && $b !== nil) ? "instance-variable" : nil)) {
              return $send(self4.process_block, "call", $to_a(args));
            } else {
              return self4.$raise($$$("NotImplementedError"), "" + self4.$class() + " #process method called before being registered");
            }
            ;
          }, -1);
          return $def(self3, "$process_block_given?", function $ProcessorDsl_process_block_given$ques$4() {
            var $a, self4 = this;
            return ($a = self4["process_block"], $a != null && $a !== nil) ? "instance-variable" : nil;
          });
        })($nesting3[0]);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "DocumentProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("ProcessorDsl"));
          return $def(self3, "$prefer", function $$prefer() {
            var self4 = this;
            return self4.$option("position", ">>");
          });
        })($nesting3[0], $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "SyntaxProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("ProcessorDsl"));
          $def(self3, "$named", function $$named(value) {
            var self4 = this;
            if ($eqeqeq($$2("Processor"), self4)) {
              return self4.name = value;
            } else {
              return self4.$option("name", value);
            }
          });
          $def(self3, "$content_model", function $$content_model(value) {
            var self4 = this;
            return self4.$option("content_model", value);
          });
          $alias(self3, "parse_content_as", "content_model");
          $def(self3, "$positional_attributes", function $$positional_attributes($a) {
            var $post_args, value, self4 = this;
            $post_args = $slice(arguments);
            value = $post_args;
            return self4.$option("positional_attrs", value.$flatten());
          }, -1);
          $alias(self3, "name_positional_attributes", "positional_attributes");
          $alias(self3, "positional_attrs", "positional_attributes");
          $def(self3, "$default_attributes", function $$default_attributes(value) {
            var self4 = this;
            return self4.$option("default_attrs", value);
          });
          $alias(self3, "default_attrs", "default_attributes");
          $def(self3, "$resolve_attributes", function $$resolve_attributes($a) {
            var $post_args, args, $b, self4 = this, $ret_or_1 = nil, names = nil, defaults = nil;
            $post_args = $slice(arguments);
            args = $post_args;
            if (!$truthy($rb_gt(args.$size(), 1))) {
              if ($truthy((args = args.$fetch(0, true))["$respond_to?"]("to_sym"))) {
                args = [args];
              }
            }
            ;
            if ($eqeqeq(true, $ret_or_1 = args)) {
              self4.$option("positional_attrs", []);
              return self4.$option("default_attrs", $hash2([], {}));
            } else if ($eqeqeq($$$("Array"), $ret_or_1)) {
              $b = [[], $hash2([], {})], names = $b[0], defaults = $b[1], $b;
              $send(args, "each", [], function $$5(arg) {
                var $c, $d, name = nil, _ = nil, value = nil, idx = nil;
                if (arg == null)
                  arg = nil;
                if ($truthy((arg = arg.$to_s())["$include?"]("="))) {
                  $d = arg.$partition("="), $c = $to_ary($d), name = $c[0] == null ? nil : $c[0], _ = $c[1] == null ? nil : $c[1], value = $c[2] == null ? nil : $c[2], $d;
                  if ($truthy(name["$include?"](":"))) {
                    $d = name.$partition(":"), $c = $to_ary($d), idx = $c[0] == null ? nil : $c[0], _ = $c[1] == null ? nil : $c[1], name = $c[2] == null ? nil : $c[2], $d;
                    idx = $eqeq(idx, "@") ? names.$size() : idx.$to_i();
                    names["$[]="](idx, name);
                  }
                  ;
                  return $c = [name, value], $send(defaults, "[]=", $c), $c[$c.length - 1];
                } else if ($truthy(arg["$include?"](":"))) {
                  $d = arg.$partition(":"), $c = $to_ary($d), idx = $c[0] == null ? nil : $c[0], _ = $c[1] == null ? nil : $c[1], name = $c[2] == null ? nil : $c[2], $d;
                  idx = $eqeq(idx, "@") ? names.$size() : idx.$to_i();
                  return $c = [idx, name], $send(names, "[]=", $c), $c[$c.length - 1];
                } else {
                  return names["$<<"](arg);
                }
                ;
              });
              self4.$option("positional_attrs", names.$compact());
              return self4.$option("default_attrs", defaults);
            } else if ($eqeqeq($$$("Hash"), $ret_or_1)) {
              $b = [[], $hash2([], {})], names = $b[0], defaults = $b[1], $b;
              $send(args, "each", [], function $$6(key, val) {
                var $c, $d, name = nil, idx = nil, _ = nil;
                if (key == null)
                  key = nil;
                if (val == null)
                  val = nil;
                if ($truthy((name = key.$to_s())["$include?"](":"))) {
                  $d = name.$partition(":"), $c = $to_ary($d), idx = $c[0] == null ? nil : $c[0], _ = $c[1] == null ? nil : $c[1], name = $c[2] == null ? nil : $c[2], $d;
                  idx = $eqeq(idx, "@") ? names.$size() : idx.$to_i();
                  names["$[]="](idx, name);
                }
                ;
                if ($truthy(val)) {
                  return $c = [name, val], $send(defaults, "[]=", $c), $c[$c.length - 1];
                } else {
                  return nil;
                }
                ;
              });
              self4.$option("positional_attrs", names.$compact());
              return self4.$option("default_attrs", defaults);
            } else {
              return self4.$raise($$$("ArgumentError"), "unsupported attributes specification for macro: " + args.$inspect());
            }
            ;
          }, -1);
          return $alias(self3, "resolves_attributes", "resolve_attributes");
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Preprocessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          return $def(self3, "$process", function $$process(document2, reader) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("Preprocessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        $const_set($$("Preprocessor"), "DSL", $$("DocumentProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "TreeProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          return $def(self3, "$process", function $$process(document2) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("TreeProcessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        $const_set($$("TreeProcessor"), "DSL", $$("DocumentProcessorDsl"));
        $const_set($nesting3[0], "Treeprocessor", $$("TreeProcessor"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Postprocessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          return $def(self3, "$process", function $$process(document2, output) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("Postprocessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        $const_set($$("Postprocessor"), "DSL", $$("DocumentProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "IncludeProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $def(self3, "$process", function $$process(document2, reader, target, attributes) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("IncludeProcessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
          return $def(self3, "$handles?", $return_val(true));
        })($nesting3[0], $$("Processor"), $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "IncludeProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("DocumentProcessorDsl"));
          return $def(self3, "$handles?", function $IncludeProcessorDsl_handles$ques$7($a) {
            var block = $IncludeProcessorDsl_handles$ques$7.$$p || nil, $post_args, args, $b, self4 = this;
            if (self4.handles_block == null)
              self4.handles_block = nil;
            $IncludeProcessorDsl_handles$ques$7.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            if (block !== nil) {
              if (!$truthy(args["$empty?"]())) {
                self4.$raise($$$("ArgumentError"), "wrong number of arguments (given " + args.$size() + ", expected 0)");
              }
              ;
              return self4.handles_block = block;
            } else if ($truthy(($b = self4["handles_block"], $b != null && $b !== nil) ? "instance-variable" : nil)) {
              return self4.handles_block.$call(args["$[]"](0));
            } else {
              return true;
            }
            ;
          }, -1);
        })($nesting3[0], $nesting3);
        $const_set($$("IncludeProcessor"), "DSL", $$("IncludeProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "DocinfoProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.config = nil;
          $def(self3, "$initialize", function $$initialize(config) {
            var $a, $yield = $$initialize.$$p || nil, self4 = this, $ret_or_1 = nil;
            $$initialize.$$p = null;
            if (config == null)
              config = $hash2([], {});
            $send2(self4, $find_super(self4, "initialize", $$initialize, false, true), "initialize", [config], null);
            if ($truthy($ret_or_1 = self4.config["$[]"]("location"))) {
              return $ret_or_1;
            } else {
              return $a = ["location", "head"], $send(self4.config, "[]=", $a), $a[$a.length - 1];
            }
            ;
          }, -1);
          return $def(self3, "$process", function $$process(document2) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("DocinfoProcessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "DocinfoProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("DocumentProcessorDsl"));
          return $def(self3, "$at_location", function $$at_location(value) {
            var self4 = this;
            return self4.$option("location", value);
          });
        })($nesting3[0], $nesting3);
        $const_set($$("DocinfoProcessor"), "DSL", $$("DocinfoProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "BlockProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.config = nil;
          self3.$attr_accessor("name");
          $def(self3, "$initialize", function $$initialize(name, config) {
            var $a, $yield = $$initialize.$$p || nil, self4 = this, $ret_or_1 = nil, $ret_or_2 = nil;
            $$initialize.$$p = null;
            if (name == null)
              name = nil;
            if (config == null)
              config = $hash2([], {});
            $send2(self4, $find_super(self4, "initialize", $$initialize, false, true), "initialize", [config], null);
            self4.name = $truthy($ret_or_1 = name) ? $ret_or_1 : self4.config["$[]"]("name");
            if ($eqeqeq($NilClass, $ret_or_1 = self4.config["$[]"]("contexts"))) {
              if ($truthy($ret_or_2 = self4.config["$[]"]("contexts"))) {
                $ret_or_2;
              } else {
                self4.config["$[]="]("contexts", ["open", "paragraph"].$to_set());
              }
            } else if ($eqeqeq($$$("Symbol"), $ret_or_1)) {
              self4.config["$[]="]("contexts", [self4.config["$[]"]("contexts")].$to_set());
            } else {
              self4.config["$[]="]("contexts", self4.config["$[]"]("contexts").$to_set());
            }
            ;
            if ($truthy($ret_or_1 = self4.config["$[]"]("content_model"))) {
              return $ret_or_1;
            } else {
              return $a = ["content_model", "compound"], $send(self4.config, "[]=", $a), $a[$a.length - 1];
            }
            ;
          }, -1);
          return $def(self3, "$process", function $$process(parent, reader, attributes) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("BlockProcessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "BlockProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("SyntaxProcessorDsl"));
          $def(self3, "$contexts", function $$contexts($a) {
            var $post_args, value, self4 = this;
            $post_args = $slice(arguments);
            value = $post_args;
            return self4.$option("contexts", value.$flatten().$to_set());
          }, -1);
          $alias(self3, "on_contexts", "contexts");
          $alias(self3, "on_context", "contexts");
          return $alias(self3, "bind_to", "contexts");
        })($nesting3[0], $nesting3);
        $const_set($$("BlockProcessor"), "DSL", $$("BlockProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "MacroProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.config = nil;
          self3.$attr_accessor("name");
          $def(self3, "$initialize", function $$initialize(name, config) {
            var $a, $yield = $$initialize.$$p || nil, self4 = this, $ret_or_1 = nil;
            $$initialize.$$p = null;
            if (name == null)
              name = nil;
            if (config == null)
              config = $hash2([], {});
            $send2(self4, $find_super(self4, "initialize", $$initialize, false, true), "initialize", [config], null);
            self4.name = $truthy($ret_or_1 = name) ? $ret_or_1 : self4.config["$[]"]("name");
            if ($truthy($ret_or_1 = self4.config["$[]"]("content_model"))) {
              return $ret_or_1;
            } else {
              return $a = ["content_model", "attributes"], $send(self4.config, "[]=", $a), $a[$a.length - 1];
            }
            ;
          }, -1);
          return $def(self3, "$process", function $$process(parent, target, attributes) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"), "" + $$2("MacroProcessor") + " subclass " + self4.$class() + " must implement the #process method");
          });
        })($nesting3[0], $$("Processor"), $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "MacroProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("SyntaxProcessorDsl"));
          $def(self3, "$resolve_attributes", function $$resolve_attributes($a) {
            var $post_args, args, $yield = $$resolve_attributes.$$p || nil, self4 = this;
            $$resolve_attributes.$$p = null;
            $post_args = $slice(arguments);
            args = $post_args;
            if ($eqeq(args.$size(), 1) && $not(args["$[]"](0))) {
              return self4.$option("content_model", "text");
            } else {
              $send2(self4, $find_super(self4, "resolve_attributes", $$resolve_attributes, false, true), "resolve_attributes", $to_a(args), $yield);
              return self4.$option("content_model", "attributes");
            }
            ;
          }, -1);
          return $alias(self3, "resolves_attributes", "resolve_attributes");
        })($nesting3[0], $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "BlockMacroProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.name = nil;
          return $def(self3, "$name", function $$name() {
            var self4 = this;
            if (!$truthy($$2("MacroNameRx")["$match?"](self4.name.$to_s()))) {
              self4.$raise($$$("ArgumentError"), "invalid name for block macro: " + self4.name);
            }
            ;
            return self4.name;
          });
        })($nesting3[0], $$("MacroProcessor"), $nesting3);
        $const_set($$("BlockMacroProcessor"), "DSL", $$("MacroProcessorDsl"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "InlineMacroProcessor");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.config = $proto.name = nil;
          $class_variable_set($nesting4[0], "@@rx_cache", $hash2([], {}));
          $def(self3, "$regexp", function $$regexp() {
            var $a, self4 = this, $ret_or_1 = nil;
            if ($truthy($ret_or_1 = self4.config["$[]"]("regexp"))) {
              return $ret_or_1;
            } else {
              return $a = ["regexp", self4.$resolve_regexp(self4.name.$to_s(), self4.config["$[]"]("format"))], $send(self4.config, "[]=", $a), $a[$a.length - 1];
            }
          });
          return $def(self3, "$resolve_regexp", function $$resolve_regexp(name, format) {
            var $a, self4 = this, $ret_or_1 = nil;
            if (!$truthy($$2("MacroNameRx")["$match?"](name))) {
              self4.$raise($$$("ArgumentError"), "invalid name for inline macro: " + name);
            }
            ;
            if ($truthy($ret_or_1 = $class_variable_get($nesting4[0], "@@rx_cache", false)["$[]"]([name, format]))) {
              return $ret_or_1;
            } else {
              return $a = [[name, format], $regexp(["\\\\?", name, ":", $eqeq(format, "short") ? "(){0}" : "(\\S+?)", "\\[(|", $$2("CC_ANY"), "*?[^\\\\])\\]"])], $send($class_variable_get($nesting4[0], "@@rx_cache", false), "[]=", $a), $a[$a.length - 1];
            }
            ;
          });
        })($nesting3[0], $$("MacroProcessor"), $nesting3);
        (function($base3, $parent_nesting3) {
          var self3 = $module($base3, "InlineMacroProcessorDsl");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          self3.$include($$2("MacroProcessorDsl"));
          $def(self3, "$format", function $$format(value) {
            var self4 = this;
            return self4.$option("format", value);
          });
          $alias(self3, "match_format", "format");
          $alias(self3, "using_format", "format");
          return $def(self3, "$match", function $$match(value) {
            var self4 = this;
            return self4.$option("regexp", value);
          });
        })($nesting3[0], $nesting3);
        $const_set($$("InlineMacroProcessor"), "DSL", $$("InlineMacroProcessorDsl"));
        (function($base3, $super) {
          var self3 = $klass($base3, $super, "Extension");
          self3.$attr_reader("kind");
          self3.$attr_reader("config");
          self3.$attr_reader("instance");
          return $def(self3, "$initialize", function $$initialize(kind, instance, config) {
            var self4 = this;
            self4.kind = kind;
            self4.instance = instance;
            return self4.config = config;
          });
        })($nesting3[0], null);
        (function($base3, $super) {
          var self3 = $klass($base3, $super, "ProcessorExtension");
          self3.$attr_reader("process_method");
          return $def(self3, "$initialize", function $$initialize(kind, instance, process_method) {
            var $yield = $$initialize.$$p || nil, self4 = this, $ret_or_1 = nil;
            $$initialize.$$p = null;
            if (process_method == null)
              process_method = nil;
            $send2(self4, $find_super(self4, "initialize", $$initialize, false, true), "initialize", [kind, instance, instance.$config()], null);
            return self4.process_method = $truthy($ret_or_1 = process_method) ? $ret_or_1 : instance.$method("process");
          }, -3);
        })($nesting3[0], $$("Extension"));
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Group");
          var $nesting4 = [self3].concat($parent_nesting3);
          (function(self4, $parent_nesting4) {
            var $nesting5 = [self4].concat($parent_nesting4), $$2 = Opal2.$r($nesting5);
            return $def(self4, "$register", function $$register(name) {
              var self5 = this;
              if (name == null)
                name = nil;
              return $$2("Extensions").$register(name, self5);
            }, -1);
          })(Opal2.get_singleton_class(self3), $nesting4);
          return $def(self3, "$activate", function $$activate(registry) {
            var self4 = this;
            return self4.$raise($$$("NotImplementedError"));
          });
        })($nesting3[0], null, $nesting3);
        (function($base3, $super, $parent_nesting3) {
          var self3 = $klass($base3, $super, "Registry");
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4), $proto = self3.$$prototype;
          $proto.document = $proto.groups = $proto.preprocessor_extensions = $proto.tree_processor_extensions = $proto.postprocessor_extensions = $proto.include_processor_extensions = $proto.docinfo_processor_extensions = $proto.block_extensions = $proto.block_macro_extensions = $proto.inline_macro_extensions = nil;
          self3.$attr_reader("document");
          self3.$attr_reader("groups");
          $def(self3, "$initialize", function $$initialize(groups) {
            var self4 = this;
            if (groups == null)
              groups = $hash2([], {});
            self4.groups = groups;
            self4.$reset();
            self4.preprocessor_extensions = self4.tree_processor_extensions = self4.postprocessor_extensions = self4.include_processor_extensions = self4.docinfo_processor_extensions = self4.block_extensions = self4.block_macro_extensions = self4.inline_macro_extensions = nil;
            return self4.document = nil;
          }, -1);
          $def(self3, "$activate", function $$activate(document2) {
            var self4 = this, ext_groups = nil;
            if ($truthy(self4.document)) {
              self4.$reset();
            }
            ;
            self4.document = document2;
            if (!$truthy((ext_groups = $rb_plus($$2("Extensions").$groups().$values(), self4.groups.$values()))["$empty?"]())) {
              $send(ext_groups, "each", [], function $$8(group) {
                var self5 = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;
                if (group == null)
                  group = nil;
                if ($eqeqeq($$$("Proc"), $ret_or_1 = group)) {
                  switch (group.$arity()) {
                    case 0:
                    case -1:
                      return $send(self5, "instance_exec", [], group.$to_proc());
                    case 1:
                      return group.$call(self5);
                    default:
                      return nil;
                  }
                } else if ($eqeqeq($Class, $ret_or_1)) {
                  return group.$new().$activate(self5);
                } else {
                  return group.$activate(self5);
                }
                ;
              }, { $$s: self4 });
            }
            ;
            return self4;
          });
          $def(self3, "$preprocessor", function $$preprocessor($a) {
            var block = $$preprocessor.$$p || nil, $post_args, args, self4 = this;
            $$preprocessor.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_document_processor", ["preprocessor", args], block.$to_proc());
          }, -1);
          $def(self3, "$preprocessors?", function $Registry_preprocessors$ques$9() {
            var self4 = this;
            return self4.preprocessor_extensions["$!"]()["$!"]();
          });
          $def(self3, "$preprocessors", $return_ivar("preprocessor_extensions"));
          $def(self3, "$tree_processor", function $$tree_processor($a) {
            var block = $$tree_processor.$$p || nil, $post_args, args, self4 = this;
            $$tree_processor.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_document_processor", ["tree_processor", args], block.$to_proc());
          }, -1);
          $def(self3, "$tree_processors?", function $Registry_tree_processors$ques$10() {
            var self4 = this;
            return self4.tree_processor_extensions["$!"]()["$!"]();
          });
          $def(self3, "$tree_processors", $return_ivar("tree_processor_extensions"));
          $alias(self3, "treeprocessor", "tree_processor");
          $alias(self3, "treeprocessors?", "tree_processors?");
          $alias(self3, "treeprocessors", "tree_processors");
          $def(self3, "$postprocessor", function $$postprocessor($a) {
            var block = $$postprocessor.$$p || nil, $post_args, args, self4 = this;
            $$postprocessor.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_document_processor", ["postprocessor", args], block.$to_proc());
          }, -1);
          $def(self3, "$postprocessors?", function $Registry_postprocessors$ques$11() {
            var self4 = this;
            return self4.postprocessor_extensions["$!"]()["$!"]();
          });
          $def(self3, "$postprocessors", $return_ivar("postprocessor_extensions"));
          $def(self3, "$include_processor", function $$include_processor($a) {
            var block = $$include_processor.$$p || nil, $post_args, args, self4 = this;
            $$include_processor.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_document_processor", ["include_processor", args], block.$to_proc());
          }, -1);
          $def(self3, "$include_processors?", function $Registry_include_processors$ques$12() {
            var self4 = this;
            return self4.include_processor_extensions["$!"]()["$!"]();
          });
          $def(self3, "$include_processors", $return_ivar("include_processor_extensions"));
          $def(self3, "$docinfo_processor", function $$docinfo_processor($a) {
            var block = $$docinfo_processor.$$p || nil, $post_args, args, self4 = this;
            $$docinfo_processor.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_document_processor", ["docinfo_processor", args], block.$to_proc());
          }, -1);
          $def(self3, "$docinfo_processors?", function $Registry_docinfo_processors$ques$13(location) {
            var self4 = this;
            if (location == null)
              location = nil;
            if ($truthy(self4.docinfo_processor_extensions)) {
              if ($truthy(location)) {
                return $send(self4.docinfo_processor_extensions, "any?", [], function $$14(ext) {
                  if (ext == null)
                    ext = nil;
                  return ext.$config()["$[]"]("location")["$=="](location);
                });
              } else {
                return true;
              }
            } else {
              return false;
            }
            ;
          }, -1);
          $def(self3, "$docinfo_processors", function $$docinfo_processors(location) {
            var self4 = this;
            if (location == null)
              location = nil;
            if ($truthy(self4.docinfo_processor_extensions)) {
              if ($truthy(location)) {
                return $send(self4.docinfo_processor_extensions, "select", [], function $$15(ext) {
                  if (ext == null)
                    ext = nil;
                  return ext.$config()["$[]"]("location")["$=="](location);
                });
              } else {
                return self4.docinfo_processor_extensions;
              }
            } else {
              return nil;
            }
            ;
          }, -1);
          $def(self3, "$block", function $$block($a) {
            var block = $$block.$$p || nil, $post_args, args, self4 = this;
            $$block.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_syntax_processor", ["block", args], block.$to_proc());
          }, -1);
          $def(self3, "$blocks?", function $Registry_blocks$ques$16() {
            var self4 = this;
            return self4.block_extensions["$!"]()["$!"]();
          });
          $def(self3, "$registered_for_block?", function $Registry_registered_for_block$ques$17(name, context) {
            var self4 = this, ext = nil;
            if ($truthy(ext = self4.block_extensions["$[]"](name.$to_sym()))) {
              if ($truthy(ext.$config()["$[]"]("contexts")["$include?"](context))) {
                return ext;
              } else {
                return false;
              }
            } else {
              return false;
            }
          });
          $def(self3, "$find_block_extension", function $$find_block_extension(name) {
            var self4 = this;
            return self4.block_extensions["$[]"](name.$to_sym());
          });
          $def(self3, "$block_macro", function $$block_macro($a) {
            var block = $$block_macro.$$p || nil, $post_args, args, self4 = this;
            $$block_macro.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_syntax_processor", ["block_macro", args], block.$to_proc());
          }, -1);
          $def(self3, "$block_macros?", function $Registry_block_macros$ques$18() {
            var self4 = this;
            return self4.block_macro_extensions["$!"]()["$!"]();
          });
          $def(self3, "$registered_for_block_macro?", function $Registry_registered_for_block_macro$ques$19(name) {
            var self4 = this, ext = nil;
            if ($truthy(ext = self4.block_macro_extensions["$[]"](name.$to_sym()))) {
              return ext;
            } else {
              return false;
            }
          });
          $def(self3, "$find_block_macro_extension", function $$find_block_macro_extension(name) {
            var self4 = this;
            return self4.block_macro_extensions["$[]"](name.$to_sym());
          });
          $def(self3, "$inline_macro", function $$inline_macro($a) {
            var block = $$inline_macro.$$p || nil, $post_args, args, self4 = this;
            $$inline_macro.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self4, "add_syntax_processor", ["inline_macro", args], block.$to_proc());
          }, -1);
          $def(self3, "$inline_macros?", function $Registry_inline_macros$ques$20() {
            var self4 = this;
            return self4.inline_macro_extensions["$!"]()["$!"]();
          });
          $def(self3, "$registered_for_inline_macro?", function $Registry_registered_for_inline_macro$ques$21(name) {
            var self4 = this, ext = nil;
            if ($truthy(ext = self4.inline_macro_extensions["$[]"](name.$to_sym()))) {
              return ext;
            } else {
              return false;
            }
          });
          $def(self3, "$find_inline_macro_extension", function $$find_inline_macro_extension(name) {
            var self4 = this;
            return self4.inline_macro_extensions["$[]"](name.$to_sym());
          });
          $def(self3, "$inline_macros", function $$inline_macros() {
            var self4 = this;
            return self4.inline_macro_extensions.$values();
          });
          $def(self3, "$prefer", function $$prefer($a) {
            var block = $$prefer.$$p || nil, $post_args, args, self4 = this, extension = nil, arg0 = nil, extensions_store = nil;
            $$prefer.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            extension = $eqeqeq($$2("ProcessorExtension"), arg0 = args.$shift()) ? arg0 : $send(self4, "send", [arg0].concat($to_a(args)), block.$to_proc());
            extensions_store = self4.$instance_variable_get(("@" + extension.$kind() + "_extensions").$to_sym());
            extensions_store.$unshift(extensions_store.$delete(extension));
            return extension;
          }, -1);
          self3.$private();
          $def(self3, "$add_document_processor", function $$add_document_processor(kind, args) {
            var block = $$add_document_processor.$$p || nil, $a, $b, $c, self4 = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, $ret_or_1 = nil, config = nil, processor = nil, extension = nil, processor_class = nil, processor_instance = nil;
            $$add_document_processor.$$p = null;
            ;
            kind_name = kind.$to_s().$tr("_", " ");
            kind_class_symbol = $send(kind_name.$split(), "map", [], function $$22(it) {
              if (it == null)
                it = nil;
              return it.$capitalize();
            }).$join().$to_sym();
            kind_class = $$2("Extensions").$const_get(kind_class_symbol, false);
            kind_java_class = $truthy(($a = $$$("::", "AsciidoctorJ", "skip_raise")) ? "constant" : nil) ? $$$($$$("AsciidoctorJ"), "Extensions").$const_get(kind_class_symbol, false) : nil;
            kind_store = $truthy($ret_or_1 = self4.$instance_variable_get(("@" + kind + "_extensions").$to_sym())) ? $ret_or_1 : self4.$instance_variable_set(("@" + kind + "_extensions").$to_sym(), []);
            if (block !== nil) {
              config = self4.$resolve_args(args, 1);
              (processor = kind_class.$new(config)).$singleton_class().$enable_dsl();
              if ($eqeq(block.$arity(), 0)) {
                $send(processor, "instance_exec", [], block.$to_proc());
              } else {
                Opal2.yield1(block, processor);
              }
              ;
              if (!$truthy(processor["$process_block_given?"]())) {
                self4.$raise($$$("NoMethodError"), "No block specified to process " + kind_name + " extension at " + block.$source_location().$join(":"));
              }
              ;
              processor.$freeze();
              extension = $$2("ProcessorExtension").$new(kind, processor);
            } else {
              $c = self4.$resolve_args(args, 2), $b = $to_ary($c), processor = $b[0] == null ? nil : $b[0], config = $b[1] == null ? nil : $b[1], $c;
              if ($truthy(processor_class = $$2("Helpers").$resolve_class(processor))) {
                if (!($truthy($rb_lt(processor_class, kind_class)) || $truthy(kind_java_class) && $truthy($rb_lt(processor_class, kind_java_class)))) {
                  self4.$raise($$$("ArgumentError"), "Invalid type for " + kind_name + " extension: " + processor);
                }
                ;
                processor_instance = processor_class.$new(config);
                processor_instance.$freeze();
                extension = $$2("ProcessorExtension").$new(kind, processor_instance);
              } else if ($eqeqeq(kind_class, processor) || $truthy(kind_java_class) && $eqeqeq(kind_java_class, processor)) {
                processor.$update_config(config);
                processor.$freeze();
                extension = $$2("ProcessorExtension").$new(kind, processor);
              } else {
                self4.$raise($$$("ArgumentError"), "Invalid arguments specified for registering " + kind_name + " extension: " + args);
              }
              ;
            }
            ;
            if ($eqeq(extension.$config()["$[]"]("position"), ">>")) {
              kind_store.$unshift(extension);
            } else {
              kind_store["$<<"](extension);
            }
            ;
            return extension;
          });
          $def(self3, "$add_syntax_processor", function $$add_syntax_processor(kind, args) {
            var block = $$add_syntax_processor.$$p || nil, $a, $b, $c, self4 = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, $ret_or_1 = nil, name = nil, config = nil, processor = nil, processor_class = nil, processor_instance = nil;
            $$add_syntax_processor.$$p = null;
            ;
            kind_name = kind.$to_s().$tr("_", " ");
            kind_class_symbol = $send(kind_name.$split(), "map", [], function $$23(it) {
              if (it == null)
                it = nil;
              return it.$capitalize();
            })["$<<"]("Processor").$join().$to_sym();
            kind_class = $$2("Extensions").$const_get(kind_class_symbol, false);
            kind_java_class = $truthy(($a = $$$("::", "AsciidoctorJ", "skip_raise")) ? "constant" : nil) ? $$$($$$("AsciidoctorJ"), "Extensions").$const_get(kind_class_symbol, false) : nil;
            kind_store = $truthy($ret_or_1 = self4.$instance_variable_get(("@" + kind + "_extensions").$to_sym())) ? $ret_or_1 : self4.$instance_variable_set(("@" + kind + "_extensions").$to_sym(), $hash2([], {}));
            if (block !== nil) {
              $c = self4.$resolve_args(args, 2), $b = $to_ary($c), name = $b[0] == null ? nil : $b[0], config = $b[1] == null ? nil : $b[1], $c;
              (processor = kind_class.$new(self4.$as_symbol(name), config)).$singleton_class().$enable_dsl();
              if ($eqeq(block.$arity(), 0)) {
                $send(processor, "instance_exec", [], block.$to_proc());
              } else {
                Opal2.yield1(block, processor);
              }
              ;
              if (!$truthy(name = self4.$as_symbol(processor.$name()))) {
                self4.$raise($$$("ArgumentError"), "No name specified for " + kind_name + " extension at " + block.$source_location().$join(":"));
              }
              ;
              if (!$truthy(processor["$process_block_given?"]())) {
                self4.$raise($$$("NoMethodError"), "No block specified to process " + kind_name + " extension at " + block.$source_location().$join(":"));
              }
              ;
              processor.$freeze();
              return $b = [name, $$2("ProcessorExtension").$new(kind, processor)], $send(kind_store, "[]=", $b), $b[$b.length - 1];
            } else {
              $c = self4.$resolve_args(args, 3), $b = $to_ary($c), processor = $b[0] == null ? nil : $b[0], name = $b[1] == null ? nil : $b[1], config = $b[2] == null ? nil : $b[2], $c;
              if ($truthy(processor_class = $$2("Helpers").$resolve_class(processor))) {
                if (!($truthy($rb_lt(processor_class, kind_class)) || $truthy(kind_java_class) && $truthy($rb_lt(processor_class, kind_java_class)))) {
                  self4.$raise($$$("ArgumentError"), "Class specified for " + kind_name + " extension does not inherit from " + kind_class + ": " + processor);
                }
                ;
                processor_instance = processor_class.$new(self4.$as_symbol(name), config);
                if (!$truthy(name = self4.$as_symbol(processor_instance.$name()))) {
                  self4.$raise($$$("ArgumentError"), "No name specified for " + kind_name + " extension: " + processor);
                }
                ;
                processor_instance.$freeze();
                return $b = [name, $$2("ProcessorExtension").$new(kind, processor_instance)], $send(kind_store, "[]=", $b), $b[$b.length - 1];
              } else if ($eqeqeq(kind_class, processor) || $truthy(kind_java_class) && $eqeqeq(kind_java_class, processor)) {
                processor.$update_config(config);
                if (!$truthy(name = $truthy(name) ? ($b = [self4.$as_symbol(name)], $send(processor, "name=", $b), $b[$b.length - 1]) : self4.$as_symbol(processor.$name()))) {
                  self4.$raise($$$("ArgumentError"), "No name specified for " + kind_name + " extension: " + processor);
                }
                ;
                processor.$freeze();
                return $b = [name, $$2("ProcessorExtension").$new(kind, processor)], $send(kind_store, "[]=", $b), $b[$b.length - 1];
              } else {
                return self4.$raise($$$("ArgumentError"), "Invalid arguments specified for registering " + kind_name + " extension: " + args);
              }
              ;
            }
            ;
          });
          $def(self3, "$reset", function $$reset() {
            var self4 = this;
            self4.preprocessor_extensions = self4.tree_processor_extensions = self4.postprocessor_extensions = self4.include_processor_extensions = self4.docinfo_processor_extensions = self4.block_extensions = self4.block_macro_extensions = self4.inline_macro_extensions = nil;
            return self4.document = nil;
          });
          $def(self3, "$resolve_args", function $$resolve_args(args, expect) {
            var opts = nil, missing = nil;
            opts = $eqeqeq($$$("Hash"), args["$[]"](-1)) ? args.$pop() : $hash2([], {});
            if ($eqeq(expect, 1)) {
              return opts;
            }
            ;
            if ($truthy($rb_gt(missing = $rb_minus($rb_minus(expect, 1), args.$size()), 0))) {
              args = $rb_plus(args, $$$("Array").$new(missing));
            } else if ($truthy($rb_lt(missing, 0))) {
              args.$pop(missing["$-@"]());
            }
            ;
            args["$<<"](opts);
            return args;
          });
          return $def(self3, "$as_symbol", function $$as_symbol(name) {
            if ($truthy(name)) {
              return name.$to_sym();
            } else {
              return nil;
            }
          });
        })($nesting3[0], null, $nesting3);
        return function(self3, $parent_nesting3) {
          var $nesting4 = [self3].concat($parent_nesting3), $$2 = Opal2.$r($nesting4);
          $def(self3, "$generate_name", function $$generate_name() {
            var self4 = this;
            return "extgrp" + self4.$next_auto_id();
          });
          $def(self3, "$next_auto_id", function $$next_auto_id() {
            var self4 = this, $ret_or_1 = nil;
            if (self4.auto_id == null)
              self4.auto_id = nil;
            self4.auto_id = $truthy($ret_or_1 = self4.auto_id) ? $ret_or_1 : -1;
            return self4.auto_id = $rb_plus(self4.auto_id, 1);
          });
          $def(self3, "$groups", function $$groups() {
            var self4 = this, $ret_or_1 = nil;
            if (self4.groups == null)
              self4.groups = nil;
            return self4.groups = $truthy($ret_or_1 = self4.groups) ? $ret_or_1 : $hash2([], {});
          });
          $def(self3, "$create", function $$create(name) {
            var block = $$create.$$p || nil, self4 = this, $ret_or_1 = nil;
            $$create.$$p = null;
            ;
            if (name == null)
              name = nil;
            if (block !== nil) {
              return $$2("Registry").$new($hash($truthy($ret_or_1 = name) ? $ret_or_1 : self4.$generate_name(), block));
            } else {
              return $$2("Registry").$new();
            }
            ;
          }, -1);
          $def(self3, "$register", function $$register($a) {
            var block = $$register.$$p || nil, $post_args, args, $b, self4 = this, argc = nil, resolved_group = nil, group = nil, $ret_or_1 = nil, name = nil;
            $$register.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            argc = args.$size();
            if (block !== nil) {
              resolved_group = block;
            } else if ($truthy(group = args.$pop())) {
              resolved_group = $truthy($ret_or_1 = $$2("Helpers").$resolve_class(group)) ? $ret_or_1 : group;
            } else {
              self4.$raise($$$("ArgumentError"), "Extension group to register not specified");
            }
            ;
            name = $truthy($ret_or_1 = args.$pop()) ? $ret_or_1 : self4.$generate_name();
            if (!$truthy(args["$empty?"]())) {
              self4.$raise($$$("ArgumentError"), "Wrong number of arguments (" + argc + " for 1..2)");
            }
            ;
            return $b = [name.$to_sym(), resolved_group], $send(self4.$groups(), "[]=", $b), $b[$b.length - 1];
          }, -1);
          $def(self3, "$unregister_all", function $$unregister_all() {
            var self4 = this;
            self4.groups = $hash2([], {});
            return nil;
          });
          return $def(self3, "$unregister", function $$unregister($a) {
            var $post_args, names, self4 = this;
            $post_args = $slice(arguments);
            names = $post_args;
            $send(names, "each_with_object", [self4.$groups()], function $$24(group, catalog) {
              if (group == null)
                group = nil;
              if (catalog == null)
                catalog = nil;
              return catalog.$delete(group.$to_sym());
            });
            return nil;
          }, -1);
        }(Opal2.get_singleton_class(self2), $nesting3);
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/stylesheet"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $truthy = Opal2.truthy, $def = Opal2.def, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("rstrip,read,join");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "Stylesheets");
        var $proto = self2.$$prototype;
        $proto.primary_stylesheet_data = nil;
        return $def(self2, "$primary_stylesheet_data", function $$primary_stylesheet_data() {
          var self3 = this, $ret_or_1 = nil;
          return self3.primary_stylesheet_data = $truthy($ret_or_1 = self3.primary_stylesheet_data) ? $ret_or_1 : $$$("IO").$read($$$("File").$join("css", "asciidoctor.css")).$rstrip();
        });
      }($nesting2[0], null);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/document"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "Document");
        return $def(self2, "$fill_datetime_attributes", function $$fill_datetime_attributes(attrs, input_mtime) {
          var $truthy = Opal2.truthy;
          var $falsy = Opal2.falsy;
          var nil2 = Opal2.nil;
          var utc_offset;
          var source_date_epoch;
          var localdate;
          var localyear;
          var localtime;
          var localdatetime;
          var docdate;
          var doctime;
          var getYear = function(time, utc_offset2) {
            return utc_offset2 === 0 ? time.getUTCFullYear() : time.getFullYear();
          };
          var getMonth = function(time, utc_offset2) {
            return utc_offset2 === 0 ? time.getUTCMonth() : time.getMonth();
          };
          var getDay = function(time, utc_offset2) {
            return utc_offset2 === 0 ? time.getUTCDate() : time.getDate();
          };
          var getHours = function(time, utc_offset2) {
            return utc_offset2 === 0 ? time.getUTCHours() : time.getHours();
          };
          var now = new Date();
          if (Opal2.const_get_qualified("::", "ENV")["$key?"]("SOURCE_DATE_EPOCH")) {
            now.setTime(parseInt(Opal2.const_get_qualified("::", "ENV")["$[]"]("SOURCE_DATE_EPOCH")) * 1e3);
            source_date_epoch = now;
            utc_offset = 0;
          } else {
            utc_offset = -now.getTimezoneOffset() / 60;
          }
          if ($truthy(localdate = attrs["$[]"]("localdate"))) {
            if ($falsy(localyear = attrs["$[]"]("localyear"))) {
              localyear = localdate.indexOf("-") === 4 ? localdate.substring(0, 4) : nil2;
              attrs["$[]="]("localyear", localyear);
            }
          } else {
            var now_year = getYear(now, utc_offset).toString();
            var now_month = ("0" + (getMonth(now, utc_offset) + 1)).slice(-2);
            var now_day = ("0" + getDay(now, utc_offset)).slice(-2);
            localdate = now_year + "-" + now_month + "-" + now_day;
            attrs["$[]="]("localdate", localdate);
            localyear = now_year;
            attrs["$[]="]("localyear", now_year);
          }
          if ($falsy(localtime = attrs["$[]"]("localtime"))) {
            var hours = ("0" + getHours(now, utc_offset)).slice(-2);
            var minutes = ("0" + now.getMinutes()).slice(-2);
            var seconds = ("0" + now.getSeconds()).slice(-2);
            var utc_offset_format;
            if (utc_offset === 0) {
              utc_offset_format = "UTC";
            } else if (utc_offset > 0) {
              utc_offset_format = ("+0" + utc_offset * 100).slice(-5);
            } else {
              utc_offset_format = ("-0" + -utc_offset * 100).slice(-5);
            }
            localtime = hours + ":" + minutes + ":" + seconds + " " + utc_offset_format;
            attrs["$[]="]("localtime", localtime);
          }
          if ($falsy(localdatetime = attrs["$[]"]("localdatetime"))) {
            localdatetime = localdate + " " + localtime;
            attrs["$[]="]("localdatetime", localdatetime);
          }
          if ($truthy(source_date_epoch)) {
            input_mtime = source_date_epoch;
          } else if ($truthy(input_mtime)) {
            utc_offset = -input_mtime.getTimezoneOffset() / 60;
          } else {
            input_mtime = now;
          }
          if ($truthy(docdate = attrs["$[]"]("docdate"))) {
            attrs["$[]="]("docyear", docdate.indexOf("-") === 4 ? docdate.substring(0, 4) : nil2);
          } else {
            var mtime_year = getYear(input_mtime, utc_offset).toString();
            var mtime_month = ("0" + (getMonth(input_mtime, utc_offset) + 1)).slice(-2);
            var mtime_day = ("0" + getDay(input_mtime, utc_offset)).slice(-2);
            docdate = mtime_year + "-" + mtime_month + "-" + mtime_day;
            attrs["$[]="]("docdate", docdate);
            if ($falsy(attrs["$[]"]("docyear"))) {
              attrs["$[]="]("docyear", mtime_year);
            }
          }
          if ($falsy(doctime = attrs["$[]"]("doctime"))) {
            var mtime_hours = ("0" + getHours(input_mtime, utc_offset)).slice(-2);
            var mtime_minutes = ("0" + input_mtime.getMinutes()).slice(-2);
            var mtime_seconds = ("0" + input_mtime.getSeconds()).slice(-2);
            var utc_offset_format;
            if (utc_offset === 0) {
              utc_offset_format = "UTC";
            } else if (utc_offset > 0) {
              utc_offset_format = ("+0" + utc_offset * 100).slice(-5);
            } else {
              utc_offset_format = ("-0" + -utc_offset * 100).slice(-5);
            }
            doctime = mtime_hours + ":" + mtime_minutes + ":" + mtime_seconds + " " + utc_offset_format;
            attrs["$[]="]("doctime", doctime);
          }
          if ($falsy(attrs["$[]"]("docdatetime"))) {
            attrs["$[]="]("docdatetime", docdate + " " + doctime);
          }
          return nil2;
        });
      }($nesting2[0], $$("AbstractBlock"));
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/substitutors"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2) {
        var self2 = $module($base2, "Substitutors");
        return $def(self2, "$sub_placeholder", function $$sub_placeholder(format_string, replacement) {
          return format_string.replace("%s", replacement);
        });
      }($nesting2[0]);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/parser"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $klass = Opal2.klass, $truthy = Opal2.truthy, $defs = Opal2.defs, $nesting = [], nil = Opal2.nil;
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $super) {
        var self2 = $klass($base2, $super, "Parser");
        if ($truthy(String.prototype.repeat)) {
          return $defs(self2, "$uniform?", function $Parser_uniform$ques$1(str, chr, len) {
            return chr.repeat(len) === str;
          });
        } else {
          return $defs(self2, "$uniform?", function $Parser_uniform$ques$2(str, chr, len) {
            return Array.apply(null, { length: len }).map(function() {
              return chr;
            }).join("") === str;
          });
        }
      }($nesting2[0], null);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext/syntax_highlighter"] = function(Opal2) {
    "use strict";
    var $module = Opal2.module, $truthy = Opal2.truthy, $def = Opal2.def, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("key?,registry,[],include?,include,empty?,debug,logger,join,keys");
    return function($base, $parent_nesting) {
      var self = $module($base, "Asciidoctor");
      var $nesting2 = [self].concat($parent_nesting);
      return function($base2, $parent_nesting2) {
        var self2 = $module($base2, "SyntaxHighlighter");
        var $nesting3 = [self2].concat($parent_nesting2);
        return function($base3, $parent_nesting3) {
          var self3 = $module($base3, "Factory");
          var $nesting4 = [self3].concat($parent_nesting3), $$ = Opal2.$r($nesting4);
          return $def(self3, "$for", function $Factory_for$1(name) {
            var self4 = this;
            if ($truthy(self4.$registry()["$key?"](name))) {
              return self4.$registry()["$[]"](name);
            } else {
              if (!$truthy(self4["$include?"]($$("Logging")))) {
                self4.$include($$("Logging"));
              }
              ;
              if ($truthy(self4.$registry()["$empty?"]())) {
                self4.$logger().$debug("no syntax highlighter available, functionality disabled.");
              } else {
                self4.$logger().$debug("syntax highlighter named '" + name + "' is not available, must be one of: '" + self4.$registry().$keys().$join("', '") + "'.");
              }
              ;
              return nil;
            }
          });
        }($nesting3[0], $nesting3);
      }($nesting2[0], $nesting2);
    }($nesting[0], $nesting);
  };
  Opal.modules["asciidoctor/js/asciidoctor_ext"] = function(Opal2) {
    "use strict";
    var self = Opal2.top, nil = Opal2.nil;
    Opal2.add_stubs("require");
    self.$require("asciidoctor/js/asciidoctor_ext/stylesheet");
    self.$require("asciidoctor/js/asciidoctor_ext/document");
    self.$require("asciidoctor/js/asciidoctor_ext/substitutors");
    self.$require("asciidoctor/js/asciidoctor_ext/parser");
    self.$require("asciidoctor/js/asciidoctor_ext/syntax_highlighter");
    self.$require("asciidoctor/js/asciidoctor_ext/browser");
    ;
  };
  Opal.modules["asciidoctor/js/opal_ext/logger"] = function(Opal2) {
    "use strict";
    var $klass = Opal2.klass, $def = Opal2.def, $truthy = Opal2.truthy, $rb_lt = Opal2.rb_lt, $nesting = [], nil = Opal2.nil;
    Opal2.add_stubs("chr,rjust,message_as_string,<,write,call,[]");
    return function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Logger");
      var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
      $proto.level = $proto.progname = $proto.pipe = $proto.formatter = nil;
      (function($base2, $super2) {
        var self2 = $klass($base2, $super2, "Formatter");
        return $def(self2, "$call", function $$call(severity, time, progname, msg) {
          var self3 = this, time_format = nil;
          time_format = time.getFullYear() + "-" + ("0" + (time.getMonth() + 1)).slice(-2) + "-" + ("0" + time.getDate()).slice(-2) + "T" + ("0" + time.getHours()).slice(-2) + ":" + ("0" + time.getMinutes()).slice(-2) + ":" + ("0" + time.getSeconds()).slice(-2) + "." + ("00" + new Date().getMilliseconds() * 1e3).slice(-6);
          return "" + severity.$chr() + ", [" + time_format + "] " + severity.$rjust(5) + " -- " + progname + ": " + self3.$message_as_string(msg);
        });
      })($nesting2[0], null);
      return $def(self, "$add", function $$add(severity, message, progname) {
        var block = $$add.$$p || nil, self2 = this, $ret_or_1 = nil;
        $$add.$$p = null;
        ;
        if (message == null)
          message = nil;
        if (progname == null)
          progname = nil;
        if ($truthy($rb_lt(severity = $truthy($ret_or_1 = severity) ? $ret_or_1 : $$("UNKNOWN"), self2.level))) {
          return true;
        }
        ;
        progname = $truthy($ret_or_1 = progname) ? $ret_or_1 : self2.progname;
        if (!$truthy(message)) {
          if (block !== nil) {
            message = Opal2.yieldX(block, []);
          } else {
            message = progname;
            progname = self2.progname;
          }
        }
        ;
        self2.pipe.$write(self2.formatter.$call($truthy($ret_or_1 = $$("SEVERITY_LABELS")["$[]"](severity)) ? $ret_or_1 : "ANY", new Date(), progname, message));
        return true;
      }, -2);
    }($nesting[0], null, $nesting);
  };
  Opal.modules["asciidoctor/js/postscript"] = function(Opal2) {
    "use strict";
    var self = Opal2.top, nil = Opal2.nil;
    Opal2.add_stubs("require");
    self.$require("asciidoctor/converter/composite");
    self.$require("asciidoctor/converter/html5");
    self.$require("asciidoctor/extensions");
    self.$require("asciidoctor/js/asciidoctor_ext");
    return self.$require("asciidoctor/js/opal_ext/logger");
  };
  Opal.queue(function(Opal2) {
    "use strict";
    var $module = Opal2.module, $const_set = Opal2.const_set, $send = Opal2.send, $to_ary = Opal2.to_ary, $defs = Opal2.defs, $def = Opal2.def, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $eqeq = Opal2.eqeq, $rb_minus = Opal2.rb_minus, $regexp = Opal2.regexp, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
    Opal2.add_stubs("require,==,to_h,sort,map,constants,const_get,downcase,to_s,<=>,upcase,[],values,new,attr_reader,instance_variable_set,send,singleton_class,<<,define,dirname,absolute_path,join,home,pwd,to_set,tap,each,chr,each_key,[]=,slice,length,-,merge,default=,drop,insert");
    self.$require("set");
    self.$require("asciidoctor/js");
    (function($base, $parent_nesting) {
      var self2 = $module($base, "Asciidoctor");
      var $a, $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2), $ret_or_1 = nil;
      $const_set($nesting2[0], "RUBY_ENGINE_OPAL", $const_set($nesting2[0], "RUBY_ENGINE", $$$("RUBY_ENGINE"))["$=="]("opal"));
      (function($base2, $parent_nesting2) {
        var self3 = $module($base2, "SafeMode");
        var $nesting3 = [self3].concat($parent_nesting2);
        $const_set($nesting3[0], "UNSAFE", 0);
        $const_set($nesting3[0], "SAFE", 1);
        $const_set($nesting3[0], "SERVER", 10);
        $const_set($nesting3[0], "SECURE", 20);
        self3.names_by_value = $send($send(self3.$constants(false), "map", [], function $SafeMode$1(sym) {
          var self4 = $SafeMode$1.$$s == null ? this : $SafeMode$1.$$s;
          if (sym == null)
            sym = nil;
          return [self4.$const_get(sym), sym.$to_s().$downcase()];
        }, { $$s: self3 }), "sort", [], function $SafeMode$2($mlhs_tmp1, $mlhs_tmp2) {
          var $a2, $b, a = nil, b = nil;
          if ($mlhs_tmp1 == null)
            $mlhs_tmp1 = nil;
          if ($mlhs_tmp2 == null)
            $mlhs_tmp2 = nil;
          $b = $mlhs_tmp1, $a2 = $to_ary($b), a = $a2[0] == null ? nil : $a2[0], $b;
          $b = $mlhs_tmp2, $a2 = $to_ary($b), b = $a2[0] == null ? nil : $a2[0], $b;
          return a["$<=>"](b);
        }, { $$has_top_level_mlhs_arg: true }).$to_h();
        $defs(self3, "$value_for_name", function $$value_for_name(name) {
          var self4 = this;
          return self4.$const_get(name.$upcase(), false);
        });
        $defs(self3, "$name_for_value", function $$name_for_value(value) {
          var self4 = this;
          if (self4.names_by_value == null)
            self4.names_by_value = nil;
          return self4.names_by_value["$[]"](value);
        });
        return $defs(self3, "$names", function $$names() {
          var self4 = this;
          if (self4.names_by_value == null)
            self4.names_by_value = nil;
          return self4.names_by_value.$values();
        });
      })($nesting2[0], $nesting2);
      (function($base2, $parent_nesting2) {
        var self3 = $module($base2, "Compliance");
        var $nesting3 = [self3].concat($parent_nesting2);
        self3.keys = $$$("Set").$new();
        (function(self4, $parent_nesting3) {
          self4.$attr_reader("keys");
          return $def(self4, "$define", function $$define(key, value) {
            var self5 = this;
            if (self5.keys == null)
              self5.keys = nil;
            self5.$instance_variable_set("@" + key, value);
            self5.$singleton_class().$send("attr_accessor", key);
            self5.keys["$<<"](key);
            return nil;
          });
        })(Opal2.get_singleton_class(self3), $nesting3);
        self3.$define("block_terminates_paragraph", true);
        self3.$define("strict_verbatim_paragraphs", true);
        self3.$define("underline_style_section_titles", true);
        self3.$define("unwrap_standalone_preamble", true);
        self3.$define("attribute_missing", "skip");
        self3.$define("attribute_undefined", "drop-line");
        self3.$define("shorthand_property_syntax", true);
        self3.$define("natural_xrefs", true);
        self3.$define("unique_id_start_index", 2);
        return self3.$define("markdown_syntax", true);
      })($nesting2[0], $nesting2);
      if (!$truthy(($a = $$("ROOT_DIR", "skip_raise")) ? "constant" : nil)) {
        $const_set($nesting2[0], "ROOT_DIR", $$$("File").$dirname($$$("File").$absolute_path(".")));
      }
      ;
      $const_set($nesting2[0], "LIB_DIR", $$$("File").$join($$("ROOT_DIR"), "lib"));
      $const_set($nesting2[0], "DATA_DIR", $$$("File").$join($$("ROOT_DIR"), "data"));
      $const_set($nesting2[0], "USER_HOME", function() {
        try {
          return $$$("Dir").$home();
        } catch ($err) {
          if (Opal2.rescue($err, [$$("StandardError")])) {
            try {
              if ($truthy($ret_or_1 = $$$("ENV")["$[]"]("HOME"))) {
                return $ret_or_1;
              } else {
                return $$$("Dir").$pwd();
              }
              ;
            } finally {
              Opal2.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }());
      $const_set($nesting2[0], "LF", "\n");
      $const_set($nesting2[0], "NULL", "\0");
      $const_set($nesting2[0], "TAB", "	");
      $const_set($nesting2[0], "MAX_INT", 9007199254740991);
      $const_set($nesting2[0], "UTF_8", $$$($$$("Encoding"), "UTF_8"));
      $const_set($nesting2[0], "BOM_BYTES_UTF_8", [239, 187, 191]);
      $const_set($nesting2[0], "BOM_BYTES_UTF_16LE", [255, 254]);
      $const_set($nesting2[0], "BOM_BYTES_UTF_16BE", [254, 255]);
      $const_set($nesting2[0], "FILE_READ_MODE", $truthy($$("RUBY_ENGINE_OPAL")) ? "r" : "rb:utf-8:utf-8");
      $const_set($nesting2[0], "URI_READ_MODE", $$("FILE_READ_MODE"));
      $const_set($nesting2[0], "FILE_WRITE_MODE", $truthy($$("RUBY_ENGINE_OPAL")) ? "w" : "w:utf-8");
      $const_set($nesting2[0], "DEFAULT_DOCTYPE", "article");
      $const_set($nesting2[0], "DEFAULT_BACKEND", "html5");
      $const_set($nesting2[0], "DEFAULT_STYLESHEET_KEYS", ["", "DEFAULT"].$to_set());
      $const_set($nesting2[0], "DEFAULT_STYLESHEET_NAME", "asciidoctor.css");
      $const_set($nesting2[0], "BACKEND_ALIASES", $hash2(["html", "docbook"], { "html": "html5", "docbook": "docbook5" }));
      $const_set($nesting2[0], "DEFAULT_PAGE_WIDTHS", $hash2(["docbook"], { "docbook": 425 }));
      $const_set($nesting2[0], "DEFAULT_EXTENSIONS", $hash2(["html", "docbook", "pdf", "epub", "manpage", "asciidoc"], { "html": ".html", "docbook": ".xml", "pdf": ".pdf", "epub": ".epub", "manpage": ".man", "asciidoc": ".adoc" }));
      $const_set($nesting2[0], "ASCIIDOC_EXTENSIONS", $hash2([".adoc", ".asciidoc", ".asc", ".ad", ".txt"], { ".adoc": true, ".asciidoc": true, ".asc": true, ".ad": true, ".txt": true }));
      $const_set($nesting2[0], "SETEXT_SECTION_LEVELS", $hash2(["=", "-", "~", "^", "+"], { "=": 0, "-": 1, "~": 2, "^": 3, "+": 4 }));
      $const_set($nesting2[0], "ADMONITION_STYLES", ["NOTE", "TIP", "IMPORTANT", "WARNING", "CAUTION"].$to_set());
      $const_set($nesting2[0], "ADMONITION_STYLE_HEADS", $send($$$("Set").$new(), "tap", [], function $Asciidoctor$3(accum) {
        if (accum == null)
          accum = nil;
        return $send($$("ADMONITION_STYLES"), "each", [], function $$4(s) {
          if (s == null)
            s = nil;
          return accum["$<<"](s.$chr());
        });
      }));
      $const_set($nesting2[0], "PARAGRAPH_STYLES", ["comment", "example", "literal", "listing", "normal", "open", "pass", "quote", "sidebar", "source", "verse", "abstract", "partintro"].$to_set());
      $const_set($nesting2[0], "VERBATIM_STYLES", ["literal", "listing", "source", "verse"].$to_set());
      $const_set($nesting2[0], "DELIMITED_BLOCKS", $hash2(["--", "----", "....", "====", "****", "____", "++++", "|===", ",===", ":===", "!===", "////", "```"], { "--": ["open", ["comment", "example", "literal", "listing", "pass", "quote", "sidebar", "source", "verse", "admonition", "abstract", "partintro"].$to_set()], "----": ["listing", ["literal", "source"].$to_set()], "....": ["literal", ["listing", "source"].$to_set()], "====": ["example", ["admonition"].$to_set()], "****": ["sidebar", $$$("Set").$new()], "____": ["quote", ["verse"].$to_set()], "++++": ["pass", ["stem", "latexmath", "asciimath"].$to_set()], "|===": ["table", $$$("Set").$new()], ",===": ["table", $$$("Set").$new()], ":===": ["table", $$$("Set").$new()], "!===": ["table", $$$("Set").$new()], "////": ["comment", $$$("Set").$new()], "```": ["fenced_code", $$$("Set").$new()] }));
      $const_set($nesting2[0], "DELIMITED_BLOCK_HEADS", $send($hash2([], {}), "tap", [], function $Asciidoctor$5(accum) {
        if (accum == null)
          accum = nil;
        return $send($$("DELIMITED_BLOCKS"), "each_key", [], function $$6(k) {
          var $b;
          if (k == null)
            k = nil;
          return $b = [k.$slice(0, 2), true], $send(accum, "[]=", $b), $b[$b.length - 1];
        });
      }));
      $const_set($nesting2[0], "DELIMITED_BLOCK_TAILS", $send($hash2([], {}), "tap", [], function $Asciidoctor$7(accum) {
        if (accum == null)
          accum = nil;
        return $send($$("DELIMITED_BLOCKS"), "each_key", [], function $$8(k) {
          var $b;
          if (k == null)
            k = nil;
          if ($eqeq(k.$length(), 4)) {
            return $b = [k, k["$[]"]($rb_minus(k.$length(), 1))], $send(accum, "[]=", $b), $b[$b.length - 1];
          } else {
            return nil;
          }
          ;
        });
      }));
      $const_set($nesting2[0], "CAPTION_ATTRIBUTE_NAMES", $hash2(["example", "figure", "listing", "table"], { "example": "example-caption", "figure": "figure-caption", "listing": "listing-caption", "table": "table-caption" }));
      $const_set($nesting2[0], "LAYOUT_BREAK_CHARS", $hash2(["'", "<"], { "'": "thematic_break", "<": "page_break" }));
      $const_set($nesting2[0], "MARKDOWN_THEMATIC_BREAK_CHARS", $hash2(["-", "*", "_"], { "-": "thematic_break", "*": "thematic_break", "_": "thematic_break" }));
      $const_set($nesting2[0], "HYBRID_LAYOUT_BREAK_CHARS", $$("LAYOUT_BREAK_CHARS").$merge($$("MARKDOWN_THEMATIC_BREAK_CHARS")));
      $const_set($nesting2[0], "NESTABLE_LIST_CONTEXTS", ["ulist", "olist", "dlist"]);
      $const_set($nesting2[0], "ORDERED_LIST_STYLES", ["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"]);
      $const_set($nesting2[0], "ORDERED_LIST_KEYWORDS", $hash2(["loweralpha", "lowerroman", "upperalpha", "upperroman"], { "loweralpha": "a", "lowerroman": "i", "upperalpha": "A", "upperroman": "I" }));
      $const_set($nesting2[0], "ATTR_REF_HEAD", "{");
      $const_set($nesting2[0], "LIST_CONTINUATION", "+");
      $const_set($nesting2[0], "HARD_LINE_BREAK", " +");
      $const_set($nesting2[0], "LINE_CONTINUATION", " \\");
      $const_set($nesting2[0], "LINE_CONTINUATION_LEGACY", " +");
      $const_set($nesting2[0], "BLOCK_MATH_DELIMITERS", $hash2(["asciimath", "latexmath"], { "asciimath": ["\\$", "\\$"], "latexmath": ["\\[", "\\]"] }));
      $const_set($nesting2[0], "INLINE_MATH_DELIMITERS", $hash2(["asciimath", "latexmath"], { "asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"] }));
      $const_set($nesting2[0], "STEM_TYPE_ALIASES", $hash2(["latexmath", "latex", "tex"], { "latexmath": "latexmath", "latex": "latexmath", "tex": "latexmath" }))["$default="]("asciimath");
      $const_set($nesting2[0], "FONT_AWESOME_VERSION", "4.7.0");
      $const_set($nesting2[0], "HIGHLIGHT_JS_VERSION", "9.18.3");
      $const_set($nesting2[0], "MATHJAX_VERSION", "2.7.9");
      $const_set($nesting2[0], "DEFAULT_ATTRIBUTES", $hash2(["appendix-caption", "appendix-refsig", "caution-caption", "chapter-refsig", "example-caption", "figure-caption", "important-caption", "last-update-label", "note-caption", "part-refsig", "prewrap", "sectids", "section-refsig", "table-caption", "tip-caption", "toc-placement", "toc-title", "untitled-label", "version-label", "warning-caption"], { "appendix-caption": "Appendix", "appendix-refsig": "Appendix", "caution-caption": "Caution", "chapter-refsig": "Chapter", "example-caption": "Example", "figure-caption": "Figure", "important-caption": "Important", "last-update-label": "Last updated", "note-caption": "Note", "part-refsig": "Part", "prewrap": "", "sectids": "", "section-refsig": "Section", "table-caption": "Table", "tip-caption": "Tip", "toc-placement": "auto", "toc-title": "Table of Contents", "untitled-label": "Untitled", "version-label": "Version", "warning-caption": "Warning" }));
      $const_set($nesting2[0], "FLEXIBLE_ATTRIBUTES", ["sectnums"]);
      $const_set($nesting2[0], "INTRINSIC_ATTRIBUTES", $hash2(["startsb", "endsb", "vbar", "caret", "asterisk", "tilde", "plus", "backslash", "backtick", "blank", "empty", "sp", "two-colons", "two-semicolons", "nbsp", "deg", "zwsp", "quot", "apos", "lsquo", "rsquo", "ldquo", "rdquo", "wj", "brvbar", "pp", "cpp", "amp", "lt", "gt"], { "startsb": "[", "endsb": "]", "vbar": "|", "caret": "^", "asterisk": "*", "tilde": "~", "plus": "&#43;", "backslash": "\\", "backtick": "`", "blank": "", "empty": "", "sp": " ", "two-colons": "::", "two-semicolons": ";;", "nbsp": "&#160;", "deg": "&#176;", "zwsp": "&#8203;", "quot": "&#34;", "apos": "&#39;", "lsquo": "&#8216;", "rsquo": "&#8217;", "ldquo": "&#8220;", "rdquo": "&#8221;", "wj": "&#8288;", "brvbar": "&#166;", "pp": "&#43;&#43;", "cpp": "C&#43;&#43;", "amp": "&", "lt": "<", "gt": ">" }));
      nil;
      $const_set($nesting2[0], "QUOTE_SUBS", $send($hash2([], {}), "tap", [], function $Asciidoctor$9(accum) {
        var normal = nil, compat = nil;
        if (accum == null)
          accum = nil;
        accum["$[]="](false, normal = [["strong", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?\\*\\*(", $$("CC_ALL"), "+?)\\*\\*"], "m")], ["strong", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?\\*(\\S|\\S", $$("CC_ALL"), "*?\\S)\\*(?!", $$("CG_WORD"), ")"], "m")], ["double", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ';:}])(?:\\[([^\\]]+)\\])?"`(\\S|\\S', $$("CC_ALL"), '*?\\S)`"(?!', $$("CG_WORD"), ")"], "m")], ["single", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:`}])(?:\\[([^\\]]+)\\])?'`(\\S|\\S", $$("CC_ALL"), "*?\\S)`'(?!", $$("CG_WORD"), ")"], "m")], ["monospaced", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?``(", $$("CC_ALL"), "+?)``"], "m")], ["monospaced", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:\"'`}])(?:\\[([^\\]]+)\\])?`(\\S|\\S", $$("CC_ALL"), "*?\\S)`(?![", $$("CC_WORD"), "\"'`])"], "m")], ["emphasis", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?__(", $$("CC_ALL"), "+?)__"], "m")], ["emphasis", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?_(\\S|\\S", $$("CC_ALL"), "*?\\S)_(?!", $$("CG_WORD"), ")"], "m")], ["mark", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?##(", $$("CC_ALL"), "+?)##"], "m")], ["mark", "constrained", $regexp(["(^|[^", $$("CC_WORD"), "&;:}])(?:\\[([^\\]]+)\\])?#(\\S|\\S", $$("CC_ALL"), "*?\\S)#(?!", $$("CG_WORD"), ")"], "m")], ["superscript", "unconstrained", /\\?(?:\[([^\]]+)\])?\^(\S+?)\^/], ["subscript", "unconstrained", /\\?(?:\[([^\]]+)\])?~(\S+?)~/]]);
        accum["$[]="](true, compat = normal.$drop(0));
        compat["$[]="](2, ["double", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?``(\\S|\\S", $$("CC_ALL"), "*?\\S)''(?!", $$("CG_WORD"), ")"], "m")]);
        compat["$[]="](3, ["single", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?`(\\S|\\S", $$("CC_ALL"), "*?\\S)'(?!", $$("CG_WORD"), ")"], "m")]);
        compat["$[]="](4, ["monospaced", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?\\+\\+(", $$("CC_ALL"), "+?)\\+\\+"], "m")]);
        compat["$[]="](5, ["monospaced", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?\\+(\\S|\\S", $$("CC_ALL"), "*?\\S)\\+(?!", $$("CG_WORD"), ")"], "m")]);
        return compat.$insert(3, ["emphasis", "constrained", $regexp(["(^|[^", $$("CC_WORD"), ";:}])(?:\\[([^\\]]+)\\])?'(\\S|\\S", $$("CC_ALL"), "*?\\S)'(?!", $$("CG_WORD"), ")"], "m")]);
      }));
      $const_set($nesting2[0], "REPLACEMENTS", [[/\\?\(C\)/, "&#169;", "none"], [/\\?\(R\)/, "&#174;", "none"], [/\\?\(TM\)/, "&#8482;", "none"], [/(?: |\n|^|\\)--(?: |\n|$)/, "&#8201;&#8212;&#8201;", "none"], [$regexp(["(", $$("CG_WORD"), ")\\\\?--(?=", $$("CG_WORD"), ")"]), "&#8212;&#8203;", "leading"], [/\\?\.\.\./, "&#8230;&#8203;", "none"], [/\\?`'/, "&#8217;", "none"], [$regexp(["(", $$("CG_ALNUM"), ")\\\\?'(?=", $$("CG_ALPHA"), ")"]), "&#8217;", "leading"], [/\\?-&gt;/, "&#8594;", "none"], [/\\?=&gt;/, "&#8658;", "none"], [/\\?&lt;-/, "&#8592;", "none"], [/\\?&lt;=/, "&#8656;", "none"], [/\\?(&)amp;((?:[a-zA-Z][a-zA-Z]+\d{0,2}|#\d\d\d{0,4}|#x[\da-fA-F][\da-fA-F][\da-fA-F]{0,3});)/, "", "bounding"]]);
      nil;
      return nil;
    })($nesting[0], $nesting);
    self.$require("asciidoctor.rb/../asciidoctor/core_ext");
    self.$require("asciidoctor.rb/../asciidoctor/helpers");
    self.$require("asciidoctor.rb/../asciidoctor/logging");
    self.$require("asciidoctor.rb/../asciidoctor/rx");
    self.$require("asciidoctor.rb/../asciidoctor/substitutors");
    self.$require("asciidoctor.rb/../asciidoctor/version");
    self.$require("asciidoctor.rb/../asciidoctor/abstract_node");
    self.$require("asciidoctor.rb/../asciidoctor/abstract_block");
    self.$require("asciidoctor.rb/../asciidoctor/attribute_list");
    self.$require("asciidoctor.rb/../asciidoctor/block");
    self.$require("asciidoctor.rb/../asciidoctor/callouts");
    self.$require("asciidoctor.rb/../asciidoctor/converter");
    self.$require("asciidoctor.rb/../asciidoctor/document");
    self.$require("asciidoctor.rb/../asciidoctor/inline");
    self.$require("asciidoctor.rb/../asciidoctor/list");
    self.$require("asciidoctor.rb/../asciidoctor/parser");
    self.$require("asciidoctor.rb/../asciidoctor/path_resolver");
    self.$require("asciidoctor.rb/../asciidoctor/reader");
    self.$require("asciidoctor.rb/../asciidoctor/section");
    self.$require("asciidoctor.rb/../asciidoctor/stylesheets");
    self.$require("asciidoctor.rb/../asciidoctor/table");
    self.$require("asciidoctor.rb/../asciidoctor/writer");
    self.$require("asciidoctor.rb/../asciidoctor/load");
    self.$require("asciidoctor.rb/../asciidoctor/convert");
    self.$require("asciidoctor.rb/../asciidoctor/syntax_highlighter");
    self.$require("asciidoctor.rb/../asciidoctor/timings");
    return self.$require("asciidoctor/js/postscript");
    ;
  });
  const toHash = function(object) {
    return object && !object.$$is_hash ? Opal.hash2(Object.keys(object), object) : object;
  };
  const fromHash = function(hash) {
    const object = {};
    if (hash) {
      const stringMap = hash.$$smap;
      for (const key in stringMap) {
        const value = stringMap[key];
        object[key] = value === Opal.nil ? void 0 : value;
      }
      const numericMap = hash.$$map;
      if (numericMap) {
        const positional = [];
        for (const key in numericMap) {
          const entry = numericMap[key];
          const value = entry.value;
          const index = entry.key - 1;
          positional[index] = value === Opal.nil ? void 0 : value;
        }
        if (positional.length > 0) {
          object.$positional = positional;
        }
      }
    }
    return object;
  };
  const fromHashKeys = function(hash) {
    const object = {};
    if (hash) {
      const data = hash.$$keys;
      for (const key in data) {
        const value = data[key].value;
        object[key.toString()] = value === Opal.nil ? void 0 : value;
      }
    }
    return object;
  };
  const prepareOptions = function(options) {
    options = toHash(options);
    if (options) {
      const converter = options["$[]"]("converter");
      if (converter && converter !== Opal.nil) {
        options["$[]="]("converter", bridgeConverter(converter));
      }
      const attrs = options["$[]"]("attributes");
      if (attrs && typeof attrs === "object" && attrs.constructor.name === "Object") {
        options = options.$dup();
        options["$[]="]("attributes", toHash(attrs));
      }
    }
    return options;
  };
  const bridgeConverter = function(converter) {
    const buildBackendTraitsFromObject = function(obj) {
      return Object.assign(
        {},
        obj.basebackend ? { basebackend: obj.basebackend } : {},
        obj.outfilesuffix ? { outfilesuffix: obj.outfilesuffix } : {},
        obj.filetype ? { filetype: obj.filetype } : {},
        obj.htmlsyntax ? { htmlsyntax: obj.htmlsyntax } : {},
        obj.supports_templates ? { supports_templates: obj.supports_templates } : {}
      );
    };
    const assignBackendTraitsToInstance = function(obj, instance) {
      if (obj.backend_traits) {
        instance.backend_traits = toHash(obj.backend_traits);
      } else if (obj.backendTraits) {
        instance.backend_traits = toHash(obj.backendTraits);
      } else if (obj.basebackend || obj.outfilesuffix || obj.filetype || obj.htmlsyntax || obj.supports_templates) {
        instance.backend_traits = toHash(buildBackendTraitsFromObject(obj));
      }
    };
    const bridgeHandlesMethodToInstance = function(obj, instance) {
      bridgeMethodToInstance(obj, instance, "$handles?", "handles", function() {
        return true;
      });
    };
    const bridgeComposedMethodToInstance = function(obj, instance) {
      bridgeMethodToInstance(obj, instance, "$composed", "composed");
    };
    const bridgeEqEqMethodToInstance = function(obj, instance) {
      bridgeMethodToInstance(obj, instance, "$==", "==", function(other) {
        return instance === other;
      });
    };
    const bridgeSendMethodToInstance = function(obj, instance) {
      bridgeMethodToInstance(obj, instance, "$send", "send", function(symbol) {
        const [, ...args] = Array.from(arguments);
        const func = instance["$" + symbol];
        if (func) {
          return func.apply(instance, args);
        }
        throw new Error(`undefined method \`${symbol}\` for \`${instance.toString()}\``);
      });
    };
    const bridgeMethodToInstance = function(obj, instance, methodName, functionName, defaultImplementation) {
      if (typeof obj[methodName] === "undefined") {
        if (typeof obj[functionName] === "function") {
          instance[methodName] = obj[functionName];
        } else if (defaultImplementation) {
          instance[methodName] = defaultImplementation;
        }
      }
    };
    const addRespondToMethod = function(instance) {
      if (typeof instance["$respond_to?"] !== "function") {
        instance["$respond_to?"] = function(name) {
          return typeof this[name] === "function";
        };
      }
    };
    if (typeof converter === "function") {
      const object = initializeClass(ConverterBase, converter.constructor.name, {
        initialize: function(backend, opts) {
          const self = this;
          const result = new converter(backend, opts);
          Object.assign(this, result);
          assignBackendTraitsToInstance(result, self);
          const propertyNames = Object.getOwnPropertyNames(converter.prototype);
          for (let i = 0; i < propertyNames.length; i++) {
            const propertyName = propertyNames[i];
            if (propertyName !== "constructor") {
              self[propertyName] = result[propertyName];
            }
          }
          if (typeof result.$convert === "undefined" && typeof result.convert === "function") {
            self.$convert = result.convert;
          }
          bridgeHandlesMethodToInstance(result, self);
          bridgeComposedMethodToInstance(result, self);
          addRespondToMethod(self);
          self.super(backend, opts);
        }
      });
      object.$extend(ConverterBackendTraits);
      return object;
    }
    if (typeof converter === "object") {
      if (typeof converter.$convert === "undefined" && typeof converter.convert === "function") {
        converter.$convert = converter.convert;
      }
      assignBackendTraitsToInstance(converter, converter);
      if (converter.backend_traits) {
        const converterBackendTraitsFunctionNames = [
          "basebackend",
          "filetype",
          "htmlsyntax",
          "outfilesuffix",
          "supports_templates",
          "supports_templates?",
          "init_backend_traits",
          "backend_traits"
        ];
        for (const functionName of converterBackendTraitsFunctionNames) {
          converter["$" + functionName] = ConverterBackendTraits.prototype["$" + functionName];
        }
        converter.$$meta = ConverterBackendTraits;
      }
      bridgeHandlesMethodToInstance(converter, converter);
      bridgeComposedMethodToInstance(converter, converter);
      bridgeEqEqMethodToInstance(converter, converter);
      bridgeSendMethodToInstance(converter, converter);
      addRespondToMethod(converter);
      return converter;
    }
    return converter;
  };
  function initializeClass(superClass, className, functions, defaultFunctions, argProxyFunctions) {
    const scope = Opal.klass(Opal.Object, superClass, className, function() {
    });
    let postConstructFunction;
    let initializeFunction;
    let constructorFunction;
    const defaultFunctionsOverridden = {};
    for (const functionName in functions) {
      if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
        (function(functionName2) {
          const userFunction = functions[functionName2];
          if (functionName2 === "postConstruct") {
            postConstructFunction = userFunction;
          } else if (functionName2 === "initialize") {
            initializeFunction = userFunction;
          } else if (functionName2 === "constructor") {
            constructorFunction = userFunction;
          } else {
            if (defaultFunctions && Object.prototype.hasOwnProperty.call(defaultFunctions, functionName2)) {
              defaultFunctionsOverridden[functionName2] = true;
            }
            let $function;
            Opal.def(scope, "$" + functionName2, $function = function() {
              let args;
              if (argProxyFunctions && Object.prototype.hasOwnProperty.call(argProxyFunctions, functionName2)) {
                args = argProxyFunctions[functionName2](arguments);
              } else {
                args = arguments;
              }
              const $block = $function.$$p;
              if ($block) {
                args[args.length] = function() {
                  return Opal.yield1($block);
                };
                args.length += 1;
                $function.$$p = null;
              }
              return userFunction.apply(this, args);
            });
          }
        })(functionName);
      }
    }
    let initialize;
    if (typeof constructorFunction === "function") {
      initialize = function() {
        const args = Array.from(arguments);
        for (let i = 0; i < args.length; i++) {
          if (typeof args[i] === "object" && "$$smap" in args[i]) {
            args[i] = fromHash(args[i]);
          }
        }
        args.unshift(null);
        const result = new (Function.prototype.bind.apply(constructorFunction, args))();
        Object.assign(this, result);
        if (typeof postConstructFunction === "function") {
          postConstructFunction.bind(this)();
        }
      };
    } else if (typeof initializeFunction === "function") {
      initialize = function() {
        const args = Array.from(arguments);
        for (let i = 0; i < args.length; i++) {
          if (typeof args[i] === "object" && "$$smap" in args[i]) {
            args[i] = fromHash(args[i]);
          }
        }
        initializeFunction.apply(this, args);
        if (typeof postConstructFunction === "function") {
          postConstructFunction.bind(this)();
        }
      };
    } else {
      initialize = function() {
        Opal.send(this, Opal.find_super_dispatcher(this, "initialize", initialize));
        if (typeof postConstructFunction === "function") {
          postConstructFunction.bind(this)();
        }
      };
    }
    Opal.def(scope, "$initialize", initialize);
    let $superFunction;
    Opal.def(scope, "super", $superFunction = function(func) {
      if (typeof func === "function") {
        Opal.send(this, Opal.find_super_dispatcher(this, func.name, func));
      } else {
        const argumentsList = Array.from(arguments);
        for (let i = 0; i < argumentsList.length; i++) {
          if (typeof argumentsList[i] === "object") {
            argumentsList[i] = toHash(argumentsList[i]);
          }
        }
        Opal.send(this, Opal.find_super_dispatcher(this, "initialize", initialize), argumentsList);
      }
    });
    for (const functionName in functions) {
      $superFunction[functionName] = function() {
        const argumentsList = Array.from(arguments);
        for (let i = 0; i < argumentsList.length; i++) {
          if (typeof argumentsList[i] === "object" && typeof argumentsList[i].constructor === "function" && argumentsList[i].constructor.name === "Object") {
            argumentsList[i] = toHash(argumentsList[i]);
          }
        }
        const self = scope.$$prototype;
        return Opal.send(self, Opal.find_super_dispatcher(self, functionName, self[`$${functionName}`]), argumentsList);
      };
    }
    if (defaultFunctions) {
      for (const defaultFunctionName in defaultFunctions) {
        if (Object.prototype.hasOwnProperty.call(defaultFunctions, defaultFunctionName) && !Object.prototype.hasOwnProperty.call(defaultFunctionsOverridden, defaultFunctionName)) {
          (function(defaultFunctionName2) {
            const defaultFunction = defaultFunctions[defaultFunctionName2];
            Opal.def(scope, "$" + defaultFunctionName2, function() {
              return defaultFunction.apply(this, arguments);
            });
          })(defaultFunctionName);
        }
      }
    }
    return scope;
  }
  const Asciidoctor2 = Opal.Asciidoctor.$$class;
  Asciidoctor2.prototype.getCoreVersion = function() {
    return this.$$const.VERSION;
  };
  Asciidoctor2.prototype.getRuntime = function() {
    return {
      ioModule: Opal.const_get_qualified("::", "JAVASCRIPT_IO_MODULE"),
      platform: Opal.const_get_qualified("::", "JAVASCRIPT_PLATFORM"),
      engine: Opal.const_get_qualified("::", "JAVASCRIPT_ENGINE"),
      framework: Opal.const_get_qualified("::", "JAVASCRIPT_FRAMEWORK")
    };
  };
  Asciidoctor2.prototype.convert = function(input, options) {
    if (typeof input === "object" && input.constructor.name === "Buffer") {
      input = input.toString("utf8");
    }
    const toFile = options && options.to_file;
    if (typeof toFile === "object" && toFile.constructor.name === "Writable" && typeof toFile.write === "function") {
      toFile["$respond_to?"] = (name) => name === "write";
      toFile.$object_id = () => "";
      toFile.$write = function(data) {
        this.write(data);
      };
    }
    const opts = prepareOptions(options);
    const result = this.$convert(input, opts);
    if (typeof toFile === "object" && toFile.constructor.name === "Writable" && typeof toFile.end === "function") {
      toFile.end();
    }
    return result === Opal.nil ? "" : result;
  };
  Asciidoctor2.prototype.convertFile = function(filename, options) {
    return this.$convert_file(filename, prepareOptions(options));
  };
  Asciidoctor2.prototype.load = function(input, options) {
    if (typeof input === "object" && input.constructor.name === "Buffer") {
      input = input.toString("utf8");
    }
    return this.$load(input, prepareOptions(options));
  };
  Asciidoctor2.prototype.loadFile = function(filename, options) {
    return this.$load_file(filename, prepareOptions(options));
  };
  const AbstractBlock = Opal.Asciidoctor.AbstractBlock;
  AbstractBlock.prototype.getContentModel = function() {
    const contentModel = this.content_model;
    return contentModel === Opal.nil ? void 0 : contentModel;
  };
  AbstractBlock.prototype.setContentModel = function(contentModel) {
    this.content_model = contentModel;
  };
  AbstractBlock.prototype.append = function(block) {
    this.$append(block);
    return this;
  };
  AbstractBlock.prototype.getTitle = function() {
    const title = this.$title();
    return title === Opal.nil ? void 0 : title;
  };
  AbstractBlock.prototype.setTitle = function(title) {
    title = typeof title === "undefined" ? Opal.nil : title;
    return this["$title="](title);
  };
  AbstractBlock.prototype.assignCaption = function(value, captionContext) {
    value = typeof value === "undefined" ? Opal.nil : value;
    captionContext = typeof captionContext === "undefined" ? null : captionContext;
    this.$assign_caption(value, captionContext);
  };
  AbstractBlock.prototype.getCaptionedTitle = function() {
    return this.$captioned_title();
  };
  AbstractBlock.prototype.getStyle = function() {
    const style = this.style;
    return style === Opal.nil ? void 0 : style;
  };
  AbstractBlock.prototype.setStyle = function(style) {
    this.style = style;
  };
  AbstractBlock.prototype.getSourceLocation = function() {
    const sourceLocation = this.source_location;
    if (sourceLocation === Opal.nil) {
      return void 0;
    }
    sourceLocation.getFile = function() {
      const file = this.file;
      return file === Opal.nil ? void 0 : file;
    };
    sourceLocation.getDirectory = function() {
      const dir = this.dir;
      return dir === Opal.nil ? void 0 : dir;
    };
    sourceLocation.getPath = function() {
      const path = this.path;
      return path === Opal.nil ? void 0 : path;
    };
    sourceLocation.getLineNumber = function() {
      const lineno = this.lineno;
      return lineno === Opal.nil ? void 0 : lineno;
    };
    return sourceLocation;
  };
  AbstractBlock.prototype.getCaption = function() {
    const caption = this.$caption();
    return caption === Opal.nil ? void 0 : caption;
  };
  AbstractBlock.prototype.setCaption = function(caption) {
    this.caption = typeof caption === "undefined" ? Opal.nil : caption;
  };
  AbstractBlock.prototype.getLevel = function() {
    const level = this.level;
    return level === Opal.nil ? void 0 : level;
  };
  AbstractBlock.prototype.getSubstitutions = function() {
    return this.subs;
  };
  AbstractBlock.prototype.hasSubstitution = function(substitution) {
    return this["$sub?"](substitution);
  };
  AbstractBlock.prototype.removeSubstitution = function(substitution) {
    this.$remove_sub(substitution);
  };
  AbstractBlock.prototype.hasBlocks = function() {
    return this.blocks.length > 0;
  };
  AbstractBlock.prototype.getBlocks = function() {
    return this.blocks;
  };
  AbstractBlock.prototype.getContent = function() {
    const content = this.$content();
    return content === Opal.nil ? void 0 : content;
  };
  AbstractBlock.prototype.convert = function() {
    return this.$convert();
  };
  AbstractBlock.prototype.findBy = function(selector, block) {
    if (typeof block === "undefined" && typeof selector === "function") {
      return Opal.send(this, "find_by", null, selector);
    } else if (typeof block === "function") {
      return Opal.send(this, "find_by", [toHash(selector)], block);
    } else {
      return this.$find_by(toHash(selector));
    }
  };
  AbstractBlock.prototype.getLineNumber = function() {
    const lineno = this.$lineno();
    return lineno === Opal.nil ? void 0 : lineno;
  };
  AbstractBlock.prototype.hasSections = function() {
    return this.next_section_index !== Opal.nil && this.next_section_index > 0;
  };
  AbstractBlock.prototype.getSections = function() {
    return this.$sections();
  };
  AbstractBlock.prototype.getNumeral = function() {
    const numeral = this.$numeral();
    return numeral === Opal.nil ? void 0 : numeral;
  };
  AbstractBlock.prototype.setNumeral = function(value) {
    this["$numeral="](value);
  };
  AbstractBlock.prototype.hasTitle = function() {
    return this["$title?"]();
  };
  AbstractBlock.prototype.getAlt = function() {
    return this.$alt();
  };
  const Section = Opal.Asciidoctor.Section;
  Section.create = function(parent, level, numbered, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return this.$new(parent, level, numbered, toHash(opts));
  };
  Section.prototype.setLevel = function(level) {
    this.level = level;
  };
  Section.prototype.getIndex = function() {
    return this.index;
  };
  Section.prototype.setIndex = function(index) {
    this.index = index;
  };
  Section.prototype.getSectionName = function() {
    const sectname = this.sectname;
    return sectname === Opal.nil ? void 0 : sectname;
  };
  Section.prototype.setSectionName = function(value) {
    this.sectname = value;
  };
  Section.prototype.getSectionNumeral = function() {
    return this.$sectnum();
  };
  Section.prototype.getSectionNumber = Section.prototype.getSectionNumeral;
  Section.prototype.isSpecial = function() {
    return this.special;
  };
  Section.prototype.setSpecial = function(value) {
    this.special = value;
  };
  Section.prototype.isNumbered = function() {
    return this.numbered;
  };
  Section.prototype.getCaption = function() {
    const value = this.caption;
    return value === Opal.nil ? void 0 : value;
  };
  Section.prototype.getName = function() {
    return this.getTitle();
  };
  const Block = Opal.Asciidoctor.Block;
  Block.create = function(parent, context, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return this.$new(parent, context, toHash(opts));
  };
  Block.prototype.getSource = function() {
    return this.$source();
  };
  Block.prototype.getSourceLines = function() {
    return this.lines;
  };
  const AbstractNode = Opal.Asciidoctor.AbstractNode;
  AbstractNode.prototype.applySubstitutions = function(text, subs) {
    return this.$apply_subs(text, subs);
  };
  AbstractNode.prototype.resolveSubstitutions = function(subs, type, defaults, subject) {
    if (typeof type === "undefined") {
      type = "block";
    }
    if (typeof defaults === "undefined") {
      defaults = Opal.nil;
    }
    if (typeof subject === "undefined") {
      subject = Opal.nil;
    }
    const value = this.$resolve_subs(subs, type, defaults, subject);
    return value === Opal.nil ? void 0 : value;
  };
  AbstractNode.prototype.resolveBlockSubstitutions = function(subs, defaults, subject) {
    return this.resolveSubstitutions(subs, "block", defaults, subject);
  };
  AbstractNode.prototype.resolvePassSubstitutions = function(subs) {
    return this.resolveSubstitutions(subs, "inline", void 0, "passthrough macro");
  };
  AbstractNode.prototype.getNodeName = function() {
    return this.node_name;
  };
  AbstractNode.prototype.getAttributes = function() {
    return fromHash(this.attributes);
  };
  AbstractNode.prototype.getAttribute = function(name, defaultValue, fallbackName) {
    const value = this.$attr(name, defaultValue, fallbackName);
    return value === Opal.nil ? void 0 : value;
  };
  AbstractNode.prototype.hasAttribute = function(name) {
    return name in this.attributes.$$smap;
  };
  AbstractNode.prototype.isAttribute = function(name, expectedValue, fallbackName) {
    return this["$attr?"](name, expectedValue, fallbackName);
  };
  AbstractNode.prototype.setAttribute = function(name, value, overwrite) {
    if (typeof overwrite === "undefined")
      overwrite = true;
    return this.$set_attr(name, value, overwrite);
  };
  AbstractNode.prototype.removeAttribute = function(name) {
    const value = this.$remove_attr(name);
    return value === Opal.nil ? void 0 : value;
  };
  AbstractNode.prototype.getDocument = function() {
    return this.document;
  };
  AbstractNode.prototype.getParent = function() {
    const parent = this.parent;
    return parent === Opal.nil ? void 0 : parent;
  };
  AbstractNode.prototype.isInline = function() {
    return this["$inline?"]();
  };
  AbstractNode.prototype.isBlock = function() {
    return this["$block?"]();
  };
  AbstractNode.prototype.isRole = function(expectedValue) {
    return this["$role?"](expectedValue);
  };
  AbstractNode.prototype.getRole = function() {
    const role = this.$role();
    return role === Opal.nil ? void 0 : role;
  };
  AbstractNode.prototype.setRole = function(names) {
    if (Array.isArray(names) || typeof names === "string" && arguments.length === 1) {
      return this["$role="](names);
    }
    return this["$role="](Array.from(arguments));
  };
  AbstractNode.prototype.hasRole = function(name) {
    return this["$has_role?"](name);
  };
  AbstractNode.prototype.getRoles = function() {
    return this.$roles();
  };
  AbstractNode.prototype.addRole = function(name) {
    return this.$add_role(name);
  };
  AbstractNode.prototype.removeRole = function(name) {
    return this.$remove_role(name);
  };
  AbstractNode.prototype.isReftext = function() {
    return this["$reftext?"]();
  };
  AbstractNode.prototype.getReftext = function() {
    const reftext = this.$reftext();
    return reftext === Opal.nil ? void 0 : reftext;
  };
  AbstractNode.prototype.getContext = function() {
    const context = this.context;
    return typeof context === "string" ? context : context.toString();
  };
  AbstractNode.prototype.getId = function() {
    const id = this.id;
    return id === Opal.nil ? void 0 : id;
  };
  AbstractNode.prototype.setId = function(id) {
    this.id = id;
  };
  AbstractNode.prototype.isOption = function(name) {
    return this["$option?"](name);
  };
  AbstractNode.prototype.setOption = function(name) {
    return this.$set_option(name);
  };
  AbstractNode.prototype.getIconUri = function(name) {
    return this.$icon_uri(name);
  };
  AbstractNode.prototype.getMediaUri = function(target, assetDirKey) {
    return this.$media_uri(target, assetDirKey);
  };
  AbstractNode.prototype.getImageUri = function(targetImage, assetDirKey) {
    return this.$image_uri(targetImage, assetDirKey);
  };
  AbstractNode.prototype.getConverter = function() {
    return this.$converter();
  };
  AbstractNode.prototype.readContents = function(target, options) {
    return this.$read_contents(target, toHash(options));
  };
  AbstractNode.prototype.readAsset = function(path, options) {
    const result = this.$read_asset(path, toHash(options));
    return result === Opal.nil ? void 0 : result;
  };
  AbstractNode.prototype.normalizeWebPath = function(target, start, preserveTargetUri) {
    return this.$normalize_web_path(target, start, preserveTargetUri);
  };
  AbstractNode.prototype.normalizeSystemPath = function(target, start, jail, options) {
    return this.$normalize_system_path(target, start, jail, toHash(options));
  };
  AbstractNode.prototype.normalizeAssetPath = function(assetRef, assetName, autoCorrect) {
    return this.$normalize_asset_path(assetRef, assetName, autoCorrect);
  };
  const Document = Opal.Asciidoctor.Document;
  Document.prototype.append = function(block) {
    this["$<<"](block);
    return this;
  };
  Document.prototype.getSyntaxHighlighter = function() {
    const syntaxHighlighter = this.syntax_highlighter;
    const prototype = syntaxHighlighter.__proto__;
    if (prototype) {
      if (typeof prototype["$highlight?"] === "function") {
        prototype.handlesHighlighting = function() {
          const value = prototype["$highlight?"]();
          return value === Opal.nil ? false : value;
        };
      }
      if (typeof prototype["$docinfo?"] === "function") {
        prototype.hasDocinfo = prototype["$docinfo?"];
      }
      if (typeof prototype.$format === "function") {
        prototype.format = function(node, lang, opts) {
          return this.$format(node, lang, toHash(opts));
        };
      }
      if (typeof prototype.$docinfo === "function") {
        prototype.docinfo = function(location, doc, opts) {
          return this.$docinfo(location, doc, toHash(opts));
        };
      }
    }
    return syntaxHighlighter;
  };
  Document.prototype.getRefs = function() {
    return fromHash(this.catalog.$$smap.refs);
  };
  Document.prototype.getImages = function() {
    return this.catalog.$$smap.images;
  };
  Document.prototype.getLinks = function() {
    return this.catalog.$$smap.links;
  };
  Document.prototype.hasFootnotes = function() {
    return this["$footnotes?"]();
  };
  Document.prototype.getFootnotes = function() {
    return this.$footnotes();
  };
  Document.prototype.getHeader = function() {
    return this.header;
  };
  Document.prototype.setAttribute = function(name, value) {
    return this.$set_attribute(name, value);
  };
  Document.prototype.removeAttribute = function(name) {
    this.attributes.$delete(name);
    this.attribute_overrides.$delete(name);
  };
  Document.prototype.convert = function(options) {
    const result = this.$convert(toHash(options));
    return result === Opal.nil ? "" : result;
  };
  Document.prototype.write = function(output, target) {
    return this.$write(output, target);
  };
  Document.prototype.getAuthor = function() {
    return this.$author();
  };
  Document.prototype.getSource = function() {
    return this.$source();
  };
  Document.prototype.getSourceLines = function() {
    return this.$source_lines();
  };
  Document.prototype.isNested = function() {
    return this["$nested?"]();
  };
  Document.prototype.isEmbedded = function() {
    return this["$embedded?"]();
  };
  Document.prototype.hasExtensions = function() {
    return this["$extensions?"]();
  };
  Document.prototype.getDoctype = function() {
    return this.doctype;
  };
  Document.prototype.getBackend = function() {
    return this.backend;
  };
  Document.prototype.isBasebackend = function(base) {
    return this["$basebackend?"](base);
  };
  Document.prototype.getTitle = function() {
    const title = this.$title();
    return title === Opal.nil ? void 0 : title;
  };
  Document.prototype.setTitle = function(title) {
    return this["$title="](title);
  };
  Document.prototype.getDocumentTitle = function(options) {
    const doctitle = this.$doctitle(toHash(options));
    return doctitle === Opal.nil ? void 0 : doctitle;
  };
  Document.prototype.getDoctitle = Document.prototype.getDocumentTitle;
  Document.prototype.getCatalog = function() {
    return fromHash(this.catalog);
  };
  Document.prototype.getReferences = Document.prototype.getCatalog;
  Document.prototype.getRevisionDate = function() {
    return this.getAttribute("revdate");
  };
  Document.prototype.getRevdate = function() {
    return this.getRevisionDate();
  };
  Document.prototype.getRevisionNumber = function() {
    return this.getAttribute("revnumber");
  };
  Document.prototype.getRevisionRemark = function() {
    return this.getAttribute("revremark");
  };
  Document.prototype.setHeaderAttribute = function(name, value, overwrite) {
    if (typeof overwrite === "undefined")
      overwrite = true;
    if (typeof value === "undefined")
      value = "";
    return this.$set_header_attribute(name, value, overwrite);
  };
  Document.prototype.getAuthors = function() {
    return this.$authors();
  };
  const Footnote = Document.Footnote;
  Footnote.prototype.getIndex = function() {
    const index = this.$$data.index;
    return index === Opal.nil ? void 0 : index;
  };
  Footnote.prototype.getId = function() {
    const id = this.$$data.id;
    return id === Opal.nil ? void 0 : id;
  };
  Footnote.prototype.getText = function() {
    const text = this.$$data.text;
    return text === Opal.nil ? void 0 : text;
  };
  const ImageReference = Document.ImageReference;
  ImageReference.prototype.getTarget = function() {
    return this.$$data.target;
  };
  ImageReference.prototype.getImagesDirectory = function() {
    const value = this.$$data.imagesdir;
    return value === Opal.nil ? void 0 : value;
  };
  const Author = Document.Author;
  Author.prototype.getName = function() {
    const name = this.$$data.name;
    return name === Opal.nil ? void 0 : name;
  };
  Author.prototype.getFirstName = function() {
    const firstName = this.$$data.firstname;
    return firstName === Opal.nil ? void 0 : firstName;
  };
  Author.prototype.getMiddleName = function() {
    const middleName = this.$$data.middlename;
    return middleName === Opal.nil ? void 0 : middleName;
  };
  Author.prototype.getLastName = function() {
    const lastName = this.$$data.lastname;
    return lastName === Opal.nil ? void 0 : lastName;
  };
  Author.prototype.getInitials = function() {
    const initials = this.$$data.initials;
    return initials === Opal.nil ? void 0 : initials;
  };
  Author.prototype.getEmail = function() {
    const email = this.$$data.email;
    return email === Opal.nil ? void 0 : email;
  };
  Document.RevisionInfo = function(date, number, remark) {
    this.date = date;
    this.number = number;
    this.remark = remark;
  };
  const RevisionInfo = Document.RevisionInfo;
  RevisionInfo.prototype.getDate = function() {
    return this.date;
  };
  RevisionInfo.prototype.getNumber = function() {
    return this.number;
  };
  RevisionInfo.prototype.getRemark = function() {
    return this.remark;
  };
  RevisionInfo.prototype.isEmpty = function() {
    return this.date === void 0 && this.number === void 0 && this.remark === void 0;
  };
  const SafeMode = Opal.Asciidoctor.SafeMode;
  SafeMode.getValueForName = function(name) {
    return this.$value_for_name(name);
  };
  SafeMode.getNameForValue = function(value) {
    const name = this.$name_for_value(value);
    return name === Opal.nil ? void 0 : name;
  };
  SafeMode.getNames = function() {
    return this.$names();
  };
  const Callouts = Opal.Asciidoctor.Callouts;
  Callouts.create = function() {
    return this.$new();
  };
  Callouts.prototype.register = function(ordinal) {
    return this.$register(ordinal);
  };
  Callouts.prototype.readNextId = function() {
    return this.$read_next_id();
  };
  Callouts.prototype.getCalloutIds = function(ordinal) {
    return this.$callout_ids(ordinal);
  };
  Callouts.prototype.getLists = function() {
    const lists = this.lists;
    if (lists && lists.length > 0) {
      for (let i = 0; i < lists.length; i++) {
        const list = lists[i];
        if (list && list.length > 0) {
          for (let j = 0; j < list.length; j++) {
            if (typeof list[j] === "object" && "$$smap" in list[j]) {
              list[j] = fromHash(list[j]);
            }
          }
        }
      }
    }
    return lists;
  };
  Callouts.prototype.getListIndex = function() {
    return this.list_index;
  };
  Callouts.prototype.getCurrentList = function() {
    const currentList = this.$current_list();
    if (currentList && currentList.length > 0) {
      for (let i = 0; i < currentList.length; i++) {
        if (typeof currentList[i] === "object" && "$$smap" in currentList[i]) {
          currentList[i] = fromHash(currentList[i]);
        }
      }
    }
    return currentList;
  };
  Callouts.prototype.nextList = function() {
    return this.$nextList();
  };
  Callouts.prototype.rewind = function() {
    return this.$rewind();
  };
  Document.prototype.getRevisionInfo = function() {
    return new Document.RevisionInfo(this.getRevisionDate(), this.getRevisionNumber(), this.getRevisionRemark());
  };
  Document.prototype.hasRevisionInfo = function() {
    const revisionInfo = this.getRevisionInfo();
    return !revisionInfo.isEmpty();
  };
  Document.prototype.getNotitle = function() {
    return this.$notitle();
  };
  Document.prototype.getNoheader = function() {
    return this.$noheader();
  };
  Document.prototype.getNofooter = function() {
    return this.$nofooter();
  };
  Document.prototype.hasHeader = function() {
    return this["$header?"]();
  };
  Document.prototype.playbackAttributes = function(blockAttributes) {
    blockAttributes = toHash(blockAttributes);
    if (blockAttributes) {
      const attrEntries = blockAttributes["$[]"]("attribute_entries");
      if (attrEntries && Array.isArray(attrEntries)) {
        const result = [];
        for (let i = 0; i < attrEntries.length; i++) {
          const attrEntryObject = attrEntries[i];
          if (attrEntryObject && typeof attrEntryObject === "object" && attrEntryObject.constructor.name === "Object") {
            attrEntryObject.$name = function() {
              return this.name;
            };
            attrEntryObject.$value = function() {
              return this.value;
            };
            attrEntryObject.$negate = function() {
              return this.negate;
            };
          }
          result.push(attrEntryObject);
        }
        blockAttributes["$[]="]("attribute_entries", result);
      }
    }
    this.$playback_attributes(blockAttributes);
  };
  Document.prototype.deleteAttribute = function(name) {
    return this.$delete_attribute(name);
  };
  Document.prototype.isAttributeLocked = function(key) {
    return this["$attribute_locked?"](key);
  };
  Document.prototype.restoreAttributes = function() {
    return this.$restore_attributes();
  };
  Document.prototype.parse = function(data) {
    return this.$parse(data);
  };
  Document.prototype.getDocinfo = function(docinfoLocation, suffix) {
    return this.$docinfo(docinfoLocation, suffix);
  };
  Document.prototype.hasDocinfoProcessors = function(docinfoLocation) {
    return this["$docinfo_processors?"](docinfoLocation);
  };
  Document.prototype.incrementAndStoreCounter = function(counterName, block) {
    return this.$increment_and_store_counter(counterName, block);
  };
  Document.prototype.counterIncrement = Document.prototype.incrementAndStoreCounter;
  Document.prototype.counter = function(name, seed) {
    return this.$counter(name, seed);
  };
  Document.prototype.getSafe = function() {
    return this.safe;
  };
  Document.prototype.getCompatMode = function() {
    return this.compat_mode;
  };
  Document.prototype.getSourcemap = function() {
    const sourcemap = this.sourcemap;
    return sourcemap === Opal.nil ? false : sourcemap;
  };
  Document.prototype.setSourcemap = function(value) {
    this.sourcemap = value;
  };
  Document.prototype.getCounters = function() {
    return fromHash(this.counters);
  };
  Document.prototype.getCallouts = function() {
    return this.$callouts();
  };
  Document.prototype.getBaseDir = function() {
    return this.base_dir;
  };
  Document.prototype.getOptions = function() {
    return fromHash(this.options);
  };
  Document.prototype.getOutfilesuffix = function() {
    return this.outfilesuffix;
  };
  Document.prototype.getParentDocument = function() {
    const parentDocument = this.parent_document;
    return parentDocument === Opal.nil ? void 0 : parentDocument;
  };
  Document.prototype.getReader = function() {
    return this.reader;
  };
  Document.prototype.getConverter = function() {
    return this.converter;
  };
  Document.prototype.getExtensions = function() {
    const extensions = this.extensions;
    return extensions === Opal.nil ? void 0 : extensions;
  };
  const Title = Document.Title;
  Title.prototype.getMain = function() {
    return this.main;
  };
  Title.prototype.getCombined = function() {
    return this.combined;
  };
  Title.prototype.getSubtitle = function() {
    const subtitle = this.subtitle;
    return subtitle === Opal.nil ? void 0 : subtitle;
  };
  Title.prototype.isSanitized = function() {
    const sanitized = this["$sanitized?"]();
    return sanitized === Opal.nil ? false : sanitized;
  };
  Title.prototype.hasSubtitle = function() {
    return this["$subtitle?"]();
  };
  const Inline = Opal.Asciidoctor.Inline;
  Inline.create = function(parent, context, text, opts) {
    return this.$new(parent, context, text, prepareOptions(opts));
  };
  Inline.prototype.convert = function() {
    return this.$convert();
  };
  Inline.prototype.getText = function() {
    const text = this.$text();
    return text === Opal.nil ? void 0 : text;
  };
  Inline.prototype.getType = function() {
    return this.$type();
  };
  Inline.prototype.getTarget = function() {
    const target = this.$target();
    return target === Opal.nil ? void 0 : target;
  };
  Inline.prototype.getAlt = function() {
    return this.$alt();
  };
  const List = Opal.Asciidoctor.List;
  List.prototype.hasItems = function() {
    return this["$items?"]();
  };
  List.prototype.getItems = function() {
    return this.blocks;
  };
  const ListItem = Opal.Asciidoctor.ListItem;
  ListItem.prototype.getText = function() {
    return this.$text();
  };
  ListItem.prototype.setText = function(text) {
    return this["$text="](text);
  };
  ListItem.prototype.hasText = function() {
    return this["$text?"]();
  };
  ListItem.prototype.getMarker = function() {
    return this.marker;
  };
  ListItem.prototype.setMarker = function(marker) {
    this.marker = marker;
  };
  ListItem.prototype.getList = function() {
    return this.$list();
  };
  ListItem.prototype.getParent = ListItem.prototype.getList;
  const Reader = Opal.Asciidoctor.Reader;
  Reader.prototype.pushInclude = function(data, file, path, lineno, attributes) {
    return this.$push_include(data, file, path, lineno, toHash(attributes));
  };
  Reader.prototype.getCursor = function() {
    return this.$cursor();
  };
  Reader.prototype.getLines = function() {
    return this.$lines();
  };
  Reader.prototype.getString = function() {
    return this.$string();
  };
  Reader.prototype.hasMoreLines = function() {
    return this["$has_more_lines?"]();
  };
  Reader.prototype.isEmpty = function() {
    return this["$empty?"]();
  };
  Reader.prototype.peekLine = function(direct) {
    direct = direct || false;
    const line = this.$peek_line(direct);
    return line === Opal.nil ? void 0 : line;
  };
  Reader.prototype.readLine = function() {
    const line = this.$read_line();
    return line === Opal.nil ? void 0 : line;
  };
  Reader.prototype.readLines = function() {
    return this.$read_lines();
  };
  Reader.prototype.read = function() {
    return this.$read();
  };
  Reader.prototype.advance = function() {
    return this.$advance();
  };
  const Cursor = Opal.Asciidoctor.Reader.Cursor;
  Cursor.prototype.getFile = function() {
    const file = this.file;
    return file === Opal.nil ? void 0 : file;
  };
  Cursor.prototype.getDirectory = function() {
    const dir = this.dir;
    return dir === Opal.nil ? void 0 : dir;
  };
  Cursor.prototype.getPath = function() {
    const path = this.path;
    return path === Opal.nil ? void 0 : path;
  };
  Cursor.prototype.getLineNumber = function() {
    return this.lineno;
  };
  function initializeLoggerFormatterClass(className, functions) {
    const superclass = Opal.const_get_qualified(Opal.Logger, "Formatter");
    return initializeClass(superclass, className, functions, {}, {
      call: function(args) {
        for (let i = 0; i < args.length; i++) {
          if (typeof args[i] === "object" && "$$smap" in args[i]) {
            args[i] = fromHash(args[i]);
          }
        }
        return args;
      }
    });
  }
  function initializeLoggerClass(className, functions) {
    const superClass = Opal.const_get_qualified(Opal.Asciidoctor, "Logger");
    return initializeClass(superClass, className, functions, {}, {
      add: function(args) {
        if (args.length >= 2 && typeof args[2] === "object" && "$$smap" in args[2]) {
          const message = args[2];
          const messageObject = fromHash(message);
          messageObject.getText = function() {
            return this.text;
          };
          messageObject.getSourceLocation = function() {
            return this.source_location;
          };
          messageObject.$inspect = function() {
            const sourceLocation = this.getSourceLocation();
            if (sourceLocation) {
              return sourceLocation.getPath() + ": line " + sourceLocation.getLineNumber() + ": " + this.getText();
            } else {
              return this.getText();
            }
          };
          args[2] = messageObject;
        }
        if (args.length >= 1) {
          args[1] = args[1] === Opal.nil ? void 0 : args[1];
        }
        return args;
      }
    });
  }
  const LoggerManager = Opal.const_get_qualified(Opal.Asciidoctor, "LoggerManager", true);
  Opal.Asciidoctor.LoggerManager = LoggerManager;
  LoggerManager.getLogger = function() {
    return this.$logger();
  };
  LoggerManager.setLogger = function(logger) {
    this["$logger="](logger);
  };
  LoggerManager.newLogger = function(name, functions) {
    return initializeLoggerClass(name, functions).$new();
  };
  LoggerManager.newFormatter = function(name, functions) {
    return initializeLoggerFormatterClass(name, functions).$new();
  };
  const LoggerSeverity = Opal.const_get_qualified(Opal.Logger, "Severity", true);
  Opal.Asciidoctor.LoggerSeverity = LoggerSeverity;
  LoggerSeverity.get = function(severity) {
    return LoggerSeverity.$constants()[severity];
  };
  const LoggerFormatter = Opal.const_get_qualified(Opal.Logger, "Formatter", true);
  Opal.Asciidoctor.LoggerFormatter = LoggerFormatter;
  LoggerFormatter.prototype.call = function(severity, time, programName, message) {
    return this.$call(LoggerSeverity.get(severity), time, programName, message);
  };
  const MemoryLogger = Opal.const_get_qualified(Opal.Asciidoctor, "MemoryLogger", true);
  Opal.Asciidoctor.MemoryLogger = MemoryLogger;
  MemoryLogger.create = function() {
    return this.$new();
  };
  MemoryLogger.prototype.getMessages = function() {
    const messages = this.messages;
    const result = [];
    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      const messageObject = fromHash(message);
      if (typeof messageObject.message === "string") {
        messageObject.getText = function() {
          return this.message;
        };
      } else {
        messageObject.message = fromHash(messageObject.message);
        messageObject.getText = function() {
          return this.message.text;
        };
      }
      messageObject.getSeverity = function() {
        return this.severity.toString();
      };
      messageObject.getSourceLocation = function() {
        return this.message.source_location;
      };
      result.push(messageObject);
    }
    return result;
  };
  const Logging = Opal.const_get_qualified(Opal.Asciidoctor, "Logging", true);
  Opal.Asciidoctor.Logging = Logging;
  Logging.getLogger = function() {
    return LoggerManager.$logger();
  };
  Logging.createLogMessage = function(text, context) {
    return Logging.prototype.$message_with_context(text, toHash(context));
  };
  Reader.prototype.getLogger = Logging.getLogger;
  Reader.prototype.createLogMessage = Logging.createLogMessage;
  AbstractNode.prototype.getLogger = Logging.getLogger;
  AbstractNode.prototype.createLogMessage = Logging.createLogMessage;
  const Logger = Opal.const_get_qualified(Opal.Asciidoctor, "Logger", true);
  Opal.Asciidoctor.Logger = Logger;
  Logger.prototype.getMaxSeverity = function() {
    const result = this.max_severity;
    return result === Opal.nil ? void 0 : result;
  };
  Logger.prototype.getFormatter = function() {
    return this.formatter;
  };
  Logger.prototype.setFormatter = function(formatter) {
    this.formatter = formatter;
  };
  Logger.prototype.getLevel = function() {
    return this.level;
  };
  Logger.prototype.setLevel = function(level) {
    this.level = level;
  };
  Logger.prototype.getProgramName = function() {
    return this.progname;
  };
  Logger.prototype.setProgramName = function(programName) {
    this.progname = programName;
  };
  const RubyLogger = Opal.const_get_qualified("::", "Logger");
  const log = function(logger, level, message) {
    logger["$" + level](message);
  };
  RubyLogger.prototype.add = function(severity, message, programName) {
    const severityValue = typeof severity === "string" ? LoggerSeverity[severity.toUpperCase()] : severity;
    this.$add(severityValue, message, programName);
  };
  RubyLogger.prototype.log = RubyLogger.prototype.add;
  RubyLogger.prototype.debug = function(message) {
    log(this, "debug", message);
  };
  RubyLogger.prototype.info = function(message) {
    log(this, "info", message);
  };
  RubyLogger.prototype.warn = function(message) {
    log(this, "warn", message);
  };
  RubyLogger.prototype.error = function(message) {
    log(this, "error", message);
  };
  RubyLogger.prototype.fatal = function(message) {
    log(this, "fatal", message);
  };
  RubyLogger.prototype.isDebugEnabled = function() {
    return this["$debug?"]();
  };
  RubyLogger.prototype.isInfoEnabled = function() {
    return this["$info?"]();
  };
  RubyLogger.prototype.isWarnEnabled = function() {
    return this["$warn?"]();
  };
  RubyLogger.prototype.isErrorEnabled = function() {
    return this["$error?"]();
  };
  RubyLogger.prototype.isFatalEnabled = function() {
    return this["$fatal?"]();
  };
  const NullLogger = Opal.const_get_qualified(Opal.Asciidoctor, "NullLogger", true);
  Opal.Asciidoctor.NullLogger = NullLogger;
  NullLogger.create = function() {
    return this.$new();
  };
  NullLogger.prototype.getMaxSeverity = function() {
    return this.max_severity;
  };
  Opal.Asciidoctor.StopIteration = Opal.StopIteration;
  const Timings = Opal.const_get_qualified(Opal.Asciidoctor, "Timings", true);
  Opal.Asciidoctor.Timings = Timings;
  Timings.create = function() {
    return this.$new();
  };
  Timings.prototype.printReport = function(to, subject) {
    let outputFunction;
    if (to) {
      if (typeof to.$add === "function") {
        outputFunction = function(message) {
          to.$add(1, message);
        };
      } else if (typeof to.log === "function") {
        outputFunction = to.log;
      } else if (typeof to.write === "function") {
        outputFunction = function(message) {
          to.write(message, "utf-8");
        };
      } else {
        throw new Error("The output should be a Stream (with a write function), an object with a log function or a Ruby Logger (with a add function)");
      }
    } else {
      outputFunction = function(message) {
        Opal.gvars.stdout.$write(message);
      };
    }
    if (subject) {
      outputFunction("Input file: " + subject);
    }
    outputFunction(" Time to read and parse source: " + this.$read_parse().toFixed(2));
    outputFunction(" Time to convert document: " + this.$convert().toFixed(2));
    outputFunction(" Total time (read, parse and convert): " + this.$read_parse_convert().toFixed(2));
  };
  const SyntaxHighlighter = Opal.const_get_qualified(Opal.Asciidoctor, "SyntaxHighlighter", true);
  Opal.Asciidoctor.SyntaxHighlighter = SyntaxHighlighter;
  SyntaxHighlighter.register = function(names, functions) {
    const name = typeof names === "string" ? names : names[0];
    if (typeof functions === "function") {
      const classObject = functions;
      const prototype = classObject.prototype;
      const properties = Object.getOwnPropertyNames(prototype);
      functions = {};
      for (const propertyIdx in properties) {
        const propertyName = properties[propertyIdx];
        functions[propertyName] = prototype[propertyName];
      }
    }
    const scope = initializeClass(SyntaxHighlighterBase, name, functions, {}, {
      format: function(args) {
        if (args.length >= 2 && typeof args[2] === "object" && "$$smap" in args[2]) {
          args[2] = fromHash(args[2]);
        }
        if (args.length >= 1) {
          args[1] = args[1] === Opal.nil ? void 0 : args[1];
        }
        return args;
      },
      highlight: function(args) {
        if (args.length >= 3 && typeof args[3] === "object" && "$$smap" in args[3]) {
          let opts = args[3];
          opts = fromHash(opts);
          for (const key in opts) {
            const value = opts[key];
            if (key === "callouts") {
              const callouts = fromHashKeys(value);
              for (const idx in callouts) {
                const callout = callouts[idx];
                for (let i = 0; i < callout.length; i++) {
                  const items = callout[i];
                  for (let j = 0; j < items.length; j++) {
                    items[j] = items[j] === Opal.nil ? void 0 : items[j];
                  }
                }
              }
              opts[key] = callouts;
            } else {
              opts[key] = value === Opal.nil ? void 0 : value;
            }
          }
          args[3] = opts;
        }
        if (args.length >= 2) {
          args[2] = args[2] === Opal.nil ? void 0 : args[2];
        }
        return args;
      }
    });
    for (const functionName in functions) {
      if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
        (function(functionName2) {
          const userFunction = functions[functionName2];
          if (functionName2 === "handlesHighlighting") {
            Opal.def(scope, "$highlight?", function() {
              return userFunction.call();
            });
          } else if (functionName2 === "hasDocinfo") {
            Opal.def(scope, "$docinfo?", function(location) {
              return userFunction.apply(this, [location]);
            });
          }
        })(functionName);
      }
    }
    Opal.def(scope, "$name", function() {
      return name;
    });
    SyntaxHighlighter.$register(scope, names);
    return scope;
  };
  SyntaxHighlighter.get = function(name) {
    const result = SyntaxHighlighter.$for(name);
    return result === Opal.nil ? void 0 : result;
  };
  SyntaxHighlighter.for = SyntaxHighlighter.get;
  const SyntaxHighlighterBase = Opal.const_get_qualified(SyntaxHighlighter, "Base", true);
  Opal.Asciidoctor.SyntaxHighlighterBase = SyntaxHighlighterBase;
  SyntaxHighlighterBase.prototype.registerFor = function(names) {
    SyntaxHighlighter.$register(this, names);
  };
  const Table = Opal.Asciidoctor.Table;
  Table.create = function(parent, attributes) {
    return this.$new(parent, toHash(attributes));
  };
  Table.prototype.getCaption = function() {
    return this.caption;
  };
  Table.prototype.getRows = function() {
    return this.rows;
  };
  Table.prototype.getColumns = function() {
    return this.columns;
  };
  Table.prototype.getHeadRows = function() {
    return this.rows.head;
  };
  Table.prototype.hasHeadRows = function() {
    return this.rows !== Opal.nil && this.rows.head.length > 0;
  };
  Table.prototype.getBodyRows = function() {
    return this.rows.body;
  };
  Table.prototype.hasBodyRows = function() {
    return this.rows !== Opal.nil && this.rows.body.length > 0;
  };
  Table.prototype.getFootRows = function() {
    return this.rows.foot;
  };
  Table.prototype.hasFootRows = function() {
    return this.rows !== Opal.nil && this.rows.foot.length > 0;
  };
  Table.prototype.hasHeaderOption = function() {
    return this.has_header_option;
  };
  Table.prototype.hasFooterOption = function() {
    return this.isOption("footer");
  };
  Table.prototype.hasAutowidthOption = function() {
    return this.isOption("autowidth");
  };
  Table.prototype.getRowCount = function() {
    return this.getAttribute("rowcount");
  };
  Table.prototype.setRowCount = function(value) {
    this.setAttribute("rowcount", value);
  };
  Table.prototype.getColumnCount = function() {
    return this.getAttribute("colcount");
  };
  Table.prototype.setColumnCount = function(value) {
    this.setAttribute("colcount", value);
  };
  const Rows = Opal.Asciidoctor.Table.Rows;
  Rows.create = function(head, foot, body) {
    return this.$new(head, foot, body);
  };
  Rows.prototype.getHead = function() {
    return this.head;
  };
  Rows.prototype.getFoot = function() {
    return this.foot;
  };
  Rows.prototype.getBody = function() {
    return this.body;
  };
  Rows.prototype.bySection = function() {
    return [["head", this.head], ["body", this.body], ["foot", this.foot]];
  };
  const Column = Opal.Asciidoctor.Table.Column;
  Column.create = function(table, index, attributes) {
    return this.$new(table, index, toHash(attributes));
  };
  Column.prototype.getColumnNumber = function() {
    return this.getAttribute("colnumber");
  };
  Column.prototype.getWidth = function() {
    return this.getAttribute("width");
  };
  Column.prototype.getHorizontalAlign = function() {
    return this.getAttribute("halign");
  };
  Column.prototype.getVerticalAlign = function() {
    return this.getAttribute("valign");
  };
  Column.prototype.getStyle = function() {
    const style = this.style;
    return style === Opal.nil ? void 0 : style;
  };
  const Cell = Opal.Asciidoctor.Table.Cell;
  Cell.create = function(column, cellText, attributes, opts) {
    return this.$new(column, cellText, toHash(attributes), toHash(opts));
  };
  Cell.prototype.getColumnSpan = function() {
    const colspan = this.colspan;
    return colspan === Opal.nil ? void 0 : colspan;
  };
  Cell.prototype.setColumnSpan = function(value) {
    return this["$colspan="](value);
  };
  Cell.prototype.getRowSpan = function() {
    const rowspan = this.rowspan;
    return rowspan === Opal.nil ? void 0 : rowspan;
  };
  Cell.prototype.setRowSpan = function(value) {
    return this["$rowspan="](value);
  };
  Cell.prototype.getContent = function() {
    return this.$content();
  };
  Cell.prototype.getText = function() {
    return this.$text();
  };
  Cell.prototype.getSource = function() {
    return this.$source();
  };
  Cell.prototype.getLines = function() {
    return this.$lines();
  };
  Cell.prototype.getLineNumber = function() {
    const lineno = this.$lineno();
    return lineno === Opal.nil ? void 0 : lineno;
  };
  Cell.prototype.getFile = function() {
    const file = this.$file();
    return file === Opal.nil ? void 0 : file;
  };
  Cell.prototype.getStyle = function() {
    const style = this.$style();
    return style === Opal.nil ? void 0 : style;
  };
  Cell.prototype.getColumn = function() {
    const column = this.$column();
    return column === Opal.nil ? void 0 : column;
  };
  Cell.prototype.getWidth = function() {
    return this.getAttribute("width");
  };
  Cell.prototype.getColumnPercentageWidth = function() {
    return this.getAttribute("colpcwidth");
  };
  Cell.prototype.getInnerDocument = function() {
    const innerDocument = this.inner_document;
    return innerDocument === Opal.nil ? void 0 : innerDocument;
  };
  const TemplateConverter = Opal.Asciidoctor.Converter.TemplateConverter;
  if (TemplateConverter) {
    Opal.Asciidoctor.TemplateConverter = TemplateConverter;
    TemplateConverter.create = function(backend, templateDirectories, opts) {
      if (opts && opts.template_cache) {
        opts.template_cache = toHash(opts.template_cache);
      }
      this.$new(backend, templateDirectories, toHash(opts));
    };
    TemplateConverter.getCache = function() {
      const caches = fromHash(this.caches);
      if (caches) {
        if (caches.scans) {
          caches.scans = fromHash(caches.scans);
          for (const key in caches.scans) {
            caches.scans[key] = fromHash(caches.scans[key]);
          }
        }
        if (caches.templates) {
          caches.templates = fromHash(caches.templates);
        }
      }
      return caches;
    };
    TemplateConverter.clearCache = function() {
      this.$clear_caches();
    };
    TemplateConverter.prototype.convert = function(node, templateName, opts) {
      return this.$convert(node, templateName, toHash(opts));
    };
    TemplateConverter.prototype.handles = function(name) {
      return this["$handles?"](name);
    };
    TemplateConverter.prototype.getContentOnly = function(node) {
      return this.$content_only(node);
    };
    TemplateConverter.prototype.skip = function(node) {
      this.$skip(node);
    };
    TemplateConverter.prototype.getTemplates = function() {
      return fromHash(this.$templates());
    };
    TemplateConverter.prototype.register = function(name, template) {
      return this.$register(name, template);
    };
    const TemplateEngine = {};
    TemplateEngine.registry = {};
    Opal.Asciidoctor.TemplateEngine = TemplateEngine;
    TemplateEngine.register = function(names, templateEngineAdapter) {
      if (typeof names === "string") {
        this.registry[names] = templateEngineAdapter;
      } else {
        for (let i = 0; i < names.length; i++) {
          const name = names[i];
          this.registry[name] = templateEngineAdapter;
        }
      }
    };
  }
  const CompositeConverter = Opal.Asciidoctor.Converter.CompositeConverter;
  if (CompositeConverter) {
    Opal.Asciidoctor.CompositeConverter = CompositeConverter;
    CompositeConverter.prototype.convert = function(node, transform, opts) {
      return this.$convert(node, transform, toHash(opts));
    };
    CompositeConverter.prototype.getContentOnly = function(node) {
      return this.$content_only(node);
    };
    CompositeConverter.prototype.skip = function(node) {
      this.$skip(node);
    };
    CompositeConverter.prototype.getConverters = function() {
      return this.converters;
    };
    CompositeConverter.prototype.getConverter = function(transform) {
      const converter = this.$converter_for(transform);
      return converter === Opal.nil ? void 0 : converter;
    };
    CompositeConverter.prototype.findConverter = function(transform) {
      return this.$find_converter(transform);
    };
  }
  const Converter = Opal.const_get_qualified(Opal.Asciidoctor, "Converter");
  Opal.Asciidoctor.Converter = Converter;
  Converter.prototype.convert = function(node, transform, opts) {
    return this.$convert(node, transform, toHash(opts));
  };
  Converter.create = function(backend, opts) {
    return this.$create(backend, toHash(opts));
  };
  const ConverterFactory = Opal.Asciidoctor.Converter.Factory;
  const ConverterBase = Opal.Asciidoctor.Converter.Base;
  Opal.Asciidoctor.ConverterFactory = ConverterFactory;
  const ConverterBackendTraits = Opal.Asciidoctor.Converter.BackendTraits;
  Opal.Asciidoctor.ConverterBackendTraits = ConverterBackendTraits;
  ConverterFactory.register = function(converter, backends) {
    const args = [bridgeConverter(converter)].concat(backends);
    return Converter.$register.apply(Converter, args);
  };
  ConverterFactory.getDefault = function(initialize) {
    return this.$default(initialize);
  };
  ConverterFactory.prototype.create = function(backend, opts) {
    return this.$create(backend, toHash(opts));
  };
  ConverterFactory.getRegistry = function() {
    return fromHash(Converter.$registry());
  };
  ConverterFactory.for = function(backend) {
    const converter = Converter.$for(backend);
    return converter === Opal.nil ? void 0 : converter;
  };
  ConverterFactory.unregisterAll = function() {
    const internalRegistry = Converter.DefaultFactory.$$cvars["@@registry"];
    Converter.DefaultFactory.$$cvars["@@registry"] = toHash({ html5: internalRegistry["$[]"]("html5") });
  };
  const Html5Converter = Opal.Asciidoctor.Converter.Html5Converter;
  Opal.Asciidoctor.Html5Converter = Html5Converter;
  Html5Converter.create = function() {
    return this.$new();
  };
  Html5Converter.prototype.convert = function(node, transform, opts) {
    return this.$convert(node, transform, opts);
  };
  const toBlock = function(block) {
    block.$$arity = block.length;
    return block;
  };
  const registerExtension = function(registry, type, processor, name) {
    if (typeof processor === "object" || processor.$$is_class) {
      return registry["$" + type](processor, name);
    } else {
      return Opal.send(registry, type, name && [name], toBlock(processor));
    }
  };
  const Extensions = Opal.const_get_qualified(Opal.Asciidoctor, "Extensions");
  Opal.Asciidoctor.Extensions = Extensions;
  Extensions.create = function(name, block) {
    if (typeof name === "function" && typeof block === "undefined") {
      return Opal.send(this, "create", null, toBlock(name));
    } else if (typeof block === "function") {
      return Opal.send(this, "create", [name], toBlock(block));
    } else {
      return this.$create();
    }
  };
  Extensions.register = function(name, block) {
    if (typeof name === "function" && typeof block === "undefined") {
      return Opal.send(this, "register", null, toBlock(name));
    } else {
      return Opal.send(this, "register", [name], toBlock(block));
    }
  };
  Extensions.getGroups = function() {
    return fromHash(this.$groups());
  };
  Extensions.unregisterAll = function() {
    this.$unregister_all();
  };
  Extensions.unregister = function() {
    const names = Array.prototype.concat.apply([], arguments);
    const groups = this.$groups();
    const groupNameIdx = {};
    let i = 0;
    const groupSymbolNames = groups.$$keys;
    for (; i < groupSymbolNames.length; i++) {
      const groupSymbolName = groupSymbolNames[i];
      groupNameIdx[groupSymbolName.toString()] = groupSymbolName;
    }
    for (let j = 0; j < names.length; j++) {
      const groupStringName = names[j];
      if (groupStringName in groupNameIdx)
        Opal.hash_delete(groups, groupNameIdx[groupStringName]);
    }
  };
  const Registry = Extensions.Registry;
  Registry.prototype.getGroups = Extensions.getGroups;
  Registry.prototype.unregisterAll = function() {
    this.groups = Opal.hash();
  };
  Registry.prototype.unregister = Extensions.unregister;
  Registry.prototype.prefer = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    if (typeof processor === "object" || processor.$$is_class) {
      return this.$prefer(name, processor);
    } else {
      return Opal.send(this, "prefer", name && [name], toBlock(processor));
    }
  };
  Registry.prototype.block = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "block", processor, name);
  };
  Registry.prototype.inlineMacro = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "inline_macro", processor, name);
  };
  Registry.prototype.includeProcessor = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "include_processor", processor, name);
  };
  Registry.prototype.blockMacro = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "block_macro", processor, name);
  };
  Registry.prototype.treeProcessor = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "tree_processor", processor, name);
  };
  Registry.prototype.postprocessor = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "postprocessor", processor, name);
  };
  Registry.prototype.preprocessor = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "preprocessor", processor, name);
  };
  Registry.prototype.docinfoProcessor = function(name, processor) {
    if (arguments.length === 1) {
      processor = name;
      name = null;
    }
    return registerExtension(this, "docinfo_processor", processor, name);
  };
  Registry.prototype.hasPreprocessors = function() {
    return this["$preprocessors?"]();
  };
  Registry.prototype.hasTreeProcessors = function() {
    return this["$tree_processors?"]();
  };
  Registry.prototype.hasIncludeProcessors = function() {
    return this["$include_processors?"]();
  };
  Registry.prototype.hasPostprocessors = function() {
    return this["$postprocessors?"]();
  };
  Registry.prototype.hasDocinfoProcessors = function(location) {
    return this["$docinfo_processors?"](location);
  };
  Registry.prototype.hasBlocks = function() {
    return this["$blocks?"]();
  };
  Registry.prototype.hasBlockMacros = function() {
    return this["$block_macros?"]();
  };
  Registry.prototype.hasInlineMacros = function() {
    return this["$inline_macros?"]();
  };
  Registry.prototype.getPreprocessors = function() {
    return this.$preprocessors();
  };
  Registry.prototype.getTreeProcessors = function() {
    return this.$tree_processors();
  };
  Registry.prototype.getIncludeProcessors = function() {
    return this.$include_processors();
  };
  Registry.prototype.getPostprocessors = function() {
    return this.$postprocessors();
  };
  Registry.prototype.getDocinfoProcessors = function(location) {
    return this.$docinfo_processors(location);
  };
  Registry.prototype.getBlocks = function() {
    return this.block_extensions.$values();
  };
  Registry.prototype.getBlockMacros = function() {
    return this.block_macro_extensions.$values();
  };
  Registry.prototype.getInlineMacros = function() {
    return this.$inline_macros();
  };
  Registry.prototype.getInlineMacroFor = function(name) {
    const result = this["$registered_for_inline_macro?"](name);
    return result === false ? void 0 : result;
  };
  Registry.prototype.getBlockFor = function(name, context) {
    if (typeof context === "undefined") {
      const ext = this.$find_block_extension(name);
      return ext === Opal.nil ? void 0 : ext;
    }
    const result = this["$registered_for_block?"](name, context);
    return result === false ? void 0 : result;
  };
  Registry.prototype.getBlockMacroFor = function(name) {
    const result = this["$registered_for_block_macro?"](name);
    return result === false ? void 0 : result;
  };
  const Processor = Extensions.Processor;
  Processor.prototype.prepend = function() {
    this.$option("position", ">>");
  };
  Processor.prototype.process = function(block) {
    const handler = {
      apply: function(target, thisArg, argumentsList) {
        for (let i = 0; i < argumentsList.length; i++) {
          if (typeof argumentsList[i] === "object" && "$$smap" in argumentsList[i]) {
            argumentsList[i] = fromHash(argumentsList[i]);
          }
        }
        return target.apply(thisArg, argumentsList);
      }
    };
    const blockProxy = new Proxy(block, handler);
    return Opal.send(this, "process", null, toBlock(blockProxy));
  };
  Processor.prototype.named = function(name) {
    return this.$named(name);
  };
  Processor.prototype.createBlock = function(parent, context, source, attrs, opts) {
    return this.$create_block(parent, context, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createList = function(parent, context, attrs) {
    return this.$create_list(parent, context, toHash(attrs));
  };
  Processor.prototype.createListItem = function(parent, text) {
    return this.$create_list_item(parent, text);
  };
  Processor.prototype.createImageBlock = function(parent, attrs, opts) {
    return this.$create_image_block(parent, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createParagraph = function(parent, source, attrs, opts) {
    return this.$create_paragraph(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createOpenBlock = function(parent, source, attrs, opts) {
    return this.$create_open_block(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createExampleBlock = function(parent, source, attrs, opts) {
    return this.$create_example_block(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createPassBlock = function(parent, source, attrs, opts) {
    return this.$create_pass_block(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createListingBlock = function(parent, source, attrs, opts) {
    return this.$create_listing_block(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createLiteralBlock = function(parent, source, attrs, opts) {
    return this.$create_literal_block(parent, source, toHash(attrs), toHash(opts));
  };
  Processor.prototype.createAnchor = function(parent, text, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return this.$create_anchor(parent, text, toHash(opts));
  };
  Processor.prototype.createInlinePass = function(parent, text, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return this.$create_inline_pass(parent, text, toHash(opts));
  };
  Processor.prototype.createInline = function(parent, context, text, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return this.$create_inline(parent, context, text, toHash(opts));
  };
  Processor.prototype.parseContent = function(parent, content, attrs) {
    return this.$parse_content(parent, content, toHash(attrs));
  };
  Processor.prototype.parseAttributes = function(block, attrlist, opts) {
    if (opts && opts.attributes) {
      opts.attributes = toHash(opts.attributes);
    }
    return fromHash(this.$parse_attributes(block, attrlist, toHash(opts)));
  };
  Processor.prototype.positionalAttributes = function(value) {
    return this.$positional_attrs(value);
  };
  Processor.prototype.resolveAttributes = function(value) {
    if (typeof value === "object" && !Array.isArray(value)) {
      return this.$resolves_attributes(toHash(value));
    }
    if (arguments.length > 1) {
      return this.$resolves_attributes(Array.prototype.slice.call(arguments));
    }
    if (typeof value === "undefined") {
      return this.$resolves_attributes(Opal.nil);
    }
    return this.$resolves_attributes(value);
  };
  Processor.prototype.resolvesAttributes = Processor.prototype.resolveAttributes;
  Processor.prototype.getConfig = function() {
    return fromHash(this.config);
  };
  Processor.prototype.option = function(key, value) {
    this.$option(key, value);
  };
  const BlockProcessor = Extensions.BlockProcessor;
  BlockProcessor.prototype.defaultAttributes = function(value) {
    this.$default_attributes(toHash(value));
  };
  BlockProcessor.prototype.onContext = function(context) {
    return this.$on_context(context);
  };
  BlockProcessor.prototype.onContexts = function(contexts) {
    return this.$on_contexts(Array.prototype.slice.call(arguments));
  };
  BlockProcessor.prototype.getName = function() {
    const name = this.name;
    return name === Opal.nil ? void 0 : name;
  };
  BlockProcessor.prototype.parseContentAs = function(value) {
    this.$parse_content_as(value);
  };
  const BlockMacroProcessor = Extensions.BlockMacroProcessor;
  BlockMacroProcessor.prototype.defaultAttributes = function(value) {
    this.$default_attributes(toHash(value));
  };
  BlockMacroProcessor.prototype.getName = function() {
    const name = this.name;
    return name === Opal.nil ? void 0 : name;
  };
  BlockMacroProcessor.prototype.parseContentAs = function(value) {
    this.$parse_content_as(value);
  };
  const InlineMacroProcessor = Extensions.InlineMacroProcessor;
  InlineMacroProcessor.prototype.defaultAttributes = function(value) {
    this.$default_attributes(toHash(value));
  };
  InlineMacroProcessor.prototype.getName = function() {
    const name = this.name;
    return name === Opal.nil ? void 0 : name;
  };
  InlineMacroProcessor.prototype.parseContentAs = function(value) {
    this.$parse_content_as(value);
  };
  InlineMacroProcessor.prototype.matchFormat = function(value) {
    this.$match_format(value);
  };
  InlineMacroProcessor.prototype.match = function(value) {
    this.$match(value);
  };
  const IncludeProcessor = Extensions.IncludeProcessor;
  IncludeProcessor.prototype.handles = function(block) {
    return Opal.send(this, "handles?", null, toBlock(block));
  };
  IncludeProcessor.prototype.prefer = function() {
    this.$prefer();
  };
  const TreeProcessor = Extensions.TreeProcessor;
  TreeProcessor.prototype.prefer = function() {
    this.$prefer();
  };
  const Postprocessor = Extensions.Postprocessor;
  Postprocessor.prototype.prefer = function() {
    this.$prefer();
  };
  const Preprocessor = Extensions.Preprocessor;
  Preprocessor.prototype.prefer = function() {
    this.$prefer();
  };
  const DocinfoProcessor = Extensions.DocinfoProcessor;
  DocinfoProcessor.prototype.prefer = function() {
    this.$prefer();
  };
  DocinfoProcessor.prototype.atLocation = function(value) {
    this.$at_location(value);
  };
  function initializeProcessorClass(superclassName, className, functions) {
    const superClass = Opal.const_get_qualified(Extensions, superclassName);
    return initializeClass(superClass, className, functions, {
      "handles?": function() {
        return true;
      }
    });
  }
  Extensions.createPostprocessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("Postprocessor", name, functions);
  };
  Extensions.newPostprocessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createPostprocessor(name, functions).$new();
  };
  Extensions.createPreprocessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("Preprocessor", name, functions);
  };
  Extensions.newPreprocessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createPreprocessor(name, functions).$new();
  };
  Extensions.createTreeProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("TreeProcessor", name, functions);
  };
  Extensions.newTreeProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createTreeProcessor(name, functions).$new();
  };
  Extensions.createIncludeProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("IncludeProcessor", name, functions);
  };
  Extensions.newIncludeProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createIncludeProcessor(name, functions).$new();
  };
  Extensions.createDocinfoProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("DocinfoProcessor", name, functions);
  };
  Extensions.newDocinfoProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createDocinfoProcessor(name, functions).$new();
  };
  Extensions.createBlockProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("BlockProcessor", name, functions);
  };
  Extensions.newBlockProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createBlockProcessor(name, functions).$new();
  };
  Extensions.createInlineMacroProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("InlineMacroProcessor", name, functions);
  };
  Extensions.newInlineMacroProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createInlineMacroProcessor(name, functions).$new();
  };
  Extensions.createBlockMacroProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return initializeProcessorClass("BlockMacroProcessor", name, functions);
  };
  Extensions.newBlockMacroProcessor = function(name, functions) {
    if (arguments.length === 1) {
      functions = name;
      name = null;
    }
    return this.createBlockMacroProcessor(name, functions).$new();
  };
  var ASCIIDOCTOR_JS_VERSION = "3.0.4";
  Opal.Asciidoctor.prototype.getVersion = function() {
    return ASCIIDOCTOR_JS_VERSION;
  };
  return Opal.Asciidoctor;
}
var init_asciidoctor = __esm({
  "node_modules/@asciidoctor/core/dist/browser/asciidoctor.js"() {
    (function(global_object) {
      "use strict";
      var console2;
      if (typeof globalThis !== "undefined") {
        global_object = globalThis;
      } else if (typeof global !== "undefined") {
        global_object = global;
      } else if (typeof window !== "undefined") {
        global_object = window;
      }
      if (global_object.console == null) {
        global_object.console = {};
      }
      if (typeof global_object.console === "object") {
        console2 = global_object.console;
      } else {
        console2 = {};
      }
      if (!("log" in console2)) {
        console2.log = function() {
        };
      }
      if (!("warn" in console2)) {
        console2.warn = console2.log;
      }
      if (typeof global_object.Opal !== "undefined") {
        console2.warn("Opal already loaded. Loading twice can cause troubles, please fix your setup.");
        return global_object.Opal;
      }
      var nil;
      var BasicObject;
      var _Object;
      var Module;
      var Class;
      var _Opal;
      var Kernel;
      var Opal2 = global_object.Opal = {};
      Opal2.global = global_object;
      Opal2.config = {
        missing_require_severity: "error",
        // error, warning, ignore
        unsupported_features_severity: "warning",
        // error, warning, ignore
        experimental_features_severity: "warning",
        // warning, ignore
        enable_stack_trace: true
        // true, false
      };
      var $call = Function.prototype.call;
      var $bind = Function.prototype.bind;
      var $has_own = Object.hasOwn || $call.bind(Object.prototype.hasOwnProperty);
      var $set_proto = Object.setPrototypeOf;
      var $slice = $call.bind(Array.prototype.slice);
      var $splice = $call.bind(Array.prototype.splice);
      var nil_id = 4;
      var unique_id = nil_id;
      function $uid() {
        unique_id += 2;
        return unique_id;
      }
      ;
      Opal2.uid = $uid;
      Opal2.id = function(obj) {
        if (obj.$$is_number)
          return obj * 2 + 1;
        if (obj.$$id == null) {
          $prop(obj, "$$id", $uid());
        }
        return obj.$$id;
      };
      var $gvars = Opal2.gvars = {};
      Opal2.exit = function(status) {
        if ($gvars.DEBUG)
          console2.log("Exited with status " + status);
      };
      Opal2.exceptions = [];
      Opal2.pop_exception = function() {
        var exception = Opal2.exceptions.pop();
        if (exception) {
          $gvars["!"] = exception;
          $gvars["@"] = exception.$backtrace();
        } else {
          $gvars["!"] = $gvars["@"] = nil;
        }
      };
      function $raise(klass, message) {
        if (!klass)
          klass = Opal2.Exception || Error;
        if (Kernel && Kernel.$raise) {
          if (arguments.length > 2) {
            Kernel.$raise(klass.$new.apply(klass, $slice(arguments, 1)));
          } else {
            Kernel.$raise(klass, message);
          }
        } else if (!klass.$new) {
          throw new klass(message);
        } else {
          throw klass.$new(message);
        }
      }
      function $prop(object, name, initialValue) {
        if (typeof object === "string") {
          object[name] = initialValue;
        } else {
          Object.defineProperty(object, name, {
            value: initialValue,
            enumerable: false,
            configurable: true,
            writable: true
          });
        }
      }
      Opal2.prop = $prop;
      Opal2.defineProperty = Opal2.prop;
      Opal2.slice = $slice;
      var $truthy = Opal2.truthy = function(val) {
        return false !== val && nil !== val && void 0 !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
      };
      Opal2.falsy = function(val) {
        return !$truthy(val);
      };
      Opal2.type_error = function(object, type, method, coerced) {
        object = object.$$class;
        if (coerced && method) {
          coerced = coerced.$$class;
          $raise(
            Opal2.TypeError,
            "can't convert " + object + " into " + type + " (" + object + "#" + method + " gives " + coerced + ")"
          );
        } else {
          $raise(
            Opal2.TypeError,
            "no implicit conversion of " + object + " into " + type
          );
        }
      };
      Opal2.coerce_to = function(object, type, method, args) {
        var body;
        if (method === "to_int" && type === Opal2.Integer && object.$$is_number)
          return object < 0 ? Math.ceil(object) : Math.floor(object);
        if (method === "to_str" && type === Opal2.String && object.$$is_string)
          return object;
        if (Opal2.is_a(object, type))
          return object;
        if (object["$respond_to?"].$$pristine && object.$method_missing.$$pristine) {
          body = object[$jsid(method)];
          if (body == null || body.$$stub)
            Opal2.type_error(object, type);
          return body.apply(object, args);
        }
        if (!object["$respond_to?"](method)) {
          Opal2.type_error(object, type);
        }
        if (args == null)
          args = [];
        return Opal2.send(object, method, args);
      };
      Opal2.respond_to = function(obj, jsid, include_all) {
        if (obj == null || !obj.$$class)
          return false;
        include_all = !!include_all;
        var body = obj[jsid];
        if (obj["$respond_to?"].$$pristine) {
          if (typeof body === "function" && !body.$$stub) {
            return true;
          }
          if (!obj["$respond_to_missing?"].$$pristine) {
            return Opal2.send(obj, obj["$respond_to_missing?"], [jsid.substr(1), include_all]);
          }
        } else {
          return Opal2.send(obj, obj["$respond_to?"], [jsid.substr(1), include_all]);
        }
      };
      Opal2.trace_class = false;
      Opal2.tracers_for_class = [];
      function invoke_tracers_for_class(klass_or_module) {
        var i, ii, tracer;
        for (i = 0, ii = Opal2.tracers_for_class.length; i < ii; i++) {
          tracer = Opal2.tracers_for_class[i];
          tracer.trace_object = klass_or_module;
          tracer.block.$call(tracer);
        }
      }
      function handle_autoload(cref, name) {
        if (!cref.$$autoload[name].loaded) {
          cref.$$autoload[name].loaded = true;
          try {
            Opal2.Kernel.$require(cref.$$autoload[name].path);
          } catch (e) {
            cref.$$autoload[name].exception = e;
            throw e;
          }
          cref.$$autoload[name].required = true;
          if (cref.$$const[name] != null) {
            cref.$$autoload[name].success = true;
            return cref.$$const[name];
          }
        } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
          if (cref.$$autoload[name].exception) {
            throw cref.$$autoload[name].exception;
          }
        }
      }
      function const_get_name(cref, name) {
        if (cref) {
          if (cref.$$const[name] != null) {
            return cref.$$const[name];
          }
          if (cref.$$autoload && cref.$$autoload[name]) {
            return handle_autoload(cref, name);
          }
        }
      }
      function const_lookup_nesting(nesting, name) {
        var i, ii, constant;
        if (nesting.length === 0)
          return;
        for (i = 0, ii = nesting.length; i < ii; i++) {
          constant = nesting[i].$$const[name];
          if (constant != null) {
            return constant;
          } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
            return handle_autoload(nesting[i], name);
          }
        }
      }
      function const_lookup_ancestors(cref, name) {
        var i, ii, ancestors;
        if (cref == null)
          return;
        ancestors = $ancestors(cref);
        for (i = 0, ii = ancestors.length; i < ii; i++) {
          if (ancestors[i].$$const && $has_own(ancestors[i].$$const, name)) {
            return ancestors[i].$$const[name];
          } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
            return handle_autoload(ancestors[i], name);
          }
        }
      }
      function const_lookup_Object(cref, name) {
        if (cref == null || cref.$$is_module) {
          return const_lookup_ancestors(_Object, name);
        }
      }
      function const_missing(cref, name) {
        return (cref || _Object).$const_missing(name);
      }
      Opal2.const_get_local = function(cref, name, skip_missing) {
        var result;
        if (cref == null)
          return;
        if (cref === "::")
          cref = _Object;
        if (!cref.$$is_module && !cref.$$is_class) {
          $raise(Opal2.TypeError, cref.toString() + " is not a class/module");
        }
        result = const_get_name(cref, name);
        return result != null || skip_missing ? result : const_missing(cref, name);
      };
      Opal2.const_get_qualified = function(cref, name, skip_missing) {
        var result, cache, cached, current_version = Opal2.const_cache_version;
        if (name == null) {
          result = const_get_name(_Object, cref);
          if (result != null)
            return result;
          return Opal2.const_get_qualified(_Object, cref, skip_missing);
        }
        if (cref == null)
          return;
        if (cref === "::")
          cref = _Object;
        if (!cref.$$is_module && !cref.$$is_class) {
          $raise(Opal2.TypeError, cref.toString() + " is not a class/module");
        }
        if ((cache = cref.$$const_cache) == null) {
          $prop(cref, "$$const_cache", /* @__PURE__ */ Object.create(null));
          cache = cref.$$const_cache;
        }
        cached = cache[name];
        if (cached == null || cached[0] !== current_version) {
          (result = const_get_name(cref, name)) != null || (result = const_lookup_ancestors(cref, name)) != null;
          cache[name] = [current_version, result];
        } else {
          result = cached[1];
        }
        return result != null || skip_missing ? result : const_missing(cref, name);
      };
      Opal2.const_cache_version = 1;
      Opal2.const_get_relative = function(nesting, name, skip_missing) {
        var cref = nesting[0], result, current_version = Opal2.const_cache_version, cache, cached;
        if ((cache = nesting.$$const_cache) == null) {
          $prop(nesting, "$$const_cache", /* @__PURE__ */ Object.create(null));
          cache = nesting.$$const_cache;
        }
        cached = cache[name];
        if (cached == null || cached[0] !== current_version) {
          (result = const_get_name(cref, name)) != null || (result = const_lookup_nesting(nesting, name)) != null || (result = const_lookup_ancestors(cref, name)) != null || (result = const_lookup_Object(cref, name)) != null;
          cache[name] = [current_version, result];
        } else {
          result = cached[1];
        }
        return result != null || skip_missing ? result : const_missing(cref, name);
      };
      function $const_set(cref, name, value) {
        var new_const = true;
        if (cref == null || cref === "::")
          cref = _Object;
        if (value.$$is_a_module) {
          if (value.$$name == null || value.$$name === nil)
            value.$$name = name;
          if (value.$$base_module == null)
            value.$$base_module = cref;
        }
        cref.$$const = cref.$$const || /* @__PURE__ */ Object.create(null);
        if (name in cref.$$const || "$$autoload" in cref && name in cref.$$autoload) {
          new_const = false;
        }
        cref.$$const[name] = value;
        cref.$$ = cref.$$const;
        Opal2.const_cache_version++;
        if (cref === _Object)
          Opal2[name] = value;
        $prop(cref, name, value);
        if (new_const && cref.$const_added && !cref.$const_added.$$pristine) {
          cref.$const_added(name);
        }
        return value;
      }
      ;
      Opal2.const_set = $const_set;
      Opal2.constants = function(cref, inherit) {
        if (inherit == null)
          inherit = true;
        var module2, modules = [cref], i, ii, constants = {}, constant;
        if (inherit)
          modules = modules.concat($ancestors(cref));
        if (inherit && cref.$$is_module)
          modules = modules.concat([Opal2.Object]).concat($ancestors(Opal2.Object));
        for (i = 0, ii = modules.length; i < ii; i++) {
          module2 = modules[i];
          if (cref !== _Object && module2 == _Object)
            break;
          for (constant in module2.$$const) {
            constants[constant] = true;
          }
          if (module2.$$autoload) {
            for (constant in module2.$$autoload) {
              constants[constant] = true;
            }
          }
        }
        return Object.keys(constants);
      };
      Opal2.const_remove = function(cref, name) {
        Opal2.const_cache_version++;
        if (cref.$$const[name] != null) {
          var old = cref.$$const[name];
          delete cref.$$const[name];
          return old;
        }
        if (cref.$$autoload && cref.$$autoload[name]) {
          delete cref.$$autoload[name];
          return nil;
        }
        $raise(Opal2.NameError, "constant " + cref + "::" + cref.$name() + " not defined");
      };
      Opal2.const_get_relative_factory = function(nesting) {
        return function(name, skip_missing) {
          return Opal2.$$(nesting, name, skip_missing);
        };
      };
      Opal2.$$ = Opal2.const_get_relative;
      Opal2.$$$ = Opal2.const_get_qualified;
      Opal2.$r = Opal2.const_get_relative_factory;
      function $allocate_class(name, superclass, singleton) {
        var klass;
        if (superclass != null && superclass.$$bridge) {
          klass = function() {
            var args = $slice(arguments), self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();
            $set_proto(self, klass.$$prototype);
            return self;
          };
        } else {
          klass = function() {
          };
        }
        if (name && name !== nil) {
          $prop(klass, "displayName", "::" + name);
        }
        $prop(klass, "$$name", name);
        $prop(klass, "$$constructor", klass);
        $prop(klass, "$$prototype", klass.prototype);
        $prop(klass, "$$const", {});
        $prop(klass, "$$is_class", true);
        $prop(klass, "$$is_a_module", true);
        $prop(klass, "$$super", superclass);
        $prop(klass, "$$cvars", {});
        $prop(klass, "$$own_included_modules", []);
        $prop(klass, "$$own_prepended_modules", []);
        $prop(klass, "$$ancestors", []);
        $prop(klass, "$$ancestors_cache_version", null);
        $prop(klass, "$$subclasses", []);
        $prop(klass.$$prototype, "$$class", klass);
        if (Opal2.Class) {
          $set_proto(klass, Opal2.Class.prototype);
        }
        if (superclass != null) {
          $set_proto(klass.$$prototype, superclass.$$prototype);
          if (singleton !== true) {
            if (typeof WeakRef !== "undefined") {
              var i, subclass, rebuilt_subclasses = [];
              for (i = 0; i < superclass.$$subclasses.length; i++) {
                subclass = superclass.$$subclasses[i];
                if (subclass.deref() !== void 0) {
                  rebuilt_subclasses.push(subclass);
                }
              }
              rebuilt_subclasses.push(new WeakRef(klass));
              superclass.$$subclasses = rebuilt_subclasses;
            } else {
              superclass.$$subclasses.push(klass);
            }
          }
          if (superclass.$$meta) {
            Opal2.build_class_singleton_class(klass);
          }
        }
        return klass;
      }
      ;
      Opal2.allocate_class = $allocate_class;
      function find_existing_class(scope, name) {
        var klass = const_get_name(scope, name);
        if (klass) {
          if (!klass.$$is_class) {
            $raise(Opal2.TypeError, name + " is not a class");
          }
          return klass;
        }
      }
      function ensureSuperclassMatch(klass, superclass) {
        if (klass.$$super !== superclass) {
          $raise(Opal2.TypeError, "superclass mismatch for class " + klass.$$name);
        }
      }
      Opal2.klass = function(scope, superclass, name) {
        var bridged;
        if (scope == null || scope == "::") {
          scope = _Object;
        } else if (!scope.$$is_class && !scope.$$is_module) {
          scope = scope.$$class;
        }
        if (superclass != null && (!superclass.hasOwnProperty || superclass.hasOwnProperty && !superclass.hasOwnProperty("$$is_class"))) {
          if (superclass.constructor && superclass.constructor.name == "Function") {
            bridged = superclass;
            superclass = _Object;
          } else {
            $raise(Opal2.TypeError, "superclass must be a Class (" + (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name) || typeof superclass) + " given)");
          }
        }
        var klass = find_existing_class(scope, name);
        if (klass != null) {
          if (superclass) {
            ensureSuperclassMatch(klass, superclass);
          }
        } else {
          if (superclass == null) {
            superclass = _Object;
          }
          klass = $allocate_class(name, superclass);
          $const_set(scope, name, klass);
          if (superclass.$inherited) {
            superclass.$inherited(klass);
          }
          if (bridged) {
            Opal2.bridge(bridged, klass);
          }
        }
        if (Opal2.trace_class) {
          invoke_tracers_for_class(klass);
        }
        return klass;
      };
      function $allocate_module(name) {
        var constructor = function() {
        };
        var module2 = constructor;
        if (name)
          $prop(constructor, "displayName", name + ".constructor");
        $prop(module2, "$$name", name);
        $prop(module2, "$$prototype", constructor.prototype);
        $prop(module2, "$$const", {});
        $prop(module2, "$$is_module", true);
        $prop(module2, "$$is_a_module", true);
        $prop(module2, "$$cvars", {});
        $prop(module2, "$$iclasses", []);
        $prop(module2, "$$own_included_modules", []);
        $prop(module2, "$$own_prepended_modules", []);
        $prop(module2, "$$ancestors", [module2]);
        $prop(module2, "$$ancestors_cache_version", null);
        $set_proto(module2, Opal2.Module.prototype);
        return module2;
      }
      ;
      Opal2.allocate_module = $allocate_module;
      function find_existing_module(scope, name) {
        var module2 = const_get_name(scope, name);
        if (module2 == null && scope === _Object)
          module2 = const_lookup_ancestors(_Object, name);
        if (module2) {
          if (!module2.$$is_module && module2 !== _Object) {
            $raise(Opal2.TypeError, name + " is not a module");
          }
        }
        return module2;
      }
      Opal2.module = function(scope, name) {
        var module2;
        if (scope == null || scope == "::") {
          scope = _Object;
        } else if (!scope.$$is_class && !scope.$$is_module) {
          scope = scope.$$class;
        }
        module2 = find_existing_module(scope, name);
        if (module2 == null) {
          module2 = $allocate_module(name);
          $const_set(scope, name, module2);
        }
        if (Opal2.trace_class) {
          invoke_tracers_for_class(module2);
        }
        return module2;
      };
      Opal2.get_singleton_class = function(object) {
        if (object.$$is_number) {
          $raise(Opal2.TypeError, "can't define singleton");
        }
        if (object.$$meta) {
          return object.$$meta;
        }
        if (object.hasOwnProperty("$$is_class")) {
          return Opal2.build_class_singleton_class(object);
        } else if (object.hasOwnProperty("$$is_module")) {
          return Opal2.build_module_singleton_class(object);
        } else {
          return Opal2.build_object_singleton_class(object);
        }
      };
      function set_meta(obj, meta) {
        if (obj.hasOwnProperty("$$meta")) {
          obj.$$meta = meta;
        } else {
          $prop(obj, "$$meta", meta);
        }
        if (obj.$$frozen) {
          obj.$$meta.$freeze();
        } else {
          $set_proto(obj, meta.$$prototype);
        }
      }
      ;
      Opal2.build_class_singleton_class = function(klass) {
        if (klass.$$meta) {
          return klass.$$meta;
        }
        var superclass = klass === BasicObject ? Class : Opal2.get_singleton_class(klass.$$super);
        var meta = $allocate_class(null, superclass, true);
        $prop(meta, "$$is_singleton", true);
        $prop(meta, "$$singleton_of", klass);
        set_meta(klass, meta);
        $prop(klass, "$$class", Opal2.Class);
        return meta;
      };
      Opal2.build_module_singleton_class = function(mod) {
        if (mod.$$meta) {
          return mod.$$meta;
        }
        var meta = $allocate_class(null, Opal2.Module, true);
        $prop(meta, "$$is_singleton", true);
        $prop(meta, "$$singleton_of", mod);
        set_meta(mod, meta);
        $prop(mod, "$$class", Opal2.Module);
        return meta;
      };
      Opal2.build_object_singleton_class = function(object) {
        var superclass = object.$$class, klass = $allocate_class(nil, superclass, true);
        $prop(klass, "$$is_singleton", true);
        $prop(klass, "$$singleton_of", object);
        delete klass.$$prototype.$$class;
        set_meta(object, klass);
        return klass;
      };
      Opal2.is_method = function(prop) {
        return prop[0] === "$" && prop[1] !== "$";
      };
      Opal2.instance_methods = function(mod) {
        var exclude = [], results = [], ancestors = $ancestors(mod);
        for (var i = 0, l = ancestors.length; i < l; i++) {
          var ancestor = ancestors[i], proto = ancestor.$$prototype;
          if (proto.hasOwnProperty("$$dummy")) {
            proto = proto.$$define_methods_on;
          }
          var props = Object.getOwnPropertyNames(proto);
          for (var j = 0, ll = props.length; j < ll; j++) {
            var prop = props[j];
            if (Opal2.is_method(prop)) {
              var method_name = prop.slice(1), method = proto[prop];
              if (method.$$stub && exclude.indexOf(method_name) === -1) {
                exclude.push(method_name);
              }
              if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
                results.push(method_name);
              }
            }
          }
        }
        return results;
      };
      Opal2.own_instance_methods = function(mod) {
        var results = [], proto = mod.$$prototype;
        if (proto.hasOwnProperty("$$dummy")) {
          proto = proto.$$define_methods_on;
        }
        var props = Object.getOwnPropertyNames(proto);
        for (var i = 0, length = props.length; i < length; i++) {
          var prop = props[i];
          if (Opal2.is_method(prop)) {
            var method = proto[prop];
            if (!method.$$stub) {
              var method_name = prop.slice(1);
              results.push(method_name);
            }
          }
        }
        return results;
      };
      Opal2.methods = function(obj) {
        return Opal2.instance_methods(obj.$$meta || obj.$$class);
      };
      Opal2.own_methods = function(obj) {
        return obj.$$meta ? Opal2.own_instance_methods(obj.$$meta) : [];
      };
      Opal2.receiver_methods = function(obj) {
        var mod = Opal2.get_singleton_class(obj);
        var singleton_methods = Opal2.own_instance_methods(mod);
        var instance_methods = Opal2.own_instance_methods(mod.$$super);
        return singleton_methods.concat(instance_methods);
      };
      Opal2.class_variables = function(module2) {
        var ancestors = $ancestors(module2), i, length = ancestors.length, result = {};
        for (i = length - 1; i >= 0; i--) {
          var ancestor = ancestors[i];
          for (var cvar in ancestor.$$cvars) {
            result[cvar] = ancestor.$$cvars[cvar];
          }
        }
        return result;
      };
      Opal2.class_variable_set = function(module2, name, value) {
        var ancestors = $ancestors(module2), i, length = ancestors.length;
        for (i = length - 2; i >= 0; i--) {
          var ancestor = ancestors[i];
          if ($has_own(ancestor.$$cvars, name)) {
            ancestor.$$cvars[name] = value;
            return value;
          }
        }
        module2.$$cvars[name] = value;
        return value;
      };
      Opal2.class_variable_get = function(module2, name, tolerant) {
        if ($has_own(module2.$$cvars, name))
          return module2.$$cvars[name];
        var ancestors = $ancestors(module2), i, length = ancestors.length;
        for (i = 0; i < length; i++) {
          var ancestor = ancestors[i];
          if ($has_own(ancestor.$$cvars, name)) {
            return ancestor.$$cvars[name];
          }
        }
        if (!tolerant)
          $raise(Opal2.NameError, "uninitialized class variable " + name + " in " + module2.$name());
        return nil;
      };
      function isRoot(proto) {
        return proto.hasOwnProperty("$$iclass") && proto.hasOwnProperty("$$root");
      }
      function own_included_modules(module2) {
        var result = [], mod, proto = Object.getPrototypeOf(module2.$$prototype);
        while (proto) {
          if (proto.hasOwnProperty("$$class")) {
            break;
          }
          mod = protoToModule(proto);
          if (mod) {
            result.push(mod);
          }
          proto = Object.getPrototypeOf(proto);
        }
        return result;
      }
      function own_prepended_modules(module2) {
        var result = [], mod, proto = Object.getPrototypeOf(module2.$$prototype);
        if (module2.$$prototype.hasOwnProperty("$$dummy")) {
          while (proto) {
            if (proto === module2.$$prototype.$$define_methods_on) {
              break;
            }
            mod = protoToModule(proto);
            if (mod) {
              result.push(mod);
            }
            proto = Object.getPrototypeOf(proto);
          }
        }
        return result;
      }
      Opal2.append_features = function(module2, includer) {
        var module_ancestors = $ancestors(module2);
        var iclasses = [];
        if (module_ancestors.indexOf(includer) !== -1) {
          $raise(Opal2.ArgumentError, "cyclic include detected");
        }
        for (var i = 0, length = module_ancestors.length; i < length; i++) {
          var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
          $prop(iclass, "$$included", true);
          iclasses.push(iclass);
        }
        var includer_ancestors = $ancestors(includer), chain = chain_iclasses(iclasses), start_chain_after, end_chain_on;
        if (includer_ancestors.indexOf(module2) === -1) {
          start_chain_after = includer.$$prototype;
          end_chain_on = Object.getPrototypeOf(includer.$$prototype);
        } else {
          var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);
          while (module_iclass != null) {
            if (module_iclass.$$module === module2 && isRoot(module_iclass)) {
              break;
            }
            parent = module_iclass;
            module_iclass = Object.getPrototypeOf(module_iclass);
          }
          if (module_iclass) {
            var next_ancestor = Object.getPrototypeOf(module_iclass);
            while (next_ancestor.hasOwnProperty("$$iclass") && !isRoot(next_ancestor)) {
              next_ancestor = Object.getPrototypeOf(next_ancestor);
            }
            start_chain_after = parent;
            end_chain_on = next_ancestor;
          } else {
            start_chain_after = includer.$$prototype;
            end_chain_on = Object.getPrototypeOf(includer.$$prototype);
          }
        }
        $set_proto(start_chain_after, chain.first);
        $set_proto(chain.last, end_chain_on);
        includer.$$own_included_modules = own_included_modules(includer);
        Opal2.const_cache_version++;
      };
      Opal2.prepend_features = function(module2, prepender) {
        var module_ancestors = $ancestors(module2);
        var iclasses = [];
        if (module_ancestors.indexOf(prepender) !== -1) {
          $raise(Opal2.ArgumentError, "cyclic prepend detected");
        }
        for (var i = 0, length = module_ancestors.length; i < length; i++) {
          var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
          $prop(iclass, "$$prepended", true);
          iclasses.push(iclass);
        }
        var chain = chain_iclasses(iclasses), dummy_prepender = prepender.$$prototype, previous_parent = Object.getPrototypeOf(dummy_prepender), prepender_iclass, start_chain_after, end_chain_on;
        if (dummy_prepender.hasOwnProperty("$$dummy")) {
          prepender_iclass = dummy_prepender.$$define_methods_on;
        } else {
          prepender_iclass = create_dummy_iclass(prepender);
          flush_methods_in(prepender);
          $prop(dummy_prepender, "$$dummy", true);
          $prop(dummy_prepender, "$$define_methods_on", prepender_iclass);
          $set_proto(dummy_prepender, prepender_iclass);
          $set_proto(prepender_iclass, previous_parent);
        }
        var prepender_ancestors = $ancestors(prepender);
        if (prepender_ancestors.indexOf(module2) === -1) {
          start_chain_after = dummy_prepender;
          end_chain_on = Object.getPrototypeOf(dummy_prepender);
          while (end_chain_on != null) {
            if (end_chain_on.hasOwnProperty("$$root") || end_chain_on === prepender_iclass || !end_chain_on.hasOwnProperty("$$iclass")) {
              break;
            }
            end_chain_on = Object.getPrototypeOf(end_chain_on);
          }
        } else {
          $raise(Opal2.RuntimeError, "Prepending a module multiple times is not supported");
        }
        $set_proto(start_chain_after, chain.first);
        $set_proto(chain.last, end_chain_on);
        prepender.$$own_prepended_modules = own_prepended_modules(prepender);
        Opal2.const_cache_version++;
      };
      function flush_methods_in(module2) {
        var proto = module2.$$prototype, props = Object.getOwnPropertyNames(proto);
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          if (Opal2.is_method(prop)) {
            delete proto[prop];
          }
        }
      }
      function create_iclass(module2) {
        var iclass = create_dummy_iclass(module2);
        if (module2.$$is_module) {
          module2.$$iclasses.push(iclass);
        }
        return iclass;
      }
      function create_dummy_iclass(module2) {
        var iclass = {}, proto = module2.$$prototype;
        if (proto.hasOwnProperty("$$dummy")) {
          proto = proto.$$define_methods_on;
        }
        var props = Object.getOwnPropertyNames(proto), length = props.length, i;
        for (i = 0; i < length; i++) {
          var prop = props[i];
          $prop(iclass, prop, proto[prop]);
        }
        $prop(iclass, "$$iclass", true);
        $prop(iclass, "$$module", module2);
        return iclass;
      }
      function chain_iclasses(iclasses) {
        var length = iclasses.length, first = iclasses[0];
        $prop(first, "$$root", true);
        if (length === 1) {
          return { first, last: first };
        }
        var previous = first;
        for (var i = 1; i < length; i++) {
          var current = iclasses[i];
          $set_proto(previous, current);
          previous = current;
        }
        return { first: iclasses[0], last: iclasses[length - 1] };
      }
      Opal2.bridge = function(native_klass, klass) {
        if (native_klass.hasOwnProperty("$$bridge")) {
          $raise(Opal2.ArgumentError, "already bridged");
        }
        $prop(native_klass, "$$bridge", klass);
        $set_proto(native_klass.prototype, (klass.$$super || Opal2.Object).$$prototype);
        $prop(klass, "$$prototype", native_klass.prototype);
        $prop(klass.$$prototype, "$$class", klass);
        $prop(klass, "$$constructor", native_klass);
        $prop(klass, "$$bridge", true);
      };
      function protoToModule(proto) {
        if (proto.hasOwnProperty("$$dummy")) {
          return;
        } else if (proto.hasOwnProperty("$$iclass")) {
          return proto.$$module;
        } else if (proto.hasOwnProperty("$$class")) {
          return proto.$$class;
        }
      }
      function own_ancestors(module2) {
        return module2.$$own_prepended_modules.concat([module2]).concat(module2.$$own_included_modules);
      }
      function $ancestors(module2) {
        if (!module2) {
          return [];
        }
        if (module2.$$ancestors_cache_version === Opal2.const_cache_version) {
          return module2.$$ancestors;
        }
        var result = [], i, mods, length;
        for (i = 0, mods = own_ancestors(module2), length = mods.length; i < length; i++) {
          result.push(mods[i]);
        }
        if (module2.$$super) {
          for (i = 0, mods = $ancestors(module2.$$super), length = mods.length; i < length; i++) {
            result.push(mods[i]);
          }
        }
        module2.$$ancestors_cache_version = Opal2.const_cache_version;
        module2.$$ancestors = result;
        return result;
      }
      ;
      Opal2.ancestors = $ancestors;
      Opal2.included_modules = function(module2) {
        var result = [], mod = null, proto = Object.getPrototypeOf(module2.$$prototype);
        for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
          mod = protoToModule(proto);
          if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
            result.push(mod);
          }
        }
        return result;
      };
      Opal2.add_stubs = function(stubs) {
        var proto = Opal2.BasicObject.$$prototype;
        var stub, existing_method;
        stubs = stubs.split(",");
        for (var i = 0, length = stubs.length; i < length; i++) {
          stub = $jsid(stubs[i]), existing_method = proto[stub];
          if (existing_method == null || existing_method.$$stub) {
            Opal2.add_stub_for(proto, stub);
          }
        }
      };
      Opal2.add_stub_for = function(prototype, stub) {
        $prop(prototype, stub, Opal2.stub_for(stub));
      };
      Opal2.stub_for = function(method_name) {
        function method_missing_stub() {
          this.$method_missing.$$p = method_missing_stub.$$p;
          method_missing_stub.$$p = null;
          var args_ary = new Array(arguments.length);
          for (var i = 0, l = args_ary.length; i < l; i++) {
            args_ary[i] = arguments[i];
          }
          return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
        }
        method_missing_stub.$$stub = true;
        return method_missing_stub;
      };
      Opal2.ac = function(actual, expected, object, meth) {
        var inspect = "";
        if (object.$$is_a_module) {
          inspect += object.$$name + ".";
        } else {
          inspect += object.$$class.$$name + "#";
        }
        inspect += meth;
        $raise(Opal2.ArgumentError, "[" + inspect + "] wrong number of arguments (given " + actual + ", expected " + expected + ")");
      };
      Opal2.block_ac = function(actual, expected, context) {
        var inspect = "`block in " + context + "'";
        $raise(Opal2.ArgumentError, inspect + ": wrong number of arguments (given " + actual + ", expected " + expected + ")");
      };
      function get_ancestors(obj) {
        if (obj.hasOwnProperty("$$meta") && obj.$$meta !== null) {
          return $ancestors(obj.$$meta);
        } else {
          return $ancestors(obj.$$class);
        }
      }
      ;
      Opal2.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
        var jsid = $jsid(mid), ancestors, super_method;
        ancestors = get_ancestors(obj);
        var current_index = ancestors.indexOf(current_func.$$owner);
        for (var i = current_index + 1; i < ancestors.length; i++) {
          var ancestor = ancestors[i], proto = ancestor.$$prototype;
          if (proto.hasOwnProperty("$$dummy")) {
            proto = proto.$$define_methods_on;
          }
          if (proto.hasOwnProperty(jsid)) {
            super_method = proto[jsid];
            break;
          }
        }
        if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
          $raise(Opal2.NoMethodError, "super: no superclass method `" + mid + "' for " + obj, mid);
        }
        return super_method.$$stub && !allow_stubs ? null : super_method;
      };
      Opal2.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
        var call_jsid = jsid;
        if (!current_func) {
          $raise(Opal2.RuntimeError, "super called outside of method");
        }
        if (implicit && current_func.$$define_meth) {
          $raise(
            Opal2.RuntimeError,
            "implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly"
          );
        }
        if (current_func.$$def) {
          call_jsid = current_func.$$jsid;
        }
        return Opal2.find_super(obj, call_jsid, current_func, defcheck);
      };
      Opal2.find_super_dispatcher = Opal2.find_super;
      Opal2.find_iter_super_dispatcher = Opal2.find_block_super;
      Opal2.yield1 = function(block, arg) {
        if (typeof block !== "function") {
          $raise(Opal2.LocalJumpError, "no block given");
        }
        var has_mlhs = block.$$has_top_level_mlhs_arg, has_trailing_comma = block.$$has_trailing_comma_in_args;
        if (block.length > 1 || (has_mlhs || has_trailing_comma) && block.length === 1) {
          arg = Opal2.to_ary(arg);
        }
        if ((block.length > 1 || has_trailing_comma && block.length === 1) && arg.$$is_array) {
          return block.apply(null, arg);
        } else {
          return block(arg);
        }
      };
      Opal2.yieldX = function(block, args) {
        if (typeof block !== "function") {
          $raise(Opal2.LocalJumpError, "no block given");
        }
        if (block.length > 1 && args.length === 1) {
          if (args[0].$$is_array) {
            return block.apply(null, args[0]);
          }
        }
        if (!args.$$is_array) {
          var args_ary = new Array(args.length);
          for (var i = 0, l = args_ary.length; i < l; i++) {
            args_ary[i] = args[i];
          }
          return block.apply(null, args_ary);
        }
        return block.apply(null, args);
      };
      Opal2.rescue = function(exception, candidates) {
        for (var i = 0; i < candidates.length; i++) {
          var candidate = candidates[i];
          if (candidate.$$is_array) {
            var result = Opal2.rescue(exception, candidate);
            if (result) {
              return result;
            }
          } else if (candidate === Opal2.JS.Error || candidate["$==="](exception)) {
            return candidate;
          }
        }
        return null;
      };
      Opal2.is_a = function(object, klass) {
        if (klass != null && object.$$meta === klass || object.$$class === klass) {
          return true;
        }
        if (object.$$is_number && klass.$$is_number_class) {
          return klass.$$is_integer_class ? object % 1 === 0 : true;
        }
        var ancestors = $ancestors(object.$$is_class ? Opal2.get_singleton_class(object) : object.$$meta || object.$$class);
        return ancestors.indexOf(klass) !== -1;
      };
      Opal2.to_hash = function(value) {
        if (value.$$is_hash) {
          return value;
        } else if (value["$respond_to?"]("to_hash", true)) {
          var hash = value.$to_hash();
          if (hash.$$is_hash) {
            return hash;
          } else {
            $raise(Opal2.TypeError, "Can't convert " + value.$$class + " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
          }
        } else {
          $raise(Opal2.TypeError, "no implicit conversion of " + value.$$class + " into Hash");
        }
      };
      Opal2.to_ary = function(value) {
        if (value.$$is_array) {
          return value;
        } else if (value["$respond_to?"]("to_ary", true)) {
          var ary = value.$to_ary();
          if (ary === nil) {
            return [value];
          } else if (ary.$$is_array) {
            return ary;
          } else {
            $raise(Opal2.TypeError, "Can't convert " + value.$$class + " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
          }
        } else {
          return [value];
        }
      };
      Opal2.to_a = function(value) {
        if (value.$$is_array) {
          return value.slice();
        } else if (value["$respond_to?"]("to_a", true)) {
          var ary = value.$to_a();
          if (ary === nil) {
            return [value];
          } else if (ary.$$is_array) {
            return ary;
          } else {
            $raise(Opal2.TypeError, "Can't convert " + value.$$class + " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
          }
        } else {
          return [value];
        }
      };
      Opal2.extract_kwargs = function(parameters) {
        var kwargs = parameters[parameters.length - 1];
        if (kwargs != null && Opal2.respond_to(kwargs, "$to_hash", true)) {
          $splice(parameters, parameters.length - 1);
          return kwargs;
        }
      };
      Opal2.kwrestargs = function(given_args, used_args) {
        var keys = [], map = {}, key, given_map = given_args.$$smap;
        for (key in given_map) {
          if (!used_args[key]) {
            keys.push(key);
            map[key] = given_map[key];
          }
        }
        return Opal2.hash2(keys, map);
      };
      function apply_blockopts(block, blockopts) {
        if (typeof blockopts === "number") {
          block.$$arity = blockopts;
        } else if (typeof blockopts === "object") {
          Object.assign(block, blockopts);
        }
      }
      var jsid_cache = {};
      function $jsid(name) {
        return jsid_cache[name] || (jsid_cache[name] = "$" + name);
      }
      Opal2.jsid = $jsid;
      Opal2.send = function(recv, method, args, block, blockopts) {
        var body;
        if (typeof method === "function") {
          body = method;
          method = null;
        } else if (typeof method === "string") {
          body = recv[$jsid(method)];
        } else {
          $raise(Opal2.NameError, "Passed method should be a string or a function");
        }
        return Opal2.send2(recv, body, method, args, block, blockopts);
      };
      Opal2.send2 = function(recv, body, method, args, block, blockopts) {
        if (body == null && method != null && recv.$method_missing) {
          body = recv.$method_missing;
          args = [method].concat(args);
        }
        apply_blockopts(block, blockopts);
        if (typeof block === "function")
          body.$$p = block;
        return body.apply(recv, args);
      };
      Opal2.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
        var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;
        ancestors = get_ancestors(recv);
        for (i = 0; i < ancestors.length; i++) {
          ancestor = Opal2.id(ancestors[i]);
          for (j = 0; j < refinement_groups.length; j++) {
            refinements = refinement_groups[j];
            for (k = refinements.length - 1; k >= 0; k--) {
              refinement = refinements[k];
              if (typeof refinement.$$refine_modules === "undefined")
                continue;
              refine_modules = refinement.$$refine_modules;
              if (typeof refine_modules[ancestor] === "undefined")
                continue;
              refine_module = refine_modules[ancestor];
              if (typeof refine_module.$$prototype[$jsid(method)] !== "undefined") {
                body = refine_module.$$prototype[$jsid(method)];
                return Opal2.send2(recv, body, method, args, block, blockopts);
              }
            }
          }
        }
        return Opal2.send(recv, method, args, block, blockopts);
      };
      Opal2.lambda = function(block, blockopts) {
        block.$$is_lambda = true;
        apply_blockopts(block, blockopts);
        return block;
      };
      Opal2.def = function(obj, jsid, body, blockopts) {
        apply_blockopts(body, blockopts);
        if (obj === Opal2.top) {
          return Opal2.defn(Opal2.Object, jsid, body);
        } else if (!obj.$$eval && obj.$$is_a_module) {
          return Opal2.defn(obj, jsid, body);
        } else {
          return Opal2.defs(obj, jsid, body);
        }
      };
      Opal2.defn = function(module2, jsid, body) {
        $deny_frozen_access(module2);
        body.displayName = jsid;
        body.$$owner = module2;
        var name = jsid.substr(1);
        var proto = module2.$$prototype;
        if (proto.hasOwnProperty("$$dummy")) {
          proto = proto.$$define_methods_on;
        }
        $prop(proto, jsid, body);
        if (module2.$$is_module) {
          if (module2.$$module_function) {
            Opal2.defs(module2, jsid, body);
          }
          for (var i = 0, iclasses = module2.$$iclasses, length = iclasses.length; i < length; i++) {
            var iclass = iclasses[i];
            $prop(iclass, jsid, body);
          }
        }
        var singleton_of = module2.$$singleton_of;
        if (module2.$method_added && !module2.$method_added.$$stub && !singleton_of) {
          module2.$method_added(name);
        } else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
          singleton_of.$singleton_method_added(name);
        }
        return name;
      };
      Opal2.defs = function(obj, jsid, body, blockopts) {
        apply_blockopts(body, blockopts);
        if (obj.$$is_string || obj.$$is_number) {
          $raise(Opal2.TypeError, "can't define singleton");
        }
        return Opal2.defn(Opal2.get_singleton_class(obj), jsid, body);
      };
      Opal2.rdef = function(obj, jsid) {
        if (!$has_own(obj.$$prototype, jsid)) {
          $raise(Opal2.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
        }
        delete obj.$$prototype[jsid];
        if (obj.$$is_singleton) {
          if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
            obj.$$prototype.$singleton_method_removed(jsid.substr(1));
          }
        } else {
          if (obj.$method_removed && !obj.$method_removed.$$stub) {
            obj.$method_removed(jsid.substr(1));
          }
        }
      };
      Opal2.udef = function(obj, jsid) {
        if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
          $raise(Opal2.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
        }
        Opal2.add_stub_for(obj.$$prototype, jsid);
        if (obj.$$is_singleton) {
          if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
            obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
          }
        } else {
          if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
            obj.$method_undefined(jsid.substr(1));
          }
        }
      };
      function is_method_body(body) {
        return typeof body === "function" && !body.$$stub;
      }
      Opal2.alias = function(obj, name, old) {
        var id = $jsid(name), old_id = $jsid(old), body, alias;
        if (typeof obj.$$prototype === "undefined") {
          obj = Opal2.Object;
        }
        body = obj.$$prototype[old_id];
        if (obj.$$eval) {
          return Opal2.alias(Opal2.get_singleton_class(obj), name, old);
        }
        if (!is_method_body(body)) {
          var ancestor = obj.$$super;
          while (typeof body !== "function" && ancestor) {
            body = ancestor[old_id];
            ancestor = ancestor.$$super;
          }
          if (!is_method_body(body) && obj.$$is_module) {
            body = Opal2.Object.$$prototype[old_id];
          }
          if (!is_method_body(body)) {
            $raise(Opal2.NameError, "undefined method `" + old + "' for class `" + obj.$name() + "'");
          }
        }
        if (body.$$alias_of)
          body = body.$$alias_of;
        alias = function() {
          var block = alias.$$p, args, i, ii;
          args = new Array(arguments.length);
          for (i = 0, ii = arguments.length; i < ii; i++) {
            args[i] = arguments[i];
          }
          alias.$$p = null;
          return Opal2.send(this, body, args, block);
        };
        try {
          Object.defineProperty(alias, "length", { value: body.length });
        } catch (e) {
        }
        alias.displayName = name;
        alias.$$arity = body.$$arity == null ? body.length : body.$$arity;
        alias.$$parameters = body.$$parameters;
        alias.$$source_location = body.$$source_location;
        alias.$$alias_of = body;
        alias.$$alias_name = name;
        Opal2.defn(obj, id, alias);
        return obj;
      };
      Opal2.alias_gvar = function(new_name, old_name) {
        Object.defineProperty($gvars, new_name, {
          configurable: true,
          enumerable: true,
          get: function() {
            return $gvars[old_name];
          },
          set: function(new_value) {
            $gvars[old_name] = new_value;
          }
        });
        return nil;
      };
      Opal2.alias_native = function(obj, name, native_name) {
        var id = $jsid(name), body = obj.$$prototype[native_name];
        if (typeof body !== "function" || body.$$stub) {
          $raise(Opal2.NameError, "undefined native method `" + native_name + "' for class `" + obj.$name() + "'");
        }
        Opal2.defn(obj, id, body);
        return obj;
      };
      Opal2.hash_init = function(hash) {
        hash.$$smap = /* @__PURE__ */ Object.create(null);
        hash.$$map = /* @__PURE__ */ Object.create(null);
        hash.$$keys = [];
      };
      Opal2.hash_clone = function(from_hash, to_hash) {
        to_hash.$$none = from_hash.$$none;
        to_hash.$$proc = from_hash.$$proc;
        for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
          key = keys[i];
          if (key.$$is_string) {
            value = smap[key];
          } else {
            value = key.value;
            key = key.key;
          }
          Opal2.hash_put(to_hash, key, value);
        }
      };
      Opal2.hash_put = function(hash, key, value) {
        if (key.$$is_string) {
          if (!$has_own(hash.$$smap, key)) {
            hash.$$keys.push(key);
          }
          hash.$$smap[key] = value;
          return;
        }
        var key_hash, bucket, last_bucket;
        key_hash = hash.$$by_identity ? Opal2.id(key) : key.$hash();
        if (!$has_own(hash.$$map, key_hash)) {
          bucket = { key, key_hash, value };
          hash.$$keys.push(bucket);
          hash.$$map[key_hash] = bucket;
          return;
        }
        bucket = hash.$$map[key_hash];
        while (bucket) {
          if (key === bucket.key || key["$eql?"](bucket.key)) {
            last_bucket = void 0;
            bucket.value = value;
            break;
          }
          last_bucket = bucket;
          bucket = bucket.next;
        }
        if (last_bucket) {
          bucket = { key, key_hash, value };
          hash.$$keys.push(bucket);
          last_bucket.next = bucket;
        }
      };
      Opal2.hash_get = function(hash, key) {
        if (key.$$is_string) {
          if ($has_own(hash.$$smap, key)) {
            return hash.$$smap[key];
          }
          return;
        }
        var key_hash, bucket;
        key_hash = hash.$$by_identity ? Opal2.id(key) : key.$hash();
        if ($has_own(hash.$$map, key_hash)) {
          bucket = hash.$$map[key_hash];
          while (bucket) {
            if (key === bucket.key || key["$eql?"](bucket.key)) {
              return bucket.value;
            }
            bucket = bucket.next;
          }
        }
      };
      Opal2.hash_delete = function(hash, key) {
        var i, keys = hash.$$keys, length = keys.length, value, key_tmp;
        if (key.$$is_string) {
          if (typeof key !== "string")
            key = key.valueOf();
          if (!$has_own(hash.$$smap, key)) {
            return;
          }
          for (i = 0; i < length; i++) {
            key_tmp = keys[i];
            if (key_tmp.$$is_string && typeof key_tmp !== "string") {
              key_tmp = key_tmp.valueOf();
            }
            if (key_tmp === key) {
              keys.splice(i, 1);
              break;
            }
          }
          value = hash.$$smap[key];
          delete hash.$$smap[key];
          return value;
        }
        var key_hash = key.$hash();
        if (!$has_own(hash.$$map, key_hash)) {
          return;
        }
        var bucket = hash.$$map[key_hash], last_bucket;
        while (bucket) {
          if (key === bucket.key || key["$eql?"](bucket.key)) {
            value = bucket.value;
            for (i = 0; i < length; i++) {
              if (keys[i] === bucket) {
                keys.splice(i, 1);
                break;
              }
            }
            if (last_bucket && bucket.next) {
              last_bucket.next = bucket.next;
            } else if (last_bucket) {
              delete last_bucket.next;
            } else if (bucket.next) {
              hash.$$map[key_hash] = bucket.next;
            } else {
              delete hash.$$map[key_hash];
            }
            return value;
          }
          last_bucket = bucket;
          bucket = bucket.next;
        }
      };
      Opal2.hash_rehash = function(hash) {
        for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {
          if (hash.$$keys[i].$$is_string) {
            continue;
          }
          key_hash = hash.$$keys[i].key.$hash();
          if (key_hash === hash.$$keys[i].key_hash) {
            continue;
          }
          bucket = hash.$$map[hash.$$keys[i].key_hash];
          last_bucket = void 0;
          while (bucket) {
            if (bucket === hash.$$keys[i]) {
              if (last_bucket && bucket.next) {
                last_bucket.next = bucket.next;
              } else if (last_bucket) {
                delete last_bucket.next;
              } else if (bucket.next) {
                hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
              } else {
                delete hash.$$map[hash.$$keys[i].key_hash];
              }
              break;
            }
            last_bucket = bucket;
            bucket = bucket.next;
          }
          hash.$$keys[i].key_hash = key_hash;
          if (!$has_own(hash.$$map, key_hash)) {
            hash.$$map[key_hash] = hash.$$keys[i];
            continue;
          }
          bucket = hash.$$map[key_hash];
          last_bucket = void 0;
          while (bucket) {
            if (bucket === hash.$$keys[i]) {
              last_bucket = void 0;
              break;
            }
            last_bucket = bucket;
            bucket = bucket.next;
          }
          if (last_bucket) {
            last_bucket.next = hash.$$keys[i];
          }
        }
      };
      Opal2.hash = function() {
        var arguments_length = arguments.length, args, hash, i, length, key, value;
        if (arguments_length === 1 && arguments[0].$$is_hash) {
          return arguments[0];
        }
        hash = new Opal2.Hash();
        Opal2.hash_init(hash);
        if (arguments_length === 1) {
          args = arguments[0];
          if (arguments[0].$$is_array) {
            length = args.length;
            for (i = 0; i < length; i++) {
              if (args[i].length !== 2) {
                $raise(Opal2.ArgumentError, "value not of length 2: " + args[i].$inspect());
              }
              key = args[i][0];
              value = args[i][1];
              Opal2.hash_put(hash, key, value);
            }
            return hash;
          } else {
            args = arguments[0];
            for (key in args) {
              if ($has_own(args, key)) {
                value = args[key];
                Opal2.hash_put(hash, key, value);
              }
            }
            return hash;
          }
        }
        if (arguments_length % 2 !== 0) {
          $raise(Opal2.ArgumentError, "odd number of arguments for Hash");
        }
        for (i = 0; i < arguments_length; i += 2) {
          key = arguments[i];
          value = arguments[i + 1];
          Opal2.hash_put(hash, key, value);
        }
        return hash;
      };
      Opal2.hash2 = function(keys, smap) {
        var hash = new Opal2.Hash();
        hash.$$smap = smap;
        hash.$$map = /* @__PURE__ */ Object.create(null);
        hash.$$keys = keys;
        return hash;
      };
      Opal2.range = function(first, last, exc) {
        var range = new Opal2.Range();
        range.begin = first;
        range.end = last;
        range.excl = exc;
        return range;
      };
      var reserved_ivar_names = [
        // properties
        "constructor",
        "displayName",
        "__count__",
        "__noSuchMethod__",
        "__parent__",
        "__proto__",
        // methods
        "hasOwnProperty",
        "valueOf"
      ];
      Opal2.ivar = function(name) {
        if (reserved_ivar_names.indexOf(name) !== -1) {
          name += "$";
        }
        return name;
      };
      function $deny_frozen_access(obj) {
        if (obj.$$frozen) {
          $raise(Opal2.FrozenError, "can't modify frozen " + obj.$class() + ": " + obj, Opal2.hash2(["receiver"], { "receiver": obj }));
        }
      }
      ;
      Opal2.deny_frozen_access = $deny_frozen_access;
      Opal2.freeze = function(obj) {
        $prop(obj, "$$frozen", true);
        if (!obj.hasOwnProperty("$$id")) {
          $prop(obj, "$$id", $uid());
        }
        if (obj.hasOwnProperty("$$meta")) {
          obj.$$meta.$freeze();
        } else {
          $prop(obj, "$$meta", null);
        }
        if (!obj.hasOwnProperty("$$comparable")) {
          $prop(obj, "$$comparable", null);
        }
        Object.seal(obj);
        return obj;
      };
      Opal2.freeze_props = function(obj) {
        var prop, prop_type, desc;
        for (prop in obj) {
          prop_type = typeof prop;
          if ((prop_type === "string" || prop_type === "object") && prop[0] === "$") {
            continue;
          }
          desc = Object.getOwnPropertyDescriptor(obj, prop);
          if (desc && desc.enumerable && desc.writable) {
            (function() {
              var cv = obj[prop];
              Object.defineProperty(obj, prop, {
                get: function() {
                  return cv;
                },
                set: function(_val) {
                  $deny_frozen_access(obj);
                },
                enumerable: true
              });
            })();
          }
        }
      };
      Opal2.escape_regexp = function(str) {
        return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, "\\$1").replace(/[\n]/g, "\\n").replace(/[\r]/g, "\\r").replace(/[\f]/g, "\\f").replace(/[\t]/g, "\\t");
      };
      Opal2.global_regexp = function(pattern) {
        if (pattern.global) {
          return pattern;
        }
        if (pattern.$$g == null) {
          pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? "gm" : "g") + (pattern.ignoreCase ? "i" : ""));
        } else {
          pattern.$$g.lastIndex = null;
        }
        return pattern.$$g;
      };
      Opal2.global_multiline_regexp = function(pattern) {
        var result, flags;
        if (pattern.global && pattern.multiline)
          return pattern;
        flags = "gm" + (pattern.ignoreCase ? "i" : "");
        if (pattern.multiline) {
          if (pattern.$$g == null) {
            pattern.$$g = new RegExp(pattern.source, flags);
          }
          result = pattern.$$g;
        } else {
          if (pattern.$$gm == null) {
            pattern.$$gm = new RegExp(pattern.source, flags);
          }
          result = pattern.$$gm;
        }
        result.lastIndex = null;
        return result;
      };
      Opal2.regexp = function(parts, flags) {
        var part;
        var ignoreCase = typeof flags !== "undefined" && flags && flags.indexOf("i") >= 0;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];
          if (part instanceof RegExp) {
            if (part.ignoreCase !== ignoreCase)
              Opal2.Kernel.$warn(
                "ignore case doesn't match for " + part.source.$inspect(),
                Opal2.hash({ uplevel: 1 })
              );
            part = part.source;
          }
          if (part === "")
            part = "(?:" + part + ")";
          parts[i] = part;
        }
        if (flags) {
          return new RegExp(parts.join(""), flags);
        } else {
          return new RegExp(parts.join(""));
        }
      };
      Opal2.modules = {};
      Opal2.loaded_features = ["corelib/runtime"];
      Opal2.current_dir = ".";
      Opal2.require_table = { "corelib/runtime": true };
      Opal2.normalize = function(path) {
        var parts, part, new_parts = [], SEPARATOR = "/";
        if (Opal2.current_dir !== ".") {
          path = Opal2.current_dir.replace(/\/*$/, "/") + path;
        }
        path = path.replace(/^\.\//, "");
        path = path.replace(/\.(rb|opal|js)$/, "");
        parts = path.split(SEPARATOR);
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];
          if (part === "")
            continue;
          part === ".." ? new_parts.pop() : new_parts.push(part);
        }
        return new_parts.join(SEPARATOR);
      };
      Opal2.loaded = function(paths) {
        var i, l, path;
        for (i = 0, l = paths.length; i < l; i++) {
          path = Opal2.normalize(paths[i]);
          if (Opal2.require_table[path]) {
            continue;
          }
          Opal2.loaded_features.push(path);
          Opal2.require_table[path] = true;
        }
      };
      Opal2.load_normalized = function(path) {
        Opal2.loaded([path]);
        var module2 = Opal2.modules[path];
        if (module2) {
          var retval = module2(Opal2);
          if (typeof Promise !== "undefined" && retval instanceof Promise) {
            return retval.then($return_val(true));
          }
        } else {
          var severity = Opal2.config.missing_require_severity;
          var message = "cannot load such file -- " + path;
          if (severity === "error") {
            $raise(Opal2.LoadError, message);
          } else if (severity === "warning") {
            console2.warn("WARNING: LoadError: " + message);
          }
        }
        return true;
      };
      Opal2.load = function(path) {
        path = Opal2.normalize(path);
        return Opal2.load_normalized(path);
      };
      Opal2.require = function(path) {
        path = Opal2.normalize(path);
        if (Opal2.require_table[path]) {
          return false;
        }
        return Opal2.load_normalized(path);
      };
      Opal2.encodings = /* @__PURE__ */ Object.create(null);
      Opal2.set_encoding = function(str, name, type) {
        if (typeof type === "undefined")
          type = "encoding";
        if (typeof str === "string" || str.$$frozen === true)
          $raise(Opal2.FrozenError, "can't modify frozen String");
        var encoding = Opal2.find_encoding(name);
        if (encoding === str[type]) {
          return str;
        }
        str[type] = encoding;
        return str;
      };
      Opal2.find_encoding = function(name) {
        var register = Opal2.encodings;
        var encoding = register[name] || register[name.toUpperCase()];
        if (!encoding)
          $raise(Opal2.ArgumentError, "unknown encoding name - " + name);
        return encoding;
      };
      Opal2.enc = function(str, name) {
        var dup = new String(str);
        dup = Opal2.set_encoding(dup, name);
        dup.internal_encoding = dup.encoding;
        return dup;
      };
      Opal2.binary = function(str) {
        var dup = new String(str);
        return Opal2.set_encoding(dup, "binary", "internal_encoding");
      };
      Opal2.last_promise = null;
      Opal2.promise_unhandled_exception = false;
      Opal2.queue = function(proc) {
        if (Opal2.last_promise) {
          Opal2.last_promise = Opal2.last_promise.then(function() {
            if (!Opal2.promise_unhandled_exception)
              return proc(Opal2);
          })["catch"](function(error) {
            if (Opal2.respond_to(error, "$full_message")) {
              error = error.$full_message();
            }
            console2.error(error);
            Opal2.promise_unhandled_exception = true;
            Opal2.exit(1);
          });
          return Opal2.last_promise;
        } else {
          var ret = proc(Opal2);
          if (typeof Promise === "function" && typeof ret === "object" && ret instanceof Promise) {
            Opal2.last_promise = ret;
          }
          return ret;
        }
      };
      function are_both_numbers(l, r) {
        return typeof l === "number" && typeof r === "number";
      }
      Opal2.rb_plus = function(l, r) {
        return are_both_numbers(l, r) ? l + r : l["$+"](r);
      };
      Opal2.rb_minus = function(l, r) {
        return are_both_numbers(l, r) ? l - r : l["$-"](r);
      };
      Opal2.rb_times = function(l, r) {
        return are_both_numbers(l, r) ? l * r : l["$*"](r);
      };
      Opal2.rb_divide = function(l, r) {
        return are_both_numbers(l, r) ? l / r : l["$/"](r);
      };
      Opal2.rb_lt = function(l, r) {
        return are_both_numbers(l, r) ? l < r : l["$<"](r);
      };
      Opal2.rb_gt = function(l, r) {
        return are_both_numbers(l, r) ? l > r : l["$>"](r);
      };
      Opal2.rb_le = function(l, r) {
        return are_both_numbers(l, r) ? l <= r : l["$<="](r);
      };
      Opal2.rb_ge = function(l, r) {
        return are_both_numbers(l, r) ? l >= r : l["$>="](r);
      };
      function are_both_numbers_or_strings(lhs, rhs) {
        return typeof lhs === "number" && typeof rhs === "number" || typeof lhs === "string" && typeof rhs === "string";
      }
      function $eqeq(lhs, rhs) {
        return are_both_numbers_or_strings(lhs, rhs) ? lhs === rhs : $truthy(lhs["$=="](rhs));
      }
      ;
      Opal2.eqeq = $eqeq;
      Opal2.eqeqeq = function(lhs, rhs) {
        return are_both_numbers_or_strings(lhs, rhs) ? lhs === rhs : $truthy(lhs["$==="](rhs));
      };
      Opal2.neqeq = function(lhs, rhs) {
        return are_both_numbers_or_strings(lhs, rhs) ? lhs !== rhs : $truthy(lhs["$!="](rhs));
      };
      Opal2.not = function(arg) {
        if (void 0 === arg || null === arg || false === arg || nil === arg)
          return true;
        if (true === arg || arg["$!"].$$pristine)
          return false;
        return $truthy(arg["$!"]());
      };
      function $return_val(arg) {
        return function() {
          return arg;
        };
      }
      Opal2.return_val = $return_val;
      Opal2.return_self = function() {
        return this;
      };
      Opal2.return_ivar = function(ivar) {
        return function() {
          if (this[ivar] == null) {
            return nil;
          }
          return this[ivar];
        };
      };
      Opal2.assign_ivar = function(ivar) {
        return function(val) {
          $deny_frozen_access(this);
          return this[ivar] = val;
        };
      };
      Opal2.assign_ivar_val = function(ivar, static_val) {
        return function() {
          $deny_frozen_access(this);
          return this[ivar] = static_val;
        };
      };
      Opal2.ensure_kwargs = function(kwargs) {
        if (kwargs == null) {
          return Opal2.hash2([], {});
        } else if (kwargs.$$is_hash) {
          return kwargs;
        } else {
          $raise(Opal2.ArgumentError, "expected kwargs");
        }
      };
      Opal2.get_kwarg = function(kwargs, key) {
        if (!$has_own(kwargs.$$smap, key)) {
          $raise(Opal2.ArgumentError, "missing keyword: " + key);
        }
        return kwargs.$$smap[key];
      };
      Opal2.large_array_unpack = function(str) {
        var array = str.split(","), length = array.length, i;
        for (i = 0; i < length; i++) {
          switch (array[i][0]) {
            case void 0:
              array[i] = nil;
              break;
            case "-":
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              array[i] = +array[i];
          }
        }
        return array;
      };
      Opal2.BasicObject = BasicObject = $allocate_class("BasicObject", null);
      Opal2.Object = _Object = $allocate_class("Object", Opal2.BasicObject);
      Opal2.Module = Module = $allocate_class("Module", Opal2.Object);
      Opal2.Class = Class = $allocate_class("Class", Opal2.Module);
      Opal2.Opal = _Opal = $allocate_module("Opal");
      Opal2.Kernel = Kernel = $allocate_module("Kernel");
      $set_proto(Opal2.BasicObject, Opal2.Class.$$prototype);
      $set_proto(Opal2.Object, Opal2.Class.$$prototype);
      $set_proto(Opal2.Module, Opal2.Class.$$prototype);
      $set_proto(Opal2.Class, Opal2.Class.$$prototype);
      BasicObject.$$const.BasicObject = BasicObject;
      $const_set(_Object, "BasicObject", BasicObject);
      $const_set(_Object, "Object", _Object);
      $const_set(_Object, "Module", Module);
      $const_set(_Object, "Class", Class);
      $const_set(_Object, "Opal", _Opal);
      $const_set(_Object, "Kernel", Kernel);
      BasicObject.$$class = Class;
      _Object.$$class = Class;
      Module.$$class = Class;
      Class.$$class = Class;
      _Opal.$$class = Module;
      Kernel.$$class = Module;
      $prop(_Object.$$prototype, "toString", function() {
        var to_s = this.$to_s();
        if (to_s.$$is_string && typeof to_s === "object") {
          return to_s.valueOf();
        } else {
          return to_s;
        }
      });
      $prop(_Object.$$prototype, "$require", Opal2.require);
      Opal2.top = new _Object();
      Opal2.top.$to_s = Opal2.top.$inspect = $return_val("main");
      Opal2.top.$define_method = top_define_method;
      function top_define_method() {
        var args = $slice(arguments);
        var block = top_define_method.$$p;
        top_define_method.$$p = null;
        return Opal2.send(_Object, "define_method", args, block);
      }
      ;
      Opal2.NilClass = $allocate_class("NilClass", Opal2.Object);
      $const_set(_Object, "NilClass", Opal2.NilClass);
      nil = Opal2.nil = new Opal2.NilClass();
      nil.$$id = nil_id;
      nil.call = nil.apply = function() {
        $raise(Opal2.LocalJumpError, "no block given");
      };
      nil.$$frozen = true;
      nil.$$comparable = false;
      Object.seal(nil);
      Opal2.thrower = function(type) {
        var thrower = new Error("unexpected " + type);
        thrower.$thrower_type = type;
        thrower.$throw = function(value) {
          if (value == null)
            value = nil;
          thrower.$v = value;
          throw thrower;
        };
        return thrower;
      };
      Opal2.t_eval_return = Opal2.thrower("return");
      TypeError.$$super = Error;
      Opal2.file_sources = {};
    }).call(void 0);
    Opal.loaded(["corelib/runtime.js"]);
    Opal.modules["corelib/helpers"] = function(Opal2) {
      var $type_error = Opal2.type_error, $coerce_to = Opal2.coerce_to, $module = Opal2.module, $defs = Opal2.defs, $slice = Opal2.slice, $eqeqeq = Opal2.eqeqeq, $Kernel = Opal2.Kernel, $truthy = Opal2.truthy, $Opal = Opal2.Opal, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__");
      return function($base) {
        var self = $module($base, "Opal");
        $defs(self, "$bridge", function $$bridge(constructor, klass) {
          return Opal2.bridge(constructor, klass);
        });
        $defs(self, "$coerce_to!", function $Opal_coerce_to$excl$1(object, type, method, $a) {
          var $post_args, args, coerced = nil;
          $post_args = $slice(arguments, 3);
          args = $post_args;
          coerced = $coerce_to(object, type, method, args);
          if (!$eqeqeq(type, coerced)) {
            $Kernel.$raise($type_error(object, type, method, coerced));
          }
          ;
          return coerced;
        }, -4);
        $defs(self, "$coerce_to?", function $Opal_coerce_to$ques$2(object, type, method, $a) {
          var $post_args, args, coerced = nil;
          $post_args = $slice(arguments, 3);
          args = $post_args;
          if (!$truthy(object["$respond_to?"](method))) {
            return nil;
          }
          ;
          coerced = $coerce_to(object, type, method, args);
          if ($truthy(coerced["$nil?"]())) {
            return nil;
          }
          ;
          if (!$eqeqeq(type, coerced)) {
            $Kernel.$raise($type_error(object, type, method, coerced));
          }
          ;
          return coerced;
        }, -4);
        $defs(self, "$try_convert", function $$try_convert(object, type, method) {
          if ($eqeqeq(type, object)) {
            return object;
          }
          ;
          if ($truthy(object["$respond_to?"](method))) {
            return object.$__send__(method);
          } else {
            return nil;
          }
          ;
        });
        $defs(self, "$compare", function $$compare(a, b) {
          var compare = nil;
          compare = a["$<=>"](b);
          if ($truthy(compare === nil)) {
            $Kernel.$raise($$$("ArgumentError"), "comparison of " + a.$class() + " with " + b.$class() + " failed");
          }
          ;
          return compare;
        });
        $defs(self, "$destructure", function $$destructure(args) {
          if (args.length == 1) {
            return args[0];
          } else if (args.$$is_array) {
            return args;
          } else {
            var args_ary = new Array(args.length);
            for (var i = 0, l = args_ary.length; i < l; i++) {
              args_ary[i] = args[i];
            }
            return args_ary;
          }
        });
        $defs(self, "$respond_to?", function $Opal_respond_to$ques$3(obj, method, include_all) {
          if (include_all == null)
            include_all = false;
          if (obj == null || !obj.$$class) {
            return false;
          }
          ;
          return obj["$respond_to?"](method, include_all);
        }, -3);
        $defs(self, "$instance_variable_name!", function $Opal_instance_variable_name$excl$4(name) {
          name = $Opal["$coerce_to!"](name, $$$("String"), "to_str");
          if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
            $Kernel.$raise($$$("NameError").$new("'" + name + "' is not allowed as an instance variable name", name));
          }
          ;
          return name;
        });
        $defs(self, "$class_variable_name!", function $Opal_class_variable_name$excl$5(name) {
          name = $Opal["$coerce_to!"](name, $$$("String"), "to_str");
          if ($truthy(name.length < 3 || name.slice(0, 2) !== "@@")) {
            $Kernel.$raise($$$("NameError").$new("`" + name + "' is not allowed as a class variable name", name));
          }
          ;
          return name;
        });
        $defs(self, "$const_name?", function $Opal_const_name$ques$6(const_name) {
          if (typeof const_name !== "string") {
            const_name = $Opal["$coerce_to!"](const_name, $$$("String"), "to_str");
          }
          return const_name[0] === const_name[0].toUpperCase();
        });
        $defs(self, "$const_name!", function $Opal_const_name$excl$7(const_name) {
          var $a, self2 = this;
          if ($truthy(($a = $$$("::", "String", "skip_raise")) ? "constant" : nil)) {
            const_name = $Opal["$coerce_to!"](const_name, $$$("String"), "to_str");
          }
          ;
          if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
            self2.$raise($$$("NameError"), "wrong constant name " + const_name);
          }
          ;
          return const_name;
        });
        $defs(self, "$pristine", function $$pristine(owner_class, $a) {
          var $post_args, method_names;
          $post_args = $slice(arguments, 1);
          method_names = $post_args;
          var method_name, method;
          for (var i = method_names.length - 1; i >= 0; i--) {
            method_name = method_names[i];
            method = owner_class.$$prototype[Opal2.jsid(method_name)];
            if (method && !method.$$stub) {
              method.$$pristine = true;
            }
          }
          ;
          return nil;
        }, -2);
        var inspect_stack = [];
        return $defs(self, "$inspect", function $$inspect(value) {
          var e = nil;
          ;
          var pushed = false;
          return function() {
            try {
              try {
                if (value === null) {
                  return "null";
                } else if (value === void 0) {
                  return "undefined";
                } else if (typeof value.$$class === "undefined") {
                  return Object.prototype.toString.apply(value);
                } else if (typeof value.$inspect !== "function" || value.$inspect.$$stub) {
                  return "#<" + value.$$class + ":0x" + value.$__id__().$to_s(16) + ">";
                } else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
                  return "#<" + value.$$class + ":0x" + value.$__id__().$to_s(16) + ">";
                } else {
                  inspect_stack.push(value.$__id__());
                  pushed = true;
                  return value.$inspect();
                }
                ;
                return nil;
              } catch ($err) {
                if (Opal2.rescue($err, [$$$("Exception")])) {
                  e = $err;
                  try {
                    return "#<" + value.$$class + ":0x" + value.$__id__().$to_s(16) + ">";
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
            } finally {
              if (pushed)
                inspect_stack.pop();
            }
            ;
          }();
          ;
        }, -1);
      }("::");
    };
    Opal.modules["corelib/module"] = function(Opal2) {
      var $truthy = Opal2.truthy, $coerce_to = Opal2.coerce_to, $const_set = Opal2.const_set, $Object = Opal2.Object, $return_ivar = Opal2.return_ivar, $assign_ivar = Opal2.assign_ivar, $ivar = Opal2.ivar, $deny_frozen_access = Opal2.deny_frozen_access, $freeze = Opal2.freeze, $prop = Opal2.prop, $jsid = Opal2.jsid, $klass = Opal2.klass, $defs = Opal2.defs, $send = Opal2.send, $def = Opal2.def, $eqeqeq = Opal2.eqeqeq, $Module = Opal2.Module, $Kernel = Opal2.Kernel, $rb_lt = Opal2.rb_lt, $rb_gt = Opal2.rb_gt, $slice = Opal2.slice, $to_a = Opal2.to_a, $hash2 = Opal2.hash2, $Opal = Opal2.Opal, $return_val = Opal2.return_val, $eqeq = Opal2.eqeq, $lambda = Opal2.lambda, $range = Opal2.range, $send2 = Opal2.send2, $find_super = Opal2.find_super, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,pristine,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,frozen?,name,append_features,included,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,module_exec,inspect");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Module");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $defs(self, "$allocate", function $$allocate() {
          var self2 = this;
          var module2 = Opal2.allocate_module(nil, function() {
          });
          if (self2 !== Opal2.Module)
            Object.setPrototypeOf(module2, self2.$$prototype);
          return module2;
        });
        $def(self, "$initialize", function $$initialize() {
          var block = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          ;
          if (block !== nil) {
            return $send(self2, "module_eval", [], block.$to_proc());
          } else {
            return nil;
          }
          ;
        });
        $def(self, "$===", function $Module_$eq_eq_eq$1(object) {
          var self2 = this;
          if ($truthy(object == null)) {
            return false;
          }
          ;
          return Opal2.is_a(object, self2);
          ;
        });
        $def(self, "$<", function $Module_$lt$2(other) {
          var self2 = this;
          if (!$eqeqeq($Module, other)) {
            $Kernel.$raise($$$("TypeError"), "compared with non class/module");
          }
          ;
          var working = self2, ancestors, i, length;
          if (working === other) {
            return false;
          }
          for (i = 0, ancestors = Opal2.ancestors(self2), length = ancestors.length; i < length; i++) {
            if (ancestors[i] === other) {
              return true;
            }
          }
          for (i = 0, ancestors = Opal2.ancestors(other), length = ancestors.length; i < length; i++) {
            if (ancestors[i] === self2) {
              return false;
            }
          }
          return nil;
          ;
        });
        $def(self, "$<=", function $Module_$lt_eq$3(other) {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2["$equal?"](other))) {
            return $ret_or_1;
          } else {
            return $rb_lt(self2, other);
          }
        });
        $def(self, "$>", function $Module_$gt$4(other) {
          var self2 = this;
          if (!$eqeqeq($Module, other)) {
            $Kernel.$raise($$$("TypeError"), "compared with non class/module");
          }
          ;
          return $rb_lt(other, self2);
        });
        $def(self, "$>=", function $Module_$gt_eq$5(other) {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2["$equal?"](other))) {
            return $ret_or_1;
          } else {
            return $rb_gt(self2, other);
          }
        });
        $def(self, "$<=>", function $Module_$lt_eq_gt$6(other) {
          var self2 = this, lt = nil;
          if (self2 === other) {
            return 0;
          }
          ;
          if (!$eqeqeq($Module, other)) {
            return nil;
          }
          ;
          lt = $rb_lt(self2, other);
          if ($truthy(lt["$nil?"]())) {
            return nil;
          }
          ;
          if ($truthy(lt)) {
            return -1;
          } else {
            return 1;
          }
          ;
        });
        $def(self, "$alias_method", function $$alias_method(newname, oldname) {
          var self2 = this;
          $deny_frozen_access(self2);
          newname = $coerce_to(newname, $$$("String"), "to_str");
          oldname = $coerce_to(oldname, $$$("String"), "to_str");
          Opal2.alias(self2, newname, oldname);
          return self2;
        });
        $def(self, "$alias_native", function $$alias_native(mid, jsid) {
          var self2 = this;
          if (jsid == null)
            jsid = mid;
          $deny_frozen_access(self2);
          Opal2.alias_native(self2, mid, jsid);
          return self2;
        }, -2);
        $def(self, "$ancestors", function $$ancestors() {
          var self2 = this;
          return Opal2.ancestors(self2);
        });
        $def(self, "$append_features", function $$append_features(includer) {
          var self2 = this;
          $deny_frozen_access(includer);
          Opal2.append_features(self2, includer);
          return self2;
        });
        $def(self, "$attr_accessor", function $$attr_accessor($a) {
          var $post_args, names, self2 = this;
          $post_args = $slice(arguments);
          names = $post_args;
          $send(self2, "attr_reader", $to_a(names));
          return $send(self2, "attr_writer", $to_a(names));
        }, -1);
        $def(self, "$attr", function $$attr($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          if (args.length == 2 && (args[1] === true || args[1] === false)) {
            self2.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], { "uplevel": 1 }));
            args[1] ? self2.$attr_accessor(args[0]) : self2.$attr_reader(args[0]);
            return nil;
          }
          ;
          return $send(self2, "attr_reader", $to_a(args));
        }, -1);
        $def(self, "$attr_reader", function $$attr_reader($a) {
          var $post_args, names, self2 = this;
          $post_args = $slice(arguments);
          names = $post_args;
          $deny_frozen_access(self2);
          var proto = self2.$$prototype;
          for (var i = names.length - 1; i >= 0; i--) {
            var name = names[i], id = $jsid(name), ivar = $ivar(name);
            var body = $return_ivar(ivar);
            Opal2.prop(proto, ivar, nil);
            body.$$parameters = [];
            body.$$arity = 0;
            Opal2.defn(self2, id, body);
          }
          ;
          return nil;
        }, -1);
        $def(self, "$attr_writer", function $$attr_writer($a) {
          var $post_args, names, self2 = this;
          $post_args = $slice(arguments);
          names = $post_args;
          $deny_frozen_access(self2);
          var proto = self2.$$prototype;
          for (var i = names.length - 1; i >= 0; i--) {
            var name = names[i], id = $jsid(name + "="), ivar = $ivar(name);
            var body = $assign_ivar(ivar);
            body.$$parameters = [["req"]];
            body.$$arity = 1;
            Opal2.prop(proto, ivar, nil);
            Opal2.defn(self2, id, body);
          }
          ;
          return nil;
        }, -1);
        $def(self, "$autoload", function $$autoload(const$, path) {
          var self2 = this;
          $deny_frozen_access(self2);
          if (!$$("Opal")["$const_name?"](const$)) {
            $Kernel.$raise($$$("NameError"), "autoload must be constant name: " + const$);
          }
          if (path == "") {
            $Kernel.$raise($$$("ArgumentError"), "empty file name");
          }
          if (!self2.$$const.hasOwnProperty(const$)) {
            if (!self2.$$autoload) {
              self2.$$autoload = {};
            }
            Opal2.const_cache_version++;
            self2.$$autoload[const$] = { path, loaded: false, required: false, success: false, exception: false };
            if (self2.$const_added && !self2.$const_added.$$pristine) {
              self2.$const_added(const$);
            }
          }
          return nil;
        });
        $def(self, "$autoload?", function $Module_autoload$ques$7(const$) {
          var self2 = this;
          if (self2.$$autoload && self2.$$autoload[const$] && !self2.$$autoload[const$].required && !self2.$$autoload[const$].success) {
            return self2.$$autoload[const$].path;
          }
          var ancestors = self2.$ancestors();
          for (var i = 0, length = ancestors.length; i < length; i++) {
            if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
              return ancestors[i].$$autoload[const$].path;
            }
          }
          return nil;
        });
        $def(self, "$class_variables", function $$class_variables() {
          var self2 = this;
          return Object.keys(Opal2.class_variables(self2));
        });
        $def(self, "$class_variable_get", function $$class_variable_get(name) {
          var self2 = this;
          name = $Opal["$class_variable_name!"](name);
          return Opal2.class_variable_get(self2, name, false);
          ;
        });
        $def(self, "$class_variable_set", function $$class_variable_set(name, value) {
          var self2 = this;
          $deny_frozen_access(self2);
          name = $Opal["$class_variable_name!"](name);
          return Opal2.class_variable_set(self2, name, value);
          ;
        });
        $def(self, "$class_variable_defined?", function $Module_class_variable_defined$ques$8(name) {
          var self2 = this;
          name = $Opal["$class_variable_name!"](name);
          return Opal2.class_variables(self2).hasOwnProperty(name);
          ;
        });
        $def(self, "$const_added", $return_val(nil));
        $Opal.$pristine(self, "const_added");
        $def(self, "$remove_class_variable", function $$remove_class_variable(name) {
          var self2 = this;
          $deny_frozen_access(self2);
          name = $Opal["$class_variable_name!"](name);
          if (Opal2.hasOwnProperty.call(self2.$$cvars, name)) {
            var value = self2.$$cvars[name];
            delete self2.$$cvars[name];
            return value;
          } else {
            $Kernel.$raise($$$("NameError"), "cannot remove " + name + " for " + self2);
          }
          ;
        });
        $def(self, "$constants", function $$constants(inherit) {
          var self2 = this;
          if (inherit == null)
            inherit = true;
          return Opal2.constants(self2, inherit);
          ;
        }, -1);
        $defs(self, "$constants", function $$constants(inherit) {
          var self2 = this;
          ;
          if (inherit == null) {
            var nesting = (self2.$$nesting || []).concat($Object), constant, constants = {}, i, ii;
            for (i = 0, ii = nesting.length; i < ii; i++) {
              for (constant in nesting[i].$$const) {
                constants[constant] = true;
              }
            }
            return Object.keys(constants);
          } else {
            return Opal2.constants(self2, inherit);
          }
          ;
        }, -1);
        $defs(self, "$nesting", function $$nesting() {
          var self2 = this;
          return self2.$$nesting || [];
        });
        $def(self, "$const_defined?", function $Module_const_defined$ques$9(name, inherit) {
          var self2 = this;
          if (inherit == null)
            inherit = true;
          name = $$("Opal")["$const_name!"](name);
          if (!$truthy(name["$=~"]($$$($Opal, "CONST_NAME_REGEXP")))) {
            $Kernel.$raise($$$("NameError").$new("wrong constant name " + name, name));
          }
          ;
          var module2, modules = [self2], module_constants, i, ii;
          if (inherit) {
            modules = modules.concat(Opal2.ancestors(self2));
            if (self2.$$is_module) {
              modules = modules.concat([$Object]).concat(Opal2.ancestors($Object));
            }
          }
          for (i = 0, ii = modules.length; i < ii; i++) {
            module2 = modules[i];
            if (module2.$$const[name] != null) {
              return true;
            }
            if (module2.$$autoload && module2.$$autoload[name] && !module2.$$autoload[name].required && !module2.$$autoload[name].success) {
              return true;
            }
          }
          return false;
          ;
        }, -2);
        $def(self, "$const_get", function $$const_get(name, inherit) {
          var self2 = this;
          if (inherit == null)
            inherit = true;
          name = $$("Opal")["$const_name!"](name);
          if (name.indexOf("::") === 0 && name !== "::") {
            name = name.slice(2);
          }
          ;
          if ($truthy(name.indexOf("::") != -1 && name != "::")) {
            return $send(name.$split("::"), "inject", [self2], function $$10(o, c) {
              if (o == null)
                o = nil;
              if (c == null)
                c = nil;
              return o.$const_get(c);
            });
          }
          ;
          if (!$truthy(name["$=~"]($$$($Opal, "CONST_NAME_REGEXP")))) {
            $Kernel.$raise($$$("NameError").$new("wrong constant name " + name, name));
          }
          ;
          if (inherit) {
            return Opal2.$$([self2], name);
          } else {
            return Opal2.const_get_local(self2, name);
          }
          ;
        }, -2);
        $def(self, "$const_missing", function $$const_missing(name) {
          var self2 = this, full_const_name = nil;
          full_const_name = $eqeq(self2, $Object) ? name : "" + self2 + "::" + name;
          return $Kernel.$raise($$$("NameError").$new("uninitialized constant " + full_const_name, name));
        });
        $def(self, "$const_set", function $$const_set(name, value) {
          var self2 = this;
          $deny_frozen_access(self2);
          name = $Opal["$const_name!"](name);
          if ($truthy(name["$!~"]($$$($Opal, "CONST_NAME_REGEXP"))) || $truthy(name["$start_with?"]("::"))) {
            $Kernel.$raise($$$("NameError").$new("wrong constant name " + name, name));
          }
          ;
          $const_set(self2, name, value);
          return value;
        });
        $def(self, "$public_constant", $return_val(nil));
        $def(self, "$define_method", function $$define_method(name, method) {
          var block = $$define_method.$$p || nil, self2 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          $$define_method.$$p = null;
          ;
          ;
          $deny_frozen_access(self2);
          if (method === void 0 && block === nil)
            $Kernel.$raise($$$("ArgumentError"), "tried to create a Proc object without a block");
          block = $truthy($ret_or_1 = block) ? $ret_or_1 : $eqeqeq($$$("Proc"), $ret_or_2 = method) ? method : $eqeqeq($$$("Method"), $ret_or_2) ? method.$to_proc().$$unbound : $eqeqeq($$$("UnboundMethod"), $ret_or_2) ? $lambda(function $$11($a) {
            var $post_args, args, self3 = $$11.$$s == null ? this : $$11.$$s, bound = nil;
            $post_args = $slice(arguments);
            args = $post_args;
            bound = method.$bind(self3);
            return $send(bound, "call", $to_a(args));
          }, { $$arity: -1, $$s: self2 }) : $Kernel.$raise($$$("TypeError"), "wrong argument type " + block.$class() + " (expected Proc/Method)");
          if (typeof Proxy !== "undefined") {
            var meta = /* @__PURE__ */ Object.create(null);
            block.$$proxy_target = block;
            block = new Proxy(block, {
              apply: function(target, self3, args) {
                var old_name = target.$$jsid;
                target.$$jsid = name;
                try {
                  return target.apply(self3, args);
                } catch (e) {
                  if (e === target.$$brk || e === target.$$ret)
                    return e.$v;
                  throw e;
                } finally {
                  target.$$jsid = old_name;
                }
              }
            });
          }
          block.$$jsid = name;
          block.$$s = null;
          block.$$def = block;
          block.$$define_meth = true;
          return Opal2.defn(self2, $jsid(name), block);
          ;
        }, -2);
        $def(self, "$freeze", function $$freeze() {
          var self2 = this;
          if ($truthy(self2["$frozen?"]())) {
            return self2;
          }
          ;
          if (!self2.hasOwnProperty("$$base_module")) {
            $prop(self2, "$$base_module", null);
          }
          return $freeze(self2);
          ;
        });
        $def(self, "$remove_method", function $$remove_method($a) {
          var $post_args, names, self2 = this;
          $post_args = $slice(arguments);
          names = $post_args;
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            if (!(typeof name === "string" || name.$$is_string)) {
              self2.$raise($$$("TypeError"), "" + self2.$name() + " is not a symbol nor a string");
            }
            $deny_frozen_access(self2);
            Opal2.rdef(self2, "$" + name);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$singleton_class?", function $Module_singleton_class$ques$12() {
          var self2 = this;
          return !!self2.$$is_singleton;
        });
        $def(self, "$include", function $$include($a) {
          var $post_args, mods, self2 = this;
          $post_args = $slice(arguments);
          mods = $post_args;
          for (var i = mods.length - 1; i >= 0; i--) {
            var mod = mods[i];
            if (!mod.$$is_module) {
              $Kernel.$raise($$$("TypeError"), "wrong argument type " + mod.$class() + " (expected Module)");
            }
            mod.$append_features(self2);
            mod.$included(self2);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$included_modules", function $$included_modules() {
          var self2 = this;
          return Opal2.included_modules(self2);
        });
        $def(self, "$include?", function $Module_include$ques$13(mod) {
          var self2 = this;
          if (!mod.$$is_module) {
            $Kernel.$raise($$$("TypeError"), "wrong argument type " + mod.$class() + " (expected Module)");
          }
          var i, ii, mod2, ancestors = Opal2.ancestors(self2);
          for (i = 0, ii = ancestors.length; i < ii; i++) {
            mod2 = ancestors[i];
            if (mod2 === mod && mod2 !== self2) {
              return true;
            }
          }
          return false;
        });
        $def(self, "$instance_method", function $$instance_method(name) {
          var self2 = this;
          var meth = self2.$$prototype[$jsid(name)];
          if (!meth || meth.$$stub) {
            $Kernel.$raise($$$("NameError").$new("undefined method `" + name + "' for class `" + self2.$name() + "'", name));
          }
          return $$$("UnboundMethod").$new(self2, meth.$$owner || self2, meth, name);
        });
        $def(self, "$instance_methods", function $$instance_methods(include_super) {
          var self2 = this;
          if (include_super == null)
            include_super = true;
          if ($truthy(include_super)) {
            return Opal2.instance_methods(self2);
          } else {
            return Opal2.own_instance_methods(self2);
          }
          ;
        }, -1);
        $def(self, "$included", $return_val(nil));
        $def(self, "$extended", $return_val(nil));
        $def(self, "$extend_object", function $$extend_object(object) {
          $deny_frozen_access(object);
          return nil;
        });
        $def(self, "$method_added", function $$method_added($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$method_removed", function $$method_removed($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$method_undefined", function $$method_undefined($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$module_eval", function $$module_eval($a) {
          var block = $$module_eval.$$p || nil, $post_args, args, $b, self2 = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;
          $$module_eval.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy(block["$nil?"]()) && $truthy(!!Opal2.compile)) {
            if (!$truthy($range(1, 3, false)["$cover?"](args.$size()))) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (0 for 1..3)");
            }
            ;
            $b = [].concat($to_a(args)), string = $b[0] == null ? nil : $b[0], file = $b[1] == null ? nil : $b[1], _lineno = $b[2] == null ? nil : $b[2], $b;
            default_eval_options = $hash2(["file", "eval"], { "file": $truthy($ret_or_1 = file) ? $ret_or_1 : "(eval)", "eval": true });
            compiling_options = Opal2.hash({ arity_check: false }).$merge(default_eval_options);
            compiled = $Opal.$compile(string, compiling_options);
            block = $send($Kernel, "proc", [], function $$14() {
              var self3 = $$14.$$s == null ? this : $$14.$$s;
              return new Function("Opal,self", "return " + compiled)(Opal2, self3);
            }, { $$s: self2 });
          } else if ($truthy(args["$any?"]())) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + args.$size() + ` for 0)

  NOTE:If you want to enable passing a String argument please add "require 'opal-parser'" to your script
`);
          }
          ;
          var old = block.$$s, result;
          block.$$s = null;
          result = block.apply(self2, [self2]);
          block.$$s = old;
          return result;
          ;
        }, -1);
        $def(self, "$module_exec", function $$module_exec($a) {
          var block = $$module_exec.$$p || nil, $post_args, args, self2 = this;
          $$module_exec.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if (block === nil) {
            $Kernel.$raise($$$("LocalJumpError"), "no block given");
          }
          var block_self = block.$$s, result;
          block.$$s = null;
          result = block.apply(self2, args);
          block.$$s = block_self;
          return result;
          ;
        }, -1);
        $def(self, "$method_defined?", function $Module_method_defined$ques$15(method) {
          var self2 = this;
          var body = self2.$$prototype[$jsid(method)];
          return !!body && !body.$$stub;
        });
        $def(self, "$module_function", function $$module_function($a) {
          var $post_args, methods, self2 = this;
          $post_args = $slice(arguments);
          methods = $post_args;
          $deny_frozen_access(self2);
          if (methods.length === 0) {
            self2.$$module_function = true;
            return nil;
          } else {
            for (var i = 0, length = methods.length; i < length; i++) {
              var meth = methods[i], id = $jsid(meth), func = self2.$$prototype[id];
              Opal2.defs(self2, id, func);
            }
            return methods.length === 1 ? methods[0] : methods;
          }
          return self2;
          ;
        }, -1);
        $def(self, "$name", function $$name() {
          var self2 = this;
          if (self2.$$full_name) {
            return self2.$$full_name;
          }
          var result = [], base = self2;
          while (base) {
            if (base.$$name === nil || base.$$name == null)
              return nil;
            result.unshift(base.$$name);
            base = base.$$base_module;
            if (base === $Object) {
              break;
            }
          }
          if (result.length === 0) {
            return nil;
          }
          return self2.$$full_name = result.join("::");
        });
        $def(self, "$prepend", function $$prepend($a) {
          var $post_args, mods, self2 = this;
          $post_args = $slice(arguments);
          mods = $post_args;
          if (mods.length === 0) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (given 0, expected 1+)");
          }
          for (var i = mods.length - 1; i >= 0; i--) {
            var mod = mods[i];
            if (!mod.$$is_module) {
              $Kernel.$raise($$$("TypeError"), "wrong argument type " + mod.$class() + " (expected Module)");
            }
            mod.$prepend_features(self2);
            mod.$prepended(self2);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$prepend_features", function $$prepend_features(prepender) {
          var self2 = this;
          $deny_frozen_access(prepender);
          if (!self2.$$is_module) {
            $Kernel.$raise($$$("TypeError"), "wrong argument type " + self2.$class() + " (expected Module)");
          }
          Opal2.prepend_features(self2, prepender);
          return self2;
        });
        $def(self, "$prepended", $return_val(nil));
        $def(self, "$remove_const", function $$remove_const(name) {
          var self2 = this;
          $deny_frozen_access(self2);
          return Opal2.const_remove(self2, name);
          ;
        });
        $def(self, "$to_s", function $$to_s() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = Opal2.Module.$name.call(self2))) {
            return $ret_or_1;
          } else {
            return "#<" + (self2.$$is_module ? "Module" : "Class") + ":0x" + self2.$__id__().$to_s(16) + ">";
          }
        });
        $def(self, "$undef_method", function $$undef_method($a) {
          var $post_args, names, self2 = this;
          $post_args = $slice(arguments);
          names = $post_args;
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            if (!(typeof name === "string" || name.$$is_string)) {
              self2.$raise($$$("TypeError"), "" + self2.$name() + " is not a symbol nor a string");
            }
            $deny_frozen_access(self2);
            Opal2.udef(self2, "$" + names[i]);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$instance_variables", function $$instance_variables() {
          var self2 = this, consts = nil;
          consts = (Opal2.Module.$$nesting = $nesting2, self2.$constants());
          var result = [];
          for (var name in self2) {
            if (self2.hasOwnProperty(name) && name.charAt(0) !== "$" && name !== "constructor" && !consts["$include?"](name)) {
              result.push("@" + name);
            }
          }
          return result;
          ;
        });
        $def(self, "$dup", function $$dup() {
          var $yield = $$dup.$$p || nil, self2 = this, copy = nil;
          $$dup.$$p = null;
          copy = $send2(self2, $find_super(self2, "dup", $$dup, false, true), "dup", [], $yield);
          copy.$copy_class_variables(self2);
          copy.$copy_constants(self2);
          return copy;
        });
        $def(self, "$copy_class_variables", function $$copy_class_variables(other) {
          var self2 = this;
          for (var name in other.$$cvars) {
            self2.$$cvars[name] = other.$$cvars[name];
          }
        });
        $def(self, "$copy_constants", function $$copy_constants(other) {
          var self2 = this;
          var name, other_constants = other.$$const;
          for (name in other_constants) {
            $const_set(self2, name, other_constants[name]);
          }
        });
        $def(self, "$refine", function $$refine(klass) {
          var block = $$refine.$$p || nil, $a, self2 = this, refinement_module = nil, m = nil, klass_id = nil;
          $$refine.$$p = null;
          ;
          $a = [self2, nil, nil], refinement_module = $a[0], m = $a[1], klass_id = $a[2], $a;
          klass_id = Opal2.id(klass);
          if (typeof self2.$$refine_modules === "undefined") {
            self2.$$refine_modules = /* @__PURE__ */ Object.create(null);
          }
          if (typeof self2.$$refine_modules[klass_id] === "undefined") {
            m = self2.$$refine_modules[klass_id] = $$$("Refinement").$new();
          } else {
            m = self2.$$refine_modules[klass_id];
          }
          m.refinement_module = refinement_module;
          m.refined_class = klass;
          $send(m, "class_exec", [], block.$to_proc());
          return m;
        });
        $def(self, "$refinements", function $$refinements() {
          var self2 = this;
          var refine_modules = self2.$$refine_modules, hash = $hash2([], {});
          ;
          if (typeof refine_modules === "undefined")
            return hash;
          for (var id in refine_modules) {
            hash["$[]="](refine_modules[id].refined_class, refine_modules[id]);
          }
          return hash;
        });
        $def(self, "$using", function $$using(mod) {
          return $Kernel.$raise("Module#using is not permitted in methods");
        });
        $alias(self, "class_eval", "module_eval");
        $alias(self, "class_exec", "module_exec");
        return $alias(self, "inspect", "to_s");
      })("::", null, $nesting);
      return function($base, $super) {
        var self = $klass($base, $super, "Refinement");
        var $proto = self.$$prototype;
        $proto.refinement_module = $proto.refined_class = nil;
        self.$attr_reader("refined_class");
        return $def(self, "$inspect", function $$inspect() {
          var $yield = $$inspect.$$p || nil, self2 = this;
          $$inspect.$$p = null;
          if ($truthy(self2.refinement_module)) {
            return "#<refinement:" + self2.refined_class.$inspect() + "@" + self2.refinement_module.$inspect() + ">";
          } else {
            return $send2(self2, $find_super(self2, "inspect", $$inspect, false, true), "inspect", [], $yield);
          }
        });
      }("::", $Module);
    };
    Opal.modules["corelib/class"] = function(Opal2) {
      var $klass = Opal2.klass, $send = Opal2.send, $defs = Opal2.defs, $def = Opal2.def, $rb_plus = Opal2.rb_plus, $return_val = Opal2.return_val, $slice = Opal2.slice, $send2 = Opal2.send2, $find_super = Opal2.find_super, $Kernel = Opal2.Kernel, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s,raise");
      self.$require("corelib/module");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Class");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $defs(self2, "$new", function $Class_new$1(superclass) {
          var block = $Class_new$1.$$p || nil;
          $Class_new$1.$$p = null;
          ;
          if (superclass == null)
            superclass = $$("Object");
          if (!superclass.$$is_class) {
            throw Opal2.TypeError.$new("superclass must be a Class");
          }
          var klass = Opal2.allocate_class(nil, superclass);
          superclass.$inherited(klass);
          block !== nil ? $send(klass, "class_eval", [], block.$to_proc()) : nil;
          return klass;
          ;
        }, -1);
        $def(self2, "$allocate", function $$allocate() {
          var self3 = this;
          var obj = new self3.$$constructor();
          obj.$$id = Opal2.uid();
          return obj;
        });
        $def(self2, "$descendants", function $$descendants() {
          var self3 = this;
          return $rb_plus(self3.$subclasses(), $send(self3.$subclasses(), "map", [], "descendants".$to_proc()).$flatten());
        });
        $def(self2, "$inherited", $return_val(nil));
        $def(self2, "$initialize_dup", function $$initialize_dup(original) {
          var self3 = this;
          self3.$initialize_copy(original);
          self3.$$name = null;
          self3.$$full_name = null;
          ;
        });
        $def(self2, "$new", function $Class_new$2($a) {
          var block = $Class_new$2.$$p || nil, $post_args, args, self3 = this;
          $Class_new$2.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          var object = self3.$allocate();
          Opal2.send(object, object.$initialize, args, block);
          return object;
          ;
        }, -1);
        $def(self2, "$subclasses", function $$subclasses() {
          var self3 = this;
          if (typeof WeakRef !== "undefined") {
            var i, subclass, out = [];
            for (i = 0; i < self3.$$subclasses.length; i++) {
              subclass = self3.$$subclasses[i].deref();
              if (subclass !== void 0) {
                out.push(subclass);
              }
            }
            return out;
          } else {
            return self3.$$subclasses;
          }
        });
        $def(self2, "$superclass", function $$superclass() {
          var self3 = this;
          return self3.$$super || nil;
        });
        $def(self2, "$to_s", function $$to_s() {
          var $yield = $$to_s.$$p || nil, self3 = this;
          $$to_s.$$p = null;
          var singleton_of = self3.$$singleton_of;
          if (singleton_of && singleton_of.$$is_a_module) {
            return "#<Class:" + singleton_of.$name() + ">";
          } else if (singleton_of) {
            return "#<Class:#<" + singleton_of.$$class.$name() + ":0x" + Opal2.id(singleton_of).$to_s(16) + ">>";
          }
          return $send2(self3, $find_super(self3, "to_s", $$to_s, false, true), "to_s", [], null);
        });
        $def(self2, "$attached_object", function $$attached_object() {
          var self3 = this;
          if (self3.$$singleton_of != null) {
            return self3.$$singleton_of;
          } else {
            $Kernel.$raise($$$("TypeError"), "`" + self3 + "' is not a singleton class");
          }
        });
        return $alias(self2, "inspect", "to_s");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/basic_object"] = function(Opal2) {
      "use strict";
      var $klass = Opal2.klass, $slice = Opal2.slice, $def = Opal2.def, $alias = Opal2.alias, $return_val = Opal2.return_val, $Opal = Opal2.Opal, $truthy = Opal2.truthy, $range = Opal2.range, $Kernel = Opal2.Kernel, $to_a = Opal2.to_a, $hash2 = Opal2.hash2, $send = Opal2.send, $eqeq = Opal2.eqeq, $rb_ge = Opal2.rb_ge, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller");
      return function($base, $super) {
        var self = $klass($base, $super, "BasicObject");
        $def(self, "$initialize", function $$initialize($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$==", function $BasicObject_$eq_eq$1(other) {
          var self2 = this;
          return self2 === other;
        });
        $def(self, "$eql?", function $BasicObject_eql$ques$2(other) {
          var self2 = this;
          return self2["$=="](other);
        });
        $alias(self, "equal?", "==");
        $def(self, "$__id__", function $$__id__() {
          var self2 = this;
          if (self2.$$id != null) {
            return self2.$$id;
          }
          Opal2.prop(self2, "$$id", Opal2.uid());
          return self2.$$id;
        });
        $def(self, "$__send__", function $$__send__(symbol, $a) {
          var block = $$__send__.$$p || nil, $post_args, args, self2 = this;
          $$__send__.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if (!symbol.$$is_string) {
            self2.$raise($$$("TypeError"), "" + self2.$inspect() + " is not a symbol nor a string");
          }
          var func = self2[Opal2.jsid(symbol)];
          if (func) {
            if (block !== nil) {
              func.$$p = block;
            }
            return func.apply(self2, args);
          }
          if (block !== nil) {
            self2.$method_missing.$$p = block;
          }
          return self2.$method_missing.apply(self2, [symbol].concat(args));
          ;
        }, -2);
        $def(self, "$!", $return_val(false));
        $Opal.$pristine("!");
        $def(self, "$!=", function $BasicObject_$not_eq$3(other) {
          var self2 = this;
          return self2["$=="](other)["$!"]();
        });
        $def(self, "$instance_eval", function $$instance_eval($a) {
          var block = $$instance_eval.$$p || nil, $post_args, args, $b, self2 = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;
          $$instance_eval.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy(block["$nil?"]()) && $truthy(!!Opal2.compile)) {
            if (!$truthy($range(1, 3, false)["$cover?"](args.$size()))) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (0 for 1..3)");
            }
            ;
            $b = [].concat($to_a(args)), string = $b[0] == null ? nil : $b[0], file = $b[1] == null ? nil : $b[1], _lineno = $b[2] == null ? nil : $b[2], $b;
            default_eval_options = $hash2(["file", "eval"], { "file": $truthy($ret_or_1 = file) ? $ret_or_1 : "(eval)", "eval": true });
            compiling_options = Opal2.hash({ arity_check: false }).$merge(default_eval_options);
            compiled = $Opal.$compile(string, compiling_options);
            block = $send($Kernel, "proc", [], function $$4() {
              var self3 = $$4.$$s == null ? this : $$4.$$s;
              return new Function("Opal,self", "return " + compiled)(Opal2, self3);
            }, { $$s: self2 });
          } else if ($truthy(block["$nil?"]()) && $truthy($rb_ge(args.$length(), 1)) && $eqeq(args.$first()["$[]"](0), "@")) {
            return self2.$instance_variable_get(args.$first());
          } else if ($truthy(args["$any?"]())) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + args.$size() + " for 0)");
          }
          ;
          var old = block.$$s, result;
          block.$$s = null;
          if (self2.$$is_a_module) {
            self2.$$eval = true;
            try {
              result = block.call(self2, self2);
            } finally {
              self2.$$eval = false;
            }
          } else {
            result = block.call(self2, self2);
          }
          block.$$s = old;
          return result;
          ;
        }, -1);
        $def(self, "$instance_exec", function $$instance_exec($a) {
          var block = $$instance_exec.$$p || nil, $post_args, args, self2 = this;
          $$instance_exec.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if (!$truthy(block)) {
            $Kernel.$raise($$$("ArgumentError"), "no block given");
          }
          ;
          var block_self = block.$$s, result;
          block.$$s = null;
          if (self2.$$is_a_module) {
            self2.$$eval = true;
            try {
              result = block.apply(self2, args);
            } finally {
              self2.$$eval = false;
            }
          } else {
            result = block.apply(self2, args);
          }
          block.$$s = block_self;
          return result;
          ;
        }, -1);
        $def(self, "$singleton_method_added", function $$singleton_method_added($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$singleton_method_removed", function $$singleton_method_removed($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$singleton_method_undefined", function $$singleton_method_undefined($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $def(self, "$method_missing", function $$method_missing(symbol, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self2 = this, inspect_result = nil;
          $$method_missing.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          inspect_result = $Opal.$inspect(self2);
          return $Kernel.$raise($$$("NoMethodError").$new("undefined method `" + symbol + "' for " + inspect_result, symbol, args), nil, $Kernel.$caller(1));
        }, -2);
        $Opal.$pristine(self, "method_missing");
        return $def(self, "$respond_to_missing?", function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
          if (include_all == null)
            include_all = false;
          return false;
        }, -2);
      }("::", null);
    };
    Opal.modules["corelib/kernel"] = function(Opal2) {
      "use strict";
      var $truthy = Opal2.truthy, $coerce_to = Opal2.coerce_to, $respond_to = Opal2.respond_to, $Opal = Opal2.Opal, $deny_frozen_access = Opal2.deny_frozen_access, $freeze = Opal2.freeze, $freeze_props = Opal2.freeze_props, $jsid = Opal2.jsid, $module = Opal2.module, $return_val = Opal2.return_val, $def = Opal2.def, $Kernel = Opal2.Kernel, $gvars = Opal2.gvars, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $ensure_kwargs = Opal2.ensure_kwargs, $eqeq = Opal2.eqeq, $hash2 = Opal2.hash2, $rb_plus = Opal2.rb_plus, $eqeqeq = Opal2.eqeqeq, $return_self = Opal2.return_self, $rb_le = Opal2.rb_le, $extract_kwargs = Opal2.extract_kwargs, $rb_lt = Opal2.rb_lt, $Object = Opal2.Object, $alias = Opal2.alias, $klass = Opal2.klass, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("!,=~,==,object_id,raise,new,class,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include");
      (function($base, $parent_nesting) {
        var self = $module($base, "Kernel");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $def(self, "$=~", $return_val(false));
        $def(self, "$!~", function $Kernel_$excl_tilde$1(obj) {
          var self2 = this;
          return self2["$=~"](obj)["$!"]();
        });
        $def(self, "$===", function $Kernel_$eq_eq_eq$2(other) {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.$object_id()["$=="](other.$object_id()))) {
            return $ret_or_1;
          } else {
            return self2["$=="](other);
          }
        });
        $def(self, "$<=>", function $Kernel_$lt_eq_gt$3(other) {
          var self2 = this;
          self2.$$comparable = true;
          var x = self2["$=="](other);
          if (x && x !== nil) {
            return 0;
          }
          return nil;
        });
        $def(self, "$method", function $$method(name) {
          var self2 = this;
          var meth = self2[$jsid(name)];
          if (!meth || meth.$$stub) {
            $Kernel.$raise($$$("NameError").$new("undefined method `" + name + "' for class `" + self2.$class() + "'", name));
          }
          return $$$("Method").$new(self2, meth.$$owner || self2.$class(), meth, name);
        });
        $def(self, "$methods", function $$methods(all) {
          var self2 = this;
          if (all == null)
            all = true;
          if ($truthy(all)) {
            return Opal2.methods(self2);
          } else {
            return Opal2.own_methods(self2);
          }
          ;
        }, -1);
        $def(self, "$public_methods", function $$public_methods(all) {
          var self2 = this;
          if (all == null)
            all = true;
          if ($truthy(all)) {
            return Opal2.methods(self2);
          } else {
            return Opal2.receiver_methods(self2);
          }
          ;
        }, -1);
        $def(self, "$Array", function $$Array(object) {
          var coerced;
          if (object === nil) {
            return [];
          }
          if (object.$$is_array) {
            return object;
          }
          coerced = $Opal["$coerce_to?"](object, $$$("Array"), "to_ary");
          if (coerced !== nil) {
            return coerced;
          }
          coerced = $Opal["$coerce_to?"](object, $$$("Array"), "to_a");
          if (coerced !== nil) {
            return coerced;
          }
          return [object];
        });
        $def(self, "$at_exit", function $$at_exit() {
          var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
          if ($gvars.__at_exit__ == null)
            $gvars.__at_exit__ = nil;
          $$at_exit.$$p = null;
          ;
          $gvars.__at_exit__ = $truthy($ret_or_1 = $gvars.__at_exit__) ? $ret_or_1 : [];
          $gvars.__at_exit__["$<<"](block);
          return block;
        });
        $def(self, "$caller", function $$caller(start, length) {
          if (start == null)
            start = 1;
          if (length == null)
            length = nil;
          var stack, result;
          stack = new Error().$backtrace();
          result = [];
          for (var i = start + 1, ii = stack.length; i < ii; i++) {
            if (!stack[i].match(/runtime\.js/)) {
              result.push(stack[i]);
            }
          }
          if (length != nil)
            result = result.slice(0, length);
          return result;
          ;
        }, -1);
        $def(self, "$caller_locations", function $$caller_locations($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send($send(self2, "caller", $to_a(args)), "map", [], function $$4(loc) {
            if (loc == null)
              loc = nil;
            return $$$($$$($$$("Thread"), "Backtrace"), "Location").$new(loc);
          });
        }, -1);
        $def(self, "$class", function $Kernel_class$5() {
          var self2 = this;
          return self2.$$class;
        });
        $def(self, "$copy_instance_variables", function $$copy_instance_variables(other) {
          var self2 = this;
          var keys = Object.keys(other), i, ii, name;
          for (i = 0, ii = keys.length; i < ii; i++) {
            name = keys[i];
            if (name.charAt(0) !== "$" && other.hasOwnProperty(name)) {
              self2[name] = other[name];
            }
          }
        });
        $def(self, "$copy_singleton_methods", function $$copy_singleton_methods(other) {
          var self2 = this;
          var i, name, names, length;
          if (other.hasOwnProperty("$$meta") && other.$$meta !== null) {
            var other_singleton_class = Opal2.get_singleton_class(other);
            var self_singleton_class = Opal2.get_singleton_class(self2);
            names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);
            for (i = 0, length = names.length; i < length; i++) {
              name = names[i];
              if (Opal2.is_method(name)) {
                self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
              }
            }
            self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
            Object.setPrototypeOf(
              self_singleton_class.$$prototype,
              Object.getPrototypeOf(other_singleton_class.$$prototype)
            );
          }
          for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
            name = names[i];
            if (name.charAt(0) === "$" && name.charAt(1) !== "$" && other.hasOwnProperty(name)) {
              self2[name] = other[name];
            }
          }
        });
        $def(self, "$clone", function $$clone($kwargs) {
          var freeze, self2 = this, copy = nil;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = nil;
          if (!($truthy(freeze["$nil?"]()) || $eqeq(freeze, true) || $eqeq(freeze, false))) {
            self2.$raise($$("ArgumentError"), "unexpected value for freeze: " + freeze.$class());
          }
          ;
          copy = self2.$class().$allocate();
          copy.$copy_instance_variables(self2);
          copy.$copy_singleton_methods(self2);
          copy.$initialize_clone(self2, $hash2(["freeze"], { "freeze": freeze }));
          if ($eqeq(freeze, true) || $truthy(freeze["$nil?"]()) && $truthy(self2["$frozen?"]())) {
            copy.$freeze();
          }
          ;
          return copy;
        }, -1);
        $def(self, "$initialize_clone", function $$initialize_clone(other, $kwargs) {
          var freeze, self2 = this;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = nil;
          self2.$initialize_copy(other);
          return self2;
        }, -2);
        $def(self, "$define_singleton_method", function $$define_singleton_method(name, method) {
          var block = $$define_singleton_method.$$p || nil, self2 = this;
          $$define_singleton_method.$$p = null;
          ;
          ;
          return $send(self2.$singleton_class(), "define_method", [name, method], block.$to_proc());
        }, -2);
        $def(self, "$dup", function $$dup() {
          var self2 = this, copy = nil;
          copy = self2.$class().$allocate();
          copy.$copy_instance_variables(self2);
          copy.$initialize_dup(self2);
          return copy;
        });
        $def(self, "$initialize_dup", function $$initialize_dup(other) {
          var self2 = this;
          return self2.$initialize_copy(other);
        });
        $def(self, "$enum_for", function $$enum_for($a, $b) {
          var block = $$enum_for.$$p || nil, $post_args, method, args, self2 = this;
          $$enum_for.$$p = null;
          ;
          $post_args = $slice(arguments);
          if ($post_args.length > 0)
            method = $post_args.shift();
          if (method == null)
            method = "each";
          args = $post_args;
          return $send($$$("Enumerator"), "for", [self2, method].concat($to_a(args)), block.$to_proc());
        }, -1);
        $def(self, "$equal?", function $Kernel_equal$ques$6(other) {
          var self2 = this;
          return self2 === other;
        });
        $def(self, "$exit", function $$exit(status) {
          var $ret_or_1 = nil, block = nil;
          if ($gvars.__at_exit__ == null)
            $gvars.__at_exit__ = nil;
          if (status == null)
            status = true;
          $gvars.__at_exit__ = $truthy($ret_or_1 = $gvars.__at_exit__) ? $ret_or_1 : [];
          while (!$truthy($gvars.__at_exit__["$empty?"]())) {
            block = $gvars.__at_exit__.$pop();
            block.$call();
          }
          ;
          if (status.$$is_boolean) {
            status = status ? 0 : 1;
          } else {
            status = $coerce_to(status, $$$("Integer"), "to_int");
          }
          Opal2.exit(status);
          ;
          return nil;
        }, -1);
        $def(self, "$extend", function $$extend($a) {
          var $post_args, mods, self2 = this;
          $post_args = $slice(arguments);
          mods = $post_args;
          if (mods.length == 0) {
            self2.$raise($$$("ArgumentError"), "wrong number of arguments (given 0, expected 1+)");
          }
          $deny_frozen_access(self2);
          var singleton = self2.$singleton_class();
          for (var i = mods.length - 1; i >= 0; i--) {
            var mod = mods[i];
            if (!mod.$$is_module) {
              $Kernel.$raise($$$("TypeError"), "wrong argument type " + mod.$class() + " (expected Module)");
            }
            mod.$append_features(singleton);
            mod.$extend_object(self2);
            mod.$extended(self2);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$freeze", function $$freeze() {
          var self2 = this;
          if ($truthy(self2["$frozen?"]())) {
            return self2;
          }
          ;
          if (typeof self2 === "object") {
            $freeze_props(self2);
            return $freeze(self2);
          }
          return self2;
          ;
        });
        $def(self, "$frozen?", function $Kernel_frozen$ques$7() {
          var self2 = this;
          switch (typeof self2) {
            case "string":
            case "symbol":
            case "number":
            case "boolean":
              return true;
            case "object":
              return self2.$$frozen || false;
            default:
              return false;
          }
        });
        $def(self, "$gets", function $$gets($a) {
          var $post_args, args;
          if ($gvars.stdin == null)
            $gvars.stdin = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send($gvars.stdin, "gets", $to_a(args));
        }, -1);
        $def(self, "$hash", function $$hash() {
          var self2 = this;
          return self2.$__id__();
        });
        $def(self, "$initialize_copy", $return_val(nil));
        var inspect_stack = [];
        $def(self, "$inspect", function $$inspect() {
          var self2 = this, ivs = nil, id = nil, pushed = nil, e = nil;
          return function() {
            try {
              try {
                ivs = "";
                id = self2.$__id__();
                if ($truthy(inspect_stack["$include?"](id))) {
                  ivs = " ...";
                } else {
                  inspect_stack["$<<"](id);
                  pushed = true;
                  $send(self2.$instance_variables(), "each", [], function $$8(i) {
                    var self3 = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;
                    if (i == null)
                      i = nil;
                    ivar = self3.$instance_variable_get(i);
                    inspect = $$("Opal").$inspect(ivar);
                    return ivs = $rb_plus(ivs, " " + i + "=" + inspect);
                  }, { $$s: self2 });
                }
                ;
                return "#<" + self2.$class() + ":0x" + id.$to_s(16) + ivs + ">";
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StandardError")])) {
                  e = $err;
                  try {
                    return "#<" + self2.$class() + ":0x" + id.$to_s(16) + ">";
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
            } finally {
              $truthy(pushed) ? inspect_stack.$pop() : nil;
            }
            ;
          }();
        });
        $def(self, "$instance_of?", function $Kernel_instance_of$ques$9(klass) {
          var self2 = this;
          if (!klass.$$is_class && !klass.$$is_module) {
            $Kernel.$raise($$$("TypeError"), "class or module required");
          }
          return self2.$$class === klass;
        });
        $def(self, "$instance_variable_defined?", function $Kernel_instance_variable_defined$ques$10(name) {
          var self2 = this;
          name = $Opal["$instance_variable_name!"](name);
          return Opal2.hasOwnProperty.call(self2, name.substr(1));
          ;
        });
        $def(self, "$instance_variable_get", function $$instance_variable_get(name) {
          var self2 = this;
          name = $Opal["$instance_variable_name!"](name);
          var ivar = self2[Opal2.ivar(name.substr(1))];
          return ivar == null ? nil : ivar;
          ;
        });
        $def(self, "$instance_variable_set", function $$instance_variable_set(name, value) {
          var self2 = this;
          $deny_frozen_access(self2);
          name = $Opal["$instance_variable_name!"](name);
          return self2[Opal2.ivar(name.substr(1))] = value;
          ;
        });
        $def(self, "$remove_instance_variable", function $$remove_instance_variable(name) {
          var self2 = this;
          name = $Opal["$instance_variable_name!"](name);
          var key = Opal2.ivar(name.substr(1)), val;
          if (self2.hasOwnProperty(key)) {
            val = self2[key];
            delete self2[key];
            return val;
          }
          ;
          return $Kernel.$raise($$$("NameError"), "instance variable " + name + " not defined");
        });
        $def(self, "$instance_variables", function $$instance_variables() {
          var self2 = this;
          var result = [], ivar;
          for (var name in self2) {
            if (self2.hasOwnProperty(name) && name.charAt(0) !== "$") {
              if (name.substr(-1) === "$") {
                ivar = name.slice(0, name.length - 1);
              } else {
                ivar = name;
              }
              result.push("@" + ivar);
            }
          }
          return result;
        });
        $def(self, "$Integer", function $$Integer(value, base) {
          ;
          var i, str, base_digits;
          if (!value.$$is_string) {
            if (base !== void 0) {
              $Kernel.$raise($$$("ArgumentError"), "base specified for non string value");
            }
            if (value === nil) {
              $Kernel.$raise($$$("TypeError"), "can't convert nil into Integer");
            }
            if (value.$$is_number) {
              if (value === Infinity || value === -Infinity || isNaN(value)) {
                $Kernel.$raise($$$("FloatDomainError"), value);
              }
              return Math.floor(value);
            }
            if (value["$respond_to?"]("to_int")) {
              i = value.$to_int();
              if (i !== nil) {
                return i;
              }
            }
            return $Opal["$coerce_to!"](value, $$$("Integer"), "to_i");
          }
          if (value === "0") {
            return 0;
          }
          if (base === void 0) {
            base = 0;
          } else {
            base = $coerce_to(base, $$$("Integer"), "to_int");
            if (base === 1 || base < 0 || base > 36) {
              $Kernel.$raise($$$("ArgumentError"), "invalid radix " + base);
            }
          }
          str = value.toLowerCase();
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function(_, head, flag) {
            switch (flag) {
              case "0b":
                if (base === 0 || base === 2) {
                  base = 2;
                  return head;
                }
              case "0":
              case "0o":
                if (base === 0 || base === 8) {
                  base = 8;
                  return head;
                }
              case "0d":
                if (base === 0 || base === 10) {
                  base = 10;
                  return head;
                }
              case "0x":
                if (base === 0 || base === 16) {
                  base = 16;
                  return head;
                }
            }
            $Kernel.$raise($$$("ArgumentError"), 'invalid value for Integer(): "' + value + '"');
          });
          base = base === 0 ? 10 : base;
          base_digits = "0-" + (base <= 10 ? base - 1 : "9a-" + String.fromCharCode(97 + (base - 11)));
          if (!new RegExp("^\\s*[+-]?[" + base_digits + "]+\\s*$").test(str)) {
            $Kernel.$raise($$$("ArgumentError"), 'invalid value for Integer(): "' + value + '"');
          }
          i = parseInt(str, base);
          if (isNaN(i)) {
            $Kernel.$raise($$$("ArgumentError"), 'invalid value for Integer(): "' + value + '"');
          }
          return i;
          ;
        }, -2);
        $def(self, "$Float", function $$Float(value) {
          var str;
          if (value === nil) {
            $Kernel.$raise($$$("TypeError"), "can't convert nil into Float");
          }
          if (value.$$is_string) {
            str = value.toString();
            str = str.replace(/(\d)_(?=\d)/g, "$1");
            if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
              return $Kernel.$Integer(str);
            }
            if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
              $Kernel.$raise($$$("ArgumentError"), 'invalid value for Float(): "' + value + '"');
            }
            return parseFloat(str);
          }
          return $Opal["$coerce_to!"](value, $$$("Float"), "to_f");
        });
        $def(self, "$Hash", function $$Hash(arg) {
          if ($truthy(arg["$nil?"]()) || $eqeq(arg, [])) {
            return $hash2([], {});
          }
          ;
          if ($eqeqeq($$$("Hash"), arg)) {
            return arg;
          }
          ;
          return $Opal["$coerce_to!"](arg, $$$("Hash"), "to_hash");
        });
        $def(self, "$is_a?", function $Kernel_is_a$ques$11(klass) {
          var self2 = this;
          if (!klass.$$is_class && !klass.$$is_module) {
            $Kernel.$raise($$$("TypeError"), "class or module required");
          }
          return Opal2.is_a(self2, klass);
        });
        $def(self, "$itself", $return_self);
        $def(self, "$lambda", function $$lambda() {
          var block = $$lambda.$$p || nil;
          $$lambda.$$p = null;
          ;
          return Opal2.lambda(block);
          ;
        });
        $def(self, "$load", function $$load(file) {
          file = $Opal["$coerce_to!"](file, $$$("String"), "to_str");
          return Opal2.load(file);
        });
        $def(self, "$loop", function $$loop() {
          var $yield = $$loop.$$p || nil, self2 = this, e = nil;
          $$loop.$$p = null;
          if (!($yield !== nil)) {
            return $send(self2, "enum_for", ["loop"], function $$12() {
              return $$$($$$("Float"), "INFINITY");
            });
          }
          ;
          while ($truthy(true)) {
            try {
              Opal2.yieldX($yield, []);
            } catch ($err) {
              if (Opal2.rescue($err, [$$$("StopIteration")])) {
                e = $err;
                try {
                  return e.$result();
                } finally {
                  Opal2.pop_exception();
                }
              } else {
                throw $err;
              }
            }
            ;
          }
          ;
          return self2;
        });
        $def(self, "$nil?", $return_val(false));
        $def(self, "$printf", function $$printf($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy(args["$any?"]())) {
            self2.$print($send(self2, "format", $to_a(args)));
          }
          ;
          return nil;
        }, -1);
        $def(self, "$proc", function $$proc() {
          var block = $$proc.$$p || nil;
          $$proc.$$p = null;
          ;
          if (!$truthy(block)) {
            $Kernel.$raise($$$("ArgumentError"), "tried to create Proc object without a block");
          }
          ;
          block.$$is_lambda = false;
          return block;
        });
        $def(self, "$puts", function $$puts($a) {
          var $post_args, strs;
          if ($gvars.stdout == null)
            $gvars.stdout = nil;
          $post_args = $slice(arguments);
          strs = $post_args;
          return $send($gvars.stdout, "puts", $to_a(strs));
        }, -1);
        $def(self, "$p", function $$p($a) {
          var $post_args, args;
          $post_args = $slice(arguments);
          args = $post_args;
          $send(args, "each", [], function $$13(obj) {
            if ($gvars.stdout == null)
              $gvars.stdout = nil;
            if (obj == null)
              obj = nil;
            return $gvars.stdout.$puts(obj.$inspect());
          });
          if ($truthy($rb_le(args.$length(), 1))) {
            return args["$[]"](0);
          } else {
            return args;
          }
          ;
        }, -1);
        $def(self, "$print", function $$print($a) {
          var $post_args, strs;
          if ($gvars.stdout == null)
            $gvars.stdout = nil;
          $post_args = $slice(arguments);
          strs = $post_args;
          return $send($gvars.stdout, "print", $to_a(strs));
        }, -1);
        $def(self, "$readline", function $$readline($a) {
          var $post_args, args;
          if ($gvars.stdin == null)
            $gvars.stdin = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send($gvars.stdin, "readline", $to_a(args));
        }, -1);
        $def(self, "$warn", function $$warn($a, $b) {
          var $post_args, $kwargs, strs, uplevel, $c, $d, self2 = this, location = nil;
          if ($gvars.VERBOSE == null)
            $gvars.VERBOSE = nil;
          if ($gvars.stderr == null)
            $gvars.stderr = nil;
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          strs = $post_args;
          uplevel = $kwargs.$$smap["uplevel"];
          if (uplevel == null)
            uplevel = nil;
          if ($truthy(uplevel)) {
            uplevel = $Opal["$coerce_to!"](uplevel, $$$("Integer"), "to_str");
            if ($truthy($rb_lt(uplevel, 0))) {
              $Kernel.$raise($$$("ArgumentError"), "negative level (" + uplevel + ")");
            }
            ;
            location = ($c = ($d = self2.$caller($rb_plus(uplevel, 1), 1).$first(), $d === nil || $d == null ? nil : $d.$split(":in `")), $c === nil || $c == null ? nil : $c.$first());
            if ($truthy(location)) {
              location = "" + location + ": ";
            }
            ;
            strs = $send(strs, "map", [], function $$14(s) {
              if (s == null)
                s = nil;
              return "" + location + "warning: " + s;
            });
          }
          ;
          if ($truthy($gvars.VERBOSE["$nil?"]()) || $truthy(strs["$empty?"]())) {
            return nil;
          } else {
            return $send($gvars.stderr, "puts", $to_a(strs));
          }
          ;
        }, -1);
        $def(self, "$raise", function $$raise(exception, string, backtrace) {
          if ($gvars["!"] == null)
            $gvars["!"] = nil;
          if ($gvars["@"] == null)
            $gvars["@"] = nil;
          ;
          if (string == null)
            string = nil;
          if (backtrace == null)
            backtrace = nil;
          if (exception == null && $gvars["!"] !== nil) {
            throw $gvars["!"];
          }
          if (exception == null) {
            exception = $$$("RuntimeError").$new("");
          } else if ($respond_to(exception, "$to_str")) {
            exception = $$$("RuntimeError").$new(exception.$to_str());
          } else if (exception.$$is_class && $respond_to(exception, "$exception")) {
            exception = exception.$exception(string);
          } else if (exception.$$is_exception) {
          } else {
            exception = $$$("TypeError").$new("exception class/object expected");
          }
          if (backtrace !== nil) {
            exception.$set_backtrace(backtrace);
          }
          if ($gvars["!"] !== nil) {
            Opal2.exceptions.push($gvars["!"]);
          }
          $gvars["!"] = exception;
          $gvars["@"] = exception.$backtrace();
          throw exception;
          ;
        }, -1);
        $def(self, "$rand", function $$rand(max) {
          ;
          if (max === void 0) {
            return $$$($$$("Random"), "DEFAULT").$rand();
          }
          if (max.$$is_number) {
            if (max < 0) {
              max = Math.abs(max);
            }
            if (max % 1 !== 0) {
              max = max.$to_i();
            }
            if (max === 0) {
              max = void 0;
            }
          }
          ;
          return $$$($$$("Random"), "DEFAULT").$rand(max);
        }, -1);
        $def(self, "$respond_to?", function $Kernel_respond_to$ques$15(name, include_all) {
          var self2 = this;
          if (include_all == null)
            include_all = false;
          var body = self2[$jsid(name)];
          if (typeof body === "function" && !body.$$stub) {
            return true;
          }
          if (self2["$respond_to_missing?"].$$pristine === true) {
            return false;
          } else {
            return self2["$respond_to_missing?"](name, include_all);
          }
          ;
        }, -2);
        $def(self, "$respond_to_missing?", function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
          if (include_all == null)
            include_all = false;
          return false;
        }, -2);
        $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
        $def(self, "$require", function $$require(file) {
          if (typeof file !== "string" && Opal2.String && Opal2.Array) {
            file = $Opal["$coerce_to!"](file, $$$("String"), "to_str");
          }
          return Opal2.require(file);
        });
        $def(self, "$require_relative", function $$require_relative(file) {
          $Opal["$try_convert!"](file, $$$("String"), "to_str");
          file = $$$("File").$expand_path($$$("File").$join(Opal2.current_file, "..", file));
          return Opal2.require(file);
        });
        $def(self, "$require_tree", function $$require_tree(path, $kwargs) {
          var autoload;
          $kwargs = $ensure_kwargs($kwargs);
          autoload = $kwargs.$$smap["autoload"];
          if (autoload == null)
            autoload = false;
          var result = [];
          path = $$$("File").$expand_path(path);
          path = Opal2.normalize(path);
          if (path === ".")
            path = "";
          for (var name in Opal2.modules) {
            if (name["$start_with?"](path)) {
              if (!autoload) {
                result.push([name, Opal2.require(name)]);
              } else {
                result.push([name, true]);
              }
            }
          }
          return result;
          ;
        }, -2);
        $def(self, "$singleton_class", function $$singleton_class() {
          var self2 = this;
          return Opal2.get_singleton_class(self2);
        });
        $def(self, "$sleep", function $$sleep(seconds) {
          if (seconds == null)
            seconds = nil;
          if (seconds === nil) {
            $Kernel.$raise($$$("TypeError"), "can't convert NilClass into time interval");
          }
          if (!seconds.$$is_number) {
            $Kernel.$raise($$$("TypeError"), "can't convert " + seconds.$class() + " into time interval");
          }
          if (seconds < 0) {
            $Kernel.$raise($$$("ArgumentError"), "time interval must be positive");
          }
          var get_time = Opal2.global.performance ? function() {
            return performance.now();
          } : function() {
            return new Date();
          };
          var t2 = get_time();
          while (get_time() - t2 <= seconds * 1e3)
            ;
          return Math.round(seconds);
          ;
        }, -1);
        $def(self, "$srand", function $$srand(seed) {
          if (seed == null)
            seed = $$("Random").$new_seed();
          return $$$("Random").$srand(seed);
        }, -1);
        $def(self, "$String", function $$String(str) {
          var $ret_or_1 = nil;
          if ($truthy($ret_or_1 = $Opal["$coerce_to?"](str, $$$("String"), "to_str"))) {
            return $ret_or_1;
          } else {
            return $Opal["$coerce_to!"](str, $$$("String"), "to_s");
          }
        });
        $def(self, "$tap", function $$tap() {
          var block = $$tap.$$p || nil, self2 = this;
          $$tap.$$p = null;
          ;
          Opal2.yield1(block, self2);
          return self2;
        });
        $def(self, "$to_proc", $return_self);
        $def(self, "$to_s", function $$to_s() {
          var self2 = this;
          return "#<" + self2.$class() + ":0x" + self2.$__id__().$to_s(16) + ">";
        });
        $def(self, "$catch", function $Kernel_catch$17(tag) {
          var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;
          $Kernel_catch$17.$$p = null;
          if (tag == null)
            tag = nil;
          try {
            tag = $truthy($ret_or_1 = tag) ? $ret_or_1 : $Object.$new();
            return Opal2.yield1($yield, tag);
            ;
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("UncaughtThrowError")])) {
              e = $err;
              try {
                if ($eqeq(e.$tag(), tag)) {
                  return e.$value();
                }
                ;
                return $Kernel.$raise();
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
          ;
        }, -1);
        $def(self, "$throw", function $Kernel_throw$18(tag, obj) {
          if (obj == null)
            obj = nil;
          return $Kernel.$raise($$$("UncaughtThrowError").$new(tag, obj));
        }, -2);
        $def(self, "$open", function $$open($a) {
          var block = $$open.$$p || nil, $post_args, args;
          $$open.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send($$$("File"), "open", $to_a(args), block.$to_proc());
        }, -1);
        $def(self, "$yield_self", function $$yield_self() {
          var $yield = $$yield_self.$$p || nil, self2 = this;
          $$yield_self.$$p = null;
          if (!($yield !== nil)) {
            return $send(self2, "enum_for", ["yield_self"], $return_val(1));
          }
          ;
          return Opal2.yield1($yield, self2);
          ;
        });
        $alias(self, "fail", "raise");
        $alias(self, "kind_of?", "is_a?");
        $alias(self, "object_id", "__id__");
        $alias(self, "public_send", "__send__");
        $alias(self, "send", "__send__");
        $alias(self, "then", "yield_self");
        return $alias(self, "to_enum", "enum_for");
      })("::", $nesting);
      return function($base, $super) {
        var self = $klass($base, $super, "Object");
        delete $Object.$$prototype.$require;
        return self.$include($Kernel);
      }("::", null);
    };
    Opal.modules["corelib/main"] = function(Opal2) {
      var $return_val = Opal2.return_val, $def = Opal2.def, $Object = Opal2.Object, $slice = Opal2.slice, $Kernel = Opal2.Kernel, self = Opal2.top, $nesting = [], nil = Opal2.nil;
      Opal2.add_stubs("include,raise");
      return function(self2, $parent_nesting) {
        $def(self2, "$to_s", $return_val("main"));
        $def(self2, "$include", function $$include(mod) {
          return $Object.$include(mod);
        });
        $def(self2, "$autoload", function $$autoload($a) {
          var $post_args, args;
          $post_args = $slice(arguments);
          args = $post_args;
          return Opal2.Object.$autoload.apply(Opal2.Object, args);
          ;
        }, -1);
        return $def(self2, "$using", function $$using(mod) {
          return $Kernel.$raise("main.using is permitted only at toplevel");
        });
      }(Opal2.get_singleton_class(self), $nesting);
    };
    Opal.modules["corelib/error/errno"] = function(Opal2) {
      var $module = Opal2.module, $truthy = Opal2.truthy, $rb_plus = Opal2.rb_plus, $send2 = Opal2.send2, $find_super = Opal2.find_super, $def = Opal2.def, $klass = Opal2.klass, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("+,errno,class,attr_reader");
      (function($base, $parent_nesting) {
        var self = $module($base, "Errno");
        var $nesting2 = [self].concat($parent_nesting), errors = nil, klass = nil;
        errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
        klass = nil;
        var i;
        for (i = 0; i < errors.length; i++) {
          (function() {
            var class_name = errors[i][0];
            var default_message = errors[i][1];
            var errno = errors[i][2];
            klass = Opal2.klass(self, Opal2.SystemCallError, class_name);
            klass.errno = errno;
            (function(self2, $parent_nesting2) {
              return $def(self2, "$new", function $new$1(name) {
                var $yield = $new$1.$$p || nil, self3 = this, message = nil;
                $new$1.$$p = null;
                if (name == null)
                  name = nil;
                message = default_message;
                if ($truthy(name)) {
                  message = $rb_plus(message, " - " + name);
                }
                ;
                return $send2(self3, $find_super(self3, "new", $new$1, false, true), "new", [message], null);
              }, -1);
            })(Opal2.get_singleton_class(klass), $nesting2);
          })();
        }
        ;
      })("::", $nesting);
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "SystemCallError");
        var $nesting2 = [self].concat($parent_nesting);
        $def(self, "$errno", function $$errno() {
          var self2 = this;
          return self2.$class().$errno();
        });
        return function(self2, $parent_nesting2) {
          return self2.$attr_reader("errno");
        }(Opal2.get_singleton_class(self), $nesting2);
      }("::", $$$("StandardError"), $nesting);
    };
    Opal.modules["corelib/error"] = function(Opal2) {
      var $klass = Opal2.klass, $slice = Opal2.slice, $gvars = Opal2.gvars, $defs = Opal2.defs, $send = Opal2.send, $to_a = Opal2.to_a, $def = Opal2.def, $truthy = Opal2.truthy, $hash2 = Opal2.hash2, $Kernel = Opal2.Kernel, $not = Opal2.not, $rb_plus = Opal2.rb_plus, $eqeq = Opal2.eqeq, $Object = Opal2.Object, $ensure_kwargs = Opal2.ensure_kwargs, $send2 = Opal2.send2, $find_super = Opal2.find_super, $module = Opal2.module, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Exception");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
        $proto.message = nil;
        Opal2.prop(self.$$prototype, "$$is_exception", true);
        var stack_trace_limit;
        Error.stackTraceLimit = 100;
        $defs(self, "$new", function $Exception_new$1($a) {
          var $post_args, args, self2 = this;
          if ($gvars["!"] == null)
            $gvars["!"] = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          var message = args.length > 0 ? args[0] : nil;
          var error = new self2.$$constructor(message);
          error.name = self2.$$name;
          error.message = message;
          error.cause = $gvars["!"];
          Opal2.send(error, error.$initialize, args);
          if (Opal2.config.enable_stack_trace && Error.captureStackTrace) {
            Error.captureStackTrace(error, stack_trace_limit);
          }
          return error;
          ;
        }, -1);
        stack_trace_limit = self.$new;
        $defs(self, "$exception", function $$exception($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self2, "new", $to_a(args));
        }, -1);
        $def(self, "$initialize", function $$initialize($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          return self2.message = args.length > 0 ? args[0] : nil;
          ;
        }, -1);
        function correct_backtrace(backtrace) {
          var new_bt = [], m;
          for (var i = 0; i < backtrace.length; i++) {
            var loc = backtrace[i];
            if (!loc || !loc.$$is_string) {
            } else if (m = loc.match(/^    at (.*?) \((.*?)\)$/)) {
              new_bt.push(m[2] + ":in `" + m[1] + "'");
            } else if (m = loc.match(/^    at (.*?)$/)) {
              new_bt.push(m[1] + ":in `undefined'");
            } else if (m = loc.match(/^  from (.*?)$/)) {
              new_bt.push(m[1]);
            } else if (m = loc.match(/^(.*?)@(.*?)$/)) {
              new_bt.push(m[2] + ":in `" + m[1] + "'");
            }
          }
          return new_bt;
        }
        ;
        $def(self, "$backtrace", function $$backtrace() {
          var self2 = this;
          if (self2.backtrace) {
            return self2.backtrace;
          }
          var backtrace = self2.stack;
          if (typeof backtrace !== "undefined" && backtrace.$$is_string) {
            return self2.backtrace = correct_backtrace(backtrace.split("\n"));
          } else if (backtrace) {
            return self2.backtrace = correct_backtrace(backtrace);
          }
          return [];
        });
        $def(self, "$backtrace_locations", function $$backtrace_locations() {
          var $a, self2 = this;
          if (self2.backtrace_locations)
            return self2.backtrace_locations;
          self2.backtrace_locations = ($a = self2.$backtrace(), $a === nil || $a == null ? nil : $send($a, "map", [], function $$2(loc) {
            if (loc == null)
              loc = nil;
            return $$$($$$($$$("Thread"), "Backtrace"), "Location").$new(loc);
          }));
          return self2.backtrace_locations;
        });
        $def(self, "$cause", function $$cause() {
          var self2 = this;
          return self2.cause || nil;
        });
        $def(self, "$exception", function $$exception(str) {
          var self2 = this;
          if (str == null)
            str = nil;
          if (str === nil || self2 === str) {
            return self2;
          }
          var cloned = self2.$clone();
          cloned.message = str;
          if (self2.backtrace)
            cloned.backtrace = self2.backtrace.$dup();
          cloned.stack = self2.stack;
          cloned.cause = self2.cause;
          return cloned;
          ;
        }, -1);
        $def(self, "$message", function $$message() {
          var self2 = this;
          return self2.$to_s();
        });
        $def(self, "$full_message", function $$full_message(kwargs) {
          var $a, $b, self2 = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
          if ($gvars.stderr == null)
            $gvars.stderr = nil;
          if (kwargs == null)
            kwargs = nil;
          if (!$truthy(($a = $$("Hash", "skip_raise")) ? "constant" : nil)) {
            return "" + self2.message + "\n" + self2.stack;
          }
          ;
          kwargs = $hash2(["highlight", "order"], { "highlight": $gvars.stderr["$tty?"](), "order": "top" }).$merge($truthy($ret_or_1 = kwargs) ? $ret_or_1 : $hash2([], {}));
          $b = [kwargs["$[]"]("highlight"), kwargs["$[]"]("order")], highlight = $b[0], order = $b[1], $b;
          if (!$truthy([true, false]["$include?"](highlight))) {
            $Kernel.$raise($$$("ArgumentError"), "expected true or false as highlight: " + highlight);
          }
          ;
          if (!$truthy(["top", "bottom"]["$include?"](order))) {
            $Kernel.$raise($$$("ArgumentError"), "expected :top or :bottom as order: " + order);
          }
          ;
          if ($truthy(highlight)) {
            bold_underline = "\x1B[1;4m";
            bold = "\x1B[1m";
            reset = "\x1B[m";
          } else {
            bold_underline = bold = reset = "";
          }
          ;
          bt = self2.$backtrace().$dup();
          if ($not(bt) || $truthy(bt["$empty?"]())) {
            bt = self2.$caller();
          }
          ;
          first = bt.$shift();
          msg = "" + first + ": ";
          msg = $rb_plus(msg, "" + bold + self2.$to_s() + " (" + bold_underline + self2.$class() + reset + bold + ")" + reset + "\n");
          msg = $rb_plus(msg, $send(bt, "map", [], function $$3(loc) {
            if (loc == null)
              loc = nil;
            return "	from " + loc + "\n";
          }).$join());
          if ($truthy(self2.$cause())) {
            msg = $rb_plus(msg, self2.$cause().$full_message($hash2(["highlight"], { "highlight": highlight })));
          }
          ;
          if ($eqeq(order, "bottom")) {
            msg = msg.$split("\n").$reverse().$join("\n");
            msg = $rb_plus("" + bold + "Traceback" + reset + " (most recent call last):\n", msg);
          }
          ;
          return msg;
        }, -1);
        $def(self, "$inspect", function $$inspect() {
          var self2 = this, as_str = nil;
          as_str = self2.$to_s();
          if ($truthy(as_str["$empty?"]())) {
            return self2.$class().$to_s();
          } else {
            return "#<" + self2.$class().$to_s() + ": " + self2.$to_s() + ">";
          }
          ;
        });
        $def(self, "$set_backtrace", function $$set_backtrace(backtrace) {
          var self2 = this;
          var valid = true, i, ii;
          if (backtrace === nil) {
            self2.backtrace = nil;
            self2.stack = "";
          } else if (backtrace.$$is_string) {
            self2.backtrace = [backtrace];
            self2.stack = "  from " + backtrace;
          } else {
            if (backtrace.$$is_array) {
              for (i = 0, ii = backtrace.length; i < ii; i++) {
                if (!backtrace[i].$$is_string) {
                  valid = false;
                  break;
                }
              }
            } else {
              valid = false;
            }
            if (valid === false) {
              $Kernel.$raise($$$("TypeError"), "backtrace must be Array of String");
            }
            self2.backtrace = backtrace;
            self2.stack = $send(backtrace, "map", [], function $$4(i2) {
              if (i2 == null)
                i2 = nil;
              return $rb_plus("  from ", i2);
            }).join("\n");
          }
          return backtrace;
        });
        return $def(self, "$to_s", function $$to_s() {
          var self2 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = self2.message) ? self2.message.$to_s() : $ret_or_2)) {
            return $ret_or_1;
          } else {
            return self2.$class().$to_s();
          }
        });
      })("::", Error, $nesting);
      $klass("::", $$$("Exception"), "ScriptError");
      $klass("::", $$$("ScriptError"), "SyntaxError");
      $klass("::", $$$("ScriptError"), "LoadError");
      $klass("::", $$$("ScriptError"), "NotImplementedError");
      $klass("::", $$$("Exception"), "SystemExit");
      $klass("::", $$$("Exception"), "NoMemoryError");
      $klass("::", $$$("Exception"), "SignalException");
      $klass("::", $$$("SignalException"), "Interrupt");
      $klass("::", $$$("Exception"), "SecurityError");
      $klass("::", $$$("Exception"), "SystemStackError");
      $klass("::", $$$("Exception"), "StandardError");
      $klass("::", $$$("StandardError"), "EncodingError");
      $klass("::", $$$("StandardError"), "ZeroDivisionError");
      $klass("::", $$$("StandardError"), "NameError");
      $klass("::", $$$("NameError"), "NoMethodError");
      $klass("::", $$$("StandardError"), "RuntimeError");
      $klass("::", $$$("RuntimeError"), "FrozenError");
      $klass("::", $$$("StandardError"), "LocalJumpError");
      $klass("::", $$$("StandardError"), "TypeError");
      $klass("::", $$$("StandardError"), "ArgumentError");
      $klass("::", $$$("ArgumentError"), "UncaughtThrowError");
      $klass("::", $$$("StandardError"), "IndexError");
      $klass("::", $$$("IndexError"), "StopIteration");
      $klass("::", $$$("StopIteration"), "ClosedQueueError");
      $klass("::", $$$("IndexError"), "KeyError");
      $klass("::", $$$("StandardError"), "RangeError");
      $klass("::", $$$("RangeError"), "FloatDomainError");
      $klass("::", $$$("StandardError"), "IOError");
      $klass("::", $$$("IOError"), "EOFError");
      $klass("::", $$$("StandardError"), "SystemCallError");
      $klass("::", $$$("StandardError"), "RegexpError");
      $klass("::", $$$("StandardError"), "ThreadError");
      $klass("::", $$$("StandardError"), "FiberError");
      $Object.$autoload("Errno", "corelib/error/errno");
      (function($base, $super) {
        var self = $klass($base, $super, "FrozenError");
        self.$attr_reader("receiver");
        return $def(self, "$initialize", function $$initialize(message, $kwargs) {
          var receiver, $yield = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          $kwargs = $ensure_kwargs($kwargs);
          receiver = $kwargs.$$smap["receiver"];
          if (receiver == null)
            receiver = nil;
          $send2(self2, $find_super(self2, "initialize", $$initialize, false, true), "initialize", [message], null);
          return self2.receiver = receiver;
        }, -2);
      })("::", $$$("RuntimeError"));
      (function($base, $super) {
        var self = $klass($base, $super, "UncaughtThrowError");
        var $proto = self.$$prototype;
        $proto.tag = nil;
        self.$attr_reader("tag", "value");
        return $def(self, "$initialize", function $$initialize(tag, value) {
          var $yield = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          if (value == null)
            value = nil;
          self2.tag = tag;
          self2.value = value;
          return $send2(self2, $find_super(self2, "initialize", $$initialize, false, true), "initialize", ["uncaught throw " + self2.tag.$inspect()], null);
        }, -2);
      })("::", $$$("ArgumentError"));
      (function($base, $super) {
        var self = $klass($base, $super, "NameError");
        self.$attr_reader("name");
        return $def(self, "$initialize", function $$initialize(message, name) {
          var $yield = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          if (name == null)
            name = nil;
          $send2(self2, $find_super(self2, "initialize", $$initialize, false, true), "initialize", [message], null);
          return self2.name = name;
        }, -2);
      })("::", null);
      (function($base, $super) {
        var self = $klass($base, $super, "NoMethodError");
        self.$attr_reader("args");
        return $def(self, "$initialize", function $$initialize(message, name, args) {
          var $yield = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          if (name == null)
            name = nil;
          if (args == null)
            args = [];
          $send2(self2, $find_super(self2, "initialize", $$initialize, false, true), "initialize", [message, name], null);
          return self2.args = args;
        }, -2);
      })("::", null);
      (function($base, $super) {
        var self = $klass($base, $super, "StopIteration");
        return self.$attr_reader("result");
      })("::", null);
      (function($base, $super) {
        var self = $klass($base, $super, "KeyError");
        var $proto = self.$$prototype;
        $proto.receiver = $proto.key = nil;
        $def(self, "$initialize", function $$initialize(message, $kwargs) {
          var receiver, key, $yield = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          $kwargs = $ensure_kwargs($kwargs);
          receiver = $kwargs.$$smap["receiver"];
          if (receiver == null)
            receiver = nil;
          key = $kwargs.$$smap["key"];
          if (key == null)
            key = nil;
          $send2(self2, $find_super(self2, "initialize", $$initialize, false, true), "initialize", [message], null);
          self2.receiver = receiver;
          return self2.key = key;
        }, -2);
        $def(self, "$receiver", function $$receiver() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.receiver)) {
            return $ret_or_1;
          } else {
            return $Kernel.$raise($$$("ArgumentError"), "no receiver is available");
          }
        });
        return $def(self, "$key", function $$key() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.key)) {
            return $ret_or_1;
          } else {
            return $Kernel.$raise($$$("ArgumentError"), "no key is available");
          }
        });
      })("::", null);
      return function($base, $parent_nesting) {
        var self = $module($base, "JS");
        var $nesting2 = [self].concat($parent_nesting);
        return $klass($nesting2[0], null, "Error"), nil;
      }("::", $nesting);
    };
    Opal.modules["corelib/constants"] = function(Opal2) {
      var $const_set = Opal2.const_set, nil = Opal2.nil, $$$ = Opal2.$$$;
      $const_set("::", "RUBY_PLATFORM", "opal");
      $const_set("::", "RUBY_ENGINE", "opal");
      $const_set("::", "RUBY_VERSION", "3.2.0");
      $const_set("::", "RUBY_ENGINE_VERSION", "1.7.3");
      $const_set("::", "RUBY_RELEASE_DATE", "2023-03-23");
      $const_set("::", "RUBY_PATCHLEVEL", 0);
      $const_set("::", "RUBY_REVISION", "0");
      $const_set("::", "RUBY_COPYRIGHT", "opal - Copyright (C) 2011-2023 Adam Beynon and the Opal contributors");
      return $const_set("::", "RUBY_DESCRIPTION", "opal " + $$$("RUBY_ENGINE_VERSION") + " (" + $$$("RUBY_RELEASE_DATE") + " revision " + $$$("RUBY_REVISION") + ")");
    };
    Opal.modules["opal/base"] = function(Opal2) {
      var $Object = Opal2.Object, nil = Opal2.nil;
      Opal2.add_stubs("require");
      $Object.$require("corelib/runtime");
      $Object.$require("corelib/helpers");
      $Object.$require("corelib/module");
      $Object.$require("corelib/class");
      $Object.$require("corelib/basic_object");
      $Object.$require("corelib/kernel");
      $Object.$require("corelib/main");
      $Object.$require("corelib/error");
      return $Object.$require("corelib/constants");
    };
    Opal.modules["corelib/nil"] = function(Opal2) {
      var $klass = Opal2.klass, $Kernel = Opal2.Kernel, $def = Opal2.def, $return_val = Opal2.return_val, $ensure_kwargs = Opal2.ensure_kwargs, $NilClass = Opal2.NilClass, $slice = Opal2.slice, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("raise,name,new,>,length,Rational,to_i");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "NilClass");
        var $nesting2 = [self].concat($parent_nesting);
        self.$$prototype.$$meta = self;
        (function(self2, $parent_nesting2) {
          $def(self2, "$allocate", function $$allocate() {
            var self3 = this;
            return $Kernel.$raise($$$("TypeError"), "allocator undefined for " + self3.$name());
          });
          Opal2.udef(self2, "$new");
          ;
          return nil;
          ;
        })(Opal2.get_singleton_class(self), $nesting2);
        $def(self, "$!", $return_val(true));
        $def(self, "$&", $return_val(false));
        $def(self, "$|", function $NilClass_$$1(other) {
          return other !== false && other !== nil;
        });
        $def(self, "$^", function $NilClass_$$2(other) {
          return other !== false && other !== nil;
        });
        $def(self, "$==", function $NilClass_$eq_eq$3(other) {
          return other === nil;
        });
        $def(self, "$dup", $return_val(nil));
        $def(self, "$clone", function $$clone($kwargs) {
          var freeze;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = true;
          return nil;
        }, -1);
        $def(self, "$inspect", $return_val("nil"));
        $def(self, "$nil?", $return_val(true));
        $def(self, "$singleton_class", function $$singleton_class() {
          return $NilClass;
        });
        $def(self, "$to_a", function $$to_a() {
          return [];
        });
        $def(self, "$to_h", function $$to_h() {
          return Opal2.hash();
        });
        $def(self, "$to_i", $return_val(0));
        $def(self, "$to_s", $return_val(""));
        $def(self, "$to_c", function $$to_c() {
          return $$$("Complex").$new(0, 0);
        });
        $def(self, "$rationalize", function $$rationalize($a) {
          var $post_args, args;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy($rb_gt(args.$length(), 1))) {
            $Kernel.$raise($$$("ArgumentError"));
          }
          ;
          return $Kernel.$Rational(0, 1);
        }, -1);
        $def(self, "$to_r", function $$to_r() {
          return $Kernel.$Rational(0, 1);
        });
        $def(self, "$instance_variables", function $$instance_variables() {
          return [];
        });
        return $alias(self, "to_f", "to_i");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/boolean"] = function(Opal2) {
      "use strict";
      var $klass = Opal2.klass, $Kernel = Opal2.Kernel, $def = Opal2.def, $return_self = Opal2.return_self, $ensure_kwargs = Opal2.ensure_kwargs, $slice = Opal2.slice, $truthy = Opal2.truthy, $send2 = Opal2.send2, $find_super = Opal2.find_super, $to_a = Opal2.to_a, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("raise,name,==,to_s,__id__");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Boolean");
        var $nesting2 = [self].concat($parent_nesting);
        Opal2.prop(self.$$prototype, "$$is_boolean", true);
        var properties = ["$$class", "$$meta"];
        for (var i = 0; i < properties.length; i++) {
          Object.defineProperty(self.$$prototype, properties[i], {
            configurable: true,
            enumerable: false,
            get: function() {
              return this == true ? Opal2.TrueClass : this == false ? Opal2.FalseClass : Opal2.Boolean;
            }
          });
        }
        Object.defineProperty(self.$$prototype, "$$id", {
          configurable: true,
          enumerable: false,
          get: function() {
            return this == true ? 2 : this == false ? 0 : nil;
          }
        });
        ;
        (function(self2, $parent_nesting2) {
          $def(self2, "$allocate", function $$allocate() {
            var self3 = this;
            return $Kernel.$raise($$$("TypeError"), "allocator undefined for " + self3.$name());
          });
          Opal2.udef(self2, "$new");
          ;
          return nil;
          ;
        })(Opal2.get_singleton_class(self), $nesting2);
        $def(self, "$__id__", function $$__id__() {
          var self2 = this;
          return self2.valueOf() ? 2 : 0;
        });
        $def(self, "$!", function $Boolean_$excl$1() {
          var self2 = this;
          return self2 != true;
        });
        $def(self, "$&", function $Boolean_$$2(other) {
          var self2 = this;
          return self2 == true ? other !== false && other !== nil : false;
        });
        $def(self, "$|", function $Boolean_$$3(other) {
          var self2 = this;
          return self2 == true ? true : other !== false && other !== nil;
        });
        $def(self, "$^", function $Boolean_$$4(other) {
          var self2 = this;
          return self2 == true ? other === false || other === nil : other !== false && other !== nil;
        });
        $def(self, "$==", function $Boolean_$eq_eq$5(other) {
          var self2 = this;
          return self2 == true === other.valueOf();
        });
        $def(self, "$singleton_class", function $$singleton_class() {
          var self2 = this;
          return self2.$$meta;
        });
        $def(self, "$to_s", function $$to_s() {
          var self2 = this;
          return self2 == true ? "true" : "false";
        });
        $def(self, "$dup", $return_self);
        $def(self, "$clone", function $$clone($kwargs) {
          var freeze, self2 = this;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = true;
          return self2;
        }, -1);
        $def(self, "$method_missing", function $$method_missing(method, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self2 = this;
          $$method_missing.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          var body = self2.$$class.$$prototype[Opal2.jsid(method)];
          if (!$truthy(typeof body !== "undefined" && !body.$$stub)) {
            $send2(self2, $find_super(self2, "method_missing", $$method_missing, false, true), "method_missing", [method].concat($to_a(args)), block);
          }
          ;
          return Opal2.send(self2, body, args, block);
        }, -2);
        $def(self, "$respond_to_missing?", function $Boolean_respond_to_missing$ques$6(method, _include_all) {
          var self2 = this;
          if (_include_all == null)
            _include_all = false;
          var body = self2.$$class.$$prototype[Opal2.jsid(method)];
          return typeof body !== "undefined" && !body.$$stub;
          ;
        }, -2);
        $alias(self, "eql?", "==");
        $alias(self, "equal?", "==");
        $alias(self, "inspect", "to_s");
        return $alias(self, "object_id", "__id__");
      })("::", Boolean, $nesting);
      $klass("::", $$$("Boolean"), "TrueClass");
      return $klass("::", $$$("Boolean"), "FalseClass"), nil;
    };
    Opal.modules["corelib/comparable"] = function(Opal2) {
      var $truthy = Opal2.truthy, $module = Opal2.module, $rb_gt = Opal2.rb_gt, $rb_lt = Opal2.rb_lt, $eqeqeq = Opal2.eqeqeq, $Kernel = Opal2.Kernel, $def = Opal2.def, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs(">,<,===,raise,class,<=>,equal?");
      return function($base) {
        var self = $module($base, "Comparable");
        var $ret_or_1 = nil;
        function normalize(what) {
          if (Opal2.is_a(what, Opal2.Integer)) {
            return what;
          }
          if ($rb_gt(what, 0)) {
            return 1;
          }
          if ($rb_lt(what, 0)) {
            return -1;
          }
          return 0;
        }
        function fail_comparison(lhs, rhs) {
          var class_name;
          $eqeqeq(nil, $ret_or_1 = rhs) || ($eqeqeq(true, $ret_or_1) || ($eqeqeq(false, $ret_or_1) || ($eqeqeq($$$("Integer"), $ret_or_1) || $eqeqeq($$$("Float"), $ret_or_1)))) ? class_name = rhs.$inspect() : class_name = rhs.$$class;
          $Kernel.$raise($$$("ArgumentError"), "comparison of " + lhs.$class() + " with " + class_name + " failed");
        }
        function cmp_or_fail(lhs, rhs) {
          var cmp = lhs["$<=>"](rhs);
          if (!$truthy(cmp))
            fail_comparison(lhs, rhs);
          return normalize(cmp);
        }
        ;
        $def(self, "$==", function $Comparable_$eq_eq$1(other) {
          var self2 = this, cmp = nil;
          if ($truthy(self2["$equal?"](other))) {
            return true;
          }
          ;
          if (self2["$<=>"] == Opal2.Kernel["$<=>"]) {
            return false;
          }
          if (self2.$$comparable) {
            self2.$$comparable = false;
            return false;
          }
          ;
          if (!$truthy(cmp = self2["$<=>"](other))) {
            return false;
          }
          ;
          return normalize(cmp) == 0;
          ;
        });
        $def(self, "$>", function $Comparable_$gt$2(other) {
          var self2 = this;
          return cmp_or_fail(self2, other) > 0;
        });
        $def(self, "$>=", function $Comparable_$gt_eq$3(other) {
          var self2 = this;
          return cmp_or_fail(self2, other) >= 0;
        });
        $def(self, "$<", function $Comparable_$lt$4(other) {
          var self2 = this;
          return cmp_or_fail(self2, other) < 0;
        });
        $def(self, "$<=", function $Comparable_$lt_eq$5(other) {
          var self2 = this;
          return cmp_or_fail(self2, other) <= 0;
        });
        $def(self, "$between?", function $Comparable_between$ques$6(min, max) {
          var self2 = this;
          if ($rb_lt(self2, min)) {
            return false;
          }
          ;
          if ($rb_gt(self2, max)) {
            return false;
          }
          ;
          return true;
        });
        return $def(self, "$clamp", function $$clamp(min, max) {
          var self2 = this;
          if (max == null)
            max = nil;
          var c, excl;
          if (max === nil) {
            if (!Opal2.is_a(min, Opal2.Range)) {
              $Kernel.$raise($$$("TypeError"), "wrong argument type " + min.$class() + " (expected Range)");
            }
            excl = min.excl;
            max = min.end;
            min = min.begin;
            if (max !== nil && excl) {
              $Kernel.$raise($$$("ArgumentError"), "cannot clamp with an exclusive range");
            }
          }
          if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
            $Kernel.$raise($$$("ArgumentError"), "min argument must be smaller than max argument");
          }
          if (min !== nil) {
            c = cmp_or_fail(self2, min);
            if (c == 0)
              return self2;
            if (c < 0)
              return min;
          }
          if (max !== nil) {
            c = cmp_or_fail(self2, max);
            if (c > 0)
              return max;
          }
          return self2;
          ;
        }, -2);
      }("::");
    };
    Opal.modules["corelib/regexp"] = function(Opal2) {
      var $coerce_to = Opal2.coerce_to, $prop = Opal2.prop, $freeze = Opal2.freeze, $klass = Opal2.klass, $const_set = Opal2.const_set, $send2 = Opal2.send2, $find_super = Opal2.find_super, $def = Opal2.def, $truthy = Opal2.truthy, $gvars = Opal2.gvars, $slice = Opal2.slice, $Kernel = Opal2.Kernel, $Opal = Opal2.Opal, $alias = Opal2.alias, $send = Opal2.send, $hash2 = Opal2.hash2, $rb_plus = Opal2.rb_plus, $ensure_kwargs = Opal2.ensure_kwargs, $rb_ge = Opal2.rb_ge, $to_a = Opal2.to_a, $eqeqeq = Opal2.eqeqeq, $rb_minus = Opal2.rb_minus, $return_ivar = Opal2.return_ivar, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a");
      $klass("::", $$$("StandardError"), "RegexpError");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Regexp");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $const_set(self, "IGNORECASE", 1);
        $const_set(self, "EXTENDED", 2);
        $const_set(self, "MULTILINE", 4);
        Opal2.prop(self.$$prototype, "$$is_regexp", true);
        (function(self2, $parent_nesting2) {
          var $nesting3 = [self2].concat($parent_nesting2), $$2 = Opal2.$r($nesting3);
          $def(self2, "$allocate", function $$allocate() {
            var $yield = $$allocate.$$p || nil, self3 = this, allocated = nil;
            $$allocate.$$p = null;
            allocated = $send2(self3, $find_super(self3, "allocate", $$allocate, false, true), "allocate", [], $yield);
            allocated.uninitialized = true;
            return allocated;
          });
          $def(self2, "$escape", function $$escape(string) {
            return Opal2.escape_regexp(string);
          });
          $def(self2, "$last_match", function $$last_match(n) {
            if ($gvars["~"] == null)
              $gvars["~"] = nil;
            if (n == null)
              n = nil;
            if ($truthy(n["$nil?"]())) {
              return $gvars["~"];
            } else if ($truthy($gvars["~"])) {
              return $gvars["~"]["$[]"](n);
            } else {
              return nil;
            }
            ;
          }, -1);
          $def(self2, "$union", function $$union($a) {
            var $post_args, parts, self3 = this;
            $post_args = $slice(arguments);
            parts = $post_args;
            var is_first_part_array, quoted_validated, part, options, each_part_options;
            if (parts.length == 0) {
              return /(?!)/;
            }
            if (parts.length == 1 && parts[0].$$is_regexp) {
              return parts[0];
            }
            is_first_part_array = parts[0].$$is_array;
            if (parts.length > 1 && is_first_part_array) {
              $Kernel.$raise($$$("TypeError"), "no implicit conversion of Array into String");
            }
            if (is_first_part_array) {
              parts = parts[0];
            }
            options = void 0;
            quoted_validated = [];
            for (var i = 0; i < parts.length; i++) {
              part = parts[i];
              if (part.$$is_string) {
                quoted_validated.push(self3.$escape(part));
              } else if (part.$$is_regexp) {
                each_part_options = part.$options();
                if (options != void 0 && options != each_part_options) {
                  $Kernel.$raise($$$("TypeError"), "All expressions must use the same options");
                }
                options = each_part_options;
                quoted_validated.push("(" + part.source + ")");
              } else {
                quoted_validated.push(self3.$escape(part.$to_str()));
              }
            }
            ;
            return self3.$new(quoted_validated.$join("|"), options);
          }, -1);
          $def(self2, "$new", function $new$1(regexp, options) {
            ;
            if (regexp.$$is_regexp) {
              return new RegExp(regexp);
            }
            regexp = $Opal["$coerce_to!"](regexp, $$$("String"), "to_str");
            if (regexp.charAt(regexp.length - 1) === "\\" && regexp.charAt(regexp.length - 2) !== "\\") {
              $Kernel.$raise($$$("RegexpError"), "too short escape sequence: /" + regexp + "/");
            }
            regexp = regexp.replace("\\A", "^").replace("\\z", "$");
            if (options === void 0 || options["$!"]()) {
              return new RegExp(regexp);
            }
            if (options.$$is_number) {
              var temp = "";
              if ($$2("IGNORECASE") & options) {
                temp += "i";
              }
              if ($$2("MULTILINE") & options) {
                temp += "m";
              }
              options = temp;
            } else {
              options = "i";
            }
            return new RegExp(regexp, options);
            ;
          }, -2);
          $alias(self2, "compile", "new");
          return $alias(self2, "quote", "escape");
        })(Opal2.get_singleton_class(self), $nesting2);
        $def(self, "$==", function $Regexp_$eq_eq$2(other) {
          var self2 = this;
          return other instanceof RegExp && self2.toString() === other.toString();
        });
        $def(self, "$===", function $Regexp_$eq_eq_eq$3(string) {
          var self2 = this;
          return self2.$match($Opal["$coerce_to?"](string, $$$("String"), "to_str")) !== nil;
        });
        $def(self, "$=~", function $Regexp_$eq_tilde$4(string) {
          var self2 = this, $ret_or_1 = nil;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          if ($truthy($ret_or_1 = self2.$match(string))) {
            return $gvars["~"].$begin(0);
          } else {
            return $ret_or_1;
          }
        });
        $def(self, "$freeze", function $$freeze() {
          var self2 = this;
          if ($truthy(self2["$frozen?"]())) {
            return self2;
          }
          ;
          if (!self2.hasOwnProperty("$$g")) {
            $prop(self2, "$$g", null);
          }
          if (!self2.hasOwnProperty("$$gm")) {
            $prop(self2, "$$gm", null);
          }
          return $freeze(self2);
          ;
        });
        $def(self, "$inspect", function $$inspect() {
          var self2 = this;
          var regexp_format = /^\/(.*)\/([^\/]*)$/;
          var value = self2.toString();
          var matches = regexp_format.exec(value);
          if (matches) {
            var regexp_pattern = matches[1];
            var regexp_flags = matches[2];
            var chars = regexp_pattern.split("");
            var chars_length = chars.length;
            var char_escaped = false;
            var regexp_pattern_escaped = "";
            for (var i = 0; i < chars_length; i++) {
              var current_char = chars[i];
              if (!char_escaped && current_char == "/") {
                regexp_pattern_escaped = regexp_pattern_escaped.concat("\\");
              }
              regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
              if (current_char == "\\") {
                if (char_escaped) {
                  char_escaped = false;
                } else {
                  char_escaped = true;
                }
              } else {
                char_escaped = false;
              }
            }
            return "/" + regexp_pattern_escaped + "/" + regexp_flags;
          } else {
            return value;
          }
        });
        $def(self, "$match", function $$match(string, pos) {
          var block = $$match.$$p || nil, self2 = this;
          if ($gvars["~"] == null)
            $gvars["~"] = nil;
          $$match.$$p = null;
          ;
          ;
          if (self2.uninitialized) {
            $Kernel.$raise($$$("TypeError"), "uninitialized Regexp");
          }
          if (pos === void 0) {
            if (string === nil)
              return $gvars["~"] = nil;
            var m = self2.exec($coerce_to(string, $$$("String"), "to_str"));
            if (m) {
              $gvars["~"] = $$$("MatchData").$new(self2, m);
              return block === nil ? $gvars["~"] : Opal2.yield1(block, $gvars["~"]);
            } else {
              return $gvars["~"] = nil;
            }
          }
          pos = $coerce_to(pos, $$$("Integer"), "to_int");
          if (string === nil) {
            return $gvars["~"] = nil;
          }
          string = $coerce_to(string, $$$("String"), "to_str");
          if (pos < 0) {
            pos += string.length;
            if (pos < 0) {
              return $gvars["~"] = nil;
            }
          }
          var md, re = Opal2.global_regexp(self2);
          while (true) {
            md = re.exec(string);
            if (md === null) {
              return $gvars["~"] = nil;
            }
            if (md.index >= pos) {
              $gvars["~"] = $$$("MatchData").$new(re, md);
              return block === nil ? $gvars["~"] : Opal2.yield1(block, $gvars["~"]);
            }
            re.lastIndex = md.index + 1;
          }
          ;
        }, -2);
        $def(self, "$match?", function $Regexp_match$ques$5(string, pos) {
          var self2 = this;
          ;
          if (self2.uninitialized) {
            $Kernel.$raise($$$("TypeError"), "uninitialized Regexp");
          }
          if (pos === void 0) {
            return string === nil ? false : self2.test($coerce_to(string, $$$("String"), "to_str"));
          }
          pos = $coerce_to(pos, $$$("Integer"), "to_int");
          if (string === nil) {
            return false;
          }
          string = $coerce_to(string, $$$("String"), "to_str");
          if (pos < 0) {
            pos += string.length;
            if (pos < 0) {
              return false;
            }
          }
          var md, re = Opal2.global_regexp(self2);
          md = re.exec(string);
          if (md === null || md.index < pos) {
            return false;
          } else {
            return true;
          }
          ;
        }, -2);
        $def(self, "$names", function $$names() {
          var self2 = this;
          return $send(self2.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], { "no_matchdata": true })), "map", [], "first".$to_proc()).$uniq();
        });
        $def(self, "$named_captures", function $$named_captures() {
          var self2 = this;
          return $send($send($send(self2.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], { "no_matchdata": true })), "map", [], "first".$to_proc()).$each_with_index(), "group_by", [], "first".$to_proc()), "transform_values", [], function $$6(i) {
            if (i == null)
              i = nil;
            return $send(i, "map", [], function $$7(j) {
              if (j == null)
                j = nil;
              return $rb_plus(j.$last(), 1);
            });
          });
        });
        $def(self, "$~", function $Regexp_$$8() {
          var self2 = this;
          if ($gvars._ == null)
            $gvars._ = nil;
          return self2["$=~"]($gvars._);
        });
        $def(self, "$source", function $$source() {
          var self2 = this;
          return self2.source;
        });
        $def(self, "$options", function $$options() {
          var self2 = this;
          if (self2.uninitialized) {
            $Kernel.$raise($$$("TypeError"), "uninitialized Regexp");
          }
          var result = 0;
          if (self2.multiline) {
            result |= $$("MULTILINE");
          }
          if (self2.ignoreCase) {
            result |= $$("IGNORECASE");
          }
          return result;
        });
        $def(self, "$casefold?", function $Regexp_casefold$ques$9() {
          var self2 = this;
          return self2.ignoreCase;
        });
        $alias(self, "eql?", "==");
        return $alias(self, "to_s", "source");
      })("::", RegExp, $nesting);
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "MatchData");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self.$$prototype;
        $proto.matches = nil;
        self.$attr_reader("post_match", "pre_match", "regexp", "string");
        $def(self, "$initialize", function $$initialize(regexp, match_groups, $kwargs) {
          var no_matchdata, self2 = this;
          $kwargs = $ensure_kwargs($kwargs);
          no_matchdata = $kwargs.$$smap["no_matchdata"];
          if (no_matchdata == null)
            no_matchdata = false;
          if (!$truthy(no_matchdata)) {
            $gvars["~"] = self2;
          }
          ;
          self2.regexp = regexp;
          self2.begin = match_groups.index;
          self2.string = match_groups.input;
          self2.pre_match = match_groups.input.slice(0, match_groups.index);
          self2.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
          self2.matches = [];
          for (var i = 0, length = match_groups.length; i < length; i++) {
            var group = match_groups[i];
            if (group == null) {
              self2.matches.push(nil);
            } else {
              self2.matches.push(group);
            }
          }
          ;
        }, -3);
        $def(self, "$match", function $$match(idx) {
          var self2 = this, match = nil;
          if ($truthy(match = self2["$[]"](idx))) {
            return match;
          } else if ($truthy(idx["$is_a?"]($$("Integer"))) && $truthy($rb_ge(idx, self2.$length()))) {
            return $Kernel.$raise($$$("IndexError"), "index " + idx + " out of matches");
          } else {
            return nil;
          }
        });
        $def(self, "$match_length", function $$match_length(idx) {
          var $a, self2 = this;
          return $a = self2.$match(idx), $a === nil || $a == null ? nil : $a.$length();
        });
        $def(self, "$[]", function $MatchData_$$$10($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          if (args[0].$$is_string) {
            if (self2.$regexp().$names()["$include?"](args["$[]"](0))["$!"]()) {
              $Kernel.$raise($$$("IndexError"), "undefined group name reference: " + args["$[]"](0));
            }
            return self2.$named_captures()["$[]"](args["$[]"](0));
          } else {
            return $send(self2.matches, "[]", $to_a(args));
          }
          ;
        }, -1);
        $def(self, "$offset", function $$offset(n) {
          var self2 = this;
          if (n !== 0) {
            $Kernel.$raise($$$("ArgumentError"), "MatchData#offset only supports 0th element");
          }
          return [self2.begin, self2.begin + self2.matches[n].length];
        });
        $def(self, "$==", function $MatchData_$eq_eq$11(other) {
          var self2 = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;
          if (!$eqeqeq($$$("MatchData"), other)) {
            return false;
          }
          ;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = $truthy($ret_or_4 = self2.string == other.string) ? self2.regexp.toString() == other.regexp.toString() : $ret_or_4) ? self2.pre_match == other.pre_match : $ret_or_3) ? self2.post_match == other.post_match : $ret_or_2)) {
            return self2.begin == other.begin;
          } else {
            return $ret_or_1;
          }
          ;
        });
        $def(self, "$begin", function $$begin(n) {
          var self2 = this;
          if (n !== 0) {
            $Kernel.$raise($$$("ArgumentError"), "MatchData#begin only supports 0th element");
          }
          return self2.begin;
        });
        $def(self, "$end", function $$end(n) {
          var self2 = this;
          if (n !== 0) {
            $Kernel.$raise($$$("ArgumentError"), "MatchData#end only supports 0th element");
          }
          return self2.begin + self2.matches[n].length;
        });
        $def(self, "$captures", function $$captures() {
          var self2 = this;
          return self2.matches.slice(1);
        });
        $def(self, "$named_captures", function $$named_captures() {
          var self2 = this, matches = nil;
          matches = self2.$captures();
          return $send(self2.$regexp().$named_captures(), "transform_values", [], function $$12(i) {
            if (i == null)
              i = nil;
            return matches["$[]"]($rb_minus(i.$last(), 1));
          });
        });
        $def(self, "$names", function $$names() {
          var self2 = this;
          return self2.$regexp().$names();
        });
        $def(self, "$inspect", function $$inspect() {
          var self2 = this;
          var str = "#<MatchData " + self2.matches[0].$inspect();
          if (self2.$regexp().$names()["$empty?"]()) {
            for (var i = 1, length = self2.matches.length; i < length; i++) {
              str += " " + i + ":" + self2.matches[i].$inspect();
            }
          } else {
            $send(self2.$named_captures(), "each", [], function $$13(k, v) {
              if (k == null)
                k = nil;
              if (v == null)
                v = nil;
              return str += " " + k + ":" + v.$inspect();
            });
          }
          return str + ">";
        });
        $def(self, "$length", function $$length() {
          var self2 = this;
          return self2.matches.length;
        });
        $def(self, "$to_a", $return_ivar("matches"));
        $def(self, "$to_s", function $$to_s() {
          var self2 = this;
          return self2.matches[0];
        });
        $def(self, "$values_at", function $$values_at($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          var i, a, index, values = [];
          for (i = 0; i < args.length; i++) {
            if (args[i].$$is_range) {
              a = args[i].$to_a();
              a.unshift(i, 1);
              Array.prototype.splice.apply(args, a);
            }
            index = $Opal["$coerce_to!"](args[i], $$$("Integer"), "to_int");
            if (index < 0) {
              index += self2.matches.length;
              if (index < 0) {
                values.push(nil);
                continue;
              }
            }
            values.push(self2.matches[index]);
          }
          return values;
          ;
        }, -1);
        $alias(self, "eql?", "==");
        return $alias(self, "size", "length");
      }($nesting[0], null, $nesting);
    };
    Opal.modules["corelib/string"] = function(Opal2) {
      var $coerce_to = Opal2.coerce_to, $respond_to = Opal2.respond_to, $global_multiline_regexp = Opal2.global_multiline_regexp, $prop = Opal2.prop, $klass = Opal2.klass, $def = Opal2.def, $Opal = Opal2.Opal, $defs = Opal2.defs, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $extract_kwargs = Opal2.extract_kwargs, $ensure_kwargs = Opal2.ensure_kwargs, $eqeqeq = Opal2.eqeqeq, $Kernel = Opal2.Kernel, $truthy = Opal2.truthy, $gvars = Opal2.gvars, $rb_divide = Opal2.rb_divide, $rb_plus = Opal2.rb_plus, $eqeq = Opal2.eqeq, $hash2 = Opal2.hash2, $alias = Opal2.alias, $const_set = Opal2.const_set, self = Opal2.top, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,nil?,class,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,length,each_line,to_proc,to_a,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine");
      self.$require("corelib/comparable");
      self.$require("corelib/regexp");
      (function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "String");
        var $nesting2 = [self2].concat($parent_nesting), $$2 = Opal2.$r($nesting2);
        self2.$include($$$("Comparable"));
        Opal2.prop(self2.$$prototype, "$$is_string", true);
        ;
        $def(self2, "$__id__", function $$__id__() {
          var self3 = this;
          return self3.toString();
        });
        $defs(self2, "$try_convert", function $$try_convert(what) {
          return $Opal["$coerce_to?"](what, $$$("String"), "to_str");
        });
        $defs(self2, "$new", function $String_new$1($a) {
          var $post_args, args, self3 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          var str = args[0] || "";
          var opts = args[args.length - 1];
          str = $coerce_to(str, $$$("String"), "to_str");
          if (opts && opts.$$is_hash) {
            if (opts.$$smap.encoding)
              str = str.$force_encoding(opts.$$smap.encoding);
          }
          str = new self3.$$constructor(str);
          if (!str.$initialize.$$pristine)
            $send(str, "initialize", $to_a(args));
          return str;
          ;
        }, -1);
        $def(self2, "$initialize", function $$initialize($a, $b) {
          var $post_args, $kwargs, str, encoding, capacity;
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          if ($post_args.length > 0)
            str = $post_args.shift();
          ;
          encoding = $kwargs.$$smap["encoding"];
          if (encoding == null)
            encoding = nil;
          capacity = $kwargs.$$smap["capacity"];
          if (capacity == null)
            capacity = nil;
          return nil;
        }, -1);
        $def(self2, "$%", function $String_$percent$2(data) {
          var self3 = this;
          if ($eqeqeq($$$("Array"), data)) {
            return $send(self3, "format", [self3].concat($to_a(data)));
          } else {
            return self3.$format(self3, data);
          }
        });
        $def(self2, "$*", function $String_$$3(count) {
          var self3 = this;
          count = $coerce_to(count, $$$("Integer"), "to_int");
          if (count < 0) {
            $Kernel.$raise($$$("ArgumentError"), "negative argument");
          }
          if (count === 0) {
            return "";
          }
          var result = "", string = self3.toString();
          if (string.length * count >= 1 << 28) {
            $Kernel.$raise($$$("RangeError"), "multiply count must not overflow maximum string size");
          }
          for (; ; ) {
            if ((count & 1) === 1) {
              result += string;
            }
            count >>>= 1;
            if (count === 0) {
              break;
            }
            string += string;
          }
          return result;
        });
        $def(self2, "$+", function $String_$plus$4(other) {
          var self3 = this;
          other = $coerce_to(other, $$$("String"), "to_str");
          if (other == "" && self3.$$class === Opal2.String)
            return self3;
          if (self3 == "" && other.$$class === Opal2.String)
            return other;
          var out = self3 + other;
          if (self3.encoding === out.encoding && other.encoding === out.encoding)
            return out;
          if (self3.encoding.name === "UTF-8" || other.encoding.name === "UTF-8")
            return out;
          return Opal2.enc(out, self3.encoding);
          ;
        });
        $def(self2, "$<=>", function $String_$lt_eq_gt$5(other) {
          var self3 = this;
          if ($truthy(other["$respond_to?"]("to_str"))) {
            other = other.$to_str().$to_s();
            return self3 > other ? 1 : self3 < other ? -1 : 0;
            ;
          } else {
            var cmp = other["$<=>"](self3);
            if (cmp === nil) {
              return nil;
            } else {
              return cmp > 0 ? -1 : cmp < 0 ? 1 : 0;
            }
          }
        });
        $def(self2, "$==", function $String_$eq_eq$6(other) {
          var self3 = this;
          if (other.$$is_string) {
            return self3.toString() === other.toString();
          }
          if ($respond_to(other, "$to_str")) {
            return other["$=="](self3);
          }
          return false;
        });
        $def(self2, "$=~", function $String_$eq_tilde$7(other) {
          var self3 = this;
          if (other.$$is_string) {
            $Kernel.$raise($$$("TypeError"), "type mismatch: String given");
          }
          return other["$=~"](self3);
        });
        $def(self2, "$[]", function $String_$$$8(index, length) {
          var self3 = this;
          ;
          var size = self3.length, exclude, range;
          if (index.$$is_range) {
            exclude = index.excl;
            range = index;
            length = index.end === nil ? -1 : $coerce_to(index.end, $$$("Integer"), "to_int");
            index = index.begin === nil ? 0 : $coerce_to(index.begin, $$$("Integer"), "to_int");
            if (Math.abs(index) > size) {
              return nil;
            }
            if (index < 0) {
              index += size;
            }
            if (length < 0) {
              length += size;
            }
            if (!exclude || range.end === nil) {
              length += 1;
            }
            length = length - index;
            if (length < 0) {
              length = 0;
            }
            return self3.substr(index, length);
          }
          if (index.$$is_string) {
            if (length != null) {
              $Kernel.$raise($$$("TypeError"));
            }
            return self3.indexOf(index) !== -1 ? index : nil;
          }
          if (index.$$is_regexp) {
            var match = self3.match(index);
            if (match === null) {
              $gvars["~"] = nil;
              return nil;
            }
            $gvars["~"] = $$$("MatchData").$new(index, match);
            if (length == null) {
              return match[0];
            }
            length = $coerce_to(length, $$$("Integer"), "to_int");
            if (length < 0 && -length < match.length) {
              return match[length += match.length];
            }
            if (length >= 0 && length < match.length) {
              return match[length];
            }
            return nil;
          }
          index = $coerce_to(index, $$$("Integer"), "to_int");
          if (index < 0) {
            index += size;
          }
          if (length == null) {
            if (index >= size || index < 0) {
              return nil;
            }
            return self3.substr(index, 1);
          }
          length = $coerce_to(length, $$$("Integer"), "to_int");
          if (length < 0) {
            return nil;
          }
          if (index > size || index < 0) {
            return nil;
          }
          return self3.substr(index, length);
          ;
        }, -2);
        $def(self2, "$b", function $$b() {
          var self3 = this;
          return new String(self3).$force_encoding("binary");
        });
        $def(self2, "$capitalize", function $$capitalize() {
          var self3 = this;
          return self3.charAt(0).toUpperCase() + self3.substr(1).toLowerCase();
        });
        $def(self2, "$casecmp", function $$casecmp(other) {
          var self3 = this;
          if (!$truthy(other["$respond_to?"]("to_str"))) {
            return nil;
          }
          ;
          other = $coerce_to(other, $$$("String"), "to_str").$to_s();
          var ascii_only = /^[\x00-\x7F]*$/;
          if (ascii_only.test(self3) && ascii_only.test(other)) {
            self3 = self3.toLowerCase();
            other = other.toLowerCase();
          }
          ;
          return self3["$<=>"](other);
        });
        $def(self2, "$casecmp?", function $String_casecmp$ques$9(other) {
          var self3 = this;
          var cmp = self3.$casecmp(other);
          if (cmp === nil) {
            return nil;
          } else {
            return cmp === 0;
          }
        });
        $def(self2, "$center", function $$center(width, padstr) {
          var self3 = this;
          if (padstr == null)
            padstr = " ";
          width = $coerce_to(width, $$$("Integer"), "to_int");
          padstr = $coerce_to(padstr, $$$("String"), "to_str").$to_s();
          if ($truthy(padstr["$empty?"]())) {
            $Kernel.$raise($$$("ArgumentError"), "zero width padding");
          }
          ;
          if ($truthy(width <= self3.length)) {
            return self3;
          }
          ;
          var ljustified = self3.$ljust($rb_divide($rb_plus(width, self3.length), 2).$ceil(), padstr), rjustified = self3.$rjust($rb_divide($rb_plus(width, self3.length), 2).$floor(), padstr);
          return rjustified + ljustified.slice(self3.length);
          ;
        }, -2);
        $def(self2, "$chomp", function $$chomp(separator) {
          var self3 = this;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          if (separator == null)
            separator = $gvars["/"];
          if ($truthy(separator === nil || self3.length === 0)) {
            return self3;
          }
          ;
          separator = $Opal["$coerce_to!"](separator, $$$("String"), "to_str").$to_s();
          var result;
          if (separator === "\n") {
            result = self3.replace(/\r?\n?$/, "");
          } else if (separator === "") {
            result = self3.replace(/(\r?\n)+$/, "");
          } else if (self3.length >= separator.length) {
            var tail = self3.substr(self3.length - separator.length, separator.length);
            if (tail === separator) {
              result = self3.substr(0, self3.length - separator.length);
            }
          }
          if (result != null) {
            return result;
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$chop", function $$chop() {
          var self3 = this;
          var length = self3.length, result;
          if (length <= 1) {
            result = "";
          } else if (self3.charAt(length - 1) === "\n" && self3.charAt(length - 2) === "\r") {
            result = self3.substr(0, length - 2);
          } else {
            result = self3.substr(0, length - 1);
          }
          return result;
        });
        $def(self2, "$chr", function $$chr() {
          var self3 = this;
          return self3.charAt(0);
        });
        $def(self2, "$clone", function $$clone($kwargs) {
          var freeze, self3 = this, copy = nil;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = nil;
          if (!($truthy(freeze["$nil?"]()) || $eqeq(freeze, true) || $eqeq(freeze, false))) {
            self3.$raise($$2("ArgumentError"), "unexpected value for freeze: " + freeze.$class());
          }
          ;
          copy = new String(self3);
          copy.$copy_singleton_methods(self3);
          copy.$initialize_clone(self3, $hash2(["freeze"], { "freeze": freeze }));
          if ($eqeq(freeze, true)) {
            if (!copy.$$frozen) {
              copy.$$frozen = true;
            }
          } else if ($truthy(freeze["$nil?"]())) {
            if (self3.$$frozen) {
              copy.$$frozen = true;
            }
          }
          ;
          return copy;
        }, -1);
        $def(self2, "$dup", function $$dup() {
          var self3 = this, copy = nil;
          copy = new String(self3);
          copy.$initialize_dup(self3);
          return copy;
        });
        $def(self2, "$count", function $$count($a) {
          var $post_args, sets, self3 = this;
          $post_args = $slice(arguments);
          sets = $post_args;
          if (sets.length === 0) {
            $Kernel.$raise($$$("ArgumentError"), "ArgumentError: wrong number of arguments (0 for 1+)");
          }
          var char_class = char_class_from_char_sets(sets);
          if (char_class === null) {
            return 0;
          }
          return self3.length - self3.replace(new RegExp(char_class, "g"), "").length;
          ;
        }, -1);
        $def(self2, "$delete", function $String_delete$10($a) {
          var $post_args, sets, self3 = this;
          $post_args = $slice(arguments);
          sets = $post_args;
          if (sets.length === 0) {
            $Kernel.$raise($$$("ArgumentError"), "ArgumentError: wrong number of arguments (0 for 1+)");
          }
          var char_class = char_class_from_char_sets(sets);
          if (char_class === null) {
            return self3;
          }
          return self3.replace(new RegExp(char_class, "g"), "");
          ;
        }, -1);
        $def(self2, "$delete_prefix", function $$delete_prefix(prefix) {
          var self3 = this;
          if (!prefix.$$is_string) {
            prefix = $coerce_to(prefix, $$$("String"), "to_str");
          }
          if (self3.slice(0, prefix.length) === prefix) {
            return self3.slice(prefix.length);
          } else {
            return self3;
          }
        });
        $def(self2, "$delete_suffix", function $$delete_suffix(suffix) {
          var self3 = this;
          if (!suffix.$$is_string) {
            suffix = $coerce_to(suffix, $$$("String"), "to_str");
          }
          if (self3.slice(self3.length - suffix.length) === suffix) {
            return self3.slice(0, self3.length - suffix.length);
          } else {
            return self3;
          }
        });
        $def(self2, "$downcase", function $$downcase() {
          var self3 = this;
          return self3.toLowerCase();
        });
        $def(self2, "$each_line", function $$each_line($a, $b) {
          var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self3 = this;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          $$each_line.$$p = null;
          ;
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          if ($post_args.length > 0)
            separator = $post_args.shift();
          if (separator == null)
            separator = $gvars["/"];
          chomp = $kwargs.$$smap["chomp"];
          if (chomp == null)
            chomp = false;
          if (!(block !== nil)) {
            return self3.$enum_for("each_line", separator, $hash2(["chomp"], { "chomp": chomp }));
          }
          ;
          if (separator === nil) {
            Opal2.yield1(block, self3);
            return self3;
          }
          separator = $coerce_to(separator, $$$("String"), "to_str");
          var a, i, n, length, chomped, trailing, splitted, value;
          if (separator.length === 0) {
            for (a = self3.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
              if (a[i] || a[i + 1]) {
                value = (a[i] || "") + (a[i + 1] || "");
                if (chomp) {
                  value = value.$chomp("\n");
                }
                Opal2.yield1(block, value);
              }
            }
            return self3;
          }
          chomped = self3.$chomp(separator);
          trailing = self3.length != chomped.length;
          splitted = chomped.split(separator);
          for (i = 0, length = splitted.length; i < length; i++) {
            value = splitted[i];
            if (i < length - 1 || trailing) {
              value += separator;
            }
            if (chomp) {
              value = value.$chomp(separator);
            }
            Opal2.yield1(block, value);
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$empty?", function $String_empty$ques$11() {
          var self3 = this;
          return self3.length === 0;
        });
        $def(self2, "$end_with?", function $String_end_with$ques$12($a) {
          var $post_args, suffixes, self3 = this;
          $post_args = $slice(arguments);
          suffixes = $post_args;
          for (var i = 0, length = suffixes.length; i < length; i++) {
            var suffix = $coerce_to(suffixes[i], $$$("String"), "to_str").$to_s();
            if (self3.length >= suffix.length && self3.substr(self3.length - suffix.length, suffix.length) == suffix) {
              return true;
            }
          }
          ;
          return false;
        }, -1);
        $def(self2, "$gsub", function $$gsub(pattern, replacement) {
          var block = $$gsub.$$p || nil, self3 = this;
          $$gsub.$$p = null;
          ;
          ;
          if (replacement === void 0 && block === nil) {
            return self3.$enum_for("gsub", pattern);
          }
          var result = "", match_data = nil, index = 0, match, _replacement;
          if (pattern.$$is_regexp) {
            pattern = $global_multiline_regexp(pattern);
          } else {
            pattern = $coerce_to(pattern, $$$("String"), "to_str");
            pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gm");
          }
          var lastIndex;
          while (true) {
            match = pattern.exec(self3);
            if (match === null) {
              $gvars["~"] = nil;
              result += self3.slice(index);
              break;
            }
            match_data = $$$("MatchData").$new(pattern, match);
            if (replacement === void 0) {
              lastIndex = pattern.lastIndex;
              _replacement = block(match[0]);
              pattern.lastIndex = lastIndex;
            } else if (replacement.$$is_hash) {
              _replacement = replacement["$[]"](match[0]).$to_s();
            } else {
              if (!replacement.$$is_string) {
                replacement = $coerce_to(replacement, $$$("String"), "to_str");
              }
              _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function(original, slashes, command) {
                if (slashes.length % 2 === 0) {
                  return original;
                }
                switch (command) {
                  case "+":
                    for (var i = match.length - 1; i > 0; i--) {
                      if (match[i] !== void 0) {
                        return slashes.slice(1) + match[i];
                      }
                    }
                    return "";
                  case "&":
                    return slashes.slice(1) + match[0];
                  case "`":
                    return slashes.slice(1) + self3.slice(0, match.index);
                  case "'":
                    return slashes.slice(1) + self3.slice(match.index + match[0].length);
                  default:
                    return slashes.slice(1) + (match[command] || "");
                }
              }).replace(/\\\\/g, "\\");
            }
            if (pattern.lastIndex === match.index) {
              result += self3.slice(index, match.index) + _replacement + (self3[match.index] || "");
              pattern.lastIndex += 1;
            } else {
              result += self3.slice(index, match.index) + _replacement;
            }
            index = pattern.lastIndex;
          }
          $gvars["~"] = match_data;
          return result;
          ;
        }, -2);
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return self3.toString();
        });
        $def(self2, "$hex", function $$hex() {
          var self3 = this;
          return self3.$to_i(16);
        });
        $def(self2, "$include?", function $String_include$ques$13(other) {
          var self3 = this;
          if (!other.$$is_string) {
            other = $coerce_to(other, $$$("String"), "to_str");
          }
          return self3.indexOf(other) !== -1;
        });
        $def(self2, "$index", function $$index(search, offset) {
          var self3 = this;
          ;
          var index, match, regex;
          if (offset === void 0) {
            offset = 0;
          } else {
            offset = $coerce_to(offset, $$$("Integer"), "to_int");
            if (offset < 0) {
              offset += self3.length;
              if (offset < 0) {
                return nil;
              }
            }
          }
          if (search.$$is_regexp) {
            regex = $global_multiline_regexp(search);
            while (true) {
              match = regex.exec(self3);
              if (match === null) {
                $gvars["~"] = nil;
                index = -1;
                break;
              }
              if (match.index >= offset) {
                $gvars["~"] = $$$("MatchData").$new(regex, match);
                index = match.index;
                break;
              }
              regex.lastIndex = match.index + 1;
            }
          } else {
            search = $coerce_to(search, $$$("String"), "to_str");
            if (search.length === 0 && offset > self3.length) {
              index = -1;
            } else {
              index = self3.indexOf(search, offset);
            }
          }
          return index === -1 ? nil : index;
          ;
        }, -2);
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta = {
            "\x07": "\\a",
            "\x1B": "\\e",
            "\b": "\\b",
            "	": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\v": "\\v",
            '"': '\\"',
            "\\": "\\\\"
          }, escaped = self3.replace(escapable, function(chr) {
            if (meta[chr])
              return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 255 && (self3.encoding["$binary?"]() || self3.internal_encoding["$binary?"]())) {
              return "\\x" + ("00" + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return "\\u" + ("0000" + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
          return '"' + escaped.replace(/\#[\$\@\{]/g, "\\$&") + '"';
        });
        $def(self2, "$intern", function $$intern() {
          var self3 = this;
          return self3.toString();
        });
        $def(self2, "$length", function $$length() {
          var self3 = this;
          return self3.length;
        });
        $alias(self2, "size", "length");
        $def(self2, "$lines", function $$lines($a, $b) {
          var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self3 = this, e = nil;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          $$lines.$$p = null;
          ;
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          if ($post_args.length > 0)
            separator = $post_args.shift();
          if (separator == null)
            separator = $gvars["/"];
          chomp = $kwargs.$$smap["chomp"];
          if (chomp == null)
            chomp = false;
          e = $send(self3, "each_line", [separator, $hash2(["chomp"], { "chomp": chomp })], block.$to_proc());
          if ($truthy(block)) {
            return self3;
          } else {
            return e.$to_a();
          }
          ;
        }, -1);
        $def(self2, "$ljust", function $$ljust(width, padstr) {
          var self3 = this;
          if (padstr == null)
            padstr = " ";
          width = $coerce_to(width, $$$("Integer"), "to_int");
          padstr = $coerce_to(padstr, $$$("String"), "to_str").$to_s();
          if ($truthy(padstr["$empty?"]())) {
            $Kernel.$raise($$$("ArgumentError"), "zero width padding");
          }
          ;
          if ($truthy(width <= self3.length)) {
            return self3;
          }
          ;
          var index = -1, result = "";
          width -= self3.length;
          while (++index < width) {
            result += padstr;
          }
          return self3 + result.slice(0, width);
          ;
        }, -2);
        $def(self2, "$lstrip", function $$lstrip() {
          var self3 = this;
          return self3.replace(/^[\u0000\s]*/, "");
        });
        $def(self2, "$ascii_only?", function $String_ascii_only$ques$14() {
          var self3 = this;
          if (!self3.encoding.ascii)
            return false;
          return /^[\x00-\x7F]*$/.test(self3);
        });
        $def(self2, "$match", function $$match(pattern, pos) {
          var block = $$match.$$p || nil, self3 = this;
          $$match.$$p = null;
          ;
          ;
          if ($eqeqeq($$2("String"), pattern) || $truthy(pattern["$respond_to?"]("to_str"))) {
            pattern = $$$("Regexp").$new(pattern.$to_str());
          }
          ;
          if (!$eqeqeq($$$("Regexp"), pattern)) {
            $Kernel.$raise($$$("TypeError"), "wrong argument type " + pattern.$class() + " (expected Regexp)");
          }
          ;
          return $send(pattern, "match", [self3, pos], block.$to_proc());
        }, -2);
        $def(self2, "$match?", function $String_match$ques$15(pattern, pos) {
          var self3 = this;
          ;
          if ($eqeqeq($$2("String"), pattern) || $truthy(pattern["$respond_to?"]("to_str"))) {
            pattern = $$$("Regexp").$new(pattern.$to_str());
          }
          ;
          if (!$eqeqeq($$$("Regexp"), pattern)) {
            $Kernel.$raise($$$("TypeError"), "wrong argument type " + pattern.$class() + " (expected Regexp)");
          }
          ;
          return pattern["$match?"](self3, pos);
        }, -2);
        $def(self2, "$next", function $$next() {
          var self3 = this;
          var i = self3.length;
          if (i === 0) {
            return "";
          }
          var result = self3;
          var first_alphanum_char_index = self3.search(/[a-zA-Z0-9]/);
          var carry = false;
          var code;
          while (i--) {
            code = self3.charCodeAt(i);
            if (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122) {
              switch (code) {
                case 57:
                  carry = true;
                  code = 48;
                  break;
                case 90:
                  carry = true;
                  code = 65;
                  break;
                case 122:
                  carry = true;
                  code = 97;
                  break;
                default:
                  carry = false;
                  code += 1;
              }
            } else {
              if (first_alphanum_char_index === -1) {
                if (code === 255) {
                  carry = true;
                  code = 0;
                } else {
                  carry = false;
                  code += 1;
                }
              } else {
                carry = true;
              }
            }
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
            if (carry && (i === 0 || i === first_alphanum_char_index)) {
              switch (code) {
                case 65:
                  break;
                case 97:
                  break;
                default:
                  code += 1;
              }
              if (i === 0) {
                result = String.fromCharCode(code) + result;
              } else {
                result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
              }
              carry = false;
            }
            if (!carry) {
              break;
            }
          }
          return result;
        });
        $def(self2, "$oct", function $$oct() {
          var self3 = this;
          var result, string = self3, radix = 8;
          if (/^\s*_/.test(string)) {
            return 0;
          }
          string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function(original, head, flag, tail) {
            switch (tail.charAt(0)) {
              case "+":
              case "-":
                return original;
              case "0":
                if (tail.charAt(1) === "x" && flag === "0x") {
                  return original;
                }
            }
            switch (flag) {
              case "0b":
                radix = 2;
                break;
              case "0":
              case "0o":
                radix = 8;
                break;
              case "0d":
                radix = 10;
                break;
              case "0x":
                radix = 16;
                break;
            }
            return head + tail;
          });
          result = parseInt(string.replace(/_(?!_)/g, ""), radix);
          return isNaN(result) ? 0 : result;
        });
        $def(self2, "$ord", function $$ord() {
          var self3 = this;
          if (typeof self3.codePointAt === "function") {
            return self3.codePointAt(0);
          } else {
            return self3.charCodeAt(0);
          }
        });
        $def(self2, "$partition", function $$partition(sep) {
          var self3 = this;
          var i, m;
          if (sep.$$is_regexp) {
            m = sep.exec(self3);
            if (m === null) {
              i = -1;
            } else {
              $$$("MatchData").$new(sep, m);
              sep = m[0];
              i = m.index;
            }
          } else {
            sep = $coerce_to(sep, $$$("String"), "to_str");
            i = self3.indexOf(sep);
          }
          if (i === -1) {
            return [self3, "", ""];
          }
          return [
            self3.slice(0, i),
            self3.slice(i, i + sep.length),
            self3.slice(i + sep.length)
          ];
        });
        $def(self2, "$reverse", function $$reverse() {
          var self3 = this;
          return self3.split("").reverse().join("");
        });
        $def(self2, "$rindex", function $$rindex(search, offset) {
          var self3 = this;
          ;
          var i, m, r, _m;
          if (offset === void 0) {
            offset = self3.length;
          } else {
            offset = $coerce_to(offset, $$$("Integer"), "to_int");
            if (offset < 0) {
              offset += self3.length;
              if (offset < 0) {
                return nil;
              }
            }
          }
          if (search.$$is_regexp) {
            m = null;
            r = $global_multiline_regexp(search);
            while (true) {
              _m = r.exec(self3);
              if (_m === null || _m.index > offset) {
                break;
              }
              m = _m;
              r.lastIndex = m.index + 1;
            }
            if (m === null) {
              $gvars["~"] = nil;
              i = -1;
            } else {
              $$$("MatchData").$new(r, m);
              i = m.index;
            }
          } else {
            search = $coerce_to(search, $$$("String"), "to_str");
            i = self3.lastIndexOf(search, offset);
          }
          return i === -1 ? nil : i;
          ;
        }, -2);
        $def(self2, "$rjust", function $$rjust(width, padstr) {
          var self3 = this;
          if (padstr == null)
            padstr = " ";
          width = $coerce_to(width, $$$("Integer"), "to_int");
          padstr = $coerce_to(padstr, $$$("String"), "to_str").$to_s();
          if ($truthy(padstr["$empty?"]())) {
            $Kernel.$raise($$$("ArgumentError"), "zero width padding");
          }
          ;
          if ($truthy(width <= self3.length)) {
            return self3;
          }
          ;
          var chars = Math.floor(width - self3.length), patterns = Math.floor(chars / padstr.length), result = Array(patterns + 1).join(padstr), remaining = chars - result.length;
          return result + padstr.slice(0, remaining) + self3;
          ;
        }, -2);
        $def(self2, "$rpartition", function $$rpartition(sep) {
          var self3 = this;
          var i, m, r, _m;
          if (sep.$$is_regexp) {
            m = null;
            r = $global_multiline_regexp(sep);
            while (true) {
              _m = r.exec(self3);
              if (_m === null) {
                break;
              }
              m = _m;
              r.lastIndex = m.index + 1;
            }
            if (m === null) {
              i = -1;
            } else {
              $$$("MatchData").$new(r, m);
              sep = m[0];
              i = m.index;
            }
          } else {
            sep = $coerce_to(sep, $$$("String"), "to_str");
            i = self3.lastIndexOf(sep);
          }
          if (i === -1) {
            return ["", "", self3];
          }
          return [
            self3.slice(0, i),
            self3.slice(i, i + sep.length),
            self3.slice(i + sep.length)
          ];
        });
        $def(self2, "$rstrip", function $$rstrip() {
          var self3 = this;
          return self3.replace(/[\s\u0000]*$/, "");
        });
        $def(self2, "$scan", function $$scan(pattern, $kwargs) {
          var block = $$scan.$$p || nil, no_matchdata, self3 = this;
          $$scan.$$p = null;
          ;
          $kwargs = $ensure_kwargs($kwargs);
          no_matchdata = $kwargs.$$smap["no_matchdata"];
          if (no_matchdata == null)
            no_matchdata = false;
          var result = [], match_data = nil, match;
          if (pattern.$$is_regexp) {
            pattern = $global_multiline_regexp(pattern);
          } else {
            pattern = $coerce_to(pattern, $$$("String"), "to_str");
            pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gm");
          }
          while ((match = pattern.exec(self3)) != null) {
            match_data = $$$("MatchData").$new(pattern, match, $hash2(["no_matchdata"], { "no_matchdata": no_matchdata }));
            if (block === nil) {
              match.length == 1 ? result.push(match[0]) : result.push(match_data.$captures());
            } else {
              match.length == 1 ? Opal2.yield1(block, match[0]) : Opal2.yield1(block, match_data.$captures());
            }
            if (pattern.lastIndex === match.index) {
              pattern.lastIndex += 1;
            }
          }
          if (!no_matchdata)
            $gvars["~"] = match_data;
          return block !== nil ? self3 : result;
          ;
        }, -2);
        $def(self2, "$singleton_class", function $$singleton_class() {
          var self3 = this;
          return Opal2.get_singleton_class(self3);
        });
        $def(self2, "$split", function $$split(pattern, limit) {
          var self3 = this, $ret_or_1 = nil;
          if ($gvars[";"] == null)
            $gvars[";"] = nil;
          ;
          ;
          if (self3.length === 0) {
            return [];
          }
          if (limit === void 0) {
            limit = 0;
          } else {
            limit = $Opal["$coerce_to!"](limit, $$$("Integer"), "to_int");
            if (limit === 1) {
              return [self3];
            }
          }
          if (pattern === void 0 || pattern === nil) {
            pattern = $truthy($ret_or_1 = $gvars[";"]) ? $ret_or_1 : " ";
          }
          var result = [], string = self3.toString(), index = 0, match, i, ii;
          if (pattern.$$is_regexp) {
            pattern = $global_multiline_regexp(pattern);
          } else {
            pattern = $coerce_to(pattern, $$$("String"), "to_str").$to_s();
            if (pattern === " ") {
              pattern = /\s+/gm;
              string = string.replace(/^\s+/, "");
            } else {
              pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gm");
            }
          }
          result = string.split(pattern);
          if (result.length === 1 && result[0] === string) {
            return [result[0]];
          }
          while ((i = result.indexOf(void 0)) !== -1) {
            result.splice(i, 1);
          }
          if (limit === 0) {
            while (result[result.length - 1] === "") {
              result.length -= 1;
            }
            return result;
          }
          match = pattern.exec(string);
          if (limit < 0) {
            if (match !== null && match[0] === "" && pattern.source.indexOf("(?=") === -1) {
              for (i = 0, ii = match.length; i < ii; i++) {
                result.push("");
              }
            }
            return result;
          }
          if (match !== null && match[0] === "") {
            result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(""));
            return result;
          }
          if (limit >= result.length) {
            return result;
          }
          i = 0;
          while (match !== null) {
            i++;
            index = pattern.lastIndex;
            if (i + 1 === limit) {
              break;
            }
            match = pattern.exec(string);
          }
          result.splice(limit - 1, result.length - 1, string.slice(index));
          return result;
          ;
        }, -1);
        $def(self2, "$squeeze", function $$squeeze($a) {
          var $post_args, sets, self3 = this;
          $post_args = $slice(arguments);
          sets = $post_args;
          if (sets.length === 0) {
            return self3.replace(/(.)\1+/g, "$1");
          }
          var char_class = char_class_from_char_sets(sets);
          if (char_class === null) {
            return self3;
          }
          return self3.replace(new RegExp("(" + char_class + ")\\1+", "g"), "$1");
          ;
        }, -1);
        $def(self2, "$start_with?", function $String_start_with$ques$16($a) {
          var $post_args, prefixes, self3 = this;
          $post_args = $slice(arguments);
          prefixes = $post_args;
          for (var i = 0, length = prefixes.length; i < length; i++) {
            if (prefixes[i].$$is_regexp) {
              var regexp = prefixes[i];
              var match = regexp.exec(self3);
              if (match != null && match.index === 0) {
                $gvars["~"] = $$$("MatchData").$new(regexp, match);
                return true;
              } else {
                $gvars["~"] = nil;
              }
            } else {
              var prefix = $coerce_to(prefixes[i], $$$("String"), "to_str").$to_s();
              if (self3.indexOf(prefix) === 0) {
                return true;
              }
            }
          }
          return false;
          ;
        }, -1);
        $def(self2, "$strip", function $$strip() {
          var self3 = this;
          return self3.replace(/^[\s\u0000]*|[\s\u0000]*$/g, "");
        });
        $def(self2, "$sub", function $$sub(pattern, replacement) {
          var block = $$sub.$$p || nil, self3 = this;
          $$sub.$$p = null;
          ;
          ;
          if (!pattern.$$is_regexp) {
            pattern = $coerce_to(pattern, $$$("String"), "to_str");
            pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
          }
          var result, match = pattern.exec(self3);
          if (match === null) {
            $gvars["~"] = nil;
            result = self3.toString();
          } else {
            $$$("MatchData").$new(pattern, match);
            if (replacement === void 0) {
              if (block === nil) {
                $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (1 for 2)");
              }
              result = self3.slice(0, match.index) + block(match[0]) + self3.slice(match.index + match[0].length);
            } else if (replacement.$$is_hash) {
              result = self3.slice(0, match.index) + replacement["$[]"](match[0]).$to_s() + self3.slice(match.index + match[0].length);
            } else {
              replacement = $coerce_to(replacement, $$$("String"), "to_str");
              replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function(original, slashes, command) {
                if (slashes.length % 2 === 0) {
                  return original;
                }
                switch (command) {
                  case "+":
                    for (var i = match.length - 1; i > 0; i--) {
                      if (match[i] !== void 0) {
                        return slashes.slice(1) + match[i];
                      }
                    }
                    return "";
                  case "&":
                    return slashes.slice(1) + match[0];
                  case "`":
                    return slashes.slice(1) + self3.slice(0, match.index);
                  case "'":
                    return slashes.slice(1) + self3.slice(match.index + match[0].length);
                  default:
                    return slashes.slice(1) + (match[command] || "");
                }
              }).replace(/\\\\/g, "\\");
              result = self3.slice(0, match.index) + replacement + self3.slice(match.index + match[0].length);
            }
          }
          return result;
          ;
        }, -2);
        $def(self2, "$sum", function $$sum(n) {
          var self3 = this;
          if (n == null)
            n = 16;
          n = $coerce_to(n, $$$("Integer"), "to_int");
          var result = 0, length = self3.length, i = 0;
          for (; i < length; i++) {
            result += self3.charCodeAt(i);
          }
          if (n <= 0) {
            return result;
          }
          return result & Math.pow(2, n) - 1;
          ;
        }, -1);
        $def(self2, "$swapcase", function $$swapcase() {
          var self3 = this;
          var str = self3.replace(/([a-z]+)|([A-Z]+)/g, function($0, $1, $2) {
            return $1 ? $0.toUpperCase() : $0.toLowerCase();
          });
          return str;
        });
        $def(self2, "$to_f", function $$to_f() {
          var self3 = this;
          if (self3.charAt(0) === "_") {
            return 0;
          }
          var result = parseFloat(self3.replace(/_/g, ""));
          if (isNaN(result) || result == Infinity || result == -Infinity) {
            return 0;
          } else {
            return result;
          }
        });
        $def(self2, "$to_i", function $$to_i(base) {
          var self3 = this;
          if (base == null)
            base = 10;
          var result, string = self3.toLowerCase(), radix = $coerce_to(base, $$$("Integer"), "to_int");
          if (radix === 1 || radix < 0 || radix > 36) {
            $Kernel.$raise($$$("ArgumentError"), "invalid radix " + radix);
          }
          if (/^\s*_/.test(string)) {
            return 0;
          }
          string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function(original, head, flag, tail) {
            switch (tail.charAt(0)) {
              case "+":
              case "-":
                return original;
              case "0":
                if (tail.charAt(1) === "x" && flag === "0x" && (radix === 0 || radix === 16)) {
                  return original;
                }
            }
            switch (flag) {
              case "0b":
                if (radix === 0 || radix === 2) {
                  radix = 2;
                  return head + tail;
                }
                break;
              case "0":
              case "0o":
                if (radix === 0 || radix === 8) {
                  radix = 8;
                  return head + tail;
                }
                break;
              case "0d":
                if (radix === 0 || radix === 10) {
                  radix = 10;
                  return head + tail;
                }
                break;
              case "0x":
                if (radix === 0 || radix === 16) {
                  radix = 16;
                  return head + tail;
                }
                break;
            }
            return original;
          });
          result = parseInt(string.replace(/_(?!_)/g, ""), radix);
          return isNaN(result) ? 0 : result;
          ;
        }, -1);
        $def(self2, "$to_proc", function $$to_proc() {
          var $yield = $$to_proc.$$p || nil, self3 = this, method_name = nil, jsid = nil, proc = nil;
          $$to_proc.$$p = null;
          method_name = self3.valueOf();
          jsid = Opal2.jsid(method_name);
          proc = $send($Kernel, "proc", [], function $$17($a) {
            var block = $$17.$$p || nil, $post_args, args;
            $$17.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            if (args.length === 0) {
              $Kernel.$raise($$$("ArgumentError"), "no receiver given");
            }
            var recv = args[0];
            if (recv == null)
              recv = nil;
            var body = recv[jsid];
            if (!body) {
              body = recv.$method_missing;
              args[0] = method_name;
            } else {
              args = args.slice(1);
            }
            if (typeof block === "function") {
              body.$$p = block;
            }
            if (args.length === 0) {
              return body.call(recv);
            } else {
              return body.apply(recv, args);
            }
            ;
          }, -1);
          proc.$$source_location = nil;
          return proc;
        });
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this;
          return self3.toString();
        });
        $def(self2, "$tr", function $$tr(from, to) {
          var self3 = this;
          from = $coerce_to(from, $$$("String"), "to_str").$to_s();
          to = $coerce_to(to, $$$("String"), "to_str").$to_s();
          if (from.length == 0 || from === to) {
            return self3;
          }
          var i, in_range, c, ch, start, end, length;
          var subs = {};
          var from_chars = from.split("");
          var from_length = from_chars.length;
          var to_chars = to.split("");
          var to_length = to_chars.length;
          var inverse = false;
          var global_sub = null;
          if (from_chars[0] === "^" && from_chars.length > 1) {
            inverse = true;
            from_chars.shift();
            global_sub = to_chars[to_length - 1];
            from_length -= 1;
          }
          var from_chars_expanded = [];
          var last_from = null;
          in_range = false;
          for (i = 0; i < from_length; i++) {
            ch = from_chars[i];
            if (last_from == null) {
              last_from = ch;
              from_chars_expanded.push(ch);
            } else if (ch === "-") {
              if (last_from === "-") {
                from_chars_expanded.push("-");
                from_chars_expanded.push("-");
              } else if (i == from_length - 1) {
                from_chars_expanded.push("-");
              } else {
                in_range = true;
              }
            } else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$("ArgumentError"), 'invalid range "' + String.fromCharCode(start) + "-" + String.fromCharCode(end) + '" in string transliteration');
              }
              for (c = start + 1; c < end; c++) {
                from_chars_expanded.push(String.fromCharCode(c));
              }
              from_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            } else {
              from_chars_expanded.push(ch);
            }
          }
          from_chars = from_chars_expanded;
          from_length = from_chars.length;
          if (inverse) {
            for (i = 0; i < from_length; i++) {
              subs[from_chars[i]] = true;
            }
          } else {
            if (to_length > 0) {
              var to_chars_expanded = [];
              var last_to = null;
              in_range = false;
              for (i = 0; i < to_length; i++) {
                ch = to_chars[i];
                if (last_to == null) {
                  last_to = ch;
                  to_chars_expanded.push(ch);
                } else if (ch === "-") {
                  if (last_to === "-") {
                    to_chars_expanded.push("-");
                    to_chars_expanded.push("-");
                  } else if (i == to_length - 1) {
                    to_chars_expanded.push("-");
                  } else {
                    in_range = true;
                  }
                } else if (in_range) {
                  start = last_to.charCodeAt(0);
                  end = ch.charCodeAt(0);
                  if (start > end) {
                    $Kernel.$raise($$$("ArgumentError"), 'invalid range "' + String.fromCharCode(start) + "-" + String.fromCharCode(end) + '" in string transliteration');
                  }
                  for (c = start + 1; c < end; c++) {
                    to_chars_expanded.push(String.fromCharCode(c));
                  }
                  to_chars_expanded.push(ch);
                  in_range = null;
                  last_to = null;
                } else {
                  to_chars_expanded.push(ch);
                }
              }
              to_chars = to_chars_expanded;
              to_length = to_chars.length;
            }
            var length_diff = from_length - to_length;
            if (length_diff > 0) {
              var pad_char = to_length > 0 ? to_chars[to_length - 1] : "";
              for (i = 0; i < length_diff; i++) {
                to_chars.push(pad_char);
              }
            }
            for (i = 0; i < from_length; i++) {
              subs[from_chars[i]] = to_chars[i];
            }
          }
          var new_str = "";
          for (i = 0, length = self3.length; i < length; i++) {
            ch = self3.charAt(i);
            var sub = subs[ch];
            if (inverse) {
              new_str += sub == null ? global_sub : ch;
            } else {
              new_str += sub != null ? sub : ch;
            }
          }
          return new_str;
        });
        $def(self2, "$tr_s", function $$tr_s(from, to) {
          var self3 = this;
          from = $coerce_to(from, $$$("String"), "to_str").$to_s();
          to = $coerce_to(to, $$$("String"), "to_str").$to_s();
          if (from.length == 0) {
            return self3;
          }
          var i, in_range, c, ch, start, end, length;
          var subs = {};
          var from_chars = from.split("");
          var from_length = from_chars.length;
          var to_chars = to.split("");
          var to_length = to_chars.length;
          var inverse = false;
          var global_sub = null;
          if (from_chars[0] === "^" && from_chars.length > 1) {
            inverse = true;
            from_chars.shift();
            global_sub = to_chars[to_length - 1];
            from_length -= 1;
          }
          var from_chars_expanded = [];
          var last_from = null;
          in_range = false;
          for (i = 0; i < from_length; i++) {
            ch = from_chars[i];
            if (last_from == null) {
              last_from = ch;
              from_chars_expanded.push(ch);
            } else if (ch === "-") {
              if (last_from === "-") {
                from_chars_expanded.push("-");
                from_chars_expanded.push("-");
              } else if (i == from_length - 1) {
                from_chars_expanded.push("-");
              } else {
                in_range = true;
              }
            } else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$("ArgumentError"), 'invalid range "' + String.fromCharCode(start) + "-" + String.fromCharCode(end) + '" in string transliteration');
              }
              for (c = start + 1; c < end; c++) {
                from_chars_expanded.push(String.fromCharCode(c));
              }
              from_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            } else {
              from_chars_expanded.push(ch);
            }
          }
          from_chars = from_chars_expanded;
          from_length = from_chars.length;
          if (inverse) {
            for (i = 0; i < from_length; i++) {
              subs[from_chars[i]] = true;
            }
          } else {
            if (to_length > 0) {
              var to_chars_expanded = [];
              var last_to = null;
              in_range = false;
              for (i = 0; i < to_length; i++) {
                ch = to_chars[i];
                if (last_from == null) {
                  last_from = ch;
                  to_chars_expanded.push(ch);
                } else if (ch === "-") {
                  if (last_to === "-") {
                    to_chars_expanded.push("-");
                    to_chars_expanded.push("-");
                  } else if (i == to_length - 1) {
                    to_chars_expanded.push("-");
                  } else {
                    in_range = true;
                  }
                } else if (in_range) {
                  start = last_from.charCodeAt(0);
                  end = ch.charCodeAt(0);
                  if (start > end) {
                    $Kernel.$raise($$$("ArgumentError"), 'invalid range "' + String.fromCharCode(start) + "-" + String.fromCharCode(end) + '" in string transliteration');
                  }
                  for (c = start + 1; c < end; c++) {
                    to_chars_expanded.push(String.fromCharCode(c));
                  }
                  to_chars_expanded.push(ch);
                  in_range = null;
                  last_from = null;
                } else {
                  to_chars_expanded.push(ch);
                }
              }
              to_chars = to_chars_expanded;
              to_length = to_chars.length;
            }
            var length_diff = from_length - to_length;
            if (length_diff > 0) {
              var pad_char = to_length > 0 ? to_chars[to_length - 1] : "";
              for (i = 0; i < length_diff; i++) {
                to_chars.push(pad_char);
              }
            }
            for (i = 0; i < from_length; i++) {
              subs[from_chars[i]] = to_chars[i];
            }
          }
          var new_str = "";
          var last_substitute = null;
          for (i = 0, length = self3.length; i < length; i++) {
            ch = self3.charAt(i);
            var sub = subs[ch];
            if (inverse) {
              if (sub == null) {
                if (last_substitute == null) {
                  new_str += global_sub;
                  last_substitute = true;
                }
              } else {
                new_str += ch;
                last_substitute = null;
              }
            } else {
              if (sub != null) {
                if (last_substitute == null || last_substitute !== sub) {
                  new_str += sub;
                  last_substitute = sub;
                }
              } else {
                new_str += ch;
                last_substitute = null;
              }
            }
          }
          return new_str;
        });
        $def(self2, "$upcase", function $$upcase() {
          var self3 = this;
          return self3.toUpperCase();
        });
        $def(self2, "$upto", function $$upto(stop, excl) {
          var block = $$upto.$$p || nil, self3 = this;
          $$upto.$$p = null;
          ;
          if (excl == null)
            excl = false;
          if (!(block !== nil)) {
            return self3.$enum_for("upto", stop, excl);
          }
          ;
          var a, b, s = self3.toString();
          stop = $coerce_to(stop, $$$("String"), "to_str");
          if (s.length === 1 && stop.length === 1) {
            a = s.charCodeAt(0);
            b = stop.charCodeAt(0);
            while (a <= b) {
              if (excl && a === b) {
                break;
              }
              block(String.fromCharCode(a));
              a += 1;
            }
          } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {
            a = parseInt(s, 10);
            b = parseInt(stop, 10);
            while (a <= b) {
              if (excl && a === b) {
                break;
              }
              block(a.toString());
              a += 1;
            }
          } else {
            while (s.length <= stop.length && s <= stop) {
              if (excl && s === stop) {
                break;
              }
              block(s);
              s = s.$succ();
            }
          }
          return self3;
          ;
        }, -2);
        function char_class_from_char_sets(sets) {
          function explode_sequences_in_character_set(set2) {
            var result = "", i2, len2 = set2.length, curr_char, skip_next_dash, char_code_from, char_code_upto, char_code;
            for (i2 = 0; i2 < len2; i2++) {
              curr_char = set2.charAt(i2);
              if (curr_char === "-" && i2 > 0 && i2 < len2 - 1 && !skip_next_dash) {
                char_code_from = set2.charCodeAt(i2 - 1);
                char_code_upto = set2.charCodeAt(i2 + 1);
                if (char_code_from > char_code_upto) {
                  $Kernel.$raise($$$("ArgumentError"), 'invalid range "' + char_code_from + "-" + char_code_upto + '" in string transliteration');
                }
                for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
                  result += String.fromCharCode(char_code);
                }
                skip_next_dash = true;
                i2++;
              } else {
                skip_next_dash = curr_char === "\\";
                result += curr_char;
              }
            }
            return result;
          }
          function intersection(setA, setB) {
            if (setA.length === 0) {
              return setB;
            }
            var result = "", i2, len2 = setA.length, chr2;
            for (i2 = 0; i2 < len2; i2++) {
              chr2 = setA.charAt(i2);
              if (setB.indexOf(chr2) !== -1) {
                result += chr2;
              }
            }
            return result;
          }
          var i, len, set, neg, chr, tmp, pos_intersection = "", neg_intersection = "";
          for (i = 0, len = sets.length; i < len; i++) {
            set = $coerce_to(sets[i], $$$("String"), "to_str");
            neg = set.charAt(0) === "^" && set.length > 1;
            set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
            if (neg) {
              neg_intersection = intersection(neg_intersection, set);
            } else {
              pos_intersection = intersection(pos_intersection, set);
            }
          }
          if (pos_intersection.length > 0 && neg_intersection.length > 0) {
            tmp = "";
            for (i = 0, len = pos_intersection.length; i < len; i++) {
              chr = pos_intersection.charAt(i);
              if (neg_intersection.indexOf(chr) === -1) {
                tmp += chr;
              }
            }
            pos_intersection = tmp;
            neg_intersection = "";
          }
          if (pos_intersection.length > 0) {
            return "[" + $$$("Regexp").$escape(pos_intersection) + "]";
          }
          if (neg_intersection.length > 0) {
            return "[^" + $$$("Regexp").$escape(neg_intersection) + "]";
          }
          return null;
        }
        ;
        $def(self2, "$instance_variables", function $$instance_variables() {
          return [];
        });
        $defs(self2, "$_load", function $$_load($a) {
          var $post_args, args, self3 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self3, "new", $to_a(args));
        }, -1);
        $def(self2, "$unicode_normalize", function $$unicode_normalize(form) {
          var self3 = this;
          if (form == null)
            form = "nfc";
          if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]["$include?"](form))) {
            $Kernel.$raise($$$("ArgumentError"), "Invalid normalization form " + form);
          }
          ;
          return self3.normalize(form.$upcase());
        }, -1);
        $def(self2, "$unicode_normalized?", function $String_unicode_normalized$ques$18(form) {
          var self3 = this;
          if (form == null)
            form = "nfc";
          return self3.$unicode_normalize(form)["$=="](self3);
        }, -1);
        $def(self2, "$unpack", function $$unpack(format) {
          return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.");
        });
        $def(self2, "$unpack1", function $$unpack1(format) {
          return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.");
        });
        $def(self2, "$freeze", function $$freeze() {
          var self3 = this;
          if (typeof self3 === "string") {
            return self3;
          }
          $prop(self3, "$$frozen", true);
          return self3;
        });
        $def(self2, "$-@", function $String_$minus$$19() {
          var self3 = this;
          if (typeof self3 === "string")
            return self3;
          if (self3.$$frozen)
            return self3;
          if (self3.encoding.name == "UTF-8" && self3.internal_encoding.name == "UTF-8")
            return self3.toString();
          return self3.$dup().$freeze();
        });
        $def(self2, "$frozen?", function $String_frozen$ques$20() {
          var self3 = this;
          return typeof self3 === "string" || self3.$$frozen === true;
        });
        $alias(self2, "+@", "dup");
        $alias(self2, "===", "==");
        $alias(self2, "byteslice", "[]");
        $alias(self2, "eql?", "==");
        $alias(self2, "equal?", "===");
        $alias(self2, "object_id", "__id__");
        $alias(self2, "slice", "[]");
        $alias(self2, "succ", "next");
        $alias(self2, "to_str", "to_s");
        $alias(self2, "to_sym", "intern");
        return $Opal.$pristine(self2, "initialize");
      })("::", String, $nesting);
      return $const_set($nesting[0], "Symbol", $$("String"));
    };
    Opal.modules["corelib/enumerable"] = function(Opal2) {
      var $truthy = Opal2.truthy, $coerce_to = Opal2.coerce_to, $yield1 = Opal2.yield1, $yieldX = Opal2.yieldX, $deny_frozen_access = Opal2.deny_frozen_access, $module = Opal2.module, $send = Opal2.send, $slice = Opal2.slice, $to_a = Opal2.to_a, $Opal = Opal2.Opal, $thrower = Opal2.thrower, $def = Opal2.def, $Kernel = Opal2.Kernel, $return_val = Opal2.return_val, $rb_gt = Opal2.rb_gt, $rb_times = Opal2.rb_times, $rb_lt = Opal2.rb_lt, $eqeq = Opal2.eqeq, $rb_plus = Opal2.rb_plus, $rb_minus = Opal2.rb_minus, $rb_divide = Opal2.rb_divide, $rb_le = Opal2.rb_le, $hash2 = Opal2.hash2, $lambda = Opal2.lambda, $not = Opal2.not, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries");
      return function($base, $parent_nesting) {
        var self = $module($base, "Enumerable");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        function comparableForPattern(value) {
          if (value.length === 0) {
            value = [nil];
          }
          if (value.length > 1) {
            value = [value];
          }
          return value;
        }
        ;
        $def(self, "$all?", function $Enumerable_all$ques$1(pattern) {
          try {
            var $t_return = $thrower("return");
            var block = $Enumerable_all$ques$1.$$p || nil, self2 = this;
            $Enumerable_all$ques$1.$$p = null;
            ;
            ;
            if ($truthy(pattern !== void 0)) {
              $send(self2, "each", [], function $$2($a) {
                var $post_args, value, comparable = nil;
                $post_args = $slice(arguments);
                value = $post_args;
                comparable = comparableForPattern(value);
                if ($truthy($send(pattern, "public_send", ["==="].concat($to_a(comparable))))) {
                  return nil;
                } else {
                  $t_return.$throw(false);
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else if (block !== nil) {
              $send(self2, "each", [], function $$3($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy(Opal2.yieldX(block, $to_a(value)))) {
                  return nil;
                } else {
                  $t_return.$throw(false);
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else {
              $send(self2, "each", [], function $$4($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy($Opal.$destructure(value))) {
                  return nil;
                } else {
                  $t_return.$throw(false);
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            }
            ;
            return true;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$any?", function $Enumerable_any$ques$5(pattern) {
          try {
            var $t_return = $thrower("return");
            var block = $Enumerable_any$ques$5.$$p || nil, self2 = this;
            $Enumerable_any$ques$5.$$p = null;
            ;
            ;
            if ($truthy(pattern !== void 0)) {
              $send(self2, "each", [], function $$6($a) {
                var $post_args, value, comparable = nil;
                $post_args = $slice(arguments);
                value = $post_args;
                comparable = comparableForPattern(value);
                if ($truthy($send(pattern, "public_send", ["==="].concat($to_a(comparable))))) {
                  $t_return.$throw(true);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else if (block !== nil) {
              $send(self2, "each", [], function $$7($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy(Opal2.yieldX(block, $to_a(value)))) {
                  $t_return.$throw(true);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else {
              $send(self2, "each", [], function $$8($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy($Opal.$destructure(value))) {
                  $t_return.$throw(true);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            }
            ;
            return false;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$chunk", function $$chunk() {
          var block = $$chunk.$$p || nil, self2 = this;
          $$chunk.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "to_enum", ["chunk"], function $$9() {
              var self3 = $$9.$$s == null ? this : $$9.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          return $send($$$("Enumerator"), "new", [], function $$10(yielder) {
            var self3 = $$10.$$s == null ? this : $$10.$$s;
            if (yielder == null)
              yielder = nil;
            var previous = nil, accumulate = [];
            function releaseAccumulate() {
              if (accumulate.length > 0) {
                yielder.$yield(previous, accumulate);
              }
            }
            self3.$each.$$p = function(value) {
              var key = $yield1(block, value);
              if (key === nil) {
                releaseAccumulate();
                accumulate = [];
                previous = nil;
              } else {
                if (previous === nil || previous === key) {
                  accumulate.push(value);
                } else {
                  releaseAccumulate();
                  accumulate = [value];
                }
                previous = key;
              }
            };
            self3.$each();
            releaseAccumulate();
            ;
          }, { $$s: self2 });
        });
        $def(self, "$chunk_while", function $$chunk_while() {
          var block = $$chunk_while.$$p || nil, self2 = this;
          $$chunk_while.$$p = null;
          ;
          if (!(block !== nil)) {
            $Kernel.$raise($$$("ArgumentError"), "no block given");
          }
          ;
          return $send(self2, "slice_when", [], function $$11(before, after) {
            if (before == null)
              before = nil;
            if (after == null)
              after = nil;
            return Opal2.yieldX(block, [before, after])["$!"]();
          });
        });
        $def(self, "$collect", function $$collect() {
          var block = $$collect.$$p || nil, self2 = this;
          $$collect.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["collect"], function $$12() {
              var self3 = $$12.$$s == null ? this : $$12.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var result = [];
          self2.$each.$$p = function() {
            var value = $yieldX(block, arguments);
            result.push(value);
          };
          self2.$each();
          return result;
          ;
        });
        $def(self, "$collect_concat", function $$collect_concat() {
          var block = $$collect_concat.$$p || nil, self2 = this;
          $$collect_concat.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["collect_concat"], function $$13() {
              var self3 = $$13.$$s == null ? this : $$13.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          return $send(self2, "map", [], block.$to_proc()).$flatten(1);
        });
        $def(self, "$compact", function $$compact() {
          var self2 = this;
          return self2.$to_a().$compact();
        });
        $def(self, "$count", function $$count(object) {
          var block = $$count.$$p || nil, self2 = this, result = nil;
          $$count.$$p = null;
          ;
          ;
          result = 0;
          if (object != null && block !== nil) {
            self2.$warn("warning: given block not used");
          }
          ;
          if ($truthy(object != null)) {
            block = $send($Kernel, "proc", [], function $$14($a) {
              var $post_args, args;
              $post_args = $slice(arguments);
              args = $post_args;
              return $Opal.$destructure(args)["$=="](object);
            }, -1);
          } else if ($truthy(block["$nil?"]())) {
            block = $send($Kernel, "proc", [], $return_val(true));
          }
          ;
          $send(self2, "each", [], function $$15($a) {
            var $post_args, args;
            $post_args = $slice(arguments);
            args = $post_args;
            if ($truthy($yieldX(block, args))) {
              return result++;
            } else {
              return nil;
            }
            ;
          }, -1);
          return result;
        }, -1);
        $def(self, "$cycle", function $$cycle(n) {
          var block = $$cycle.$$p || nil, self2 = this;
          $$cycle.$$p = null;
          ;
          if (n == null)
            n = nil;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["cycle", n], function $$16() {
              var self3 = $$16.$$s == null ? this : $$16.$$s;
              if ($truthy(n["$nil?"]())) {
                if ($truthy(self3["$respond_to?"]("size"))) {
                  return $$$($$$("Float"), "INFINITY");
                } else {
                  return nil;
                }
              } else {
                n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
                if ($truthy($rb_gt(n, 0))) {
                  return $rb_times(self3.$enumerator_size(), n);
                } else {
                  return 0;
                }
                ;
              }
            }, { $$s: self2 });
          }
          ;
          if (!$truthy(n["$nil?"]())) {
            n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
            if ($truthy(n <= 0)) {
              return nil;
            }
            ;
          }
          ;
          var all = [], i, length, value;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value2 = $yield1(block, param);
            all.push(param);
          };
          self2.$each();
          if (all.length === 0) {
            return nil;
          }
          if (n === nil) {
            while (true) {
              for (i = 0, length = all.length; i < length; i++) {
                value = $yield1(block, all[i]);
              }
            }
          } else {
            while (n > 1) {
              for (i = 0, length = all.length; i < length; i++) {
                value = $yield1(block, all[i]);
              }
              n--;
            }
          }
          ;
        }, -1);
        $def(self, "$detect", function $$detect(ifnone) {
          try {
            var $t_return = $thrower("return");
            var block = $$detect.$$p || nil, self2 = this;
            $$detect.$$p = null;
            ;
            ;
            if (!(block !== nil)) {
              return self2.$enum_for("detect", ifnone);
            }
            ;
            $send(self2, "each", [], function $$17($a) {
              var $post_args, args, value = nil;
              $post_args = $slice(arguments);
              args = $post_args;
              value = $Opal.$destructure(args);
              if ($truthy(Opal2.yield1(block, value))) {
                $t_return.$throw(value);
              } else {
                return nil;
              }
              ;
            }, { $$arity: -1, $$ret: $t_return });
            if (ifnone !== void 0) {
              if (typeof ifnone === "function") {
                return ifnone();
              } else {
                return ifnone;
              }
            }
            ;
            return nil;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$drop", function $$drop(number) {
          var self2 = this;
          number = $coerce_to(number, $$$("Integer"), "to_int");
          if ($truthy(number < 0)) {
            $Kernel.$raise($$$("ArgumentError"), "attempt to drop negative size");
          }
          ;
          var result = [], current = 0;
          self2.$each.$$p = function() {
            if (number <= current) {
              result.push($Opal.$destructure(arguments));
            }
            current++;
          };
          self2.$each();
          return result;
          ;
        });
        $def(self, "$drop_while", function $$drop_while() {
          var block = $$drop_while.$$p || nil, self2 = this;
          $$drop_while.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("drop_while");
          }
          ;
          var result = [], dropping = true;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments);
            if (dropping) {
              var value = $yield1(block, param);
              if (!$truthy(value)) {
                dropping = false;
                result.push(param);
              }
            } else {
              result.push(param);
            }
          };
          self2.$each();
          return result;
          ;
        });
        $def(self, "$each_cons", function $$each_cons(n) {
          var block = $$each_cons.$$p || nil, self2 = this;
          $$each_cons.$$p = null;
          ;
          if ($truthy(arguments.length != 1)) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " for 1)");
          }
          ;
          n = $Opal.$try_convert(n, $$$("Integer"), "to_int");
          if ($truthy(n <= 0)) {
            $Kernel.$raise($$$("ArgumentError"), "invalid size");
          }
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["each_cons", n], function $$18() {
              var self3 = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;
              enum_size = self3.$enumerator_size();
              if ($truthy(enum_size["$nil?"]())) {
                return nil;
              } else if ($eqeq(enum_size, 0) || $truthy($rb_lt(enum_size, n))) {
                return 0;
              } else {
                return $rb_plus($rb_minus(enum_size, n), 1);
              }
              ;
            }, { $$s: self2 });
          }
          ;
          var buffer = [];
          self2.$each.$$p = function() {
            var element = $Opal.$destructure(arguments);
            buffer.push(element);
            if (buffer.length > n) {
              buffer.shift();
            }
            if (buffer.length == n) {
              $yield1(block, buffer.slice(0, n));
            }
          };
          self2.$each();
          return self2;
          ;
        });
        $def(self, "$each_entry", function $$each_entry($a) {
          var block = $$each_entry.$$p || nil, $post_args, data, self2 = this;
          $$each_entry.$$p = null;
          ;
          $post_args = $slice(arguments);
          data = $post_args;
          if (!(block !== nil)) {
            return $send(self2, "to_enum", ["each_entry"].concat($to_a(data)), function $$19() {
              var self3 = $$19.$$s == null ? this : $$19.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          self2.$each.$$p = function() {
            var item = $Opal.$destructure(arguments);
            $yield1(block, item);
          };
          self2.$each.apply(self2, data);
          return self2;
          ;
        }, -1);
        $def(self, "$each_slice", function $$each_slice(n) {
          var block = $$each_slice.$$p || nil, self2 = this;
          $$each_slice.$$p = null;
          ;
          n = $coerce_to(n, $$$("Integer"), "to_int");
          if ($truthy(n <= 0)) {
            $Kernel.$raise($$$("ArgumentError"), "invalid slice size");
          }
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["each_slice", n], function $$20() {
              var self3 = $$20.$$s == null ? this : $$20.$$s;
              if ($truthy(self3["$respond_to?"]("size"))) {
                return $rb_divide(self3.$size(), n).$ceil();
              } else {
                return nil;
              }
            }, { $$s: self2 });
          }
          ;
          var slice = [];
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments);
            slice.push(param);
            if (slice.length === n) {
              $yield1(block, slice);
              slice = [];
            }
          };
          self2.$each();
          if (slice.length > 0) {
            $yield1(block, slice);
          }
          ;
          return self2;
        });
        $def(self, "$each_with_index", function $$each_with_index($a) {
          var block = $$each_with_index.$$p || nil, $post_args, args, self2 = this;
          $$each_with_index.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["each_with_index"].concat($to_a(args)), function $$21() {
              var self3 = $$21.$$s == null ? this : $$21.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var index = 0;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments);
            block(param, index);
            index++;
          };
          self2.$each.apply(self2, args);
          ;
          return self2;
        }, -1);
        $def(self, "$each_with_object", function $$each_with_object(object) {
          var block = $$each_with_object.$$p || nil, self2 = this;
          $$each_with_object.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["each_with_object", object], function $$22() {
              var self3 = $$22.$$s == null ? this : $$22.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments);
            block(param, object);
          };
          self2.$each();
          ;
          return object;
        });
        $def(self, "$entries", function $$entries($a) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          var result = [];
          self2.$each.$$p = function() {
            result.push($Opal.$destructure(arguments));
          };
          self2.$each.apply(self2, args);
          return result;
          ;
        }, -1);
        $def(self, "$filter_map", function $$filter_map() {
          var block = $$filter_map.$$p || nil, self2 = this;
          $$filter_map.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["filter_map"], function $$23() {
              var self3 = $$23.$$s == null ? this : $$23.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          return $send($send(self2, "map", [], block.$to_proc()), "select", [], "itself".$to_proc());
        });
        $def(self, "$find_all", function $$find_all() {
          var block = $$find_all.$$p || nil, self2 = this;
          $$find_all.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["find_all"], function $$24() {
              var self3 = $$24.$$s == null ? this : $$24.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var result = [];
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if ($truthy(value)) {
              result.push(param);
            }
          };
          self2.$each();
          return result;
          ;
        });
        $def(self, "$find_index", function $$find_index(object) {
          try {
            var $t_return = $thrower("return");
            var block = $$find_index.$$p || nil, self2 = this, index = nil;
            $$find_index.$$p = null;
            ;
            ;
            if ($truthy(object === void 0 && block === nil)) {
              return self2.$enum_for("find_index");
            }
            ;
            if (object != null && block !== nil) {
              self2.$warn("warning: given block not used");
            }
            ;
            index = 0;
            if ($truthy(object != null)) {
              $send(self2, "each", [], function $$25($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($eqeq($Opal.$destructure(value), object)) {
                  $t_return.$throw(index);
                }
                ;
                return index += 1;
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else {
              $send(self2, "each", [], function $$26($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy(Opal2.yieldX(block, $to_a(value)))) {
                  $t_return.$throw(index);
                }
                ;
                return index += 1;
                ;
              }, { $$arity: -1, $$ret: $t_return });
            }
            ;
            return nil;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$first", function $$first(number) {
          try {
            var $t_return = $thrower("return");
            var self2 = this, result = nil, current = nil;
            ;
            if ($truthy(number === void 0)) {
              return $send(self2, "each", [], function $$27(value) {
                if (value == null)
                  value = nil;
                $t_return.$throw(value);
              }, { $$ret: $t_return });
            } else {
              result = [];
              number = $coerce_to(number, $$$("Integer"), "to_int");
              if ($truthy(number < 0)) {
                $Kernel.$raise($$$("ArgumentError"), "attempt to take negative size");
              }
              ;
              if ($truthy(number == 0)) {
                return [];
              }
              ;
              current = 0;
              $send(self2, "each", [], function $$28($a) {
                var $post_args, args;
                $post_args = $slice(arguments);
                args = $post_args;
                result.push($Opal.$destructure(args));
                if ($truthy(number <= ++current)) {
                  $t_return.$throw(result);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
              return result;
            }
            ;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$grep", function $$grep(pattern) {
          var block = $$grep.$$p || nil, self2 = this, result = nil;
          $$grep.$$p = null;
          ;
          result = [];
          $send(self2, "each", [], function $$29($a) {
            var $post_args, value, cmp = nil;
            $post_args = $slice(arguments);
            value = $post_args;
            cmp = comparableForPattern(value);
            if (!$truthy($send(pattern, "__send__", ["==="].concat($to_a(cmp))))) {
              return nil;
            }
            ;
            if (block !== nil) {
              if ($truthy($rb_gt(value.$length(), 1))) {
                value = [value];
              }
              ;
              value = Opal2.yieldX(block, $to_a(value));
            } else if ($truthy($rb_le(value.$length(), 1))) {
              value = value["$[]"](0);
            }
            ;
            return result.$push(value);
          }, -1);
          return result;
        });
        $def(self, "$grep_v", function $$grep_v(pattern) {
          var block = $$grep_v.$$p || nil, self2 = this, result = nil;
          $$grep_v.$$p = null;
          ;
          result = [];
          $send(self2, "each", [], function $$30($a) {
            var $post_args, value, cmp = nil;
            $post_args = $slice(arguments);
            value = $post_args;
            cmp = comparableForPattern(value);
            if ($truthy($send(pattern, "__send__", ["==="].concat($to_a(cmp))))) {
              return nil;
            }
            ;
            if (block !== nil) {
              if ($truthy($rb_gt(value.$length(), 1))) {
                value = [value];
              }
              ;
              value = Opal2.yieldX(block, $to_a(value));
            } else if ($truthy($rb_le(value.$length(), 1))) {
              value = value["$[]"](0);
            }
            ;
            return result.$push(value);
          }, -1);
          return result;
        });
        $def(self, "$group_by", function $$group_by() {
          var block = $$group_by.$$p || nil, $a, self2 = this, hash = nil, $ret_or_1 = nil;
          $$group_by.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["group_by"], function $$31() {
              var self3 = $$31.$$s == null ? this : $$31.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          hash = $hash2([], {});
          var result;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            ($truthy($ret_or_1 = hash["$[]"](value)) ? $ret_or_1 : ($a = [value, []], $send(hash, "[]=", $a), $a[$a.length - 1]))["$<<"](param);
          };
          self2.$each();
          if (result !== void 0) {
            return result;
          }
          ;
          return hash;
        });
        $def(self, "$include?", function $Enumerable_include$ques$32(obj) {
          try {
            var $t_return = $thrower("return");
            var self2 = this;
            $send(self2, "each", [], function $$33($a) {
              var $post_args, args;
              $post_args = $slice(arguments);
              args = $post_args;
              if ($eqeq($Opal.$destructure(args), obj)) {
                $t_return.$throw(true);
              } else {
                return nil;
              }
              ;
            }, { $$arity: -1, $$ret: $t_return });
            return false;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        });
        $def(self, "$inject", function $$inject(object, sym) {
          var block = $$inject.$$p || nil, self2 = this;
          $$inject.$$p = null;
          ;
          ;
          ;
          var result = object;
          if (block !== nil && sym === void 0) {
            self2.$each.$$p = function() {
              var value = $Opal.$destructure(arguments);
              if (result === void 0) {
                result = value;
                return;
              }
              value = $yieldX(block, [result, value]);
              result = value;
            };
          } else {
            if (sym === void 0) {
              if (!$$$("Symbol")["$==="](object)) {
                $Kernel.$raise($$$("TypeError"), "" + object.$inspect() + " is not a Symbol");
              }
              sym = object;
              result = void 0;
            }
            self2.$each.$$p = function() {
              var value = $Opal.$destructure(arguments);
              if (result === void 0) {
                result = value;
                return;
              }
              result = result.$__send__(sym, value);
            };
          }
          self2.$each();
          return result == void 0 ? nil : result;
          ;
        }, -1);
        $def(self, "$lazy", function $$lazy() {
          var self2 = this;
          return $send($$$($$$("Enumerator"), "Lazy"), "new", [self2, self2.$enumerator_size()], function $$34(enum$, $a) {
            var $post_args, args;
            if (enum$ == null)
              enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            return $send(enum$, "yield", $to_a(args));
          }, -2);
        });
        $def(self, "$enumerator_size", function $$enumerator_size() {
          var self2 = this;
          if ($truthy(self2["$respond_to?"]("size"))) {
            return self2.$size();
          } else {
            return nil;
          }
        });
        $def(self, "$max", function $$max(n) {
          var block = $$max.$$p || nil, self2 = this;
          $$max.$$p = null;
          ;
          ;
          if (n === void 0 || n === nil) {
            var result, value;
            self2.$each.$$p = function() {
              var item = $Opal.$destructure(arguments);
              if (result === void 0) {
                result = item;
                return;
              }
              if (block !== nil) {
                value = $yieldX(block, [item, result]);
              } else {
                value = item["$<=>"](result);
              }
              if (value === nil) {
                $Kernel.$raise($$$("ArgumentError"), "comparison failed");
              }
              if (value > 0) {
                result = item;
              }
            };
            self2.$each();
            if (result === void 0) {
              return nil;
            } else {
              return result;
            }
          }
          n = $coerce_to(n, $$$("Integer"), "to_int");
          ;
          return $send(self2, "sort", [], block.$to_proc()).$reverse().$first(n);
        }, -1);
        $def(self, "$max_by", function $$max_by(n) {
          var block = $$max_by.$$p || nil, self2 = this;
          $$max_by.$$p = null;
          ;
          if (n == null)
            n = nil;
          if (!$truthy(block)) {
            return $send(self2, "enum_for", ["max_by", n], function $$35() {
              var self3 = $$35.$$s == null ? this : $$35.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          if (!$truthy(n["$nil?"]())) {
            return $send(self2, "sort_by", [], block.$to_proc()).$reverse().$take(n);
          }
          ;
          var result, by;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if (result === void 0) {
              result = param;
              by = value;
              return;
            }
            if (value["$<=>"](by) > 0) {
              result = param;
              by = value;
            }
          };
          self2.$each();
          return result === void 0 ? nil : result;
          ;
        }, -1);
        $def(self, "$min", function $$min(n) {
          var block = $$min.$$p || nil, self2 = this;
          $$min.$$p = null;
          ;
          if (n == null)
            n = nil;
          if (!$truthy(n["$nil?"]())) {
            if (block !== nil) {
              return $send(self2, "sort", [], function $$36(a, b) {
                if (a == null)
                  a = nil;
                if (b == null)
                  b = nil;
                return Opal2.yieldX(block, [a, b]);
                ;
              }).$take(n);
            } else {
              return self2.$sort().$take(n);
            }
          }
          ;
          var result;
          if (block !== nil) {
            self2.$each.$$p = function() {
              var param = $Opal.$destructure(arguments);
              if (result === void 0) {
                result = param;
                return;
              }
              var value = block(param, result);
              if (value === nil) {
                $Kernel.$raise($$$("ArgumentError"), "comparison failed");
              }
              if (value < 0) {
                result = param;
              }
            };
          } else {
            self2.$each.$$p = function() {
              var param = $Opal.$destructure(arguments);
              if (result === void 0) {
                result = param;
                return;
              }
              if ($Opal.$compare(param, result) < 0) {
                result = param;
              }
            };
          }
          self2.$each();
          return result === void 0 ? nil : result;
          ;
        }, -1);
        $def(self, "$min_by", function $$min_by(n) {
          var block = $$min_by.$$p || nil, self2 = this;
          $$min_by.$$p = null;
          ;
          if (n == null)
            n = nil;
          if (!$truthy(block)) {
            return $send(self2, "enum_for", ["min_by", n], function $$37() {
              var self3 = $$37.$$s == null ? this : $$37.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          if (!$truthy(n["$nil?"]())) {
            return $send(self2, "sort_by", [], block.$to_proc()).$take(n);
          }
          ;
          var result, by;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if (result === void 0) {
              result = param;
              by = value;
              return;
            }
            if (value["$<=>"](by) < 0) {
              result = param;
              by = value;
            }
          };
          self2.$each();
          return result === void 0 ? nil : result;
          ;
        }, -1);
        $def(self, "$minmax", function $$minmax() {
          var block = $$minmax.$$p || nil, self2 = this, $ret_or_1 = nil;
          $$minmax.$$p = null;
          ;
          block = $truthy($ret_or_1 = block) ? $ret_or_1 : $send($Kernel, "proc", [], function $$38(a, b) {
            if (a == null)
              a = nil;
            if (b == null)
              b = nil;
            return a["$<=>"](b);
          });
          var min = nil, max = nil, first_time = true;
          self2.$each.$$p = function() {
            var element = $Opal.$destructure(arguments);
            if (first_time) {
              min = max = element;
              first_time = false;
            } else {
              var min_cmp = block.$call(min, element);
              if (min_cmp === nil) {
                $Kernel.$raise($$$("ArgumentError"), "comparison failed");
              } else if (min_cmp > 0) {
                min = element;
              }
              var max_cmp = block.$call(max, element);
              if (max_cmp === nil) {
                $Kernel.$raise($$$("ArgumentError"), "comparison failed");
              } else if (max_cmp < 0) {
                max = element;
              }
            }
          };
          self2.$each();
          return [min, max];
          ;
        });
        $def(self, "$minmax_by", function $$minmax_by() {
          var block = $$minmax_by.$$p || nil, self2 = this;
          $$minmax_by.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self2, "enum_for", ["minmax_by"], function $$39() {
              var self3 = $$39.$$s == null ? this : $$39.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var min_result = nil, max_result = nil, min_by, max_by;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if (min_by === void 0 || value["$<=>"](min_by) < 0) {
              min_result = param;
              min_by = value;
            }
            if (max_by === void 0 || value["$<=>"](max_by) > 0) {
              max_result = param;
              max_by = value;
            }
          };
          self2.$each();
          return [min_result, max_result];
          ;
        });
        $def(self, "$none?", function $Enumerable_none$ques$40(pattern) {
          try {
            var $t_return = $thrower("return");
            var block = $Enumerable_none$ques$40.$$p || nil, self2 = this;
            $Enumerable_none$ques$40.$$p = null;
            ;
            ;
            if ($truthy(pattern !== void 0)) {
              $send(self2, "each", [], function $$41($a) {
                var $post_args, value, comparable = nil;
                $post_args = $slice(arguments);
                value = $post_args;
                comparable = comparableForPattern(value);
                if ($truthy($send(pattern, "public_send", ["==="].concat($to_a(comparable))))) {
                  $t_return.$throw(false);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else if (block !== nil) {
              $send(self2, "each", [], function $$42($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if ($truthy(Opal2.yieldX(block, $to_a(value)))) {
                  $t_return.$throw(false);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else {
              $send(self2, "each", [], function $$43($a) {
                var $post_args, value, item = nil;
                $post_args = $slice(arguments);
                value = $post_args;
                item = $Opal.$destructure(value);
                if ($truthy(item)) {
                  $t_return.$throw(false);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            }
            ;
            return true;
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$one?", function $Enumerable_one$ques$44(pattern) {
          try {
            var $t_return = $thrower("return");
            var block = $Enumerable_one$ques$44.$$p || nil, self2 = this, count = nil;
            $Enumerable_one$ques$44.$$p = null;
            ;
            ;
            count = 0;
            if ($truthy(pattern !== void 0)) {
              $send(self2, "each", [], function $$45($a) {
                var $post_args, value, comparable = nil;
                $post_args = $slice(arguments);
                value = $post_args;
                comparable = comparableForPattern(value);
                if ($truthy($send(pattern, "public_send", ["==="].concat($to_a(comparable))))) {
                  count = $rb_plus(count, 1);
                  if ($truthy($rb_gt(count, 1))) {
                    $t_return.$throw(false);
                  } else {
                    return nil;
                  }
                  ;
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else if (block !== nil) {
              $send(self2, "each", [], function $$46($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if (!$truthy(Opal2.yieldX(block, $to_a(value)))) {
                  return nil;
                }
                ;
                count = $rb_plus(count, 1);
                if ($truthy($rb_gt(count, 1))) {
                  $t_return.$throw(false);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            } else {
              $send(self2, "each", [], function $$47($a) {
                var $post_args, value;
                $post_args = $slice(arguments);
                value = $post_args;
                if (!$truthy($Opal.$destructure(value))) {
                  return nil;
                }
                ;
                count = $rb_plus(count, 1);
                if ($truthy($rb_gt(count, 1))) {
                  $t_return.$throw(false);
                } else {
                  return nil;
                }
                ;
              }, { $$arity: -1, $$ret: $t_return });
            }
            ;
            return count["$=="](1);
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        }, -1);
        $def(self, "$partition", function $$partition() {
          var block = $$partition.$$p || nil, self2 = this;
          $$partition.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["partition"], function $$48() {
              var self3 = $$48.$$s == null ? this : $$48.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var truthy = [], falsy = [], result;
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if ($truthy(value)) {
              truthy.push(param);
            } else {
              falsy.push(param);
            }
          };
          self2.$each();
          return [truthy, falsy];
          ;
        });
        $def(self, "$reject", function $$reject() {
          var block = $$reject.$$p || nil, self2 = this;
          $$reject.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["reject"], function $$49() {
              var self3 = $$49.$$s == null ? this : $$49.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var result = [];
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = $yield1(block, param);
            if (!$truthy(value)) {
              result.push(param);
            }
          };
          self2.$each();
          return result;
          ;
        });
        $def(self, "$reverse_each", function $$reverse_each() {
          var block = $$reverse_each.$$p || nil, self2 = this;
          $$reverse_each.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["reverse_each"], function $$50() {
              var self3 = $$50.$$s == null ? this : $$50.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          var result = [];
          self2.$each.$$p = function() {
            result.push(arguments);
          };
          self2.$each();
          for (var i = result.length - 1; i >= 0; i--) {
            $yieldX(block, result[i]);
          }
          return result;
          ;
        });
        $def(self, "$slice_before", function $$slice_before(pattern) {
          var block = $$slice_before.$$p || nil, self2 = this;
          $$slice_before.$$p = null;
          ;
          ;
          if ($truthy(pattern === void 0 && block === nil)) {
            $Kernel.$raise($$$("ArgumentError"), "both pattern and block are given");
          }
          ;
          if ($truthy(pattern !== void 0 && block !== nil || arguments.length > 1)) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " expected 1)");
          }
          ;
          return $send($$$("Enumerator"), "new", [], function $$51(e) {
            var self3 = $$51.$$s == null ? this : $$51.$$s;
            if (e == null)
              e = nil;
            var slice = [];
            if (block !== nil) {
              if (pattern === void 0) {
                self3.$each.$$p = function() {
                  var param = $Opal.$destructure(arguments), value = $yield1(block, param);
                  if ($truthy(value) && slice.length > 0) {
                    e["$<<"](slice);
                    slice = [];
                  }
                  slice.push(param);
                };
              } else {
                self3.$each.$$p = function() {
                  var param = $Opal.$destructure(arguments), value = block(param, pattern.$dup());
                  if ($truthy(value) && slice.length > 0) {
                    e["$<<"](slice);
                    slice = [];
                  }
                  slice.push(param);
                };
              }
            } else {
              self3.$each.$$p = function() {
                var param = $Opal.$destructure(arguments), value = pattern["$==="](param);
                if ($truthy(value) && slice.length > 0) {
                  e["$<<"](slice);
                  slice = [];
                }
                slice.push(param);
              };
            }
            self3.$each();
            if (slice.length > 0) {
              e["$<<"](slice);
            }
            ;
          }, { $$s: self2 });
        }, -1);
        $def(self, "$slice_after", function $$slice_after(pattern) {
          var block = $$slice_after.$$p || nil, self2 = this;
          $$slice_after.$$p = null;
          ;
          ;
          if ($truthy(pattern === void 0 && block === nil)) {
            $Kernel.$raise($$$("ArgumentError"), "both pattern and block are given");
          }
          ;
          if ($truthy(pattern !== void 0 && block !== nil || arguments.length > 1)) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " expected 1)");
          }
          ;
          if ($truthy(pattern !== void 0)) {
            block = $send($Kernel, "proc", [], function $$52(e) {
              if (e == null)
                e = nil;
              return pattern["$==="](e);
            });
          }
          ;
          return $send($$$("Enumerator"), "new", [], function $$53(yielder) {
            var self3 = $$53.$$s == null ? this : $$53.$$s;
            if (yielder == null)
              yielder = nil;
            var accumulate;
            self3.$each.$$p = function() {
              var element = $Opal.$destructure(arguments), end_chunk = $yield1(block, element);
              if (accumulate == null) {
                accumulate = [];
              }
              if ($truthy(end_chunk)) {
                accumulate.push(element);
                yielder.$yield(accumulate);
                accumulate = null;
              } else {
                accumulate.push(element);
              }
            };
            self3.$each();
            if (accumulate != null) {
              yielder.$yield(accumulate);
            }
            ;
          }, { $$s: self2 });
        }, -1);
        $def(self, "$slice_when", function $$slice_when() {
          var block = $$slice_when.$$p || nil, self2 = this;
          $$slice_when.$$p = null;
          ;
          if (!(block !== nil)) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (0 for 1)");
          }
          ;
          return $send($$$("Enumerator"), "new", [], function $$54(yielder) {
            var self3 = $$54.$$s == null ? this : $$54.$$s;
            if (yielder == null)
              yielder = nil;
            var slice = nil, last_after = nil;
            self3.$each_cons.$$p = function() {
              var params = $Opal.$destructure(arguments), before = params[0], after = params[1], match = $yieldX(block, [before, after]);
              last_after = after;
              if (slice === nil) {
                slice = [];
              }
              if ($truthy(match)) {
                slice.push(before);
                yielder.$yield(slice);
                slice = [];
              } else {
                slice.push(before);
              }
            };
            self3.$each_cons(2);
            if (slice !== nil) {
              slice.push(last_after);
              yielder.$yield(slice);
            }
            ;
          }, { $$s: self2 });
        });
        $def(self, "$sort", function $$sort() {
          var block = $$sort.$$p || nil, self2 = this, ary = nil;
          $$sort.$$p = null;
          ;
          ary = self2.$to_a();
          if (!(block !== nil)) {
            block = $lambda(function $$55(a, b) {
              if (a == null)
                a = nil;
              if (b == null)
                b = nil;
              return a["$<=>"](b);
            });
          }
          ;
          return $send(ary, "sort", [], block.$to_proc());
        });
        $def(self, "$sort_by", function $$sort_by() {
          var block = $$sort_by.$$p || nil, self2 = this, dup = nil;
          $$sort_by.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["sort_by"], function $$56() {
              var self3 = $$56.$$s == null ? this : $$56.$$s;
              return self3.$enumerator_size();
            }, { $$s: self2 });
          }
          ;
          dup = $send(self2, "map", [], function $$57() {
            var arg = nil;
            arg = $Opal.$destructure(arguments);
            return [Opal2.yield1(block, arg), arg];
          });
          $send(dup, "sort!", [], function $$58(a, b) {
            if (a == null)
              a = nil;
            if (b == null)
              b = nil;
            return a[0]["$<=>"](b[0]);
          });
          return $send(dup, "map!", [], function $$59(i) {
            if (i == null)
              i = nil;
            return i[1];
            ;
          });
        });
        $def(self, "$sum", function $$sum(initial) {
          var $yield = $$sum.$$p || nil, self2 = this, result = nil, compensation = nil;
          $$sum.$$p = null;
          if (initial == null)
            initial = 0;
          result = initial;
          compensation = 0;
          $send(self2, "each", [], function $$60($a) {
            var $post_args, args, item = nil, y = nil, t2 = nil;
            $post_args = $slice(arguments);
            args = $post_args;
            item = $yield !== nil ? Opal2.yieldX($yield, $to_a(args)) : $Opal.$destructure(args);
            if ($not([$$$($$$("Float"), "INFINITY"), $$$($$$("Float"), "INFINITY")["$-@"]()]["$include?"](item)) && $truthy(item["$respond_to?"]("-"))) {
              y = $rb_minus(item, compensation);
              t2 = $rb_plus(result, y);
              compensation = $rb_minus($rb_minus(t2, result), y);
              return result = t2;
            } else {
              return result = $rb_plus(result, item);
            }
            ;
          }, -1);
          return result;
        }, -1);
        $def(self, "$take", function $$take(num) {
          var self2 = this;
          return self2.$first(num);
        });
        $def(self, "$take_while", function $$take_while() {
          try {
            var $t_return = $thrower("return");
            var block = $$take_while.$$p || nil, self2 = this, result = nil;
            $$take_while.$$p = null;
            ;
            if (!$truthy(block)) {
              return self2.$enum_for("take_while");
            }
            ;
            result = [];
            return $send(self2, "each", [], function $$61($a) {
              var $post_args, args, value = nil;
              $post_args = $slice(arguments);
              args = $post_args;
              value = $Opal.$destructure(args);
              if (!$truthy(Opal2.yield1(block, value))) {
                $t_return.$throw(result);
              }
              ;
              return result.push(value);
              ;
            }, { $$arity: -1, $$ret: $t_return });
          } catch ($e) {
            if ($e === $t_return)
              return $e.$v;
            throw $e;
          }
        });
        $def(self, "$uniq", function $$uniq() {
          var block = $$uniq.$$p || nil, self2 = this, hash = nil;
          $$uniq.$$p = null;
          ;
          hash = $hash2([], {});
          $send(self2, "each", [], function $$62($a) {
            var $post_args, args, $b, value = nil, produced = nil;
            $post_args = $slice(arguments);
            args = $post_args;
            value = $Opal.$destructure(args);
            produced = block !== nil ? Opal2.yield1(block, value) : value;
            if ($truthy(hash["$key?"](produced))) {
              return nil;
            } else {
              return $b = [produced, value], $send(hash, "[]=", $b), $b[$b.length - 1];
            }
            ;
          }, -1);
          return hash.$values();
        });
        $def(self, "$tally", function $$tally(hash) {
          var self2 = this, out = nil;
          ;
          if (hash && hash !== nil) {
            $deny_frozen_access(hash);
          }
          ;
          out = $send($send(self2, "group_by", [], "itself".$to_proc()), "transform_values", [], "count".$to_proc());
          if ($truthy(hash)) {
            $send(out, "each", [], function $$63(k, v) {
              var $a;
              if (k == null)
                k = nil;
              if (v == null)
                v = nil;
              return $a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, "[]=", $a), $a[$a.length - 1];
            });
            return hash;
          } else {
            return out;
          }
          ;
        }, -1);
        $def(self, "$to_h", function $$to_h($a) {
          var block = $$to_h.$$p || nil, $post_args, args, self2 = this;
          $$to_h.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if (block !== nil) {
            return $send($send(self2, "map", [], block.$to_proc()), "to_h", $to_a(args));
          }
          ;
          var hash = $hash2([], {});
          self2.$each.$$p = function() {
            var param = $Opal.$destructure(arguments);
            var ary = $Opal["$coerce_to?"](param, $$$("Array"), "to_ary"), key, val;
            if (!ary.$$is_array) {
              $Kernel.$raise($$$("TypeError"), "wrong element type " + ary.$class() + " (expected array)");
            }
            if (ary.length !== 2) {
              $Kernel.$raise($$$("ArgumentError"), "wrong array length (expected 2, was " + ary.$length() + ")");
            }
            key = ary[0];
            val = ary[1];
            Opal2.hash_put(hash, key, val);
          };
          self2.$each.apply(self2, args);
          return hash;
          ;
        }, -1);
        $def(self, "$to_set", function $$to_set($a, $b) {
          var block = $$to_set.$$p || nil, $post_args, klass, args, self2 = this;
          $$to_set.$$p = null;
          ;
          $post_args = $slice(arguments);
          if ($post_args.length > 0)
            klass = $post_args.shift();
          if (klass == null)
            klass = $$("Set");
          args = $post_args;
          return $send(klass, "new", [self2].concat($to_a(args)), block.$to_proc());
        }, -1);
        $def(self, "$zip", function $$zip($a) {
          var block = $$zip.$$p || nil, $post_args, others, self2 = this;
          $$zip.$$p = null;
          ;
          $post_args = $slice(arguments);
          others = $post_args;
          return $send(self2.$to_a(), "zip", $to_a(others));
        }, -1);
        $alias(self, "find", "detect");
        $alias(self, "filter", "find_all");
        $alias(self, "flat_map", "collect_concat");
        $alias(self, "map", "collect");
        $alias(self, "member?", "include?");
        $alias(self, "reduce", "inject");
        $alias(self, "select", "find_all");
        return $alias(self, "to_a", "entries");
      }("::", $nesting);
    };
    Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal2) {
      var $klass = Opal2.klass, $truthy = Opal2.truthy, $to_a = Opal2.to_a, $eqeq = Opal2.eqeq, $Kernel = Opal2.Kernel, $def = Opal2.def, $rb_gt = Opal2.rb_gt, $rb_lt = Opal2.rb_lt, $rb_le = Opal2.rb_le, $rb_ge = Opal2.rb_ge, $rb_plus = Opal2.rb_plus, $rb_minus = Opal2.rb_minus, $eqeqeq = Opal2.eqeqeq, $not = Opal2.not, $rb_times = Opal2.rb_times, $rb_divide = Opal2.rb_divide, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Enumerator");
        var $nesting2 = [self].concat($parent_nesting);
        return function($base2, $super2, $parent_nesting2) {
          var self2 = $klass($base2, $super2, "ArithmeticSequence");
          var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
          $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
          Opal2.prop(self2.$$prototype, "$$is_arithmetic_seq", true);
          var inf = Infinity;
          $def(self2, "$initialize", function $$initialize(range, step, creation_method) {
            var $a, self3 = this, $ret_or_1 = nil;
            ;
            if (creation_method == null)
              creation_method = "step";
            self3.creation_method = creation_method;
            if ($truthy(range["$is_a?"]($$$("Array")))) {
              $a = [].concat($to_a(range)), self3.step_arg1 = $a[0] == null ? nil : $a[0], self3.step_arg2 = $a[1] == null ? nil : $a[1], self3.topfx = $a[2] == null ? nil : $a[2], self3.bypfx = $a[3] == null ? nil : $a[3], $a;
              self3.receiver_num = step;
              self3.step = 1;
              self3.range = $truthy(self3.step_arg2) ? (self3.step = self3.step_arg2, Opal2.Range.$new(self3.receiver_num, self3.step_arg1, false)) : $truthy(self3.step_arg1) ? Opal2.Range.$new(self3.receiver_num, self3.step_arg1, false) : Opal2.Range.$new(self3.receiver_num, nil, false);
            } else {
              if (!$truthy(step)) {
                self3.skipped_arg = true;
              }
              ;
              $a = [range, $truthy($ret_or_1 = step) ? $ret_or_1 : 1], self3.range = $a[0], self3.step = $a[1], $a;
            }
            ;
            self3.object = self3;
            if ($eqeq(self3.step, 0)) {
              $Kernel.$raise($$("ArgumentError"), "step can't be 0");
            }
            ;
            if ($truthy(self3.step["$respond_to?"]("to_int"))) {
              return nil;
            } else {
              return $Kernel.$raise($$("ArgumentError"), "no implicit conversion of " + self3.step.$class() + " into Integer");
            }
            ;
          }, -2);
          self2.$attr_reader("step");
          $def(self2, "$begin", function $$begin() {
            var self3 = this;
            return self3.range.$begin();
          });
          $def(self2, "$end", function $$end() {
            var self3 = this;
            return self3.range.$end();
          });
          $def(self2, "$exclude_end?", function $ArithmeticSequence_exclude_end$ques$1() {
            var self3 = this;
            return self3.range["$exclude_end?"]();
          });
          $def(self2, "$_lesser_than_end?", function $ArithmeticSequence__lesser_than_end$ques$2(val) {
            var self3 = this, end_ = nil, $ret_or_1 = nil;
            end_ = $truthy($ret_or_1 = self3.$end()) ? $ret_or_1 : inf;
            if ($truthy($rb_gt(self3.$step(), 0))) {
              if ($truthy(self3["$exclude_end?"]())) {
                return $rb_lt(val, end_);
              } else {
                return $rb_le(val, end_);
              }
            } else if ($truthy(self3["$exclude_end?"]())) {
              return $rb_gt(val, end_);
            } else {
              return $rb_ge(val, end_);
            }
            ;
          });
          $def(self2, "$_greater_than_begin?", function $ArithmeticSequence__greater_than_begin$ques$3(val) {
            var self3 = this, begin_ = nil, $ret_or_1 = nil;
            begin_ = $truthy($ret_or_1 = self3.$begin()) ? $ret_or_1 : inf["$-@"]();
            if ($truthy($rb_gt(self3.$step(), 0))) {
              return $rb_gt(val, begin_);
            } else {
              return $rb_lt(val, begin_);
            }
            ;
          });
          $def(self2, "$first", function $$first(count) {
            var self3 = this, iter = nil, $ret_or_1 = nil, out = nil;
            ;
            iter = $truthy($ret_or_1 = self3.$begin()) ? $ret_or_1 : inf["$-@"]();
            if (!$truthy(count)) {
              return $truthy(self3["$_lesser_than_end?"](iter)) ? iter : nil;
            }
            ;
            out = [];
            while ($truthy($truthy($ret_or_1 = self3["$_lesser_than_end?"](iter)) ? $rb_gt(count, 0) : $ret_or_1)) {
              out["$<<"](iter);
              iter = $rb_plus(iter, self3.$step());
              count = $rb_minus(count, 1);
            }
            ;
            return out;
          }, -1);
          $def(self2, "$each", function $$each() {
            var block = $$each.$$p || nil, self3 = this, $ret_or_1 = nil, iter = nil;
            $$each.$$p = null;
            ;
            if (!(block !== nil)) {
              return self3;
            }
            ;
            if ($eqeqeq(nil, $ret_or_1 = self3.$begin())) {
              $Kernel.$raise($$("TypeError"), "nil can't be coerced into Integer");
            } else {
              nil;
            }
            ;
            iter = $truthy($ret_or_1 = self3.$begin()) ? $ret_or_1 : inf["$-@"]();
            while ($truthy(self3["$_lesser_than_end?"](iter))) {
              Opal2.yield1(block, iter);
              iter = $rb_plus(iter, self3.$step());
            }
            ;
            return self3;
          });
          $def(self2, "$last", function $$last(count) {
            var self3 = this, $ret_or_1 = nil, iter = nil, out = nil;
            ;
            if ($eqeqeq(inf, $ret_or_1 = self3.$end()) || $eqeqeq(inf["$-@"](), $ret_or_1)) {
              $Kernel.$raise($$$("FloatDomainError"), self3.$end());
            } else if ($eqeqeq(nil, $ret_or_1)) {
              $Kernel.$raise($$$("RangeError"), "cannot get the last element of endless arithmetic sequence");
            } else {
              nil;
            }
            ;
            iter = $rb_minus(self3.$end(), $rb_minus(self3.$end(), self3.$begin())["$%"](self3.$step()));
            if (!$truthy(self3["$_lesser_than_end?"](iter))) {
              iter = $rb_minus(iter, self3.$step());
            }
            ;
            if (!$truthy(count)) {
              return $truthy(self3["$_greater_than_begin?"](iter)) ? iter : nil;
            }
            ;
            out = [];
            while ($truthy($truthy($ret_or_1 = self3["$_greater_than_begin?"](iter)) ? $rb_gt(count, 0) : $ret_or_1)) {
              out["$<<"](iter);
              iter = $rb_minus(iter, self3.$step());
              count = $rb_minus(count, 1);
            }
            ;
            return out.$reverse();
          }, -1);
          $def(self2, "$size", function $$size() {
            var self3 = this, step_sign = nil, iter = nil;
            step_sign = $truthy($rb_gt(self3.$step(), 0)) ? 1 : -1;
            if ($not(self3["$_lesser_than_end?"](self3.$begin()))) {
              return 0;
            } else if ($truthy([inf["$-@"](), inf]["$include?"](self3.$step()))) {
              return 1;
            } else if ($truthy([$rb_times(inf["$-@"](), step_sign), nil]["$include?"](self3.$begin())) || $truthy([$rb_times(inf, step_sign), nil]["$include?"](self3.$end()))) {
              return inf;
            } else {
              iter = $rb_minus(self3.$end(), $rb_minus(self3.$end(), self3.$begin())["$%"](self3.$step()));
              if (!$truthy(self3["$_lesser_than_end?"](iter))) {
                iter = $rb_minus(iter, self3.$step());
              }
              ;
              return $rb_plus($rb_divide($rb_minus(iter, self3.$begin()), self3.$step()).$abs().$to_i(), 1);
            }
            ;
          });
          $def(self2, "$==", function $ArithmeticSequence_$eq_eq$4(other) {
            var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;
            if ($truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = $truthy($ret_or_4 = self3.$class()["$=="](other.$class())) ? self3.$begin()["$=="](other.$begin()) : $ret_or_4) ? self3.$end()["$=="](other.$end()) : $ret_or_3) ? self3.$step()["$=="](other.$step()) : $ret_or_2)) {
              return self3["$exclude_end?"]()["$=="](other["$exclude_end?"]());
            } else {
              return $ret_or_1;
            }
          });
          $def(self2, "$hash", function $$hash() {
            var self3 = this;
            return [self3.$begin(), self3.$end(), self3.$step(), self3["$exclude_end?"]()].$hash();
          });
          $def(self2, "$inspect", function $$inspect() {
            var self3 = this, args = nil;
            if ($truthy(self3.receiver_num)) {
              args = $truthy(self3.step_arg2) ? "(" + self3.topfx + self3.step_arg1.$inspect() + ", " + self3.bypfx + self3.step_arg2.$inspect() + ")" : $truthy(self3.step_arg1) ? "(" + self3.topfx + self3.step_arg1.$inspect() + ")" : nil;
              return "(" + self3.receiver_num.$inspect() + "." + self3.creation_method + args + ")";
            } else {
              args = $truthy(self3.skipped_arg) ? nil : "(" + self3.step + ")";
              return "((" + self3.range.$inspect() + ")." + self3.creation_method + args + ")";
            }
          });
          $alias(self2, "===", "==");
          return $alias(self2, "eql?", "==");
        }(self, self, $nesting2);
      }("::", null, $nesting);
    };
    Opal.modules["corelib/enumerator/chain"] = function(Opal2) {
      var $deny_frozen_access = Opal2.deny_frozen_access, $klass = Opal2.klass, $slice = Opal2.slice, $def = Opal2.def, $send = Opal2.send, $to_a = Opal2.to_a, $truthy = Opal2.truthy, $rb_plus = Opal2.rb_plus, $thrower = Opal2.thrower, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect");
      return function($base, $super) {
        var self = $klass($base, $super, "Enumerator");
        return function($base2, $super2) {
          var self2 = $klass($base2, $super2, "Chain");
          var $proto = self2.$$prototype;
          $proto.enums = $proto.iterated = nil;
          $def(self2, "$initialize", function $$initialize($a) {
            var $post_args, enums, self3 = this;
            $post_args = $slice(arguments);
            enums = $post_args;
            $deny_frozen_access(self3);
            self3.enums = enums;
            self3.iterated = [];
            return self3.object = self3;
          }, -1);
          $def(self2, "$each", function $$each($a) {
            var block = $$each.$$p || nil, $post_args, args, self3 = this;
            $$each.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            if (!(block !== nil)) {
              return $send(self3, "to_enum", ["each"].concat($to_a(args)), function $$1() {
                var self4 = $$1.$$s == null ? this : $$1.$$s;
                return self4.$size();
              }, { $$s: self3 });
            }
            ;
            $send(self3.enums, "each", [], function $$2(enum$) {
              var self4 = $$2.$$s == null ? this : $$2.$$s;
              if (self4.iterated == null)
                self4.iterated = nil;
              if (enum$ == null)
                enum$ = nil;
              self4.iterated["$<<"](enum$);
              return $send(enum$, "each", $to_a(args), block.$to_proc());
            }, { $$s: self3 });
            return self3;
          }, -1);
          $def(self2, "$size", function $$size($a) {
            try {
              var $t_return = $thrower("return");
              var $post_args, args, self3 = this, accum = nil;
              $post_args = $slice(arguments);
              args = $post_args;
              accum = 0;
              $send(self3.enums, "each", [], function $$3(enum$) {
                var size = nil;
                if (enum$ == null)
                  enum$ = nil;
                size = $send(enum$, "size", $to_a(args));
                if ($truthy([nil, $$$($$$("Float"), "INFINITY")]["$include?"](size))) {
                  $t_return.$throw(size);
                }
                ;
                return accum = $rb_plus(accum, size);
              }, { $$ret: $t_return });
              return accum;
            } catch ($e) {
              if ($e === $t_return)
                return $e.$v;
              throw $e;
            }
          }, -1);
          $def(self2, "$rewind", function $$rewind() {
            var self3 = this;
            $send(self3.iterated, "reverse_each", [], function $$4(enum$) {
              if (enum$ == null)
                enum$ = nil;
              if ($truthy(enum$["$respond_to?"]("rewind"))) {
                return enum$.$rewind();
              } else {
                return nil;
              }
              ;
            });
            self3.iterated = [];
            return self3;
          });
          return $def(self2, "$inspect", function $$inspect() {
            var self3 = this;
            return "#<Enumerator::Chain: " + self3.enums.$inspect() + ">";
          });
        }(self, self);
      }("::", null);
    };
    Opal.modules["corelib/enumerator/generator"] = function(Opal2) {
      var $deny_frozen_access = Opal2.deny_frozen_access, $klass = Opal2.klass, $truthy = Opal2.truthy, $Kernel = Opal2.Kernel, $def = Opal2.def, $slice = Opal2.slice, $send = Opal2.send, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("include,raise,new,to_proc");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Enumerator");
        var $nesting2 = [self].concat($parent_nesting);
        return function($base2, $super2, $parent_nesting2) {
          var self2 = $klass($base2, $super2, "Generator");
          var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
          $proto.block = nil;
          self2.$include($$$("Enumerable"));
          $def(self2, "$initialize", function $$initialize() {
            var block = $$initialize.$$p || nil, self3 = this;
            $$initialize.$$p = null;
            ;
            $deny_frozen_access(self3);
            if (!$truthy(block)) {
              $Kernel.$raise($$$("LocalJumpError"), "no block given");
            }
            ;
            return self3.block = block;
          });
          return $def(self2, "$each", function $$each($a) {
            var block = $$each.$$p || nil, $post_args, args, self3 = this, yielder = nil;
            $$each.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            yielder = $send($$("Yielder"), "new", [], block.$to_proc());
            try {
              args.unshift(yielder);
              Opal2.yieldX(self3.block, args);
            } catch (e) {
              if (e && e.$thrower_type == "breaker") {
                return e.$v;
              } else {
                throw e;
              }
            }
            ;
            return self3;
          }, -1);
        }($nesting2[0], null, $nesting2);
      }($nesting[0], null, $nesting);
    };
    Opal.modules["corelib/enumerator/lazy"] = function(Opal2) {
      var $truthy = Opal2.truthy, $coerce_to = Opal2.coerce_to, $yield1 = Opal2.yield1, $yieldX = Opal2.yieldX, $deny_frozen_access = Opal2.deny_frozen_access, $klass = Opal2.klass, $slice = Opal2.slice, $send2 = Opal2.send2, $find_super = Opal2.find_super, $to_a = Opal2.to_a, $defs = Opal2.defs, $Kernel = Opal2.Kernel, $send = Opal2.send, $def = Opal2.def, $return_self = Opal2.return_self, $Opal = Opal2.Opal, $rb_lt = Opal2.rb_lt, $eqeqeq = Opal2.eqeqeq, $rb_plus = Opal2.rb_plus, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Enumerator");
        var $nesting2 = [self].concat($parent_nesting);
        return function($base2, $super2, $parent_nesting2) {
          var self2 = $klass($base2, $super2, "Lazy");
          var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3), $proto = self2.$$prototype;
          $proto.enumerator = nil;
          $klass(self2, $$$("Exception"), "StopLazyError");
          $defs(self2, "$for", function $Lazy_for$1(object, $a) {
            var $post_args, $fwd_rest, $yield = $Lazy_for$1.$$p || nil, self3 = this, lazy = nil;
            $Lazy_for$1.$$p = null;
            $post_args = $slice(arguments, 1);
            $fwd_rest = $post_args;
            lazy = $send2(self3, $find_super(self3, "for", $Lazy_for$1, false, true), "for", [object].concat($to_a($fwd_rest)), $yield);
            lazy.enumerator = object;
            return lazy;
          }, -2);
          $def(self2, "$initialize", function $$initialize(object, size) {
            var block = $$initialize.$$p || nil, self3 = this;
            $$initialize.$$p = null;
            ;
            if (size == null)
              size = nil;
            $deny_frozen_access(self3);
            if (!(block !== nil)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy new without a block");
            }
            ;
            self3.enumerator = object;
            return $send2(self3, $find_super(self3, "initialize", $$initialize, false, true), "initialize", [size], function $$2(yielder, $a) {
              var $post_args, each_args;
              if (yielder == null)
                yielder = nil;
              $post_args = $slice(arguments, 1);
              each_args = $post_args;
              try {
                return $send(object, "each", $to_a(each_args), function $$3($b) {
                  var $post_args2, args;
                  $post_args2 = $slice(arguments);
                  args = $post_args2;
                  args.unshift(yielder);
                  $yieldX(block, args);
                  ;
                }, -1);
              } catch ($err) {
                if (Opal2.rescue($err, [$$("StopLazyError")])) {
                  try {
                    return nil;
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
            }, -2);
          }, -2);
          $def(self2, "$lazy", $return_self);
          $def(self2, "$collect", function $$collect() {
            var block = $$collect.$$p || nil, self3 = this;
            $$collect.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy map without a block");
            }
            ;
            return $send($$("Lazy"), "new", [self3, self3.$enumerator_size()], function $$4(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              var value = $yieldX(block, args);
              enum$.$yield(value);
              ;
            }, -2);
          });
          $def(self2, "$collect_concat", function $$collect_concat() {
            var block = $$collect_concat.$$p || nil, self3 = this;
            $$collect_concat.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy map without a block");
            }
            ;
            return $send($$("Lazy"), "new", [self3, nil], function $$5(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              var value = $yieldX(block, args);
              if (value["$respond_to?"]("force") && value["$respond_to?"]("each")) {
                $send(value, "each", [], function $$6(v) {
                  if (v == null)
                    v = nil;
                  return enum$.$yield(v);
                });
              } else {
                var array = $Opal.$try_convert(value, $$$("Array"), "to_ary");
                if (array === nil) {
                  enum$.$yield(value);
                } else {
                  $send(value, "each", [], function $$7(v) {
                    if (v == null)
                      v = nil;
                    return enum$.$yield(v);
                  });
                }
              }
              ;
            }, -2);
          });
          $def(self2, "$drop", function $$drop(n) {
            var self3 = this, current_size = nil, set_size = nil, dropped = nil;
            n = $coerce_to(n, $$$("Integer"), "to_int");
            if ($truthy($rb_lt(n, 0))) {
              $Kernel.$raise($$$("ArgumentError"), "attempt to drop negative size");
            }
            ;
            current_size = self3.$enumerator_size();
            set_size = $eqeqeq($$$("Integer"), current_size) ? $truthy($rb_lt(n, current_size)) ? n : current_size : current_size;
            dropped = 0;
            return $send($$("Lazy"), "new", [self3, set_size], function $$8(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              if ($truthy($rb_lt(dropped, n))) {
                return dropped = $rb_plus(dropped, 1);
              } else {
                return $send(enum$, "yield", $to_a(args));
              }
              ;
            }, -2);
          });
          $def(self2, "$drop_while", function $$drop_while() {
            var block = $$drop_while.$$p || nil, self3 = this, succeeding = nil;
            $$drop_while.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy drop_while without a block");
            }
            ;
            succeeding = true;
            return $send($$("Lazy"), "new", [self3, nil], function $$9(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              if ($truthy(succeeding)) {
                var value = $yieldX(block, args);
                if (!$truthy(value)) {
                  succeeding = false;
                  $send(enum$, "yield", $to_a(args));
                }
              } else {
                return $send(enum$, "yield", $to_a(args));
              }
              ;
            }, -2);
          });
          $def(self2, "$enum_for", function $$enum_for($a, $b) {
            var block = $$enum_for.$$p || nil, $post_args, method, args, self3 = this;
            $$enum_for.$$p = null;
            ;
            $post_args = $slice(arguments);
            if ($post_args.length > 0)
              method = $post_args.shift();
            if (method == null)
              method = "each";
            args = $post_args;
            return $send(self3.$class(), "for", [self3, method].concat($to_a(args)), block.$to_proc());
          }, -1);
          $def(self2, "$find_all", function $$find_all() {
            var block = $$find_all.$$p || nil, self3 = this;
            $$find_all.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy select without a block");
            }
            ;
            return $send($$("Lazy"), "new", [self3, nil], function $$10(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              var value = $yieldX(block, args);
              if ($truthy(value)) {
                $send(enum$, "yield", $to_a(args));
              }
              ;
            }, -2);
          });
          $def(self2, "$grep", function $$grep(pattern) {
            var block = $$grep.$$p || nil, self3 = this;
            $$grep.$$p = null;
            ;
            if ($truthy(block)) {
              return $send($$("Lazy"), "new", [self3, nil], function $$11(enum$, $a) {
                var $post_args, args;
                if (enum$ == null)
                  enum$ = nil;
                $post_args = $slice(arguments, 1);
                args = $post_args;
                var param = $Opal.$destructure(args), value = pattern["$==="](param);
                if ($truthy(value)) {
                  value = $yield1(block, param);
                  enum$.$yield($yield1(block, param));
                }
                ;
              }, -2);
            } else {
              return $send($$("Lazy"), "new", [self3, nil], function $$12(enum$, $a) {
                var $post_args, args;
                if (enum$ == null)
                  enum$ = nil;
                $post_args = $slice(arguments, 1);
                args = $post_args;
                var param = $Opal.$destructure(args), value = pattern["$==="](param);
                if ($truthy(value)) {
                  enum$.$yield(param);
                }
                ;
              }, -2);
            }
            ;
          });
          $def(self2, "$reject", function $$reject() {
            var block = $$reject.$$p || nil, self3 = this;
            $$reject.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy reject without a block");
            }
            ;
            return $send($$("Lazy"), "new", [self3, nil], function $$13(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              var value = $yieldX(block, args);
              if (!$truthy(value)) {
                $send(enum$, "yield", $to_a(args));
              }
              ;
            }, -2);
          });
          $def(self2, "$take", function $$take(n) {
            var self3 = this, current_size = nil, set_size = nil, taken = nil;
            n = $coerce_to(n, $$$("Integer"), "to_int");
            if ($truthy($rb_lt(n, 0))) {
              $Kernel.$raise($$$("ArgumentError"), "attempt to take negative size");
            }
            ;
            current_size = self3.$enumerator_size();
            set_size = $eqeqeq($$$("Integer"), current_size) ? $truthy($rb_lt(n, current_size)) ? n : current_size : current_size;
            taken = 0;
            return $send($$("Lazy"), "new", [self3, set_size], function $$14(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              if ($truthy($rb_lt(taken, n))) {
                $send(enum$, "yield", $to_a(args));
                return taken = $rb_plus(taken, 1);
              } else {
                return $Kernel.$raise($$("StopLazyError"));
              }
              ;
            }, -2);
          });
          $def(self2, "$take_while", function $$take_while() {
            var block = $$take_while.$$p || nil, self3 = this;
            $$take_while.$$p = null;
            ;
            if (!$truthy(block)) {
              $Kernel.$raise($$$("ArgumentError"), "tried to call lazy take_while without a block");
            }
            ;
            return $send($$("Lazy"), "new", [self3, nil], function $$15(enum$, $a) {
              var $post_args, args;
              if (enum$ == null)
                enum$ = nil;
              $post_args = $slice(arguments, 1);
              args = $post_args;
              var value = $yieldX(block, args);
              if ($truthy(value)) {
                $send(enum$, "yield", $to_a(args));
              } else {
                $Kernel.$raise($$("StopLazyError"));
              }
              ;
            }, -2);
          });
          $def(self2, "$inspect", function $$inspect() {
            var self3 = this;
            return "#<" + self3.$class() + ": " + self3.enumerator.$inspect() + ">";
          });
          $alias(self2, "force", "to_a");
          $alias(self2, "filter", "find_all");
          $alias(self2, "flat_map", "collect_concat");
          $alias(self2, "map", "collect");
          $alias(self2, "select", "find_all");
          return $alias(self2, "to_enum", "enum_for");
        }(self, self, $nesting2);
      }("::", null, $nesting);
    };
    Opal.modules["corelib/enumerator/yielder"] = function(Opal2) {
      var $klass = Opal2.klass, $def = Opal2.def, $slice = Opal2.slice, $send = Opal2.send, $to_a = Opal2.to_a, $nesting = [], nil = Opal2.nil;
      Opal2.add_stubs("yield,proc");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Enumerator");
        var $nesting2 = [self].concat($parent_nesting);
        return function($base2, $super2) {
          var self2 = $klass($base2, $super2, "Yielder");
          var $proto = self2.$$prototype;
          $proto.block = nil;
          $def(self2, "$initialize", function $$initialize() {
            var block = $$initialize.$$p || nil, self3 = this;
            $$initialize.$$p = null;
            ;
            self3.block = block;
            return self3;
          });
          $def(self2, "$yield", function $Yielder_yield$1($a) {
            var $post_args, values, self3 = this;
            $post_args = $slice(arguments);
            values = $post_args;
            var value = Opal2.yieldX(self3.block, values);
            if (value && value.$thrower_type == "break") {
              throw value;
            }
            return value;
            ;
          }, -1);
          $def(self2, "$<<", function $Yielder_$lt$lt$2(value) {
            var self3 = this;
            self3.$yield(value);
            return self3;
          });
          return $def(self2, "$to_proc", function $$to_proc() {
            var self3 = this;
            return $send(self3, "proc", [], function $$3($a) {
              var $post_args, values, self4 = $$3.$$s == null ? this : $$3.$$s;
              $post_args = $slice(arguments);
              values = $post_args;
              return $send(self4, "yield", $to_a(values));
            }, { $$arity: -1, $$s: self3 });
          });
        }($nesting2[0], null);
      }($nesting[0], null, $nesting);
    };
    Opal.modules["corelib/enumerator"] = function(Opal2) {
      var $slice = Opal2.slice, $coerce_to = Opal2.coerce_to, $deny_frozen_access = Opal2.deny_frozen_access, $klass = Opal2.klass, $defs = Opal2.defs, $truthy = Opal2.truthy, $send = Opal2.send, $not = Opal2.not, $def = Opal2.def, $rb_plus = Opal2.rb_plus, $to_a = Opal2.to_a, $Opal = Opal2.Opal, $send2 = Opal2.send2, $find_super = Opal2.find_super, $rb_ge = Opal2.rb_ge, $Kernel = Opal2.Kernel, $rb_le = Opal2.rb_le, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload");
      self.$require("corelib/enumerable");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Enumerator");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self2.$$prototype;
        $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
        self2.$include($$$("Enumerable"));
        self2.$$prototype.$$is_enumerator = true;
        $defs(self2, "$for", function $Enumerator_for$1(object, $a, $b) {
          var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self3 = this;
          $Enumerator_for$1.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          if ($post_args.length > 0)
            method = $post_args.shift();
          if (method == null)
            method = "each";
          args = $post_args;
          var obj = self3.$allocate();
          obj.object = object;
          obj.size = block;
          obj.method = method;
          obj.args = args;
          obj.cursor = 0;
          return obj;
          ;
        }, -2);
        $def(self2, "$initialize", function $$initialize($a) {
          var block = $$initialize.$$p || nil, $post_args, $fwd_rest, self3 = this;
          $$initialize.$$p = null;
          ;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $deny_frozen_access(self3);
          self3.cursor = 0;
          if ($truthy(block)) {
            self3.object = $send($$("Generator"), "new", [], block.$to_proc());
            self3.method = "each";
            self3.args = [];
            self3.size = arguments[0] || nil;
            if ($truthy(self3.size) && $not(self3.size["$respond_to?"]("call"))) {
              return self3.size = $coerce_to(self3.size, $$$("Integer"), "to_int");
            } else {
              return nil;
            }
            ;
          } else {
            self3.object = arguments[0];
            self3.method = arguments[1] || "each";
            self3.args = $slice(arguments, 2);
            return self3.size = nil;
          }
          ;
        }, -1);
        $def(self2, "$each", function $$each($a) {
          var block = $$each.$$p || nil, $post_args, args, self3 = this;
          $$each.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy(block["$nil?"]()) && $truthy(args["$empty?"]())) {
            return self3;
          }
          ;
          args = $rb_plus(self3.args, args);
          if ($truthy(block["$nil?"]())) {
            return $send(self3.$class(), "new", [self3.object, self3.method].concat($to_a(args)));
          }
          ;
          return $send(self3.object, "__send__", [self3.method].concat($to_a(args)), block.$to_proc());
        }, -1);
        $def(self2, "$size", function $$size() {
          var self3 = this;
          if ($truthy(self3.size["$respond_to?"]("call"))) {
            return $send(self3.size, "call", $to_a(self3.args));
          } else {
            return self3.size;
          }
        });
        $def(self2, "$with_index", function $$with_index(offset) {
          var block = $$with_index.$$p || nil, self3 = this;
          $$with_index.$$p = null;
          ;
          if (offset == null)
            offset = 0;
          offset = $truthy(offset) ? $coerce_to(offset, $$$("Integer"), "to_int") : 0;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["with_index", offset], function $$2() {
              var self4 = $$2.$$s == null ? this : $$2.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result, index = offset;
          self3.$each.$$p = function() {
            var param = $Opal.$destructure(arguments), value = block(param, index);
            index++;
            return value;
          };
          return self3.$each();
          ;
        }, -1);
        $def(self2, "$each_with_index", function $$each_with_index() {
          var block = $$each_with_index.$$p || nil, self3 = this;
          $$each_with_index.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each_with_index"], function $$3() {
              var self4 = $$3.$$s == null ? this : $$3.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $send2(self3, $find_super(self3, "each_with_index", $$each_with_index, false, true), "each_with_index", [], block);
          return self3.object;
        });
        $def(self2, "$rewind", function $$rewind() {
          var self3 = this;
          self3.cursor = 0;
          return self3;
        });
        $def(self2, "$peek_values", function $$peek_values() {
          var self3 = this, $ret_or_1 = nil;
          self3.values = $truthy($ret_or_1 = self3.values) ? $ret_or_1 : $send(self3, "map", [], function $$4($a) {
            var $post_args, i;
            $post_args = $slice(arguments);
            i = $post_args;
            return i;
          }, -1);
          if ($truthy($rb_ge(self3.cursor, self3.values.$length()))) {
            $Kernel.$raise($$$("StopIteration"), "iteration reached an end");
          }
          ;
          return self3.values["$[]"](self3.cursor);
        });
        $def(self2, "$peek", function $$peek() {
          var self3 = this, values = nil;
          values = self3.$peek_values();
          if ($truthy($rb_le(values.$length(), 1))) {
            return values["$[]"](0);
          } else {
            return values;
          }
          ;
        });
        $def(self2, "$next_values", function $$next_values() {
          var self3 = this, out = nil;
          out = self3.$peek_values();
          self3.cursor = $rb_plus(self3.cursor, 1);
          return out;
        });
        $def(self2, "$next", function $$next() {
          var self3 = this, values = nil;
          values = self3.$next_values();
          if ($truthy($rb_le(values.$length(), 1))) {
            return values["$[]"](0);
          } else {
            return values;
          }
          ;
        });
        $def(self2, "$feed", function $$feed(arg) {
          var self3 = this;
          return self3.$raise($$("NotImplementedError"), "Opal doesn't support Enumerator#feed");
        });
        $def(self2, "$+", function $Enumerator_$plus$5(other) {
          var self3 = this;
          return $$$($$$("Enumerator"), "Chain").$new(self3, other);
        });
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this, result = nil;
          result = "#<" + self3.$class() + ": " + self3.object.$inspect() + ":" + self3.method;
          if ($truthy(self3.args["$any?"]())) {
            result = $rb_plus(result, "(" + self3.args.$inspect()["$[]"]($$$("Range").$new(1, -2)) + ")");
          }
          ;
          return $rb_plus(result, ">");
        });
        $alias(self2, "with_object", "each_with_object");
        self2.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
        self2.$autoload("Chain", "corelib/enumerator/chain");
        self2.$autoload("Generator", "corelib/enumerator/generator");
        self2.$autoload("Lazy", "corelib/enumerator/lazy");
        return self2.$autoload("Yielder", "corelib/enumerator/yielder");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/numeric"] = function(Opal2) {
      var $klass = Opal2.klass, $truthy = Opal2.truthy, $Kernel = Opal2.Kernel, $def = Opal2.def, $to_ary = Opal2.to_ary, $return_self = Opal2.return_self, $rb_minus = Opal2.rb_minus, $rb_times = Opal2.rb_times, $rb_lt = Opal2.rb_lt, $eqeq = Opal2.eqeq, $rb_divide = Opal2.rb_divide, $return_val = Opal2.return_val, $Opal = Opal2.Opal, $slice = Opal2.slice, $extract_kwargs = Opal2.extract_kwargs, $ensure_kwargs = Opal2.ensure_kwargs, $not = Opal2.not, $send = Opal2.send, $rb_ge = Opal2.rb_ge, $rb_le = Opal2.rb_le, $rb_plus = Opal2.rb_plus, $rb_gt = Opal2.rb_gt, $alias = Opal2.alias, self = Opal2.top, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect");
      self.$require("corelib/comparable");
      return function($base, $super) {
        var self2 = $klass($base, $super, "Numeric");
        self2.$include($$$("Comparable"));
        $def(self2, "$coerce", function $$coerce(other) {
          var self3 = this;
          if ($truthy(other["$instance_of?"](self3.$class()))) {
            return [other, self3];
          }
          ;
          return [$Kernel.$Float(other), $Kernel.$Float(self3)];
        });
        $def(self2, "$__coerced__", function $$__coerced__(method, other) {
          var $a, $b, self3 = this, a = nil, b = nil;
          if ($truthy(other["$respond_to?"]("coerce"))) {
            $b = other.$coerce(self3), $a = $to_ary($b), a = $a[0] == null ? nil : $a[0], b = $a[1] == null ? nil : $a[1], $b;
            return a.$__send__(method, b);
          } else
            switch (method) {
              case "+":
              case "-":
              case "*":
              case "/":
              case "%":
              case "&":
              case "|":
              case "^":
              case "**":
                return $Kernel.$raise($$$("TypeError"), "" + other.$class() + " can't be coerced into Numeric");
              case ">":
              case ">=":
              case "<":
              case "<=":
              case "<=>":
                return $Kernel.$raise($$$("ArgumentError"), "comparison of " + self3.$class() + " with " + other.$class() + " failed");
              default:
                return nil;
            }
        });
        $def(self2, "$<=>", function $Numeric_$lt_eq_gt$1(other) {
          var self3 = this;
          if ($truthy(self3["$equal?"](other))) {
            return 0;
          }
          ;
          return nil;
        });
        $def(self2, "$+@", $return_self);
        $def(self2, "$-@", function $Numeric_$minus$$2() {
          var self3 = this;
          return $rb_minus(0, self3);
        });
        $def(self2, "$%", function $Numeric_$percent$3(other) {
          var self3 = this;
          return $rb_minus(self3, $rb_times(other, self3.$div(other)));
        });
        $def(self2, "$abs", function $$abs() {
          var self3 = this;
          if ($rb_lt(self3, 0)) {
            return self3["$-@"]();
          } else {
            return self3;
          }
        });
        $def(self2, "$abs2", function $$abs2() {
          var self3 = this;
          return $rb_times(self3, self3);
        });
        $def(self2, "$angle", function $$angle() {
          var self3 = this;
          if ($rb_lt(self3, 0)) {
            return $$$($$$("Math"), "PI");
          } else {
            return 0;
          }
        });
        $def(self2, "$ceil", function $$ceil(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          return self3.$to_f().$ceil(ndigits);
        }, -1);
        $def(self2, "$conj", $return_self);
        $def(self2, "$denominator", function $$denominator() {
          var self3 = this;
          return self3.$to_r().$denominator();
        });
        $def(self2, "$div", function $$div(other) {
          var self3 = this;
          if ($eqeq(other, 0)) {
            $Kernel.$raise($$$("ZeroDivisionError"), "divided by o");
          }
          ;
          return $rb_divide(self3, other).$floor();
        });
        $def(self2, "$divmod", function $$divmod(other) {
          var self3 = this;
          return [self3.$div(other), self3["$%"](other)];
        });
        $def(self2, "$fdiv", function $$fdiv(other) {
          var self3 = this;
          return $rb_divide(self3.$to_f(), other);
        });
        $def(self2, "$floor", function $$floor(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          return self3.$to_f().$floor(ndigits);
        }, -1);
        $def(self2, "$i", function $$i() {
          var self3 = this;
          return $Kernel.$Complex(0, self3);
        });
        $def(self2, "$imag", $return_val(0));
        $def(self2, "$integer?", $return_val(false));
        $def(self2, "$nonzero?", function $Numeric_nonzero$ques$4() {
          var self3 = this;
          if ($truthy(self3["$zero?"]())) {
            return nil;
          } else {
            return self3;
          }
        });
        $def(self2, "$numerator", function $$numerator() {
          var self3 = this;
          return self3.$to_r().$numerator();
        });
        $def(self2, "$polar", function $$polar() {
          var self3 = this;
          return [self3.$abs(), self3.$arg()];
        });
        $def(self2, "$quo", function $$quo(other) {
          var self3 = this;
          return $rb_divide($Opal["$coerce_to!"](self3, $$$("Rational"), "to_r"), other);
        });
        $def(self2, "$real", $return_self);
        $def(self2, "$real?", $return_val(true));
        $def(self2, "$rect", function $$rect() {
          var self3 = this;
          return [self3, 0];
        });
        $def(self2, "$round", function $$round(digits) {
          var self3 = this;
          ;
          return self3.$to_f().$round(digits);
        }, -1);
        $def(self2, "$step", function $$step($a, $b, $c) {
          var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self3 = this, counter = nil;
          $$step.$$p = null;
          ;
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          if ($post_args.length > 0)
            limit = $post_args.shift();
          ;
          if ($post_args.length > 0)
            step = $post_args.shift();
          ;
          to = $kwargs.$$smap["to"];
          ;
          by = $kwargs.$$smap["by"];
          ;
          if (limit !== void 0 && to !== void 0) {
            $Kernel.$raise($$$("ArgumentError"), "to is given twice");
          }
          if (step !== void 0 && by !== void 0) {
            $Kernel.$raise($$$("ArgumentError"), "step is given twice");
          }
          if (to !== void 0) {
            limit = to;
          }
          if (by !== void 0) {
            step = by;
          }
          if (limit === void 0) {
            limit = nil;
          }
          function validateParameters() {
            if (step === nil) {
              $Kernel.$raise($$$("TypeError"), "step must be numeric");
            }
            if (step != null && step["$=="](0)) {
              $Kernel.$raise($$$("ArgumentError"), "step can't be 0");
            }
            if (step === nil || step == null) {
              step = 1;
            }
            var sign = step["$<=>"](0);
            if (sign === nil) {
              $Kernel.$raise($$$("ArgumentError"), "0 can't be coerced into " + step.$class());
            }
            if (limit === nil || limit == null) {
              limit = sign > 0 ? $$$($$$("Float"), "INFINITY") : $$$($$$("Float"), "INFINITY")["$-@"]();
            }
            $Opal.$compare(self3, limit);
          }
          function stepFloatSize() {
            if (step > 0 && self3 > limit || step < 0 && self3 < limit) {
              return 0;
            } else if (step === Infinity || step === -Infinity) {
              return 1;
            } else {
              var abs = Math.abs, floor = Math.floor, err = (abs(self3) + abs(limit) + abs(limit - self3)) / abs(step) * $$$($$$("Float"), "EPSILON");
              if (err === Infinity || err === -Infinity) {
                return 0;
              } else {
                if (err > 0.5) {
                  err = 0.5;
                }
                return floor((limit - self3) / step + err) + 1;
              }
            }
          }
          function stepSize() {
            validateParameters();
            if (step === 0) {
              return Infinity;
            }
            if (step % 1 !== 0) {
              return stepFloatSize();
            } else if (step > 0 && self3 > limit || step < 0 && self3 < limit) {
              return 0;
            } else {
              var ceil = Math.ceil, abs = Math.abs, lhs = abs(self3 - limit) + 1, rhs = abs(step);
              return ceil(lhs / rhs);
            }
          }
          ;
          if (!(block !== nil)) {
            if (($not(limit) || $truthy(limit["$is_a?"]($$$("Numeric")))) && ($not(step) || $truthy(step["$is_a?"]($$$("Numeric"))))) {
              return $$$($$$("Enumerator"), "ArithmeticSequence").$new([limit, step, $truthy(to) ? "to: " : nil, $truthy(by) ? "by: " : nil], self3);
            } else {
              return $send(self3, "enum_for", ["step", limit, step], stepSize.$to_proc());
            }
          }
          ;
          validateParameters();
          var isDesc = step["$negative?"](), isInf = step["$=="](0) || limit === Infinity && !isDesc || limit === -Infinity && isDesc;
          if (self3.$$is_number && step.$$is_number && limit.$$is_number) {
            if (self3 % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
              var value = self3;
              if (isInf) {
                for (; ; value += step) {
                  block(value);
                }
              } else if (isDesc) {
                for (; value >= limit; value += step) {
                  block(value);
                }
              } else {
                for (; value <= limit; value += step) {
                  block(value);
                }
              }
              return self3;
            } else {
              var begin = self3.$to_f().valueOf();
              step = step.$to_f().valueOf();
              limit = limit.$to_f().valueOf();
              var n = stepFloatSize();
              if (!isFinite(step)) {
                if (n !== 0)
                  block(begin);
              } else if (step === 0) {
                while (true) {
                  block(begin);
                }
              } else {
                for (var i = 0; i < n; i++) {
                  var d = i * step + self3;
                  if (step >= 0 ? limit < d : limit > d) {
                    d = limit;
                  }
                  block(d);
                }
              }
              return self3;
            }
          }
          ;
          counter = self3;
          while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
            Opal2.yield1(block, counter);
            counter = $rb_plus(counter, step);
          }
          ;
        }, -1);
        $def(self2, "$to_c", function $$to_c() {
          var self3 = this;
          return $Kernel.$Complex(self3, 0);
        });
        $def(self2, "$to_int", function $$to_int() {
          var self3 = this;
          return self3.$to_i();
        });
        $def(self2, "$truncate", function $$truncate(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          return self3.$to_f().$truncate(ndigits);
        }, -1);
        $def(self2, "$zero?", function $Numeric_zero$ques$5() {
          var self3 = this;
          return self3["$=="](0);
        });
        $def(self2, "$positive?", function $Numeric_positive$ques$6() {
          var self3 = this;
          return $rb_gt(self3, 0);
        });
        $def(self2, "$negative?", function $Numeric_negative$ques$7() {
          var self3 = this;
          return $rb_lt(self3, 0);
        });
        $def(self2, "$dup", $return_self);
        $def(self2, "$clone", function $$clone($kwargs) {
          var freeze, self3 = this;
          $kwargs = $ensure_kwargs($kwargs);
          freeze = $kwargs.$$smap["freeze"];
          if (freeze == null)
            freeze = true;
          return self3;
        }, -1);
        $def(self2, "$finite?", $return_val(true));
        $def(self2, "$infinite?", $return_val(nil));
        $alias(self2, "arg", "angle");
        $alias(self2, "conjugate", "conj");
        $alias(self2, "imaginary", "imag");
        $alias(self2, "magnitude", "abs");
        $alias(self2, "modulo", "%");
        $alias(self2, "phase", "arg");
        return $alias(self2, "rectangular", "rect");
      }("::", null);
    };
    Opal.modules["corelib/array"] = function(Opal2) {
      var $truthy = Opal2.truthy, $falsy = Opal2.falsy, $hash_ids = Opal2.hash_ids, $yield1 = Opal2.yield1, $hash_get = Opal2.hash_get, $hash_put = Opal2.hash_put, $hash_delete = Opal2.hash_delete, $coerce_to = Opal2.coerce_to, $respond_to = Opal2.respond_to, $deny_frozen_access = Opal2.deny_frozen_access, $freeze = Opal2.freeze, $klass = Opal2.klass, $slice = Opal2.slice, $defs = Opal2.defs, $Kernel = Opal2.Kernel, $def = Opal2.def, $Opal = Opal2.Opal, $eqeqeq = Opal2.eqeqeq, $hash2 = Opal2.hash2, $send2 = Opal2.send2, $find_super = Opal2.find_super, $send = Opal2.send, $rb_gt = Opal2.rb_gt, $rb_times = Opal2.rb_times, $eqeq = Opal2.eqeq, $rb_minus = Opal2.rb_minus, $to_a = Opal2.to_a, $to_ary = Opal2.to_ary, $gvars = Opal2.gvars, $rb_ge = Opal2.rb_ge, $assign_ivar = Opal2.assign_ivar, $rb_lt = Opal2.rb_lt, $return_self = Opal2.return_self, $neqeq = Opal2.neqeq, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class");
      self.$require("corelib/enumerable");
      self.$require("corelib/numeric");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Array");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        self2.$include($$$("Enumerable"));
        Opal2.prop(self2.$$prototype, "$$is_array", true);
        function shiftNoArg(list) {
          var r = list[0];
          var index = 1;
          var length = list.length;
          for (; index < length; index++) {
            list[index - 1] = list[index];
          }
          list.pop();
          return r;
        }
        function toArraySubclass(obj, klass) {
          if (klass.$$name === Opal2.Array) {
            return obj;
          } else {
            return klass.$allocate().$replace(obj.$to_a());
          }
        }
        function filterIf(self3, filter, block) {
          var value, raised = null, updated = new Array(self3.length);
          for (var i = 0, i2 = 0, length = self3.length; i < length; i++) {
            if (!raised) {
              try {
                value = $yield1(block, self3[i]);
              } catch (error) {
                raised = error;
              }
            }
            if (raised || filter(value)) {
              updated[i2] = self3[i];
              i2 += 1;
            }
          }
          if (i2 !== i) {
            self3.splice.apply(self3, [0, updated.length].concat(updated));
            self3.splice(i2, updated.length);
          }
          if (raised)
            throw raised;
        }
        ;
        $defs(self2, "$[]", function $Array_$$$1($a) {
          var $post_args, objects, self3 = this;
          $post_args = $slice(arguments);
          objects = $post_args;
          return toArraySubclass(objects, self3);
          ;
        }, -1);
        $def(self2, "$initialize", function $$initialize(size, obj) {
          var block = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          ;
          if (size == null)
            size = nil;
          if (obj == null)
            obj = nil;
          $deny_frozen_access(self3);
          if (obj !== nil && block !== nil) {
            $Kernel.$warn("warning: block supersedes default value argument");
          }
          if (size > $$$($$$("Integer"), "MAX")) {
            $Kernel.$raise($$$("ArgumentError"), "array size too big");
          }
          if (arguments.length > 2) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " for 0..2)");
          }
          if (arguments.length === 0) {
            self3.splice(0, self3.length);
            return self3;
          }
          if (arguments.length === 1) {
            if (size.$$is_array) {
              self3.$replace(size.$to_a());
              return self3;
            } else if (size["$respond_to?"]("to_ary")) {
              self3.$replace(size.$to_ary());
              return self3;
            }
          }
          size = $coerce_to(size, $$$("Integer"), "to_int");
          if (size < 0) {
            $Kernel.$raise($$$("ArgumentError"), "negative array size");
          }
          self3.splice(0, self3.length);
          var i, value;
          if (block === nil) {
            for (i = 0; i < size; i++) {
              self3.push(obj);
            }
          } else {
            for (i = 0, value; i < size; i++) {
              value = block(i);
              self3[i] = value;
            }
          }
          return self3;
          ;
        }, -1);
        $defs(self2, "$try_convert", function $$try_convert(obj) {
          return $Opal["$coerce_to?"](obj, $$$("Array"), "to_ary");
        });
        $def(self2, "$&", function $Array_$$2(other) {
          var self3 = this;
          other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
          var result = [], hash = $hash2([], {}), i, length, item;
          for (i = 0, length = other.length; i < length; i++) {
            $hash_put(hash, other[i], true);
          }
          for (i = 0, length = self3.length; i < length; i++) {
            item = self3[i];
            if ($hash_delete(hash, item) !== void 0) {
              result.push(item);
            }
          }
          return result;
          ;
        });
        $def(self2, "$|", function $Array_$$3(other) {
          var self3 = this;
          other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
          var hash = $hash2([], {}), i, length, item;
          for (i = 0, length = self3.length; i < length; i++) {
            $hash_put(hash, self3[i], true);
          }
          for (i = 0, length = other.length; i < length; i++) {
            $hash_put(hash, other[i], true);
          }
          return hash.$keys();
          ;
        });
        $def(self2, "$*", function $Array_$$4(other) {
          var self3 = this;
          if ($truthy(other["$respond_to?"]("to_str"))) {
            return self3.$join(other.$to_str());
          }
          ;
          other = $coerce_to(other, $$$("Integer"), "to_int");
          if ($truthy(other < 0)) {
            $Kernel.$raise($$$("ArgumentError"), "negative argument");
          }
          ;
          var result = [], converted = self3.$to_a();
          for (var i = 0; i < other; i++) {
            result = result.concat(converted);
          }
          return result;
          ;
        });
        $def(self2, "$+", function $Array_$plus$5(other) {
          var self3 = this;
          other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
          return self3.concat(other);
          ;
        });
        $def(self2, "$-", function $Array_$minus$6(other) {
          var self3 = this;
          other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
          if ($truthy(self3.length === 0)) {
            return [];
          }
          ;
          if ($truthy(other.length === 0)) {
            return self3.slice();
          }
          ;
          var result = [], hash = $hash2([], {}), i, length, item;
          for (i = 0, length = other.length; i < length; i++) {
            $hash_put(hash, other[i], true);
          }
          for (i = 0, length = self3.length; i < length; i++) {
            item = self3[i];
            if ($hash_get(hash, item) === void 0) {
              result.push(item);
            }
          }
          return result;
          ;
        });
        $def(self2, "$<<", function $Array_$lt$lt$7(object) {
          var self3 = this;
          $deny_frozen_access(self3);
          self3.push(object);
          return self3;
        });
        $def(self2, "$<=>", function $Array_$lt_eq_gt$8(other) {
          var self3 = this;
          if ($eqeqeq($$$("Array"), other)) {
            other = other.$to_a();
          } else if ($truthy(other["$respond_to?"]("to_ary"))) {
            other = other.$to_ary().$to_a();
          } else {
            return nil;
          }
          ;
          if (self3.$hash() === other.$hash()) {
            return 0;
          }
          var count = Math.min(self3.length, other.length);
          for (var i = 0; i < count; i++) {
            var tmp = self3[i]["$<=>"](other[i]);
            if (tmp !== 0) {
              return tmp;
            }
          }
          return self3.length["$<=>"](other.length);
          ;
        });
        $def(self2, "$==", function $Array_$eq_eq$9(other) {
          var self3 = this;
          var recursed = {};
          function _eqeq(array, other2) {
            var i, length, a, b;
            if (array === other2)
              return true;
            if (!other2.$$is_array) {
              if ($respond_to(other2, "$to_ary")) {
                return other2["$=="](array);
              } else {
                return false;
              }
            }
            if (array.$$constructor !== Array)
              array = array.$to_a();
            if (other2.$$constructor !== Array)
              other2 = other2.$to_a();
            if (array.length !== other2.length) {
              return false;
            }
            recursed[array.$object_id()] = true;
            for (i = 0, length = array.length; i < length; i++) {
              a = array[i];
              b = other2[i];
              if (a.$$is_array) {
                if (b.$$is_array && b.length !== a.length) {
                  return false;
                }
                if (!recursed.hasOwnProperty(a.$object_id())) {
                  if (!_eqeq(a, b)) {
                    return false;
                  }
                }
              } else {
                if (!a["$=="](b)) {
                  return false;
                }
              }
            }
            return true;
          }
          return _eqeq(self3, other);
        });
        function $array_slice_range(self3, index) {
          var size = self3.length, exclude, from, to, result;
          exclude = index.excl;
          from = index.begin === nil ? 0 : $coerce_to(index.begin, Opal2.Integer, "to_int");
          to = index.end === nil ? -1 : $coerce_to(index.end, Opal2.Integer, "to_int");
          if (from < 0) {
            from += size;
            if (from < 0) {
              return nil;
            }
          }
          if (index.excl_rev && index.begin !== nil) {
            from += 1;
          }
          if (from > size) {
            return nil;
          }
          if (to < 0) {
            to += size;
            if (to < 0) {
              return [];
            }
          }
          if (!exclude || index.end === nil) {
            to += 1;
          }
          result = self3.slice(from, to);
          return result;
        }
        function $array_slice_arithmetic_seq(self3, index) {
          var array, out = [], i = 0, pseudorange;
          if (index.step < 0) {
            pseudorange = {
              begin: index.range.end,
              end: index.range.begin,
              excl: false,
              excl_rev: index.range.excl
            };
            array = $array_slice_range(self3, pseudorange).$reverse();
          } else {
            array = $array_slice_range(self3, index.range);
          }
          while (i < array.length) {
            out.push(array[i]);
            i += Math.abs(index.step);
          }
          return out;
        }
        function $array_slice_index_length(self3, index, length) {
          var size = self3.length, exclude, from, to, result;
          index = $coerce_to(index, Opal2.Integer, "to_int");
          if (index < 0) {
            index += size;
            if (index < 0) {
              return nil;
            }
          }
          if (length === void 0) {
            if (index >= size || index < 0) {
              return nil;
            }
            return self3[index];
          } else {
            length = $coerce_to(length, Opal2.Integer, "to_int");
            if (length < 0 || index > size || index < 0) {
              return nil;
            }
            result = self3.slice(index, index + length);
          }
          return result;
        }
        ;
        $def(self2, "$[]", function $Array_$$$10(index, length) {
          var self3 = this;
          ;
          if (index.$$is_range) {
            return $array_slice_range(self3, index);
          } else if (index.$$is_arithmetic_seq) {
            return $array_slice_arithmetic_seq(self3, index);
          } else {
            return $array_slice_index_length(self3, index, length);
          }
          ;
        }, -2);
        $def(self2, "$[]=", function $Array_$$$eq$11(index, value, extra) {
          var self3 = this, data = nil, length = nil;
          ;
          $deny_frozen_access(self3);
          data = nil;
          var i, size = self3.length;
          if (index.$$is_range) {
            if (value.$$is_array)
              data = value.$to_a();
            else if (value["$respond_to?"]("to_ary"))
              data = value.$to_ary().$to_a();
            else
              data = [value];
            var exclude = index.excl, from = index.begin === nil ? 0 : $coerce_to(index.begin, Opal2.Integer, "to_int"), to = index.end === nil ? -1 : $coerce_to(index.end, Opal2.Integer, "to_int");
            if (from < 0) {
              from += size;
              if (from < 0) {
                $Kernel.$raise($$$("RangeError"), "" + index.$inspect() + " out of range");
              }
            }
            if (to < 0) {
              to += size;
            }
            if (!exclude || index.end === nil) {
              to += 1;
            }
            if (from > size) {
              for (i = size; i < from; i++) {
                self3[i] = nil;
              }
            }
            if (to < 0) {
              self3.splice.apply(self3, [from, 0].concat(data));
            } else {
              self3.splice.apply(self3, [from, to - from].concat(data));
            }
            return value;
          } else {
            if (extra === void 0) {
              length = 1;
            } else {
              length = value;
              value = extra;
              if (value.$$is_array)
                data = value.$to_a();
              else if (value["$respond_to?"]("to_ary"))
                data = value.$to_ary().$to_a();
              else
                data = [value];
            }
            var old;
            index = $coerce_to(index, $$$("Integer"), "to_int");
            length = $coerce_to(length, $$$("Integer"), "to_int");
            if (index < 0) {
              old = index;
              index += size;
              if (index < 0) {
                $Kernel.$raise($$$("IndexError"), "index " + old + " too small for array; minimum " + -self3.length);
              }
            }
            if (length < 0) {
              $Kernel.$raise($$$("IndexError"), "negative length (" + length + ")");
            }
            if (index > size) {
              for (i = size; i < index; i++) {
                self3[i] = nil;
              }
            }
            if (extra === void 0) {
              self3[index] = value;
            } else {
              self3.splice.apply(self3, [index, length].concat(data));
            }
            return value;
          }
          ;
        }, -3);
        $def(self2, "$any?", function $Array_any$ques$12(pattern) {
          var block = $Array_any$ques$12.$$p || nil, self3 = this;
          $Array_any$ques$12.$$p = null;
          ;
          ;
          if (self3.length === 0)
            return false;
          return $send2(self3, $find_super(self3, "any?", $Array_any$ques$12, false, true), "any?", [pattern], block);
        }, -1);
        $def(self2, "$assoc", function $$assoc(object) {
          var self3 = this;
          for (var i = 0, length = self3.length, item; i < length; i++) {
            if (item = self3[i], item.length && item[0]["$=="](object)) {
              return item;
            }
          }
          return nil;
        });
        $def(self2, "$at", function $$at(index) {
          var self3 = this;
          index = $coerce_to(index, $$$("Integer"), "to_int");
          if (index < 0) {
            index += self3.length;
          }
          if (index < 0 || index >= self3.length) {
            return nil;
          }
          return self3[index];
        });
        $def(self2, "$bsearch_index", function $$bsearch_index() {
          var block = $$bsearch_index.$$p || nil, self3 = this;
          $$bsearch_index.$$p = null;
          ;
          if (!(block !== nil)) {
            return self3.$enum_for("bsearch_index");
          }
          ;
          var min = 0, max = self3.length, mid, val, ret, smaller = false, satisfied = nil;
          while (min < max) {
            mid = min + Math.floor((max - min) / 2);
            val = self3[mid];
            ret = $yield1(block, val);
            if (ret === true) {
              satisfied = mid;
              smaller = true;
            } else if (ret === false || ret === nil) {
              smaller = false;
            } else if (ret.$$is_number) {
              if (ret === 0) {
                return mid;
              }
              smaller = ret < 0;
            } else {
              $Kernel.$raise($$$("TypeError"), "wrong argument type " + ret.$class() + " (must be numeric, true, false or nil)");
            }
            if (smaller) {
              max = mid;
            } else {
              min = mid + 1;
            }
          }
          return satisfied;
          ;
        });
        $def(self2, "$bsearch", function $$bsearch() {
          var block = $$bsearch.$$p || nil, self3 = this, index = nil;
          $$bsearch.$$p = null;
          ;
          if (!(block !== nil)) {
            return self3.$enum_for("bsearch");
          }
          ;
          index = $send(self3, "bsearch_index", [], block.$to_proc());
          if (index != null && index.$$is_number) {
            return self3[index];
          } else {
            return index;
          }
          ;
        });
        $def(self2, "$cycle", function $$cycle(n) {
          var block = $$cycle.$$p || nil, self3 = this;
          $$cycle.$$p = null;
          ;
          if (n == null)
            n = nil;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["cycle", n], function $$13() {
              var self4 = $$13.$$s == null ? this : $$13.$$s;
              if ($truthy(n["$nil?"]())) {
                return $$$($$$("Float"), "INFINITY");
              } else {
                n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
                if ($truthy($rb_gt(n, 0))) {
                  return $rb_times(self4.$enumerator_size(), n);
                } else {
                  return 0;
                }
                ;
              }
            }, { $$s: self3 });
          }
          ;
          if ($truthy(self3["$empty?"]()) || $eqeq(n, 0)) {
            return nil;
          }
          ;
          var i, length, value;
          if (n === nil) {
            while (true) {
              for (i = 0, length = self3.length; i < length; i++) {
                value = $yield1(block, self3[i]);
              }
            }
          } else {
            n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
            if (n <= 0) {
              return self3;
            }
            while (n > 0) {
              for (i = 0, length = self3.length; i < length; i++) {
                value = $yield1(block, self3[i]);
              }
              n--;
            }
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$clear", function $$clear() {
          var self3 = this;
          $deny_frozen_access(self3);
          self3.splice(0, self3.length);
          return self3;
        });
        $def(self2, "$count", function $$count(object) {
          var block = $$count.$$p || nil, self3 = this;
          $$count.$$p = null;
          ;
          ;
          if ($truthy(object !== void 0) || $truthy(block)) {
            return $send2(self3, $find_super(self3, "count", $$count, false, true), "count", [object], block);
          } else {
            return self3.$size();
          }
          ;
        }, -1);
        $def(self2, "$initialize_copy", function $$initialize_copy(other) {
          var self3 = this;
          return self3.$replace(other);
        });
        $def(self2, "$collect", function $$collect() {
          var block = $$collect.$$p || nil, self3 = this;
          $$collect.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["collect"], function $$14() {
              var self4 = $$14.$$s == null ? this : $$14.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result = [];
          for (var i = 0, length = self3.length; i < length; i++) {
            var value = $yield1(block, self3[i]);
            result.push(value);
          }
          return result;
          ;
        });
        $def(self2, "$collect!", function $Array_collect$excl$15() {
          var block = $Array_collect$excl$15.$$p || nil, self3 = this;
          $Array_collect$excl$15.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["collect!"], function $$16() {
              var self4 = $$16.$$s == null ? this : $$16.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          for (var i = 0, length = self3.length; i < length; i++) {
            var value = $yield1(block, self3[i]);
            self3[i] = value;
          }
          ;
          return self3;
        });
        function binomial_coefficient(n, k) {
          if (n === k || k === 0) {
            return 1;
          }
          if (k > 0 && n > k) {
            return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
          }
          return 0;
        }
        ;
        $def(self2, "$combination", function $$combination(n) {
          var $yield = $$combination.$$p || nil, self3 = this, num = nil;
          $$combination.$$p = null;
          num = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
          if (!($yield !== nil)) {
            return $send(self3, "enum_for", ["combination", num], function $$17() {
              var self4 = $$17.$$s == null ? this : $$17.$$s;
              return binomial_coefficient(self4.length, num);
            }, { $$s: self3 });
          }
          ;
          var i, length, stack, chosen, lev, done, next;
          if (num === 0) {
            Opal2.yield1($yield, []);
          } else if (num === 1) {
            for (i = 0, length = self3.length; i < length; i++) {
              Opal2.yield1($yield, [self3[i]]);
            }
          } else if (num === self3.length) {
            Opal2.yield1($yield, self3.slice());
          } else if (num >= 0 && num < self3.length) {
            stack = [];
            for (i = 0; i <= num + 1; i++) {
              stack.push(0);
            }
            chosen = [];
            lev = 0;
            done = false;
            stack[0] = -1;
            while (!done) {
              chosen[lev] = self3[stack[lev + 1]];
              while (lev < num - 1) {
                lev++;
                next = stack[lev + 1] = stack[lev] + 1;
                chosen[lev] = self3[next];
              }
              Opal2.yield1($yield, chosen.slice());
              lev++;
              do {
                done = lev === 0;
                stack[lev]++;
                lev--;
              } while (stack[lev + 1] + num === self3.length + lev + 1);
            }
          }
          ;
          return self3;
        });
        $def(self2, "$repeated_combination", function $$repeated_combination(n) {
          var $yield = $$repeated_combination.$$p || nil, self3 = this, num = nil;
          $$repeated_combination.$$p = null;
          num = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
          if (!($yield !== nil)) {
            return $send(self3, "enum_for", ["repeated_combination", num], function $$18() {
              var self4 = $$18.$$s == null ? this : $$18.$$s;
              return binomial_coefficient(self4.length + num - 1, num);
            }, { $$s: self3 });
          }
          ;
          function iterate(max, from, buffer, self4) {
            if (buffer.length == max) {
              var copy = buffer.slice();
              Opal2.yield1($yield, copy);
              return;
            }
            for (var i = from; i < self4.length; i++) {
              buffer.push(self4[i]);
              iterate(max, i, buffer, self4);
              buffer.pop();
            }
          }
          if (num >= 0) {
            iterate(num, 0, [], self3);
          }
          ;
          return self3;
        });
        $def(self2, "$compact", function $$compact() {
          var self3 = this;
          var result = [];
          for (var i = 0, length = self3.length, item; i < length; i++) {
            if ((item = self3[i]) !== nil) {
              result.push(item);
            }
          }
          return result;
        });
        $def(self2, "$compact!", function $Array_compact$excl$19() {
          var self3 = this;
          $deny_frozen_access(self3);
          var original = self3.length;
          for (var i = 0, length = self3.length; i < length; i++) {
            if (self3[i] === nil) {
              self3.splice(i, 1);
              length--;
              i--;
            }
          }
          return self3.length === original ? nil : self3;
        });
        $def(self2, "$concat", function $$concat($a) {
          var $post_args, others, self3 = this;
          $post_args = $slice(arguments);
          others = $post_args;
          $deny_frozen_access(self3);
          others = $send(others, "map", [], function $$20(other) {
            var self4 = $$20.$$s == null ? this : $$20.$$s;
            if (other == null)
              other = nil;
            other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
            if ($truthy(other["$equal?"](self4))) {
              other = other.$dup();
            }
            ;
            return other;
          }, { $$s: self3 });
          $send(others, "each", [], function $$21(other) {
            var self4 = $$21.$$s == null ? this : $$21.$$s;
            if (other == null)
              other = nil;
            for (var i = 0, length = other.length; i < length; i++) {
              self4.push(other[i]);
            }
            ;
          }, { $$s: self3 });
          return self3;
        }, -1);
        $def(self2, "$delete", function $Array_delete$22(object) {
          var $yield = $Array_delete$22.$$p || nil, self3 = this;
          $Array_delete$22.$$p = null;
          var original = self3.length;
          for (var i = 0, length = original; i < length; i++) {
            if (self3[i]["$=="](object)) {
              $deny_frozen_access(self3);
              self3.splice(i, 1);
              length--;
              i--;
            }
          }
          if (self3.length === original) {
            if ($yield !== nil) {
              return Opal2.yieldX($yield, []);
            }
            return nil;
          }
          return object;
        });
        $def(self2, "$delete_at", function $$delete_at(index) {
          var self3 = this;
          $deny_frozen_access(self3);
          index = $coerce_to(index, $$$("Integer"), "to_int");
          if (index < 0) {
            index += self3.length;
          }
          if (index < 0 || index >= self3.length) {
            return nil;
          }
          var result = self3[index];
          self3.splice(index, 1);
          return result;
        });
        $def(self2, "$delete_if", function $$delete_if() {
          var block = $$delete_if.$$p || nil, self3 = this;
          $$delete_if.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["delete_if"], function $$23() {
              var self4 = $$23.$$s == null ? this : $$23.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          filterIf(self3, $falsy, block);
          return self3;
        });
        $def(self2, "$difference", function $$difference($a) {
          var $post_args, arrays, self3 = this;
          $post_args = $slice(arguments);
          arrays = $post_args;
          return $send(arrays, "reduce", [self3.$to_a().$dup()], function $$24(a, b) {
            if (a == null)
              a = nil;
            if (b == null)
              b = nil;
            return $rb_minus(a, b);
          });
        }, -1);
        $def(self2, "$dig", function $$dig(idx, $a) {
          var $post_args, idxs, self3 = this, item = nil;
          $post_args = $slice(arguments, 1);
          idxs = $post_args;
          item = self3["$[]"](idx);
          if (item === nil || idxs.length === 0) {
            return item;
          }
          ;
          if (!$truthy(item["$respond_to?"]("dig"))) {
            $Kernel.$raise($$$("TypeError"), "" + item.$class() + " does not have #dig method");
          }
          ;
          return $send(item, "dig", $to_a(idxs));
        }, -2);
        $def(self2, "$drop", function $$drop(number) {
          var self3 = this;
          number = $coerce_to(number, $$$("Integer"), "to_int");
          if (number < 0) {
            $Kernel.$raise($$$("ArgumentError"));
          }
          return self3.slice(number);
        });
        $def(self2, "$dup", function $$dup() {
          var $yield = $$dup.$$p || nil, self3 = this;
          $$dup.$$p = null;
          if (self3.$$class === Opal2.Array && self3.$$class.$allocate.$$pristine && self3.$copy_instance_variables.$$pristine && self3.$initialize_dup.$$pristine) {
            return self3.slice(0);
          }
          ;
          return $send2(self3, $find_super(self3, "dup", $$dup, false, true), "dup", [], $yield);
        });
        $def(self2, "$each", function $$each() {
          var block = $$each.$$p || nil, self3 = this;
          $$each.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each"], function $$25() {
              var self4 = $$25.$$s == null ? this : $$25.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          for (var i = 0, length = self3.length; i < length; i++) {
            var value = $yield1(block, self3[i]);
          }
          ;
          return self3;
        });
        $def(self2, "$each_index", function $$each_index() {
          var block = $$each_index.$$p || nil, self3 = this;
          $$each_index.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each_index"], function $$26() {
              var self4 = $$26.$$s == null ? this : $$26.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          for (var i = 0, length = self3.length; i < length; i++) {
            var value = $yield1(block, i);
          }
          ;
          return self3;
        });
        $def(self2, "$empty?", function $Array_empty$ques$27() {
          var self3 = this;
          return self3.length === 0;
        });
        $def(self2, "$eql?", function $Array_eql$ques$28(other) {
          var self3 = this;
          var recursed = {};
          function _eql(array, other2) {
            var i, length, a, b;
            if (!other2.$$is_array) {
              return false;
            }
            other2 = other2.$to_a();
            if (array.length !== other2.length) {
              return false;
            }
            recursed[array.$object_id()] = true;
            for (i = 0, length = array.length; i < length; i++) {
              a = array[i];
              b = other2[i];
              if (a.$$is_array) {
                if (b.$$is_array && b.length !== a.length) {
                  return false;
                }
                if (!recursed.hasOwnProperty(a.$object_id())) {
                  if (!_eql(a, b)) {
                    return false;
                  }
                }
              } else {
                if (!a["$eql?"](b)) {
                  return false;
                }
              }
            }
            return true;
          }
          return _eql(self3, other);
        });
        $def(self2, "$fetch", function $$fetch(index, defaults) {
          var block = $$fetch.$$p || nil, self3 = this;
          $$fetch.$$p = null;
          ;
          ;
          var original = index;
          index = $coerce_to(index, $$$("Integer"), "to_int");
          if (index < 0) {
            index += self3.length;
          }
          if (index >= 0 && index < self3.length) {
            return self3[index];
          }
          if (block !== nil && defaults != null) {
            self3.$warn("warning: block supersedes default value argument");
          }
          if (block !== nil) {
            return block(original);
          }
          if (defaults != null) {
            return defaults;
          }
          if (self3.length === 0) {
            $Kernel.$raise($$$("IndexError"), "index " + original + " outside of array bounds: 0...0");
          } else {
            $Kernel.$raise($$$("IndexError"), "index " + original + " outside of array bounds: -" + self3.length + "..." + self3.length);
          }
          ;
        }, -2);
        $def(self2, "$fill", function $$fill($a) {
          var block = $$fill.$$p || nil, $post_args, args, $b, $c, self3 = this, one = nil, two = nil, obj = nil, left = nil, right = nil;
          $$fill.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          $deny_frozen_access(self3);
          var i, length, value;
          ;
          if ($truthy(block)) {
            if ($truthy(args.length > 2)) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + args.$length() + " for 0..2)");
            }
            ;
            $c = args, $b = $to_ary($c), one = $b[0] == null ? nil : $b[0], two = $b[1] == null ? nil : $b[1], $c;
          } else {
            if ($truthy(args.length == 0)) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (0 for 1..3)");
            } else if ($truthy(args.length > 3)) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + args.$length() + " for 1..3)");
            }
            ;
            $c = args, $b = $to_ary($c), obj = $b[0] == null ? nil : $b[0], one = $b[1] == null ? nil : $b[1], two = $b[2] == null ? nil : $b[2], $c;
          }
          ;
          if ($eqeqeq($$$("Range"), one)) {
            if ($truthy(two)) {
              $Kernel.$raise($$$("TypeError"), "length invalid with range");
            }
            ;
            left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$("Integer"), "to_int");
            if ($truthy(left < 0)) {
              left += this.length;
            }
            ;
            if ($truthy(left < 0)) {
              $Kernel.$raise($$$("RangeError"), "" + one.$inspect() + " out of range");
            }
            ;
            right = one.end === nil ? -1 : $coerce_to(one.end, $$$("Integer"), "to_int");
            if ($truthy(right < 0)) {
              right += this.length;
            }
            ;
            if (!$truthy(one["$exclude_end?"]())) {
              right += 1;
            }
            ;
            if ($truthy(right <= left)) {
              return self3;
            }
            ;
          } else if ($truthy(one)) {
            left = $coerce_to(one, $$$("Integer"), "to_int");
            if ($truthy(left < 0)) {
              left += this.length;
            }
            ;
            if ($truthy(left < 0)) {
              left = 0;
            }
            ;
            if ($truthy(two)) {
              right = $coerce_to(two, $$$("Integer"), "to_int");
              if ($truthy(right == 0)) {
                return self3;
              }
              ;
              right += left;
            } else {
              right = this.length;
            }
            ;
          } else {
            left = 0;
            right = this.length;
          }
          ;
          if ($truthy(left > this.length)) {
            for (i = this.length; i < right; i++) {
              self3[i] = nil;
            }
          }
          ;
          if ($truthy(right > this.length)) {
            this.length = right;
          }
          ;
          if ($truthy(block)) {
            for (length = this.length; left < right; left++) {
              value = block(left);
              self3[left] = value;
            }
          } else {
            for (length = this.length; left < right; left++) {
              self3[left] = obj;
            }
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$first", function $$first(count) {
          var self3 = this;
          ;
          if (count == null) {
            return self3.length === 0 ? nil : self3[0];
          }
          count = $coerce_to(count, $$$("Integer"), "to_int");
          if (count < 0) {
            $Kernel.$raise($$$("ArgumentError"), "negative array size");
          }
          return self3.slice(0, count);
          ;
        }, -1);
        $def(self2, "$flatten", function $$flatten(level) {
          var self3 = this;
          ;
          function _flatten(array, level2) {
            var result = [], i, length, item, ary;
            array = array.$to_a();
            for (i = 0, length = array.length; i < length; i++) {
              item = array[i];
              if (!$respond_to(item, "$to_ary", true)) {
                result.push(item);
                continue;
              }
              ary = item.$to_ary();
              if (ary === nil) {
                result.push(item);
                continue;
              }
              if (!ary.$$is_array) {
                $Kernel.$raise($$$("TypeError"));
              }
              if (ary === self3) {
                $Kernel.$raise($$$("ArgumentError"));
              }
              switch (level2) {
                case void 0:
                  result = result.concat(_flatten(ary));
                  break;
                case 0:
                  result.push(ary);
                  break;
                default:
                  result.push.apply(result, _flatten(ary, level2 - 1));
              }
            }
            return result;
          }
          if (level !== void 0) {
            level = $coerce_to(level, $$$("Integer"), "to_int");
          }
          return _flatten(self3, level);
          ;
        }, -1);
        $def(self2, "$flatten!", function $Array_flatten$excl$29(level) {
          var self3 = this;
          ;
          $deny_frozen_access(self3);
          var flattened = self3.$flatten(level);
          if (self3.length == flattened.length) {
            for (var i = 0, length = self3.length; i < length; i++) {
              if (self3[i] !== flattened[i]) {
                break;
              }
            }
            if (i == length) {
              return nil;
            }
          }
          self3.$replace(flattened);
          ;
          return self3;
        }, -1);
        $def(self2, "$freeze", function $$freeze() {
          var self3 = this;
          if ($truthy(self3["$frozen?"]())) {
            return self3;
          }
          ;
          return $freeze(self3);
          ;
        });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          var top = $hash_ids === void 0, result = ["A"], hash_id = self3.$object_id(), item, i, key;
          try {
            if (top) {
              $hash_ids = /* @__PURE__ */ Object.create(null);
            }
            if ($hash_ids[hash_id]) {
              return "self";
            }
            for (key in $hash_ids) {
              item = $hash_ids[key];
              if (self3["$eql?"](item)) {
                return "self";
              }
            }
            $hash_ids[hash_id] = self3;
            for (i = 0; i < self3.length; i++) {
              item = self3[i];
              result.push(item.$hash());
            }
            return result.join(",");
          } finally {
            if (top) {
              $hash_ids = void 0;
            }
          }
        });
        $def(self2, "$include?", function $Array_include$ques$30(member) {
          var self3 = this;
          for (var i = 0, length = self3.length; i < length; i++) {
            if (self3[i]["$=="](member)) {
              return true;
            }
          }
          return false;
        });
        $def(self2, "$index", function $$index(object) {
          var block = $$index.$$p || nil, self3 = this;
          $$index.$$p = null;
          ;
          ;
          var i, length, value;
          if (object != null && block !== nil) {
            self3.$warn("warning: given block not used");
          }
          if (object != null) {
            for (i = 0, length = self3.length; i < length; i++) {
              if (self3[i]["$=="](object)) {
                return i;
              }
            }
          } else if (block !== nil) {
            for (i = 0, length = self3.length; i < length; i++) {
              value = block(self3[i]);
              if (value !== false && value !== nil) {
                return i;
              }
            }
          } else {
            return self3.$enum_for("index");
          }
          return nil;
          ;
        }, -1);
        $def(self2, "$insert", function $$insert(index, $a) {
          var $post_args, objects, self3 = this;
          $post_args = $slice(arguments, 1);
          objects = $post_args;
          $deny_frozen_access(self3);
          index = $coerce_to(index, $$$("Integer"), "to_int");
          if (objects.length > 0) {
            if (index < 0) {
              index += self3.length + 1;
              if (index < 0) {
                $Kernel.$raise($$$("IndexError"), "" + index + " is out of bounds");
              }
            }
            if (index > self3.length) {
              for (var i = self3.length; i < index; i++) {
                self3.push(nil);
              }
            }
            self3.splice.apply(self3, [index, 0].concat(objects));
          }
          ;
          return self3;
        }, -2);
        var inspect_stack = [];
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          var result = [], id = self3.$__id__(), pushed = true;
          ;
          return function() {
            try {
              if (inspect_stack.indexOf(id) !== -1) {
                pushed = false;
                return "[...]";
              }
              inspect_stack.push(id);
              for (var i = 0, length = self3.length; i < length; i++) {
                var item = self3["$[]"](i);
                result.push($$("Opal").$inspect(item));
              }
              return "[" + result.join(", ") + "]";
              ;
              return nil;
            } finally {
              if (pushed)
                inspect_stack.pop();
            }
            ;
          }();
          ;
        });
        $def(self2, "$intersection", function $$intersection($a) {
          var $post_args, arrays, self3 = this;
          $post_args = $slice(arguments);
          arrays = $post_args;
          return $send(arrays, "reduce", [self3.$to_a().$dup()], function $$31(a, b) {
            if (a == null)
              a = nil;
            if (b == null)
              b = nil;
            return a["$&"](b);
          });
        }, -1);
        $def(self2, "$intersect?", function $Array_intersect$ques$32(other) {
          var self3 = this;
          return self3.$intersection(other)["$empty?"]()["$!"]();
        });
        $def(self2, "$join", function $$join(sep) {
          var self3 = this;
          if ($gvars[","] == null)
            $gvars[","] = nil;
          if (sep == null)
            sep = nil;
          if ($truthy(self3.length === 0)) {
            return "";
          }
          ;
          if ($truthy(sep === nil)) {
            sep = $gvars[","];
          }
          ;
          var result = [];
          var i, length, item, tmp;
          for (i = 0, length = self3.length; i < length; i++) {
            item = self3[i];
            if ($respond_to(item, "$to_str")) {
              tmp = item.$to_str();
              if (tmp !== nil) {
                result.push(tmp.$to_s());
                continue;
              }
            }
            if ($respond_to(item, "$to_ary")) {
              tmp = item.$to_ary();
              if (tmp === self3) {
                $Kernel.$raise($$$("ArgumentError"));
              }
              if (tmp !== nil) {
                result.push(tmp.$join(sep));
                continue;
              }
            }
            if ($respond_to(item, "$to_s")) {
              tmp = item.$to_s();
              if (tmp !== nil) {
                result.push(tmp);
                continue;
              }
            }
            $Kernel.$raise($$$("NoMethodError").$new("" + $$("Opal").$inspect(self3.$item()) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
          }
          if (sep === nil) {
            return result.join("");
          } else {
            return result.join($Opal["$coerce_to!"](sep, $$$("String"), "to_str").$to_s());
          }
          ;
        }, -1);
        $def(self2, "$keep_if", function $$keep_if() {
          var block = $$keep_if.$$p || nil, self3 = this;
          $$keep_if.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["keep_if"], function $$33() {
              var self4 = $$33.$$s == null ? this : $$33.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          filterIf(self3, $truthy, block);
          return self3;
        });
        $def(self2, "$last", function $$last(count) {
          var self3 = this;
          ;
          if (count == null) {
            return self3.length === 0 ? nil : self3[self3.length - 1];
          }
          count = $coerce_to(count, $$$("Integer"), "to_int");
          if (count < 0) {
            $Kernel.$raise($$$("ArgumentError"), "negative array size");
          }
          if (count > self3.length) {
            count = self3.length;
          }
          return self3.slice(self3.length - count, self3.length);
          ;
        }, -1);
        $def(self2, "$length", function $$length() {
          var self3 = this;
          return self3.length;
        });
        $def(self2, "$max", function $$max(n) {
          var block = $$max.$$p || nil, self3 = this;
          $$max.$$p = null;
          ;
          ;
          return $send(self3.$each(), "max", [n], block.$to_proc());
        }, -1);
        $def(self2, "$min", function $$min() {
          var block = $$min.$$p || nil, self3 = this;
          $$min.$$p = null;
          ;
          return $send(self3.$each(), "min", [], block.$to_proc());
        });
        function descending_factorial(from, how_many) {
          var count = how_many >= 0 ? 1 : 0;
          while (how_many) {
            count *= from;
            from--;
            how_many--;
          }
          return count;
        }
        ;
        $def(self2, "$permutation", function $$permutation(num) {
          var block = $$permutation.$$p || nil, self3 = this, perm = nil, used = nil;
          $$permutation.$$p = null;
          ;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["permutation", num], function $$34() {
              var self4 = $$34.$$s == null ? this : $$34.$$s;
              return descending_factorial(self4.length, num === void 0 ? self4.length : num);
            }, { $$s: self3 });
          }
          ;
          var permute, offensive, output;
          if (num === void 0) {
            num = self3.length;
          } else {
            num = $coerce_to(num, $$$("Integer"), "to_int");
          }
          if (num < 0 || self3.length < num) {
          } else if (num === 0) {
            Opal2.yield1(block, []);
          } else if (num === 1) {
            for (var i = 0; i < self3.length; i++) {
              Opal2.yield1(block, [self3[i]]);
            }
          } else {
            perm = $$("Array").$new(num);
            used = $$("Array").$new(self3.length, false);
            permute = function(num2, perm2, index, used2, blk) {
              self3 = this;
              for (var i2 = 0; i2 < self3.length; i2++) {
                if (used2["$[]"](i2)["$!"]()) {
                  perm2[index] = i2;
                  if (index < num2 - 1) {
                    used2[i2] = true;
                    permute.call(self3, num2, perm2, index + 1, used2, blk);
                    used2[i2] = false;
                  } else {
                    output = [];
                    for (var j = 0; j < perm2.length; j++) {
                      output.push(self3[perm2[j]]);
                    }
                    $yield1(blk, output);
                  }
                }
              }
            };
            if (block !== nil) {
              offensive = self3.slice();
              permute.call(offensive, num, perm, 0, used, block);
            } else {
              permute.call(self3, num, perm, 0, used, block);
            }
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$repeated_permutation", function $$repeated_permutation(n) {
          var $yield = $$repeated_permutation.$$p || nil, self3 = this, num = nil;
          $$repeated_permutation.$$p = null;
          num = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
          if (!($yield !== nil)) {
            return $send(self3, "enum_for", ["repeated_permutation", num], function $$35() {
              var self4 = $$35.$$s == null ? this : $$35.$$s;
              if ($truthy($rb_ge(num, 0))) {
                return self4.$size()["$**"](num);
              } else {
                return 0;
              }
            }, { $$s: self3 });
          }
          ;
          function iterate(max, buffer, self4) {
            if (buffer.length == max) {
              var copy = buffer.slice();
              Opal2.yield1($yield, copy);
              return;
            }
            for (var i = 0; i < self4.length; i++) {
              buffer.push(self4[i]);
              iterate(max, buffer, self4);
              buffer.pop();
            }
          }
          iterate(num, [], self3.slice());
          ;
          return self3;
        });
        $def(self2, "$pop", function $$pop(count) {
          var self3 = this;
          ;
          $deny_frozen_access(self3);
          if ($truthy(count === void 0)) {
            if ($truthy(self3.length === 0)) {
              return nil;
            }
            ;
            return self3.pop();
          }
          ;
          count = $coerce_to(count, $$$("Integer"), "to_int");
          if ($truthy(count < 0)) {
            $Kernel.$raise($$$("ArgumentError"), "negative array size");
          }
          ;
          if ($truthy(self3.length === 0)) {
            return [];
          }
          ;
          if ($truthy(count === 1)) {
            return [self3.pop()];
          } else if ($truthy(count > self3.length)) {
            return self3.splice(0, self3.length);
          } else {
            return self3.splice(self3.length - count, self3.length);
          }
          ;
        }, -1);
        $def(self2, "$product", function $$product($a) {
          var block = $$product.$$p || nil, $post_args, args, self3 = this;
          $$product.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          var result = block !== nil ? null : [], n = args.length + 1, counters = new Array(n), lengths = new Array(n), arrays = new Array(n), i, m, subarray, len, resultlen = 1;
          arrays[0] = self3;
          for (i = 1; i < n; i++) {
            arrays[i] = $coerce_to(args[i - 1], $$$("Array"), "to_ary");
          }
          for (i = 0; i < n; i++) {
            len = arrays[i].length;
            if (len === 0) {
              return result || self3;
            }
            resultlen *= len;
            if (resultlen > 2147483647) {
              $Kernel.$raise($$$("RangeError"), "too big to product");
            }
            lengths[i] = len;
            counters[i] = 0;
          }
          outer_loop:
            for (; ; ) {
              subarray = [];
              for (i = 0; i < n; i++) {
                subarray.push(arrays[i][counters[i]]);
              }
              if (result) {
                result.push(subarray);
              } else {
                Opal2.yield1(block, subarray);
              }
              m = n - 1;
              counters[m]++;
              while (counters[m] === lengths[m]) {
                counters[m] = 0;
                if (--m < 0)
                  break outer_loop;
                counters[m]++;
              }
            }
          return result || self3;
          ;
        }, -1);
        $def(self2, "$push", function $$push($a) {
          var $post_args, objects, self3 = this;
          $post_args = $slice(arguments);
          objects = $post_args;
          $deny_frozen_access(self3);
          for (var i = 0, length = objects.length; i < length; i++) {
            self3.push(objects[i]);
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$rassoc", function $$rassoc(object) {
          var self3 = this;
          for (var i = 0, length = self3.length, item; i < length; i++) {
            item = self3[i];
            if (item.length && item[1] !== void 0) {
              if (item[1]["$=="](object)) {
                return item;
              }
            }
          }
          return nil;
        });
        $def(self2, "$reject", function $$reject() {
          var block = $$reject.$$p || nil, self3 = this;
          $$reject.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["reject"], function $$36() {
              var self4 = $$36.$$s == null ? this : $$36.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result = [];
          for (var i = 0, length = self3.length, value; i < length; i++) {
            value = block(self3[i]);
            if (value === false || value === nil) {
              result.push(self3[i]);
            }
          }
          return result;
          ;
        });
        $def(self2, "$reject!", function $Array_reject$excl$37() {
          var block = $Array_reject$excl$37.$$p || nil, self3 = this, original = nil;
          $Array_reject$excl$37.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["reject!"], function $$38() {
              var self4 = $$38.$$s == null ? this : $$38.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          original = self3.$length();
          $send(self3, "delete_if", [], block.$to_proc());
          if ($eqeq(self3.$length(), original)) {
            return nil;
          } else {
            return self3;
          }
          ;
        });
        $def(self2, "$replace", function $$replace(other) {
          var self3 = this;
          $deny_frozen_access(self3);
          other = $eqeqeq($$$("Array"), other) ? other.$to_a() : $coerce_to(other, $$$("Array"), "to_ary").$to_a();
          self3.splice(0, self3.length);
          self3.push.apply(self3, other);
          ;
          return self3;
        });
        $def(self2, "$reverse", function $$reverse() {
          var self3 = this;
          return self3.slice(0).reverse();
        });
        $def(self2, "$reverse!", function $Array_reverse$excl$39() {
          var self3 = this;
          $deny_frozen_access(self3);
          return self3.reverse();
          ;
        });
        $def(self2, "$reverse_each", function $$reverse_each() {
          var block = $$reverse_each.$$p || nil, self3 = this;
          $$reverse_each.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["reverse_each"], function $$40() {
              var self4 = $$40.$$s == null ? this : $$40.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $send(self3.$reverse(), "each", [], block.$to_proc());
          return self3;
        });
        $def(self2, "$rindex", function $$rindex(object) {
          var block = $$rindex.$$p || nil, self3 = this;
          $$rindex.$$p = null;
          ;
          ;
          var i, value;
          if (object != null && block !== nil) {
            self3.$warn("warning: given block not used");
          }
          if (object != null) {
            for (i = self3.length - 1; i >= 0; i--) {
              if (i >= self3.length) {
                break;
              }
              if (self3[i]["$=="](object)) {
                return i;
              }
            }
          } else if (block !== nil) {
            for (i = self3.length - 1; i >= 0; i--) {
              if (i >= self3.length) {
                break;
              }
              value = block(self3[i]);
              if (value !== false && value !== nil) {
                return i;
              }
            }
          } else if (object == null) {
            return self3.$enum_for("rindex");
          }
          return nil;
          ;
        }, -1);
        $def(self2, "$rotate", function $$rotate(n) {
          var self3 = this;
          if (n == null)
            n = 1;
          var ary, idx, firstPart, lastPart;
          n = $coerce_to(n, $$$("Integer"), "to_int");
          if (self3.length === 1) {
            return self3.slice();
          }
          if (self3.length === 0) {
            return [];
          }
          ary = self3.slice();
          idx = n % ary.length;
          firstPart = ary.slice(idx);
          lastPart = ary.slice(0, idx);
          return firstPart.concat(lastPart);
          ;
        }, -1);
        $def(self2, "$rotate!", function $Array_rotate$excl$41(cnt) {
          var self3 = this, ary = nil;
          if (cnt == null)
            cnt = 1;
          $deny_frozen_access(self3);
          if (self3.length === 0 || self3.length === 1) {
            return self3;
          }
          cnt = $coerce_to(cnt, $$$("Integer"), "to_int");
          ;
          ary = self3.$rotate(cnt);
          return self3.$replace(ary);
        }, -1);
        (function($base2, $super2) {
          var self3 = $klass($base2, $super2, "SampleRandom");
          var $proto = self3.$$prototype;
          $proto.rng = nil;
          $def(self3, "$initialize", $assign_ivar("rng"));
          return $def(self3, "$rand", function $$rand(size) {
            var self4 = this, random = nil;
            random = $coerce_to(self4.rng.$rand(size), $$$("Integer"), "to_int");
            if ($truthy(random < 0)) {
              $Kernel.$raise($$$("RangeError"), "random value must be >= 0");
            }
            ;
            if (!$truthy(random < size)) {
              $Kernel.$raise($$$("RangeError"), "random value must be less than Array size");
            }
            ;
            return random;
          });
        })(self2, null);
        $def(self2, "$sample", function $$sample(count, options) {
          var self3 = this, o = nil, rng = nil;
          ;
          ;
          if ($truthy(count === void 0)) {
            return self3.$at($Kernel.$rand(self3.length));
          }
          ;
          if ($truthy(options === void 0)) {
            if ($truthy(o = $Opal["$coerce_to?"](count, $$$("Hash"), "to_hash"))) {
              options = o;
              count = nil;
            } else {
              options = nil;
              count = $coerce_to(count, $$$("Integer"), "to_int");
            }
          } else {
            count = $coerce_to(count, $$$("Integer"), "to_int");
            options = $coerce_to(options, $$$("Hash"), "to_hash");
          }
          ;
          if ($truthy(count) && $truthy(count < 0)) {
            $Kernel.$raise($$$("ArgumentError"), "count must be greater than 0");
          }
          ;
          if ($truthy(options)) {
            rng = options["$[]"]("random");
          }
          ;
          rng = $truthy(rng) && $truthy(rng["$respond_to?"]("rand")) ? $$("SampleRandom").$new(rng) : $Kernel;
          if (!$truthy(count)) {
            return self3[rng.$rand(self3.length)];
          }
          ;
          var abandon, spin, result, i, j, k, targetIndex, oldValue;
          if (count > self3.length) {
            count = self3.length;
          }
          switch (count) {
            case 0:
              return [];
              break;
            case 1:
              return [self3[rng.$rand(self3.length)]];
              break;
            case 2:
              i = rng.$rand(self3.length);
              j = rng.$rand(self3.length - 1);
              if (i <= j) {
                j++;
              }
              return [self3[i], self3[j]];
              break;
            default:
              if (self3.length / count > 3) {
                abandon = false;
                spin = 0;
                result = $$("Array").$new(count);
                i = 1;
                result[0] = rng.$rand(self3.length);
                while (i < count) {
                  k = rng.$rand(self3.length);
                  j = 0;
                  while (j < i) {
                    while (k === result[j]) {
                      spin++;
                      if (spin > 100) {
                        abandon = true;
                        break;
                      }
                      k = rng.$rand(self3.length);
                    }
                    if (abandon) {
                      break;
                    }
                    j++;
                  }
                  if (abandon) {
                    break;
                  }
                  result[i] = k;
                  i++;
                }
                if (!abandon) {
                  i = 0;
                  while (i < count) {
                    result[i] = self3[result[i]];
                    i++;
                  }
                  return result;
                }
              }
              result = self3.slice();
              for (var c = 0; c < count; c++) {
                targetIndex = rng.$rand(self3.length - c) + c;
                oldValue = result[c];
                result[c] = result[targetIndex];
                result[targetIndex] = oldValue;
              }
              return count === self3.length ? result : result["$[]"](0, count);
          }
          ;
        }, -1);
        $def(self2, "$select", function $$select() {
          var block = $$select.$$p || nil, self3 = this;
          $$select.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["select"], function $$42() {
              var self4 = $$42.$$s == null ? this : $$42.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result = [];
          for (var i = 0, length = self3.length, item, value; i < length; i++) {
            item = self3[i];
            value = $yield1(block, item);
            if ($truthy(value)) {
              result.push(item);
            }
          }
          return result;
          ;
        });
        $def(self2, "$select!", function $Array_select$excl$43() {
          var block = $Array_select$excl$43.$$p || nil, self3 = this;
          $Array_select$excl$43.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["select!"], function $$44() {
              var self4 = $$44.$$s == null ? this : $$44.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          var original = self3.length;
          $send(self3, "keep_if", [], block.$to_proc());
          return self3.length === original ? nil : self3;
          ;
        });
        $def(self2, "$shift", function $$shift(count) {
          var self3 = this;
          ;
          $deny_frozen_access(self3);
          if ($truthy(count === void 0)) {
            if ($truthy(self3.length === 0)) {
              return nil;
            }
            ;
            return shiftNoArg(self3);
          }
          ;
          count = $coerce_to(count, $$$("Integer"), "to_int");
          if ($truthy(count < 0)) {
            $Kernel.$raise($$$("ArgumentError"), "negative array size");
          }
          ;
          if ($truthy(self3.length === 0)) {
            return [];
          }
          ;
          return self3.splice(0, count);
          ;
        }, -1);
        $def(self2, "$shuffle", function $$shuffle(rng) {
          var self3 = this;
          ;
          return self3.$dup().$to_a()["$shuffle!"](rng);
        }, -1);
        $def(self2, "$shuffle!", function $Array_shuffle$excl$45(rng) {
          var self3 = this;
          ;
          $deny_frozen_access(self3);
          var randgen, i = self3.length, j, tmp;
          if (rng !== void 0) {
            rng = $Opal["$coerce_to?"](rng, $$$("Hash"), "to_hash");
            if (rng !== nil) {
              rng = rng["$[]"]("random");
              if (rng !== nil && rng["$respond_to?"]("rand")) {
                randgen = rng;
              }
            }
          }
          while (i) {
            if (randgen) {
              j = randgen.$rand(i).$to_int();
              if (j < 0) {
                $Kernel.$raise($$$("RangeError"), "random number too small " + j);
              }
              if (j >= i) {
                $Kernel.$raise($$$("RangeError"), "random number too big " + j);
              }
            } else {
              j = self3.$rand(i);
            }
            tmp = self3[--i];
            self3[i] = self3[j];
            self3[j] = tmp;
          }
          return self3;
          ;
        }, -1);
        $def(self2, "$slice!", function $Array_slice$excl$46(index, length) {
          var self3 = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;
          ;
          $deny_frozen_access(self3);
          result = nil;
          if ($truthy(length === void 0)) {
            if ($eqeqeq($$$("Range"), index)) {
              range = index;
              result = self3["$[]"](range);
              range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$("Integer"), "to_int");
              range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$("Integer"), "to_int");
              if (range_start < 0) {
                range_start += self3.length;
              }
              if (range_end < 0) {
                range_end += self3.length;
              } else if (range_end >= self3.length) {
                range_end = self3.length - 1;
                if (range.excl) {
                  range_end += 1;
                }
              }
              var range_length = range_end - range_start;
              if (range.excl && range.end !== nil) {
                range_end -= 1;
              } else {
                range_length += 1;
              }
              if (range_start < self3.length && range_start >= 0 && range_end < self3.length && range_end >= 0 && range_length > 0) {
                self3.splice(range_start, range_length);
              }
              ;
            } else {
              start = $coerce_to(index, $$$("Integer"), "to_int");
              if (start < 0) {
                start += self3.length;
              }
              if (start < 0 || start >= self3.length) {
                return nil;
              }
              result = self3[start];
              if (start === 0) {
                self3.shift();
              } else {
                self3.splice(start, 1);
              }
              ;
            }
          } else {
            start = $coerce_to(index, $$$("Integer"), "to_int");
            length = $coerce_to(length, $$$("Integer"), "to_int");
            if (length < 0) {
              return nil;
            }
            var end = start + length;
            result = self3["$[]"](start, length);
            if (start < 0) {
              start += self3.length;
            }
            if (start + length > self3.length) {
              length = self3.length - start;
            }
            if (start < self3.length && start >= 0) {
              self3.splice(start, length);
            }
            ;
          }
          ;
          return result;
        }, -2);
        $def(self2, "$sort", function $$sort() {
          var block = $$sort.$$p || nil, self3 = this;
          $$sort.$$p = null;
          ;
          if (!$truthy(self3.length > 1)) {
            return self3;
          }
          ;
          if (block === nil) {
            block = function(a, b) {
              return a["$<=>"](b);
            };
          }
          return self3.slice().sort(function(x, y) {
            var ret = block(x, y);
            if (ret === nil) {
              $Kernel.$raise($$$("ArgumentError"), "comparison of " + x.$inspect() + " with " + y.$inspect() + " failed");
            }
            return $rb_gt(ret, 0) ? 1 : $rb_lt(ret, 0) ? -1 : 0;
          });
          ;
        });
        $def(self2, "$sort!", function $Array_sort$excl$47() {
          var block = $Array_sort$excl$47.$$p || nil, self3 = this;
          $Array_sort$excl$47.$$p = null;
          ;
          $deny_frozen_access(self3);
          var result;
          if (block !== nil) {
            result = $send(self3.slice(), "sort", [], block.$to_proc());
          } else {
            result = self3.slice().$sort();
          }
          self3.length = 0;
          for (var i = 0, length = result.length; i < length; i++) {
            self3.push(result[i]);
          }
          return self3;
          ;
        });
        $def(self2, "$sort_by!", function $Array_sort_by$excl$48() {
          var block = $Array_sort_by$excl$48.$$p || nil, self3 = this;
          $Array_sort_by$excl$48.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["sort_by!"], function $$49() {
              var self4 = $$49.$$s == null ? this : $$49.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          return self3.$replace($send(self3, "sort_by", [], block.$to_proc()));
        });
        $def(self2, "$take", function $$take(count) {
          var self3 = this;
          if (count < 0) {
            $Kernel.$raise($$$("ArgumentError"));
          }
          return self3.slice(0, count);
        });
        $def(self2, "$take_while", function $$take_while() {
          var block = $$take_while.$$p || nil, self3 = this;
          $$take_while.$$p = null;
          ;
          var result = [];
          for (var i = 0, length = self3.length, item, value; i < length; i++) {
            item = self3[i];
            value = block(item);
            if (value === false || value === nil) {
              return result;
            }
            result.push(item);
          }
          return result;
          ;
        });
        $def(self2, "$to_a", function $$to_a() {
          var self3 = this;
          if (self3.$$class === Opal2.Array) {
            return self3;
          } else {
            return Opal2.Array.$new(self3);
          }
        });
        $def(self2, "$to_ary", $return_self);
        $def(self2, "$to_h", function $$to_h() {
          var block = $$to_h.$$p || nil, self3 = this, array = nil;
          $$to_h.$$p = null;
          ;
          array = self3;
          if (block !== nil) {
            array = $send(array, "map", [], block.$to_proc());
          }
          ;
          var i, len = array.length, ary, key, val, hash = $hash2([], {});
          for (i = 0; i < len; i++) {
            ary = $Opal["$coerce_to?"](array[i], $$$("Array"), "to_ary");
            if (!ary.$$is_array) {
              $Kernel.$raise($$$("TypeError"), "wrong element type " + ary.$class() + " at " + i + " (expected array)");
            }
            if (ary.length !== 2) {
              $Kernel.$raise($$$("ArgumentError"), "wrong array length at " + i + " (expected 2, was " + ary.$length() + ")");
            }
            key = ary[0];
            val = ary[1];
            $hash_put(hash, key, val);
          }
          return hash;
          ;
        });
        $def(self2, "$transpose", function $$transpose() {
          var self3 = this, result = nil, max = nil;
          if ($truthy(self3["$empty?"]())) {
            return [];
          }
          ;
          result = [];
          max = nil;
          $send(self3, "each", [], function $$50(row) {
            var $ret_or_1 = nil;
            if (row == null)
              row = nil;
            row = $eqeqeq($$$("Array"), row) ? row.$to_a() : $coerce_to(row, $$$("Array"), "to_ary").$to_a();
            max = $truthy($ret_or_1 = max) ? $ret_or_1 : row.length;
            if ($neqeq(row.length, max)) {
              $Kernel.$raise($$$("IndexError"), "element size differs (" + row.length + " should be " + max + ")");
            }
            ;
            return $send(row.length, "times", [], function $$51(i) {
              var $a, entry = nil;
              if (i == null)
                i = nil;
              entry = $truthy($ret_or_1 = result["$[]"](i)) ? $ret_or_1 : ($a = [i, []], $send(result, "[]=", $a), $a[$a.length - 1]);
              return entry["$<<"](row.$at(i));
            });
          });
          return result;
        });
        $def(self2, "$union", function $$union($a) {
          var $post_args, arrays, self3 = this;
          $post_args = $slice(arguments);
          arrays = $post_args;
          return $send(arrays, "reduce", [self3.$uniq()], function $$52(a, b) {
            if (a == null)
              a = nil;
            if (b == null)
              b = nil;
            return a["$|"](b);
          });
        }, -1);
        $def(self2, "$uniq", function $$uniq() {
          var block = $$uniq.$$p || nil, self3 = this;
          $$uniq.$$p = null;
          ;
          var hash = $hash2([], {}), i, length, item, key;
          if (block === nil) {
            for (i = 0, length = self3.length; i < length; i++) {
              item = self3[i];
              if ($hash_get(hash, item) === void 0) {
                $hash_put(hash, item, item);
              }
            }
          } else {
            for (i = 0, length = self3.length; i < length; i++) {
              item = self3[i];
              key = $yield1(block, item);
              if ($hash_get(hash, key) === void 0) {
                $hash_put(hash, key, item);
              }
            }
          }
          return hash.$values();
          ;
        });
        $def(self2, "$uniq!", function $Array_uniq$excl$53() {
          var block = $Array_uniq$excl$53.$$p || nil, self3 = this;
          $Array_uniq$excl$53.$$p = null;
          ;
          $deny_frozen_access(self3);
          var original_length = self3.length, hash = $hash2([], {}), i, length, item, key;
          for (i = 0, length = original_length; i < length; i++) {
            item = self3[i];
            key = block === nil ? item : $yield1(block, item);
            if ($hash_get(hash, key) === void 0) {
              $hash_put(hash, key, item);
              continue;
            }
            self3.splice(i, 1);
            length--;
            i--;
          }
          return self3.length === original_length ? nil : self3;
          ;
        });
        $def(self2, "$unshift", function $$unshift($a) {
          var $post_args, objects, self3 = this;
          $post_args = $slice(arguments);
          objects = $post_args;
          $deny_frozen_access(self3);
          var selfLength = self3.length;
          var objectsLength = objects.length;
          if (objectsLength == 0)
            return self3;
          var index = selfLength - objectsLength;
          for (var i = 0; i < objectsLength; i++) {
            self3.push(self3[index + i]);
          }
          var len = selfLength - 1;
          while (len - objectsLength >= 0) {
            self3[len] = self3[len - objectsLength];
            len--;
          }
          for (var j = 0; j < objectsLength; j++) {
            self3[j] = objects[j];
          }
          return self3;
          ;
        }, -1);
        $def(self2, "$values_at", function $$values_at($a) {
          var $post_args, args, self3 = this, out = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          out = [];
          $send(args, "each", [], function $$54(elem) {
            var self4 = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;
            if (elem == null)
              elem = nil;
            if ($truthy(elem["$is_a?"]($$$("Range")))) {
              finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$("Integer"), "to_int");
              start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$("Integer"), "to_int");
              if (start < 0) {
                start = start + self4.length;
                return nil;
              }
              ;
              if (finish < 0) {
                finish = finish + self4.length;
              }
              if (elem["$exclude_end?"]() && elem.$end() !== nil) {
                finish--;
              }
              if (finish < start) {
                return nil;
              }
              ;
              return $send(start, "upto", [finish], function $$55(i2) {
                var self5 = $$55.$$s == null ? this : $$55.$$s;
                if (i2 == null)
                  i2 = nil;
                return out["$<<"](self5.$at(i2));
              }, { $$s: self4 });
            } else {
              i = $coerce_to(elem, $$$("Integer"), "to_int");
              return out["$<<"](self4.$at(i));
            }
            ;
          }, { $$s: self3 });
          return out;
        }, -1);
        $def(self2, "$zip", function $$zip($a) {
          var block = $$zip.$$p || nil, $post_args, others, self3 = this, $ret_or_1 = nil;
          $$zip.$$p = null;
          ;
          $post_args = $slice(arguments);
          others = $post_args;
          var result = [], size = self3.length, part, o, i, j, jj;
          for (j = 0, jj = others.length; j < jj; j++) {
            o = others[j];
            if (o.$$is_array) {
              continue;
            }
            if (o.$$is_range || o.$$is_enumerator) {
              others[j] = o.$take(size);
              continue;
            }
            others[j] = ($truthy($ret_or_1 = $Opal["$coerce_to?"](o, $$$("Array"), "to_ary")) ? $ret_or_1 : $Opal["$coerce_to!"](o, $$$("Enumerator"), "to_enum", "each")).$to_a();
          }
          for (i = 0; i < size; i++) {
            part = [self3[i]];
            for (j = 0, jj = others.length; j < jj; j++) {
              o = others[j][i];
              if (o == null) {
                o = nil;
              }
              part[j + 1] = o;
            }
            result[i] = part;
          }
          if (block !== nil) {
            for (i = 0; i < size; i++) {
              Opal2.yield1(block, result[i]);
            }
            return nil;
          }
          return result;
          ;
        }, -1);
        $defs(self2, "$inherited", function $$inherited(klass) {
          klass.$$prototype.$to_a = function() {
            return this.slice(0, this.length);
          };
        });
        $def(self2, "$instance_variables", function $$instance_variables() {
          var $yield = $$instance_variables.$$p || nil, self3 = this;
          $$instance_variables.$$p = null;
          return $send($send2(self3, $find_super(self3, "instance_variables", $$instance_variables, false, true), "instance_variables", [], $yield), "reject", [], function $$56(ivar) {
            var $ret_or_1 = nil;
            if (ivar == null)
              ivar = nil;
            if ($truthy($ret_or_1 = /^@\d+$/.test(ivar))) {
              return $ret_or_1;
            } else {
              return ivar["$=="]("@length");
            }
            ;
          });
        });
        $def(self2, "$pack", function $$pack($a) {
          var $post_args, args;
          $post_args = $slice(arguments);
          args = $post_args;
          return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
        }, -1);
        $alias(self2, "append", "push");
        $alias(self2, "filter", "select");
        $alias(self2, "filter!", "select!");
        $alias(self2, "map", "collect");
        $alias(self2, "map!", "collect!");
        $alias(self2, "prepend", "unshift");
        $alias(self2, "size", "length");
        $alias(self2, "slice", "[]");
        $alias(self2, "to_s", "inspect");
        $Opal.$pristine(self2.$singleton_class(), "allocate");
        return $Opal.$pristine(self2, "copy_instance_variables", "initialize_dup");
      }("::", Array, $nesting);
    };
    Opal.modules["corelib/hash"] = function(Opal2) {
      var $yield1 = Opal2.yield1, $hash = Opal2.hash, $hash_init = Opal2.hash_init, $hash_get = Opal2.hash_get, $hash_put = Opal2.hash_put, $hash_delete = Opal2.hash_delete, $deny_frozen_access = Opal2.deny_frozen_access, $freeze = Opal2.freeze, $klass = Opal2.klass, $slice = Opal2.slice, $Opal = Opal2.Opal, $Kernel = Opal2.Kernel, $defs = Opal2.defs, $def = Opal2.def, $send = Opal2.send, $rb_ge = Opal2.rb_ge, $rb_gt = Opal2.rb_gt, $hash2 = Opal2.hash2, $truthy = Opal2.truthy, $to_a = Opal2.to_a, $return_self = Opal2.return_self, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,clone,select,select!,has_key?,indexes,index,length,[]=,has_value?");
      self.$require("corelib/enumerable");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Hash");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        self2.$include($$$("Enumerable"));
        self2.$$prototype.$$is_hash = true;
        $defs(self2, "$[]", function $Hash_$$$1($a) {
          var $post_args, argv, self3 = this;
          $post_args = $slice(arguments);
          argv = $post_args;
          var hash, argc = argv.length, i;
          if (argc === 1) {
            hash = $Opal["$coerce_to?"](argv["$[]"](0), $$$("Hash"), "to_hash");
            if (hash !== nil) {
              return self3.$allocate()["$merge!"](hash);
            }
            argv = $Opal["$coerce_to?"](argv["$[]"](0), $$$("Array"), "to_ary");
            if (argv === nil) {
              $Kernel.$raise($$$("ArgumentError"), "odd number of arguments for Hash");
            }
            argc = argv.length;
            hash = self3.$allocate();
            for (i = 0; i < argc; i++) {
              if (!argv[i].$$is_array)
                continue;
              switch (argv[i].length) {
                case 1:
                  hash.$store(argv[i][0], nil);
                  break;
                case 2:
                  hash.$store(argv[i][0], argv[i][1]);
                  break;
                default:
                  $Kernel.$raise($$$("ArgumentError"), "invalid number of elements (" + argv[i].length + " for 1..2)");
              }
            }
            return hash;
          }
          if (argc % 2 !== 0) {
            $Kernel.$raise($$$("ArgumentError"), "odd number of arguments for Hash");
          }
          hash = self3.$allocate();
          for (i = 0; i < argc; i += 2) {
            hash.$store(argv[i], argv[i + 1]);
          }
          return hash;
          ;
        }, -1);
        $defs(self2, "$allocate", function $$allocate() {
          var self3 = this;
          var hash = new self3.$$constructor();
          $hash_init(hash);
          hash.$$none = nil;
          hash.$$proc = nil;
          return hash;
        });
        $defs(self2, "$try_convert", function $$try_convert(obj) {
          return $Opal["$coerce_to?"](obj, $$$("Hash"), "to_hash");
        });
        $def(self2, "$initialize", function $$initialize(defaults) {
          var block = $$initialize.$$p || nil, self3 = this;
          $$initialize.$$p = null;
          ;
          ;
          $deny_frozen_access(self3);
          if (defaults !== void 0 && block !== nil) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (1 for 0)");
          }
          self3.$$none = defaults === void 0 ? nil : defaults;
          self3.$$proc = block;
          return self3;
          ;
        }, -1);
        $def(self2, "$==", function $Hash_$eq_eq$2(other) {
          var self3 = this;
          if (self3 === other) {
            return true;
          }
          if (!other.$$is_hash) {
            return false;
          }
          if (self3.$$keys.length !== other.$$keys.length) {
            return false;
          }
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
              other_value = other.$$smap[key];
            } else {
              value = key.value;
              other_value = $hash_get(other, key.key);
            }
            if (other_value === void 0 || !value["$eql?"](other_value)) {
              return false;
            }
          }
          return true;
        });
        $def(self2, "$>=", function $Hash_$gt_eq$3(other) {
          var self3 = this, result = nil;
          other = $Opal["$coerce_to!"](other, $$$("Hash"), "to_hash");
          if (self3.$$keys.length < other.$$keys.length) {
            return false;
          }
          ;
          result = true;
          $send(other, "each", [], function $$4(other_key, other_val) {
            var self4 = $$4.$$s == null ? this : $$4.$$s, val = nil;
            if (other_key == null)
              other_key = nil;
            if (other_val == null)
              other_val = nil;
            val = self4.$fetch(other_key, null);
            if (val == null || val !== other_val) {
              result = false;
              return;
            }
            ;
          }, { $$s: self3 });
          return result;
        });
        $def(self2, "$>", function $Hash_$gt$5(other) {
          var self3 = this;
          other = $Opal["$coerce_to!"](other, $$$("Hash"), "to_hash");
          if (self3.$$keys.length <= other.$$keys.length) {
            return false;
          }
          ;
          return $rb_ge(self3, other);
        });
        $def(self2, "$<", function $Hash_$lt$6(other) {
          var self3 = this;
          other = $Opal["$coerce_to!"](other, $$$("Hash"), "to_hash");
          return $rb_gt(other, self3);
        });
        $def(self2, "$<=", function $Hash_$lt_eq$7(other) {
          var self3 = this;
          other = $Opal["$coerce_to!"](other, $$$("Hash"), "to_hash");
          return $rb_ge(other, self3);
        });
        $def(self2, "$[]", function $Hash_$$$8(key) {
          var self3 = this;
          var value = $hash_get(self3, key);
          if (value !== void 0) {
            return value;
          }
          return self3.$default(key);
        });
        $def(self2, "$[]=", function $Hash_$$$eq$9(key, value) {
          var self3 = this;
          $deny_frozen_access(self3);
          $hash_put(self3, key, value);
          return value;
        });
        $def(self2, "$assoc", function $$assoc(object) {
          var self3 = this;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              if (key["$=="](object)) {
                return [key, self3.$$smap[key]];
              }
            } else {
              if (key.key["$=="](object)) {
                return [key.key, key.value];
              }
            }
          }
          return nil;
        });
        $def(self2, "$clear", function $$clear() {
          var self3 = this;
          $deny_frozen_access(self3);
          $hash_init(self3);
          return self3;
        });
        $def(self2, "$clone", function $$clone() {
          var self3 = this;
          var hash = new self3.$$class();
          $hash_init(hash);
          Opal2.hash_clone(self3, hash);
          return hash;
        });
        $def(self2, "$compact", function $$compact() {
          var self3 = this;
          var hash = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            if (value !== nil) {
              $hash_put(hash, key, value);
            }
          }
          return hash;
        });
        $def(self2, "$compact!", function $Hash_compact$excl$10() {
          var self3 = this;
          $deny_frozen_access(self3);
          var changes_were_made = false;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            if (value === nil) {
              if ($hash_delete(self3, key) !== void 0) {
                changes_were_made = true;
                length--;
                i--;
              }
            }
          }
          return changes_were_made ? self3 : nil;
        });
        $def(self2, "$compare_by_identity", function $$compare_by_identity() {
          var self3 = this;
          $deny_frozen_access(self3);
          var i, ii, key, keys = self3.$$keys, identity_hash;
          if (self3.$$by_identity)
            return self3;
          if (self3.$$keys.length === 0) {
            self3.$$by_identity = true;
            return self3;
          }
          identity_hash = $hash2([], {}).$compare_by_identity();
          for (i = 0, ii = keys.length; i < ii; i++) {
            key = keys[i];
            if (!key.$$is_string)
              key = key.key;
            $hash_put(identity_hash, key, $hash_get(self3, key));
          }
          self3.$$by_identity = true;
          self3.$$map = identity_hash.$$map;
          self3.$$smap = identity_hash.$$smap;
          return self3;
        });
        $def(self2, "$compare_by_identity?", function $Hash_compare_by_identity$ques$11() {
          var self3 = this;
          return self3.$$by_identity === true;
        });
        $def(self2, "$default", function $Hash_default$12(key) {
          var self3 = this;
          ;
          if (key !== void 0 && self3.$$proc !== nil && self3.$$proc !== void 0) {
            return self3.$$proc.$call(self3, key);
          }
          if (self3.$$none === void 0) {
            return nil;
          }
          return self3.$$none;
          ;
        }, -1);
        $def(self2, "$default=", function $Hash_default$eq$13(object) {
          var self3 = this;
          $deny_frozen_access(self3);
          self3.$$proc = nil;
          self3.$$none = object;
          return object;
        });
        $def(self2, "$default_proc", function $$default_proc() {
          var self3 = this;
          if (self3.$$proc !== void 0) {
            return self3.$$proc;
          }
          return nil;
        });
        $def(self2, "$default_proc=", function $Hash_default_proc$eq$14(default_proc) {
          var self3 = this;
          $deny_frozen_access(self3);
          var proc = default_proc;
          if (proc !== nil) {
            proc = $Opal["$coerce_to!"](proc, $$$("Proc"), "to_proc");
            if (proc["$lambda?"]() && proc.$arity().$abs() !== 2) {
              $Kernel.$raise($$$("TypeError"), "default_proc takes two arguments");
            }
          }
          self3.$$none = nil;
          self3.$$proc = proc;
          return default_proc;
        });
        $def(self2, "$delete", function $Hash_delete$15(key) {
          var block = $Hash_delete$15.$$p || nil, self3 = this;
          $Hash_delete$15.$$p = null;
          ;
          $deny_frozen_access(self3);
          var value = $hash_delete(self3, key);
          if (value !== void 0) {
            return value;
          }
          if (block !== nil) {
            return Opal2.yield1(block, key);
          }
          return nil;
          ;
        });
        $def(self2, "$delete_if", function $$delete_if() {
          var block = $$delete_if.$$p || nil, self3 = this;
          $$delete_if.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["delete_if"], function $$16() {
              var self4 = $$16.$$s == null ? this : $$16.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj !== false && obj !== nil) {
              if ($hash_delete(self3, key) !== void 0) {
                length--;
                i--;
              }
            }
          }
          return self3;
          ;
        });
        $def(self2, "$dig", function $$dig(key, $a) {
          var $post_args, keys, self3 = this, item = nil;
          $post_args = $slice(arguments, 1);
          keys = $post_args;
          item = self3["$[]"](key);
          if (item === nil || keys.length === 0) {
            return item;
          }
          ;
          if (!$truthy(item["$respond_to?"]("dig"))) {
            $Kernel.$raise($$$("TypeError"), "" + item.$class() + " does not have #dig method");
          }
          ;
          return $send(item, "dig", $to_a(keys));
        }, -2);
        $def(self2, "$each", function $$each() {
          var block = $$each.$$p || nil, self3 = this;
          $$each.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["each"], function $$17() {
              var self4 = $$17.$$s == null ? this : $$17.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          for (var i = 0, keys = self3.$$keys.slice(), length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            $yield1(block, [key, value]);
          }
          return self3;
          ;
        });
        $def(self2, "$each_key", function $$each_key() {
          var block = $$each_key.$$p || nil, self3 = this;
          $$each_key.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["each_key"], function $$18() {
              var self4 = $$18.$$s == null ? this : $$18.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          for (var i = 0, keys = self3.$$keys.slice(), length = keys.length, key; i < length; i++) {
            key = keys[i];
            block(key.$$is_string ? key : key.key);
          }
          return self3;
          ;
        });
        $def(self2, "$each_value", function $$each_value() {
          var block = $$each_value.$$p || nil, self3 = this;
          $$each_value.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["each_value"], function $$19() {
              var self4 = $$19.$$s == null ? this : $$19.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          for (var i = 0, keys = self3.$$keys.slice(), length = keys.length, key; i < length; i++) {
            key = keys[i];
            block(key.$$is_string ? self3.$$smap[key] : key.value);
          }
          return self3;
          ;
        });
        $def(self2, "$empty?", function $Hash_empty$ques$20() {
          var self3 = this;
          return self3.$$keys.length === 0;
        });
        $def(self2, "$except", function $$except($a) {
          var $post_args, keys, self3 = this;
          $post_args = $slice(arguments);
          keys = $post_args;
          return $send(self3.$dup(), "except!", $to_a(keys));
        }, -1);
        $def(self2, "$except!", function $Hash_except$excl$21($a) {
          var $post_args, keys, self3 = this;
          $post_args = $slice(arguments);
          keys = $post_args;
          $send(keys, "each", [], function $$22(key) {
            var self4 = $$22.$$s == null ? this : $$22.$$s;
            if (key == null)
              key = nil;
            return self4.$delete(key);
          }, { $$s: self3 });
          return self3;
        }, -1);
        $def(self2, "$fetch", function $$fetch(key, defaults) {
          var block = $$fetch.$$p || nil, self3 = this;
          $$fetch.$$p = null;
          ;
          ;
          var value = $hash_get(self3, key);
          if (value !== void 0) {
            return value;
          }
          if (block !== nil) {
            return block(key);
          }
          if (defaults !== void 0) {
            return defaults;
          }
          ;
          return $Kernel.$raise($$$("KeyError").$new("key not found: " + key.$inspect(), $hash2(["key", "receiver"], { "key": key, "receiver": self3 })));
        }, -2);
        $def(self2, "$fetch_values", function $$fetch_values($a) {
          var block = $$fetch_values.$$p || nil, $post_args, keys, self3 = this;
          $$fetch_values.$$p = null;
          ;
          $post_args = $slice(arguments);
          keys = $post_args;
          return $send(keys, "map", [], function $$23(key) {
            var self4 = $$23.$$s == null ? this : $$23.$$s;
            if (key == null)
              key = nil;
            return $send(self4, "fetch", [key], block.$to_proc());
          }, { $$s: self3 });
        }, -1);
        $def(self2, "$flatten", function $$flatten(level) {
          var self3 = this;
          if (level == null)
            level = 1;
          level = $Opal["$coerce_to!"](level, $$$("Integer"), "to_int");
          var result = [];
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            result.push(key);
            if (value.$$is_array) {
              if (level === 1) {
                result.push(value);
                continue;
              }
              result = result.concat(value.$flatten(level - 2));
              continue;
            }
            result.push(value);
          }
          return result;
          ;
        }, -1);
        $def(self2, "$freeze", function $$freeze() {
          var self3 = this;
          if ($truthy(self3["$frozen?"]())) {
            return self3;
          }
          ;
          return $freeze(self3);
          ;
        });
        $def(self2, "$has_key?", function $Hash_has_key$ques$24(key) {
          var self3 = this;
          return $hash_get(self3, key) !== void 0;
        });
        $def(self2, "$has_value?", function $Hash_has_value$ques$25(value) {
          var self3 = this;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key; i < length; i++) {
            key = keys[i];
            if ((key.$$is_string ? self3.$$smap[key] : key.value)["$=="](value)) {
              return true;
            }
          }
          return false;
        });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          var top = Opal2.hash_ids === void 0, hash_id = self3.$object_id(), result = ["Hash"], key, item;
          try {
            if (top) {
              Opal2.hash_ids = /* @__PURE__ */ Object.create(null);
            }
            if (Opal2[hash_id]) {
              return "self";
            }
            for (key in Opal2.hash_ids) {
              item = Opal2.hash_ids[key];
              if (self3["$eql?"](item)) {
                return "self";
              }
            }
            Opal2.hash_ids[hash_id] = self3;
            for (var i = 0, keys = self3.$$keys, length = keys.length; i < length; i++) {
              key = keys[i];
              if (key.$$is_string) {
                result.push([key, self3.$$smap[key].$hash()]);
              } else {
                result.push([key.key_hash, key.value.$hash()]);
              }
            }
            return result.sort().join();
          } finally {
            if (top) {
              Opal2.hash_ids = void 0;
            }
          }
        });
        $def(self2, "$index", function $$index(object) {
          var self3 = this;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            if (value["$=="](object)) {
              return key;
            }
          }
          return nil;
        });
        $def(self2, "$indexes", function $$indexes($a) {
          var $post_args, args, self3 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          var result = [];
          for (var i = 0, length = args.length, key, value; i < length; i++) {
            key = args[i];
            value = $hash_get(self3, key);
            if (value === void 0) {
              result.push(self3.$default());
              continue;
            }
            result.push(value);
          }
          return result;
          ;
        }, -1);
        var inspect_ids;
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          var top = inspect_ids === void 0, hash_id = self3.$object_id(), result = [];
          ;
          return function() {
            try {
              if (top) {
                inspect_ids = {};
              }
              if (inspect_ids.hasOwnProperty(hash_id)) {
                return "{...}";
              }
              inspect_ids[hash_id] = true;
              for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
                key = keys[i];
                if (key.$$is_string) {
                  value = self3.$$smap[key];
                } else {
                  value = key.value;
                  key = key.key;
                }
                key = $$("Opal").$inspect(key);
                value = $$("Opal").$inspect(value);
                result.push(key + "=>" + value);
              }
              return "{" + result.join(", ") + "}";
              ;
              return nil;
            } finally {
              if (top)
                inspect_ids = void 0;
            }
            ;
          }();
          ;
        });
        $def(self2, "$invert", function $$invert() {
          var self3 = this;
          var hash = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            $hash_put(hash, value, key);
          }
          return hash;
        });
        $def(self2, "$keep_if", function $$keep_if() {
          var block = $$keep_if.$$p || nil, self3 = this;
          $$keep_if.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["keep_if"], function $$26() {
              var self4 = $$26.$$s == null ? this : $$26.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj === false || obj === nil) {
              if ($hash_delete(self3, key) !== void 0) {
                length--;
                i--;
              }
            }
          }
          return self3;
          ;
        });
        $def(self2, "$keys", function $$keys() {
          var self3 = this;
          var result = [];
          for (var i = 0, keys = self3.$$keys, length = keys.length, key; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              result.push(key);
            } else {
              result.push(key.key);
            }
          }
          return result;
        });
        $def(self2, "$length", function $$length() {
          var self3 = this;
          return self3.$$keys.length;
        });
        $def(self2, "$merge", function $$merge($a) {
          var block = $$merge.$$p || nil, $post_args, others, self3 = this;
          $$merge.$$p = null;
          ;
          $post_args = $slice(arguments);
          others = $post_args;
          return $send(self3.$dup(), "merge!", $to_a(others), block.$to_proc());
        }, -1);
        $def(self2, "$merge!", function $Hash_merge$excl$27($a) {
          var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self3 = this;
          $Hash_merge$excl$27.$$p = null;
          ;
          $post_args = $slice(arguments);
          others = $post_args;
          $deny_frozen_access(self3);
          var i, j, other, other_keys, length, key, value, other_value;
          for (i = 0; i < others.length; ++i) {
            other = $Opal["$coerce_to!"](others[i], $$$("Hash"), "to_hash");
            other_keys = other.$$keys, length = other_keys.length;
            if (block === nil) {
              for (j = 0; j < length; j++) {
                key = other_keys[j];
                if (key.$$is_string) {
                  other_value = other.$$smap[key];
                } else {
                  other_value = key.value;
                  key = key.key;
                }
                $hash_put(self3, key, other_value);
              }
            } else {
              for (j = 0; j < length; j++) {
                key = other_keys[j];
                if (key.$$is_string) {
                  other_value = other.$$smap[key];
                } else {
                  other_value = key.value;
                  key = key.key;
                }
                value = $hash_get(self3, key);
                if (value === void 0) {
                  $hash_put(self3, key, other_value);
                  continue;
                }
                $hash_put(self3, key, block(key, value, other_value));
              }
            }
          }
          return self3;
          ;
        }, -1);
        $def(self2, "$rassoc", function $$rassoc(object) {
          var self3 = this;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            if (value["$=="](object)) {
              return [key, value];
            }
          }
          return nil;
        });
        $def(self2, "$rehash", function $$rehash() {
          var self3 = this;
          $deny_frozen_access(self3);
          Opal2.hash_rehash(self3);
          return self3;
        });
        $def(self2, "$reject", function $$reject() {
          var block = $$reject.$$p || nil, self3 = this;
          $$reject.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["reject"], function $$28() {
              var self4 = $$28.$$s == null ? this : $$28.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var hash = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj === false || obj === nil) {
              $hash_put(hash, key, value);
            }
          }
          return hash;
          ;
        });
        $def(self2, "$reject!", function $Hash_reject$excl$29() {
          var block = $Hash_reject$excl$29.$$p || nil, self3 = this;
          $Hash_reject$excl$29.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["reject!"], function $$30() {
              var self4 = $$30.$$s == null ? this : $$30.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          var changes_were_made = false;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj !== false && obj !== nil) {
              if ($hash_delete(self3, key) !== void 0) {
                changes_were_made = true;
                length--;
                i--;
              }
            }
          }
          return changes_were_made ? self3 : nil;
          ;
        });
        $def(self2, "$replace", function $$replace(other) {
          var self3 = this;
          $deny_frozen_access(self3);
          ;
          other = $Opal["$coerce_to!"](other, $$$("Hash"), "to_hash");
          $hash_init(self3);
          for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
            key = other_keys[i];
            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }
            $hash_put(self3, key, other_value);
          }
          ;
          if ($truthy(other.$default_proc())) {
            self3["$default_proc="](other.$default_proc());
          } else {
            self3["$default="](other.$default());
          }
          ;
          return self3;
        });
        $def(self2, "$select", function $$select() {
          var block = $$select.$$p || nil, self3 = this;
          $$select.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["select"], function $$31() {
              var self4 = $$31.$$s == null ? this : $$31.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var hash = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj !== false && obj !== nil) {
              $hash_put(hash, key, value);
            }
          }
          return hash;
          ;
        });
        $def(self2, "$select!", function $Hash_select$excl$32() {
          var block = $Hash_select$excl$32.$$p || nil, self3 = this;
          $Hash_select$excl$32.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["select!"], function $$33() {
              var self4 = $$33.$$s == null ? this : $$33.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          var result = nil;
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value, obj; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            obj = block(key, value);
            if (obj === false || obj === nil) {
              if ($hash_delete(self3, key) !== void 0) {
                length--;
                i--;
              }
              result = self3;
            }
          }
          return result;
          ;
        });
        $def(self2, "$shift", function $$shift() {
          var self3 = this;
          $deny_frozen_access(self3);
          var keys = self3.$$keys, key;
          if (keys.length > 0) {
            key = keys[0];
            key = key.$$is_string ? key : key.key;
            return [key, $hash_delete(self3, key)];
          }
          return nil;
        });
        $def(self2, "$slice", function $$slice($a) {
          var $post_args, keys, self3 = this;
          $post_args = $slice(arguments);
          keys = $post_args;
          var result = $hash();
          for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i], value = $hash_get(self3, key);
            if (value !== void 0) {
              $hash_put(result, key, value);
            }
          }
          return result;
          ;
        }, -1);
        $def(self2, "$to_a", function $$to_a() {
          var self3 = this;
          var result = [];
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            result.push([key, value]);
          }
          return result;
        });
        $def(self2, "$to_h", function $$to_h() {
          var block = $$to_h.$$p || nil, self3 = this;
          $$to_h.$$p = null;
          ;
          if (block !== nil) {
            return $send(self3, "map", [], block.$to_proc()).$to_h();
          }
          ;
          if (self3.$$class === Opal2.Hash) {
            return self3;
          }
          var hash = new Opal2.Hash();
          $hash_init(hash);
          Opal2.hash_clone(self3, hash);
          return hash;
          ;
        });
        $def(self2, "$to_hash", $return_self);
        $def(self2, "$to_proc", function $$to_proc() {
          var self3 = this;
          return $send(self3, "proc", [], function $$34(key) {
            var self4 = $$34.$$s == null ? this : $$34.$$s;
            ;
            if (key == null) {
              $Kernel.$raise($$$("ArgumentError"), "no key given");
            }
            ;
            return self4["$[]"](key);
          }, { $$arity: -1, $$s: self3 });
        });
        $def(self2, "$transform_keys", function $$transform_keys() {
          var block = $$transform_keys.$$p || nil, self3 = this;
          $$transform_keys.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["transform_keys"], function $$35() {
              var self4 = $$35.$$s == null ? this : $$35.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            key = $yield1(block, key);
            $hash_put(result, key, value);
          }
          return result;
          ;
        });
        $def(self2, "$transform_keys!", function $Hash_transform_keys$excl$36() {
          var block = $Hash_transform_keys$excl$36.$$p || nil, self3 = this;
          $Hash_transform_keys$excl$36.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["transform_keys!"], function $$37() {
              var self4 = $$37.$$s == null ? this : $$37.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          var keys = Opal2.slice(self3.$$keys), i, length = keys.length, key, value, new_key;
          for (i = 0; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            new_key = $yield1(block, key);
            $hash_delete(self3, key);
            $hash_put(self3, new_key, value);
          }
          return self3;
          ;
        });
        $def(self2, "$transform_values", function $$transform_values() {
          var block = $$transform_values.$$p || nil, self3 = this;
          $$transform_values.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["transform_values"], function $$38() {
              var self4 = $$38.$$s == null ? this : $$38.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var result = $hash();
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            value = $yield1(block, value);
            $hash_put(result, key, value);
          }
          return result;
          ;
        });
        $def(self2, "$transform_values!", function $Hash_transform_values$excl$39() {
          var block = $Hash_transform_values$excl$39.$$p || nil, self3 = this;
          $Hash_transform_values$excl$39.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["transform_values!"], function $$40() {
              var self4 = $$40.$$s == null ? this : $$40.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $deny_frozen_access(self3);
          for (var i = 0, keys = self3.$$keys, length = keys.length, key, value; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              value = self3.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }
            value = $yield1(block, value);
            $hash_put(self3, key, value);
          }
          return self3;
          ;
        });
        $def(self2, "$values", function $$values() {
          var self3 = this;
          var result = [];
          for (var i = 0, keys = self3.$$keys, length = keys.length, key; i < length; i++) {
            key = keys[i];
            if (key.$$is_string) {
              result.push(self3.$$smap[key]);
            } else {
              result.push(key.value);
            }
          }
          return result;
        });
        $alias(self2, "dup", "clone");
        $alias(self2, "each_pair", "each");
        $alias(self2, "eql?", "==");
        $alias(self2, "filter", "select");
        $alias(self2, "filter!", "select!");
        $alias(self2, "include?", "has_key?");
        $alias(self2, "indices", "indexes");
        $alias(self2, "key", "index");
        $alias(self2, "key?", "has_key?");
        $alias(self2, "member?", "has_key?");
        $alias(self2, "size", "length");
        $alias(self2, "store", "[]=");
        $alias(self2, "to_s", "inspect");
        $alias(self2, "update", "merge!");
        $alias(self2, "value?", "has_value?");
        return $alias(self2, "values_at", "indexes");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/number"] = function(Opal2) {
      var $klass = Opal2.klass, $Opal = Opal2.Opal, $Kernel = Opal2.Kernel, $def = Opal2.def, $eqeqeq = Opal2.eqeqeq, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $not = Opal2.not, $rb_lt = Opal2.rb_lt, $alias = Opal2.alias, $send2 = Opal2.send2, $find_super = Opal2.find_super, $send = Opal2.send, $rb_plus = Opal2.rb_plus, $rb_minus = Opal2.rb_minus, $eqeq = Opal2.eqeq, $return_self = Opal2.return_self, $rb_divide = Opal2.rb_divide, $to_ary = Opal2.to_ary, $rb_times = Opal2.rb_times, $rb_le = Opal2.rb_le, $rb_ge = Opal2.rb_ge, $return_val = Opal2.return_val, $const_set = Opal2.const_set, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,__id__,next,coerce_to?");
      self.$require("corelib/numeric");
      (function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Number");
        var $nesting2 = [self2].concat($parent_nesting);
        $Opal.$bridge(Number, self2);
        Opal2.prop(self2.$$prototype, "$$is_number", true);
        self2.$$is_number_class = true;
        (function(self3, $parent_nesting2) {
          $def(self3, "$allocate", function $$allocate() {
            var self4 = this;
            return $Kernel.$raise($$$("TypeError"), "allocator undefined for " + self4.$name());
          });
          Opal2.udef(self3, "$new");
          ;
          return nil;
          ;
        })(Opal2.get_singleton_class(self2), $nesting2);
        $def(self2, "$coerce", function $$coerce(other) {
          var self3 = this;
          if (other === nil) {
            $Kernel.$raise($$$("TypeError"), "can't convert " + other.$class() + " into Float");
          } else if (other.$$is_string) {
            return [$Kernel.$Float(other), self3];
          } else if (other["$respond_to?"]("to_f")) {
            return [$Opal["$coerce_to!"](other, $$$("Float"), "to_f"), self3];
          } else if (other.$$is_number) {
            return [other, self3];
          } else {
            $Kernel.$raise($$$("TypeError"), "can't convert " + other.$class() + " into Float");
          }
        });
        $def(self2, "$__id__", function $$__id__() {
          var self3 = this;
          return self3 * 2 + 1;
        });
        $def(self2, "$+", function $Number_$plus$1(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 + other;
          } else {
            return self3.$__coerced__("+", other);
          }
        });
        $def(self2, "$-", function $Number_$minus$2(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 - other;
          } else {
            return self3.$__coerced__("-", other);
          }
        });
        $def(self2, "$*", function $Number_$$3(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 * other;
          } else {
            return self3.$__coerced__("*", other);
          }
        });
        $def(self2, "$/", function $Number_$slash$4(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 / other;
          } else {
            return self3.$__coerced__("/", other);
          }
        });
        $def(self2, "$%", function $Number_$percent$5(other) {
          var self3 = this;
          if (other.$$is_number) {
            if (other == -Infinity) {
              return other;
            } else if (other == 0) {
              $Kernel.$raise($$$("ZeroDivisionError"), "divided by 0");
            } else if (other < 0 || self3 < 0) {
              return (self3 % other + other) % other;
            } else {
              return self3 % other;
            }
          } else {
            return self3.$__coerced__("%", other);
          }
        });
        $def(self2, "$&", function $Number_$$6(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 & other;
          } else {
            return self3.$__coerced__("&", other);
          }
        });
        $def(self2, "$|", function $Number_$$7(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 | other;
          } else {
            return self3.$__coerced__("|", other);
          }
        });
        $def(self2, "$^", function $Number_$$8(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 ^ other;
          } else {
            return self3.$__coerced__("^", other);
          }
        });
        $def(self2, "$<", function $Number_$lt$9(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 < other;
          } else {
            return self3.$__coerced__("<", other);
          }
        });
        $def(self2, "$<=", function $Number_$lt_eq$10(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 <= other;
          } else {
            return self3.$__coerced__("<=", other);
          }
        });
        $def(self2, "$>", function $Number_$gt$11(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 > other;
          } else {
            return self3.$__coerced__(">", other);
          }
        });
        $def(self2, "$>=", function $Number_$gt_eq$12(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3 >= other;
          } else {
            return self3.$__coerced__(">=", other);
          }
        });
        var spaceship_operator = function(self3, other) {
          if (other.$$is_number) {
            if (isNaN(self3) || isNaN(other)) {
              return nil;
            }
            if (self3 > other) {
              return 1;
            } else if (self3 < other) {
              return -1;
            } else {
              return 0;
            }
          } else {
            return self3.$__coerced__("<=>", other);
          }
        };
        $def(self2, "$<=>", function $Number_$lt_eq_gt$13(other) {
          var self3 = this;
          try {
            return spaceship_operator(self3, other);
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("ArgumentError")])) {
              try {
                return nil;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
        $def(self2, "$<<", function $Number_$lt$lt$14(count) {
          var self3 = this;
          count = $Opal["$coerce_to!"](count, $$$("Integer"), "to_int");
          return count > 0 ? self3 << count : self3 >> -count;
        });
        $def(self2, "$>>", function $Number_$gt$gt$15(count) {
          var self3 = this;
          count = $Opal["$coerce_to!"](count, $$$("Integer"), "to_int");
          return count > 0 ? self3 >> count : self3 << -count;
        });
        $def(self2, "$[]", function $Number_$$$16(bit) {
          var self3 = this;
          bit = $Opal["$coerce_to!"](bit, $$$("Integer"), "to_int");
          if (bit < 0) {
            return 0;
          }
          if (bit >= 32) {
            return self3 < 0 ? 1 : 0;
          }
          return self3 >> bit & 1;
          ;
        });
        $def(self2, "$+@", function $Number_$plus$$17() {
          var self3 = this;
          return +self3;
        });
        $def(self2, "$-@", function $Number_$minus$$18() {
          var self3 = this;
          return -self3;
        });
        $def(self2, "$~", function $Number_$$19() {
          var self3 = this;
          return ~self3;
        });
        $def(self2, "$**", function $Number_$$$20(other) {
          var self3 = this;
          if ($eqeqeq($$$("Integer"), other)) {
            if ($not($$$("Integer")["$==="](self3)) || $truthy($rb_gt(other, 0))) {
              return Math.pow(self3, other);
            } else {
              return $$$("Rational").$new(self3, 1)["$**"](other);
            }
          } else if ($rb_lt(self3, 0) && ($eqeqeq($$$("Float"), other) || $eqeqeq($$$("Rational"), other))) {
            return $$$("Complex").$new(self3, 0)["$**"](other.$to_f());
          } else if ($truthy(other.$$is_number != null)) {
            return Math.pow(self3, other);
          } else {
            return self3.$__coerced__("**", other);
          }
        });
        $def(self2, "$==", function $Number_$eq_eq$21(other) {
          var self3 = this;
          if (other.$$is_number) {
            return self3.valueOf() === other.valueOf();
          } else if (other["$respond_to?"]("==")) {
            return other["$=="](self3);
          } else {
            return false;
          }
        });
        $alias(self2, "===", "==");
        $def(self2, "$abs", function $$abs() {
          var self3 = this;
          return Math.abs(self3);
        });
        $def(self2, "$abs2", function $$abs2() {
          var self3 = this;
          return Math.abs(self3 * self3);
        });
        $def(self2, "$allbits?", function $Number_allbits$ques$22(mask) {
          var self3 = this;
          mask = $Opal["$coerce_to!"](mask, $$$("Integer"), "to_int");
          return (self3 & mask) == mask;
          ;
        });
        $def(self2, "$anybits?", function $Number_anybits$ques$23(mask) {
          var self3 = this;
          mask = $Opal["$coerce_to!"](mask, $$$("Integer"), "to_int");
          return (self3 & mask) !== 0;
          ;
        });
        $def(self2, "$angle", function $$angle() {
          var self3 = this;
          if ($truthy(self3["$nan?"]())) {
            return self3;
          }
          ;
          if (self3 == 0) {
            if (1 / self3 > 0) {
              return 0;
            } else {
              return Math.PI;
            }
          } else if (self3 < 0) {
            return Math.PI;
          } else {
            return 0;
          }
          ;
        });
        $def(self2, "$bit_length", function $$bit_length() {
          var self3 = this;
          if (!$eqeqeq($$$("Integer"), self3)) {
            $Kernel.$raise($$$("NoMethodError").$new("undefined method `bit_length` for " + self3 + ":Float", "bit_length"));
          }
          ;
          if (self3 === 0 || self3 === -1) {
            return 0;
          }
          var result = 0, value = self3 < 0 ? ~self3 : self3;
          while (value != 0) {
            result += 1;
            value >>>= 1;
          }
          return result;
          ;
        });
        $def(self2, "$ceil", function $$ceil(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          var f = self3.$to_f();
          if (f % 1 === 0 && ndigits >= 0) {
            return f;
          }
          var factor = Math.pow(10, ndigits), result = Math.ceil(f * factor) / factor;
          if (f % 1 === 0) {
            result = Math.round(result);
          }
          return result;
          ;
        }, -1);
        $def(self2, "$chr", function $$chr(encoding) {
          var self3 = this;
          ;
          return Opal2.enc(String.fromCharCode(self3), encoding || "BINARY");
          ;
        }, -1);
        $def(self2, "$denominator", function $$denominator() {
          var $yield = $$denominator.$$p || nil, self3 = this;
          $$denominator.$$p = null;
          if ($truthy(self3["$nan?"]()) || $truthy(self3["$infinite?"]())) {
            return 1;
          } else {
            return $send2(self3, $find_super(self3, "denominator", $$denominator, false, true), "denominator", [], $yield);
          }
        });
        $def(self2, "$downto", function $$downto(stop) {
          var block = $$downto.$$p || nil, self3 = this;
          $$downto.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["downto", stop], function $$24() {
              var self4 = $$24.$$s == null ? this : $$24.$$s;
              if (!$eqeqeq($$$("Numeric"), stop)) {
                $Kernel.$raise($$$("ArgumentError"), "comparison of " + self4.$class() + " with " + stop.$class() + " failed");
              }
              ;
              if ($truthy($rb_gt(stop, self4))) {
                return 0;
              } else {
                return $rb_plus($rb_minus(self4, stop), 1);
              }
              ;
            }, { $$s: self3 });
          }
          ;
          if (!stop.$$is_number) {
            $Kernel.$raise($$$("ArgumentError"), "comparison of " + self3.$class() + " with " + stop.$class() + " failed");
          }
          for (var i = self3; i >= stop; i--) {
            block(i);
          }
          ;
          return self3;
        });
        $def(self2, "$equal?", function $Number_equal$ques$25(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3["$=="](other))) {
            return $ret_or_1;
          } else {
            return isNaN(self3) && isNaN(other);
          }
        });
        $def(self2, "$even?", function $Number_even$ques$26() {
          var self3 = this;
          return self3 % 2 === 0;
        });
        $def(self2, "$floor", function $$floor(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          var f = self3.$to_f();
          if (f % 1 === 0 && ndigits >= 0) {
            return f;
          }
          var factor = Math.pow(10, ndigits), result = Math.floor(f * factor) / factor;
          if (f % 1 === 0) {
            result = Math.round(result);
          }
          return result;
          ;
        }, -1);
        $def(self2, "$gcd", function $$gcd(other) {
          var self3 = this;
          if (!$eqeqeq($$$("Integer"), other)) {
            $Kernel.$raise($$$("TypeError"), "not an integer");
          }
          ;
          var min = Math.abs(self3), max = Math.abs(other);
          while (min > 0) {
            var tmp = min;
            min = max % min;
            max = tmp;
          }
          return max;
          ;
        });
        $def(self2, "$gcdlcm", function $$gcdlcm(other) {
          var self3 = this;
          return [self3.$gcd(other), self3.$lcm(other)];
        });
        $def(self2, "$integer?", function $Number_integer$ques$27() {
          var self3 = this;
          return self3 % 1 === 0;
        });
        $def(self2, "$is_a?", function $Number_is_a$ques$28(klass) {
          var $yield = $Number_is_a$ques$28.$$p || nil, self3 = this;
          $Number_is_a$ques$28.$$p = null;
          if ($eqeq(klass, $$$("Integer")) && $eqeqeq($$$("Integer"), self3)) {
            return true;
          }
          ;
          if ($eqeq(klass, $$$("Integer")) && $eqeqeq($$$("Integer"), self3)) {
            return true;
          }
          ;
          if ($eqeq(klass, $$$("Float")) && $eqeqeq($$$("Float"), self3)) {
            return true;
          }
          ;
          return $send2(self3, $find_super(self3, "is_a?", $Number_is_a$ques$28, false, true), "is_a?", [klass], $yield);
        });
        $def(self2, "$instance_of?", function $Number_instance_of$ques$29(klass) {
          var $yield = $Number_instance_of$ques$29.$$p || nil, self3 = this;
          $Number_instance_of$ques$29.$$p = null;
          if ($eqeq(klass, $$$("Integer")) && $eqeqeq($$$("Integer"), self3)) {
            return true;
          }
          ;
          if ($eqeq(klass, $$$("Integer")) && $eqeqeq($$$("Integer"), self3)) {
            return true;
          }
          ;
          if ($eqeq(klass, $$$("Float")) && $eqeqeq($$$("Float"), self3)) {
            return true;
          }
          ;
          return $send2(self3, $find_super(self3, "instance_of?", $Number_instance_of$ques$29, false, true), "instance_of?", [klass], $yield);
        });
        $def(self2, "$lcm", function $$lcm(other) {
          var self3 = this;
          if (!$eqeqeq($$$("Integer"), other)) {
            $Kernel.$raise($$$("TypeError"), "not an integer");
          }
          ;
          if (self3 == 0 || other == 0) {
            return 0;
          } else {
            return Math.abs(self3 * other / self3.$gcd(other));
          }
          ;
        });
        $def(self2, "$next", function $$next() {
          var self3 = this;
          return self3 + 1;
        });
        $def(self2, "$nobits?", function $Number_nobits$ques$30(mask) {
          var self3 = this;
          mask = $Opal["$coerce_to!"](mask, $$$("Integer"), "to_int");
          return (self3 & mask) == 0;
          ;
        });
        $def(self2, "$nonzero?", function $Number_nonzero$ques$31() {
          var self3 = this;
          return self3 == 0 ? nil : self3;
        });
        $def(self2, "$numerator", function $$numerator() {
          var $yield = $$numerator.$$p || nil, self3 = this;
          $$numerator.$$p = null;
          if ($truthy(self3["$nan?"]()) || $truthy(self3["$infinite?"]())) {
            return self3;
          } else {
            return $send2(self3, $find_super(self3, "numerator", $$numerator, false, true), "numerator", [], $yield);
          }
        });
        $def(self2, "$odd?", function $Number_odd$ques$32() {
          var self3 = this;
          return self3 % 2 !== 0;
        });
        $def(self2, "$ord", $return_self);
        $def(self2, "$pow", function $$pow(b, m) {
          var self3 = this;
          ;
          if (self3 == 0) {
            $Kernel.$raise($$$("ZeroDivisionError"), "divided by 0");
          }
          if (m === void 0) {
            return self3["$**"](b);
          } else {
            if (!$$$("Integer")["$==="](b)) {
              $Kernel.$raise($$$("TypeError"), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer");
            }
            if (b < 0) {
              $Kernel.$raise($$$("TypeError"), "Integer#pow() 1st argument cannot be negative when 2nd argument specified");
            }
            if (!$$$("Integer")["$==="](m)) {
              $Kernel.$raise($$$("TypeError"), "Integer#pow() 2nd argument not allowed unless all arguments are integers");
            }
            if (m === 0) {
              $Kernel.$raise($$$("ZeroDivisionError"), "divided by 0");
            }
            return self3["$**"](b)["$%"](m);
          }
          ;
        }, -2);
        $def(self2, "$pred", function $$pred() {
          var self3 = this;
          return self3 - 1;
        });
        $def(self2, "$quo", function $$quo(other) {
          var $yield = $$quo.$$p || nil, self3 = this;
          $$quo.$$p = null;
          if ($eqeqeq($$$("Integer"), self3)) {
            return $send2(self3, $find_super(self3, "quo", $$quo, false, true), "quo", [other], $yield);
          } else {
            return $rb_divide(self3, other);
          }
        });
        $def(self2, "$rationalize", function $$rationalize(eps) {
          var $a, $b, self3 = this, f = nil, n = nil;
          ;
          if (arguments.length > 1) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " for 0..1)");
          }
          ;
          if ($eqeqeq($$$("Integer"), self3)) {
            return $$$("Rational").$new(self3, 1);
          } else if ($truthy(self3["$infinite?"]())) {
            return $Kernel.$raise($$$("FloatDomainError"), "Infinity");
          } else if ($truthy(self3["$nan?"]())) {
            return $Kernel.$raise($$$("FloatDomainError"), "NaN");
          } else if ($truthy(eps == null)) {
            $b = $$$("Math").$frexp(self3), $a = $to_ary($b), f = $a[0] == null ? nil : $a[0], n = $a[1] == null ? nil : $a[1], $b;
            f = $$$("Math").$ldexp(f, $$$($$$("Float"), "MANT_DIG")).$to_i();
            n = $rb_minus(n, $$$($$$("Float"), "MANT_DIG"));
            return $$$("Rational").$new($rb_times(2, f), 1["$<<"]($rb_minus(1, n))).$rationalize($$$("Rational").$new(1, 1["$<<"]($rb_minus(1, n))));
          } else {
            return self3.$to_r().$rationalize(eps);
          }
          ;
        }, -1);
        $def(self2, "$remainder", function $$remainder(y) {
          var self3 = this;
          return $rb_minus(self3, $rb_times(y, $rb_divide(self3, y).$truncate()));
        });
        $def(self2, "$round", function $$round(ndigits) {
          var $a, $b, self3 = this, _ = nil, exp = nil;
          ;
          if ($eqeqeq($$$("Integer"), self3)) {
            if ($truthy(ndigits == null)) {
              return self3;
            }
            ;
            if ($eqeqeq($$$("Float"), ndigits) && $truthy(ndigits["$infinite?"]())) {
              $Kernel.$raise($$$("RangeError"), "Infinity");
            }
            ;
            ndigits = $Opal["$coerce_to!"](ndigits, $$$("Integer"), "to_int");
            if ($truthy($rb_lt(ndigits, $$$($$$("Integer"), "MIN")))) {
              $Kernel.$raise($$$("RangeError"), "out of bounds");
            }
            ;
            if ($truthy(ndigits >= 0)) {
              return self3;
            }
            ;
            ndigits = ndigits["$-@"]();
            if (0.415241 * ndigits - 0.125 > self3.$size()) {
              return 0;
            }
            var f = Math.pow(10, ndigits), x = Math.floor((Math.abs(self3) + f / 2) / f) * f;
            return self3 < 0 ? -x : x;
            ;
          } else {
            if ($truthy(self3["$nan?"]()) && $truthy(ndigits == null)) {
              $Kernel.$raise($$$("FloatDomainError"), "NaN");
            }
            ;
            ndigits = $Opal["$coerce_to!"](ndigits || 0, $$$("Integer"), "to_int");
            if ($truthy($rb_le(ndigits, 0))) {
              if ($truthy(self3["$nan?"]())) {
                $Kernel.$raise($$$("RangeError"), "NaN");
              } else if ($truthy(self3["$infinite?"]())) {
                $Kernel.$raise($$$("FloatDomainError"), "Infinity");
              }
            } else if ($eqeq(ndigits, 0)) {
              return Math.round(self3);
            } else if ($truthy(self3["$nan?"]()) || $truthy(self3["$infinite?"]())) {
              return self3;
            }
            ;
            $b = $$$("Math").$frexp(self3), $a = $to_ary($b), _ = $a[0] == null ? nil : $a[0], exp = $a[1] == null ? nil : $a[1], $b;
            if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$("Float"), "DIG"), 2), $truthy($rb_gt(exp, 0)) ? $rb_divide(exp, 4) : $rb_minus($rb_divide(exp, 3), 1))))) {
              return self3;
            }
            ;
            if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? $rb_plus($rb_divide(exp, 3), 1) : $rb_divide(exp, 4))["$-@"]()))) {
              return 0;
            }
            ;
            return Math.round(self3 * Math.pow(10, ndigits)) / Math.pow(10, ndigits);
            ;
          }
          ;
        }, -1);
        $def(self2, "$times", function $$times() {
          var block = $$times.$$p || nil, self3 = this;
          $$times.$$p = null;
          ;
          if (!$truthy(block)) {
            return $send(self3, "enum_for", ["times"], function $$33() {
              var self4 = $$33.$$s == null ? this : $$33.$$s;
              return self4;
            }, { $$s: self3 });
          }
          ;
          for (var i = 0; i < self3; i++) {
            block(i);
          }
          ;
          return self3;
        });
        $def(self2, "$to_f", $return_self);
        $def(self2, "$to_i", function $$to_i() {
          var self3 = this;
          return self3 < 0 ? Math.ceil(self3) : Math.floor(self3);
        });
        $def(self2, "$to_r", function $$to_r() {
          var $a, $b, self3 = this, f = nil, e = nil;
          if ($eqeqeq($$$("Integer"), self3)) {
            return $$$("Rational").$new(self3, 1);
          } else {
            $b = $$$("Math").$frexp(self3), $a = $to_ary($b), f = $a[0] == null ? nil : $a[0], e = $a[1] == null ? nil : $a[1], $b;
            f = $$$("Math").$ldexp(f, $$$($$$("Float"), "MANT_DIG")).$to_i();
            e = $rb_minus(e, $$$($$$("Float"), "MANT_DIG"));
            return $rb_times(f, $$$($$$("Float"), "RADIX")["$**"](e)).$to_r();
          }
        });
        $def(self2, "$to_s", function $$to_s(base) {
          var self3 = this;
          if (base == null)
            base = 10;
          base = $Opal["$coerce_to!"](base, $$$("Integer"), "to_int");
          if ($truthy($rb_lt(base, 2)) || $truthy($rb_gt(base, 36))) {
            $Kernel.$raise($$$("ArgumentError"), "invalid radix " + base);
          }
          ;
          if ($eqeq(self3, 0) && $truthy(1 / self3 === -Infinity)) {
            return "-0.0";
          }
          ;
          return self3.toString(base);
          ;
        }, -1);
        $def(self2, "$truncate", function $$truncate(ndigits) {
          var self3 = this;
          if (ndigits == null)
            ndigits = 0;
          var f = self3.$to_f();
          if (f % 1 === 0 && ndigits >= 0) {
            return f;
          }
          var factor = Math.pow(10, ndigits), result = parseInt(f * factor, 10) / factor;
          if (f % 1 === 0) {
            result = Math.round(result);
          }
          return result;
          ;
        }, -1);
        $def(self2, "$digits", function $$digits(base) {
          var self3 = this;
          if (base == null)
            base = 10;
          if ($rb_lt(self3, 0)) {
            $Kernel.$raise($$$($$$("Math"), "DomainError"), "out of domain");
          }
          ;
          base = $Opal["$coerce_to!"](base, $$$("Integer"), "to_int");
          if ($truthy($rb_lt(base, 2))) {
            $Kernel.$raise($$$("ArgumentError"), "invalid radix " + base);
          }
          ;
          if (self3 != parseInt(self3))
            $Kernel.$raise($$$("NoMethodError"), "undefined method `digits' for " + self3.$inspect());
          var value = self3, result = [];
          if (self3 == 0) {
            return [0];
          }
          while (value != 0) {
            result.push(value % base);
            value = parseInt(value / base, 10);
          }
          return result;
          ;
        }, -1);
        $def(self2, "$divmod", function $$divmod(other) {
          var $yield = $$divmod.$$p || nil, self3 = this;
          $$divmod.$$p = null;
          if ($truthy(self3["$nan?"]()) || $truthy(other["$nan?"]())) {
            return $Kernel.$raise($$$("FloatDomainError"), "NaN");
          } else if ($truthy(self3["$infinite?"]())) {
            return $Kernel.$raise($$$("FloatDomainError"), "Infinity");
          } else {
            return $send2(self3, $find_super(self3, "divmod", $$divmod, false, true), "divmod", [other], $yield);
          }
        });
        $def(self2, "$upto", function $$upto(stop) {
          var block = $$upto.$$p || nil, self3 = this;
          $$upto.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["upto", stop], function $$34() {
              var self4 = $$34.$$s == null ? this : $$34.$$s;
              if (!$eqeqeq($$$("Numeric"), stop)) {
                $Kernel.$raise($$$("ArgumentError"), "comparison of " + self4.$class() + " with " + stop.$class() + " failed");
              }
              ;
              if ($truthy($rb_lt(stop, self4))) {
                return 0;
              } else {
                return $rb_plus($rb_minus(stop, self4), 1);
              }
              ;
            }, { $$s: self3 });
          }
          ;
          if (!stop.$$is_number) {
            $Kernel.$raise($$$("ArgumentError"), "comparison of " + self3.$class() + " with " + stop.$class() + " failed");
          }
          for (var i = self3; i <= stop; i++) {
            block(i);
          }
          ;
          return self3;
        });
        $def(self2, "$zero?", function $Number_zero$ques$35() {
          var self3 = this;
          return self3 == 0;
        });
        $def(self2, "$size", $return_val(4));
        $def(self2, "$nan?", function $Number_nan$ques$36() {
          var self3 = this;
          return isNaN(self3);
        });
        $def(self2, "$finite?", function $Number_finite$ques$37() {
          var self3 = this;
          return self3 != Infinity && self3 != -Infinity && !isNaN(self3);
        });
        $def(self2, "$infinite?", function $Number_infinite$ques$38() {
          var self3 = this;
          if (self3 == Infinity) {
            return 1;
          } else if (self3 == -Infinity) {
            return -1;
          } else {
            return nil;
          }
        });
        $def(self2, "$positive?", function $Number_positive$ques$39() {
          var self3 = this;
          return self3 != 0 && (self3 == Infinity || 1 / self3 > 0);
        });
        $def(self2, "$negative?", function $Number_negative$ques$40() {
          var self3 = this;
          return self3 == -Infinity || 1 / self3 < 0;
        });
        function numberToUint8Array(num) {
          var uint8array = new Uint8Array(8);
          new DataView(uint8array.buffer).setFloat64(0, num, true);
          return uint8array;
        }
        function uint8ArrayToNumber(arr) {
          return new DataView(arr.buffer).getFloat64(0, true);
        }
        function incrementNumberBit(num) {
          var arr = numberToUint8Array(num);
          for (var i = 0; i < arr.length; i++) {
            if (arr[i] === 255) {
              arr[i] = 0;
            } else {
              arr[i]++;
              break;
            }
          }
          return uint8ArrayToNumber(arr);
        }
        function decrementNumberBit(num) {
          var arr = numberToUint8Array(num);
          for (var i = 0; i < arr.length; i++) {
            if (arr[i] === 0) {
              arr[i] = 255;
            } else {
              arr[i]--;
              break;
            }
          }
          return uint8ArrayToNumber(arr);
        }
        ;
        $def(self2, "$next_float", function $$next_float() {
          var self3 = this;
          if ($eqeq(self3, $$$($$$("Float"), "INFINITY"))) {
            return $$$($$$("Float"), "INFINITY");
          }
          ;
          if ($truthy(self3["$nan?"]())) {
            return $$$($$$("Float"), "NAN");
          }
          ;
          if ($rb_ge(self3, 0)) {
            return incrementNumberBit(Math.abs(self3));
          } else {
            return decrementNumberBit(self3);
          }
          ;
        });
        $def(self2, "$prev_float", function $$prev_float() {
          var self3 = this;
          if ($eqeq(self3, $$$($$$("Float"), "INFINITY")["$-@"]())) {
            return $$$($$$("Float"), "INFINITY")["$-@"]();
          }
          ;
          if ($truthy(self3["$nan?"]())) {
            return $$$($$$("Float"), "NAN");
          }
          ;
          if ($rb_gt(self3, 0)) {
            return decrementNumberBit(self3);
          } else {
            return -incrementNumberBit(Math.abs(self3));
          }
          ;
        });
        $alias(self2, "arg", "angle");
        $alias(self2, "eql?", "==");
        $alias(self2, "fdiv", "/");
        $alias(self2, "inspect", "to_s");
        $alias(self2, "kind_of?", "is_a?");
        $alias(self2, "magnitude", "abs");
        $alias(self2, "modulo", "%");
        $alias(self2, "object_id", "__id__");
        $alias(self2, "phase", "angle");
        $alias(self2, "succ", "next");
        return $alias(self2, "to_int", "to_i");
      })("::", $$$("Numeric"), $nesting);
      $const_set("::", "Fixnum", $$$("Number"));
      (function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Integer");
        var $nesting2 = [self2].concat($parent_nesting);
        self2.$$is_number_class = true;
        self2.$$is_integer_class = true;
        (function(self3, $parent_nesting2) {
          var $nesting3 = [self3].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
          $def(self3, "$allocate", function $$allocate() {
            var self4 = this;
            return $Kernel.$raise($$$("TypeError"), "allocator undefined for " + self4.$name());
          });
          Opal2.udef(self3, "$new");
          ;
          $def(self3, "$sqrt", function $$sqrt(n) {
            n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
            if (n < 0) {
              $Kernel.$raise($$$($$$("Math"), "DomainError"), 'Numerical argument is out of domain - "isqrt"');
            }
            return parseInt(Math.sqrt(n), 10);
            ;
          });
          return $def(self3, "$try_convert", function $$try_convert(object) {
            var self4 = this;
            return $$("Opal")["$coerce_to?"](object, self4, "to_int");
          });
        })(Opal2.get_singleton_class(self2), $nesting2);
        $const_set(self2, "MAX", Math.pow(2, 30) - 1);
        return $const_set(self2, "MIN", -Math.pow(2, 30));
      })("::", $$$("Numeric"), $nesting);
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Float");
        var $nesting2 = [self2].concat($parent_nesting);
        self2.$$is_number_class = true;
        (function(self3, $parent_nesting2) {
          $def(self3, "$allocate", function $$allocate() {
            var self4 = this;
            return $Kernel.$raise($$$("TypeError"), "allocator undefined for " + self4.$name());
          });
          Opal2.udef(self3, "$new");
          ;
          return $def(self3, "$===", function $eq_eq_eq$41(other) {
            return !!other.$$is_number;
          });
        })(Opal2.get_singleton_class(self2), $nesting2);
        $const_set(self2, "INFINITY", Infinity);
        $const_set(self2, "MAX", Number.MAX_VALUE);
        $const_set(self2, "MIN", Number.MIN_VALUE);
        $const_set(self2, "NAN", NaN);
        $const_set(self2, "DIG", 15);
        $const_set(self2, "MANT_DIG", 53);
        $const_set(self2, "RADIX", 2);
        return $const_set(self2, "EPSILON", Number.EPSILON || 2220446049250313e-31);
      }("::", $$$("Numeric"), $nesting);
    };
    Opal.modules["corelib/range"] = function(Opal2) {
      var $klass = Opal2.klass, $truthy = Opal2.truthy, $Kernel = Opal2.Kernel, $def = Opal2.def, $not = Opal2.not, $send2 = Opal2.send2, $find_super = Opal2.find_super, $rb_lt = Opal2.rb_lt, $rb_le = Opal2.rb_le, $send = Opal2.send, $eqeq = Opal2.eqeq, $eqeqeq = Opal2.eqeqeq, $return_ivar = Opal2.return_ivar, $rb_gt = Opal2.rb_gt, $rb_minus = Opal2.rb_minus, $Opal = Opal2.Opal, $rb_divide = Opal2.rb_divide, $rb_plus = Opal2.rb_plus, $rb_times = Opal2.rb_times, $rb_ge = Opal2.rb_ge, $thrower = Opal2.thrower, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash,cover?");
      self.$require("corelib/enumerable");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Range");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self2.$$prototype;
        $proto.begin = $proto.end = $proto.excl = nil;
        self2.$include($$$("Enumerable"));
        self2.$$prototype.$$is_range = true;
        self2.$attr_reader("begin", "end");
        $def(self2, "$initialize", function $$initialize(first, last, exclude) {
          var self3 = this;
          if (exclude == null)
            exclude = false;
          if ($truthy(self3.begin)) {
            $Kernel.$raise($$$("NameError"), "'initialize' called twice");
          }
          ;
          if (!($truthy(first["$<=>"](last)) || $truthy(first["$nil?"]()) || $truthy(last["$nil?"]()))) {
            $Kernel.$raise($$$("ArgumentError"), "bad value for range");
          }
          ;
          self3.begin = first;
          self3.end = last;
          return self3.excl = exclude;
        }, -3);
        $def(self2, "$===", function $Range_$eq_eq_eq$1(value) {
          var self3 = this;
          return self3["$include?"](value);
        });
        function is_infinite(self3) {
          if (self3.begin === nil || self3.end === nil || self3.begin === -Infinity || self3.end === Infinity || self3.begin === Infinity || self3.end === -Infinity)
            return true;
          return false;
        }
        ;
        $def(self2, "$count", function $$count() {
          var block = $$count.$$p || nil, self3 = this;
          $$count.$$p = null;
          ;
          if ($not(block !== nil) && $truthy(is_infinite(self3))) {
            return $$$($$$("Float"), "INFINITY");
          }
          ;
          return $send2(self3, $find_super(self3, "count", $$count, false, true), "count", [], block);
        });
        $def(self2, "$to_a", function $$to_a() {
          var $yield = $$to_a.$$p || nil, self3 = this;
          $$to_a.$$p = null;
          if ($truthy(is_infinite(self3))) {
            $Kernel.$raise($$$("TypeError"), "cannot convert endless range to an array");
          }
          ;
          return $send2(self3, $find_super(self3, "to_a", $$to_a, false, true), "to_a", [], $yield);
        });
        $def(self2, "$cover?", function $Range_cover$ques$2(value) {
          var self3 = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;
          beg_cmp = $truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = self3.begin["$nil?"]()) ? -1 : $ret_or_3) ? $ret_or_2 : self3.begin["$<=>"](value)) && $ret_or_1;
          end_cmp = $truthy($ret_or_1 = $truthy($ret_or_2 = $truthy($ret_or_3 = self3.end["$nil?"]()) ? -1 : $ret_or_3) ? $ret_or_2 : value["$<=>"](self3.end)) && $ret_or_1;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = $truthy(self3.excl) ? $truthy($ret_or_3 = end_cmp) ? $rb_lt(end_cmp, 0) : $ret_or_3 : $truthy($ret_or_3 = end_cmp) ? $rb_le(end_cmp, 0) : $ret_or_3) ? beg_cmp : $ret_or_2)) {
            return $rb_le(beg_cmp, 0);
          } else {
            return $ret_or_1;
          }
          ;
        });
        $def(self2, "$each", function $$each() {
          var block = $$each.$$p || nil, self3 = this, current = nil, last = nil, $ret_or_1 = nil;
          $$each.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each"], function $$3() {
              var self4 = $$3.$$s == null ? this : $$3.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          var i, limit;
          if (self3.begin.$$is_number && self3.end.$$is_number) {
            if (self3.begin % 1 !== 0 || self3.end % 1 !== 0) {
              $Kernel.$raise($$$("TypeError"), "can't iterate from Float");
            }
            for (i = self3.begin, limit = self3.end + ($truthy(self3.excl) ? 0 : 1); i < limit; i++) {
              block(i);
            }
            return self3;
          }
          if (self3.begin.$$is_string && self3.end.$$is_string) {
            $send(self3.begin, "upto", [self3.end, self3.excl], block.$to_proc());
            return self3;
          }
          ;
          current = self3.begin;
          last = self3.end;
          if (!$truthy(current["$respond_to?"]("succ"))) {
            $Kernel.$raise($$$("TypeError"), "can't iterate from " + current.$class());
          }
          ;
          while ($truthy($truthy($ret_or_1 = self3.end["$nil?"]()) ? $ret_or_1 : $rb_lt(current["$<=>"](last), 0))) {
            Opal2.yield1(block, current);
            current = current.$succ();
          }
          ;
          if ($not(self3.excl) && $eqeq(current, last)) {
            Opal2.yield1(block, current);
          }
          ;
          return self3;
        });
        $def(self2, "$eql?", function $Range_eql$ques$4(other) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if (!$eqeqeq($$$("Range"), other)) {
            return false;
          }
          ;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = self3.excl["$==="](other["$exclude_end?"]())) ? self3.begin["$eql?"](other.$begin()) : $ret_or_2)) {
            return self3.end["$eql?"](other.$end());
          } else {
            return $ret_or_1;
          }
          ;
        });
        $def(self2, "$exclude_end?", $return_ivar("excl"));
        $def(self2, "$first", function $$first(n) {
          var $yield = $$first.$$p || nil, self3 = this;
          $$first.$$p = null;
          ;
          if ($truthy(self3.begin["$nil?"]())) {
            $Kernel.$raise($$$("RangeError"), "cannot get the minimum of beginless range");
          }
          ;
          if ($truthy(n == null)) {
            return self3.begin;
          }
          ;
          return $send2(self3, $find_super(self3, "first", $$first, false, true), "first", [n], $yield);
        }, -1);
        $def(self2, "$last", function $$last(n) {
          var self3 = this;
          ;
          if ($truthy(self3.end["$nil?"]())) {
            $Kernel.$raise($$$("RangeError"), "cannot get the maximum of endless range");
          }
          ;
          if ($truthy(n == null)) {
            return self3.end;
          }
          ;
          return self3.$to_a().$last(n);
        }, -1);
        $def(self2, "$max", function $$max() {
          var $yield = $$max.$$p || nil, self3 = this;
          $$max.$$p = null;
          if ($truthy(self3.end["$nil?"]())) {
            return $Kernel.$raise($$$("RangeError"), "cannot get the maximum of endless range");
          } else if ($yield !== nil) {
            return $send2(self3, $find_super(self3, "max", $$max, false, true), "max", [], $yield);
          } else if ($not(self3.begin["$nil?"]()) && ($truthy($rb_gt(self3.begin, self3.end)) || $truthy(self3.excl) && $eqeq(self3.begin, self3.end))) {
            return nil;
          } else {
            return self3.excl ? self3.end - 1 : self3.end;
          }
        });
        $def(self2, "$min", function $$min() {
          var $yield = $$min.$$p || nil, self3 = this;
          $$min.$$p = null;
          if ($truthy(self3.begin["$nil?"]())) {
            return $Kernel.$raise($$$("RangeError"), "cannot get the minimum of beginless range");
          } else if ($yield !== nil) {
            return $send2(self3, $find_super(self3, "min", $$min, false, true), "min", [], $yield);
          } else if ($not(self3.end["$nil?"]()) && ($truthy($rb_gt(self3.begin, self3.end)) || $truthy(self3.excl) && $eqeq(self3.begin, self3.end))) {
            return nil;
          } else {
            return self3.begin;
          }
        });
        $def(self2, "$size", function $$size() {
          var self3 = this, infinity = nil, range_begin = nil, range_end = nil;
          infinity = $$$($$$("Float"), "INFINITY");
          if ($eqeq(self3.begin, infinity) && $not(self3.end["$nil?"]()) || $eqeq(self3.end, infinity["$-@"]()) && $not(self3.begin["$nil?"]())) {
            return 0;
          }
          ;
          if ($truthy(is_infinite(self3))) {
            return infinity;
          }
          ;
          if (!($eqeqeq($$$("Numeric"), self3.begin) && $eqeqeq($$$("Numeric"), self3.end))) {
            return nil;
          }
          ;
          range_begin = self3.begin;
          range_end = self3.end;
          if ($truthy(self3.excl)) {
            range_end = $rb_minus(range_end, 1);
          }
          ;
          if ($truthy($rb_lt(range_end, range_begin))) {
            return 0;
          }
          ;
          return (Math.abs(range_end - range_begin) + 1).$to_i();
        });
        $def(self2, "$step", function $$step(n) {
          var $yield = $$step.$$p || nil, self3 = this, $ret_or_1 = nil, i = nil;
          $$step.$$p = null;
          ;
          function coerceStepSize() {
            if (n == null) {
              n = 1;
            } else if (!n.$$is_number) {
              n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
            }
            if (n < 0) {
              $Kernel.$raise($$$("ArgumentError"), "step can't be negative");
            } else if (n === 0) {
              $Kernel.$raise($$$("ArgumentError"), "step can't be 0");
            }
          }
          function enumeratorSize() {
            if (!self3.begin["$respond_to?"]("succ")) {
              return nil;
            }
            if (self3.begin.$$is_string && self3.end.$$is_string) {
              return nil;
            }
            if (n % 1 === 0) {
              return $rb_divide(self3.$size(), n).$ceil();
            } else {
              var begin = self3.begin, end = self3.end, abs = Math.abs, floor = Math.floor, err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$("Float"), "EPSILON"), size;
              if (err > 0.5) {
                err = 0.5;
              }
              if (self3.excl) {
                size = floor((end - begin) / n - err);
                if (size * n + begin < end) {
                  size++;
                }
              } else {
                size = floor((end - begin) / n + err) + 1;
              }
              return size;
            }
          }
          ;
          if (!($yield !== nil)) {
            if (($truthy(self3.begin["$is_a?"]($$("Numeric"))) || $truthy(self3.begin["$nil?"]())) && ($truthy(self3.end["$is_a?"]($$("Numeric"))) || $truthy(self3.end["$nil?"]())) && $not($truthy($ret_or_1 = self3.begin["$nil?"]()) ? self3.end["$nil?"]() : $ret_or_1)) {
              return $$$($$$("Enumerator"), "ArithmeticSequence").$new(self3, n, "step");
            } else {
              return $send(self3, "enum_for", ["step", n], function $$5() {
                coerceStepSize();
                return enumeratorSize();
              });
            }
          }
          ;
          coerceStepSize();
          if ($truthy(self3.begin.$$is_number && self3.end.$$is_number)) {
            i = 0;
            (function() {
              try {
                var $t_break = $thrower("break");
                return $send(self3, "loop", [], function $$6() {
                  var self4 = $$6.$$s == null ? this : $$6.$$s, current = nil;
                  if (self4.begin == null)
                    self4.begin = nil;
                  if (self4.excl == null)
                    self4.excl = nil;
                  if (self4.end == null)
                    self4.end = nil;
                  current = $rb_plus(self4.begin, $rb_times(i, n));
                  if ($truthy(self4.excl)) {
                    if ($truthy($rb_ge(current, self4.end))) {
                      $t_break.$throw();
                    }
                  } else if ($truthy($rb_gt(current, self4.end))) {
                    $t_break.$throw();
                  }
                  ;
                  Opal2.yield1($yield, current);
                  return i = $rb_plus(i, 1);
                }, { $$s: self3 });
              } catch ($e) {
                if ($e === $t_break)
                  return $e.$v;
                throw $e;
              }
            })();
          } else {
            if (self3.begin.$$is_string && self3.end.$$is_string && n % 1 !== 0) {
              $Kernel.$raise($$$("TypeError"), "no implicit conversion to float from string");
            }
            ;
            $send(self3, "each_with_index", [], function $$7(value, idx) {
              if (value == null)
                value = nil;
              if (idx == null)
                idx = nil;
              if ($eqeq(idx["$%"](n), 0)) {
                return Opal2.yield1($yield, value);
              } else {
                return nil;
              }
              ;
            });
          }
          ;
          return self3;
        }, -1);
        $def(self2, "$%", function $Range_$percent$8(n) {
          var self3 = this;
          if ($truthy(self3.begin["$is_a?"]($$("Numeric"))) && $truthy(self3.end["$is_a?"]($$("Numeric")))) {
            return $$$($$$("Enumerator"), "ArithmeticSequence").$new(self3, n, "%");
          } else {
            return self3.$step(n);
          }
        });
        $def(self2, "$bsearch", function $$bsearch() {
          var block = $$bsearch.$$p || nil, self3 = this;
          $$bsearch.$$p = null;
          ;
          if (!(block !== nil)) {
            return self3.$enum_for("bsearch");
          }
          ;
          if ($truthy(is_infinite(self3) && (self3.begin.$$is_number || self3.end.$$is_number))) {
            $Kernel.$raise($$$("NotImplementedError"), "Can't #bsearch an infinite range");
          }
          ;
          if (!$truthy(self3.begin.$$is_number && self3.end.$$is_number)) {
            $Kernel.$raise($$$("TypeError"), "can't do binary search for " + self3.begin.$class());
          }
          ;
          return $send(self3.$to_a(), "bsearch", [], block.$to_proc());
        });
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this, $ret_or_1 = nil;
          return "" + ($truthy($ret_or_1 = self3.begin) ? $ret_or_1 : "") + ($truthy(self3.excl) ? "..." : "..") + ($truthy($ret_or_1 = self3.end) ? $ret_or_1 : "");
        });
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this, $ret_or_1 = nil;
          return "" + ($truthy($ret_or_1 = self3.begin) ? self3.begin.$inspect() : $ret_or_1) + ($truthy(self3.excl) ? "..." : "..") + ($truthy($ret_or_1 = self3.end) ? self3.end.$inspect() : $ret_or_1);
        });
        $def(self2, "$marshal_load", function $$marshal_load(args) {
          var self3 = this;
          self3.begin = args["$[]"]("begin");
          self3.end = args["$[]"]("end");
          return self3.excl = args["$[]"]("excl");
        });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return [self3.begin, self3.end, self3.excl].$hash();
        });
        $alias(self2, "==", "eql?");
        $alias(self2, "include?", "cover?");
        return $alias(self2, "member?", "cover?");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/proc"] = function(Opal2) {
      var $slice = Opal2.slice, $klass = Opal2.klass, $truthy = Opal2.truthy, $Kernel = Opal2.Kernel, $defs = Opal2.defs, $def = Opal2.def, $send = Opal2.send, $to_a = Opal2.to_a, $return_self = Opal2.return_self, $ensure_kwargs = Opal2.ensure_kwargs, $Opal = Opal2.Opal, $alias = Opal2.alias, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("raise,proc,call,to_proc,new,source_location,coerce_to!,dup");
      return function($base, $super) {
        var self = $klass($base, $super, "Proc");
        Opal2.prop(self.$$prototype, "$$is_proc", true);
        Opal2.prop(self.$$prototype, "$$is_lambda", false);
        $defs(self, "$new", function $Proc_new$1() {
          var block = $Proc_new$1.$$p || nil;
          $Proc_new$1.$$p = null;
          ;
          if (!$truthy(block)) {
            $Kernel.$raise($$$("ArgumentError"), "tried to create a Proc object without a block");
          }
          ;
          return block;
        });
        $def(self, "$call", function $$call($a) {
          var block = $$call.$$p || nil, $post_args, args, self2 = this;
          $$call.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if (block !== nil) {
            self2.$$p = block;
          }
          var result, $brk = self2.$$brk, $ret = self2.$$ret;
          if ($brk || $ret && self2.$$is_lambda) {
            try {
              if (self2.$$is_lambda) {
                result = self2.apply(null, args);
              } else {
                result = Opal2.yieldX(self2, args);
              }
            } catch (err) {
              if (err === $brk) {
                return err.$v;
              } else if (self2.$$is_lambda && err === $ret) {
                return err.$v;
              } else {
                throw err;
              }
            }
          } else {
            if (self2.$$is_lambda) {
              result = self2.apply(null, args);
            } else {
              result = Opal2.yieldX(self2, args);
            }
          }
          return result;
          ;
        }, -1);
        $def(self, "$>>", function $Proc_$gt$gt$2(other) {
          var $yield = $Proc_$gt$gt$2.$$p || nil, self2 = this;
          $Proc_$gt$gt$2.$$p = null;
          return $send($Kernel, "proc", [], function $$3($a) {
            var block = $$3.$$p || nil, $post_args, args, self3 = $$3.$$s == null ? this : $$3.$$s, out = nil;
            $$3.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            out = $send(self3, "call", $to_a(args), block.$to_proc());
            return other.$call(out);
          }, { $$arity: -1, $$s: self2 });
        });
        $def(self, "$<<", function $Proc_$lt$lt$4(other) {
          var $yield = $Proc_$lt$lt$4.$$p || nil, self2 = this;
          $Proc_$lt$lt$4.$$p = null;
          return $send($Kernel, "proc", [], function $$5($a) {
            var block = $$5.$$p || nil, $post_args, args, self3 = $$5.$$s == null ? this : $$5.$$s, out = nil;
            $$5.$$p = null;
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            out = $send(other, "call", $to_a(args), block.$to_proc());
            return self3.$call(out);
          }, { $$arity: -1, $$s: self2 });
        });
        $def(self, "$to_proc", $return_self);
        $def(self, "$lambda?", function $Proc_lambda$ques$6() {
          var self2 = this;
          return !!self2.$$is_lambda;
        });
        $def(self, "$arity", function $$arity() {
          var self2 = this;
          if (self2.$$is_curried) {
            return -1;
          } else if (self2.$$arity != null) {
            return self2.$$arity;
          } else {
            return self2.length;
          }
        });
        $def(self, "$source_location", function $$source_location() {
          var self2 = this, $ret_or_1 = nil;
          if (self2.$$is_curried) {
            return nil;
          }
          ;
          if ($truthy($ret_or_1 = self2.$$source_location)) {
            return $ret_or_1;
          } else {
            return nil;
          }
          ;
        });
        $def(self, "$binding", function $$binding() {
          var $a, self2 = this;
          if (self2.$$is_curried) {
            $Kernel.$raise($$$("ArgumentError"), "Can't create Binding");
          }
          ;
          if ($truthy(($a = $$$("::", "Binding", "skip_raise")) ? "constant" : nil)) {
            return $$$("Binding").$new(nil, [], self2.$$s, self2.$source_location());
          } else {
            return nil;
          }
          ;
        });
        $def(self, "$parameters", function $$parameters($kwargs) {
          var lambda, self2 = this;
          $kwargs = $ensure_kwargs($kwargs);
          lambda = $kwargs.$$smap["lambda"];
          ;
          if (self2.$$is_curried) {
            return [["rest"]];
          } else if (self2.$$parameters) {
            if (lambda == null ? self2.$$is_lambda : lambda) {
              return self2.$$parameters;
            } else {
              var result = [], i, length;
              for (i = 0, length = self2.$$parameters.length; i < length; i++) {
                var parameter = self2.$$parameters[i];
                if (parameter[0] === "req") {
                  parameter = ["opt", parameter[1]];
                }
                result.push(parameter);
              }
              return result;
            }
          } else {
            return [];
          }
          ;
        }, -1);
        $def(self, "$curry", function $$curry(arity) {
          var self2 = this;
          ;
          if (arity === void 0) {
            arity = self2.length;
          } else {
            arity = $Opal["$coerce_to!"](arity, $$$("Integer"), "to_int");
            if (self2.$$is_lambda && arity !== self2.length) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arity + " for " + self2.length + ")");
            }
          }
          function curried() {
            var args = $slice(arguments), length = args.length, result;
            if (length > arity && self2.$$is_lambda && !self2.$$is_curried) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + length + " for " + arity + ")");
            }
            if (length >= arity) {
              return self2.$call.apply(self2, args);
            }
            result = function() {
              return curried.apply(
                null,
                args.concat($slice(arguments))
              );
            };
            result.$$is_lambda = self2.$$is_lambda;
            result.$$is_curried = true;
            return result;
          }
          ;
          curried.$$is_lambda = self2.$$is_lambda;
          curried.$$is_curried = true;
          return curried;
          ;
        }, -1);
        $def(self, "$dup", function $$dup() {
          var self2 = this;
          var original_proc = self2.$$original_proc || self2, proc = function() {
            return original_proc.apply(this, arguments);
          };
          for (var prop in self2) {
            if (self2.hasOwnProperty(prop)) {
              proc[prop] = self2[prop];
            }
          }
          return proc;
        });
        $alias(self, "===", "call");
        $alias(self, "clone", "dup");
        $alias(self, "yield", "call");
        return $alias(self, "[]", "call");
      }("::", Function);
    };
    Opal.modules["corelib/method"] = function(Opal2) {
      var $klass = Opal2.klass, $def = Opal2.def, $truthy = Opal2.truthy, $slice = Opal2.slice, $alias = Opal2.alias, $Kernel = Opal2.Kernel, $send = Opal2.send, $to_a = Opal2.to_a, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc");
      (function($base, $super) {
        var self = $klass($base, $super, "Method");
        var $proto = self.$$prototype;
        $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
        self.$attr_reader("owner", "receiver", "name");
        $def(self, "$initialize", function $$initialize(receiver, owner, method, name) {
          var self2 = this;
          self2.receiver = receiver;
          self2.owner = owner;
          self2.name = name;
          return self2.method = method;
        });
        $def(self, "$arity", function $$arity() {
          var self2 = this;
          return self2.method.$arity();
        });
        $def(self, "$parameters", function $$parameters() {
          var self2 = this;
          return self2.method.$$parameters;
        });
        $def(self, "$source_location", function $$source_location() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.method.$$source_location)) {
            return $ret_or_1;
          } else {
            return ["(eval)", 0];
          }
        });
        $def(self, "$comments", function $$comments() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.method.$$comments)) {
            return $ret_or_1;
          } else {
            return [];
          }
        });
        $def(self, "$call", function $$call($a) {
          var block = $$call.$$p || nil, $post_args, args, self2 = this;
          $$call.$$p = null;
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          self2.method.$$p = block;
          return self2.method.apply(self2.receiver, args);
          ;
        }, -1);
        $def(self, "$curry", function $$curry(arity) {
          var self2 = this;
          ;
          return self2.method.$curry(arity);
        }, -1);
        $def(self, "$>>", function $Method_$gt$gt$1(other) {
          var self2 = this;
          return self2.method["$>>"](other);
        });
        $def(self, "$<<", function $Method_$lt$lt$2(other) {
          var self2 = this;
          return self2.method["$<<"](other);
        });
        $def(self, "$unbind", function $$unbind() {
          var self2 = this;
          return $$$("UnboundMethod").$new(self2.receiver.$class(), self2.owner, self2.method, self2.name);
        });
        $def(self, "$to_proc", function $$to_proc() {
          var self2 = this;
          var proc = self2.$call.bind(self2);
          proc.$$unbound = self2.method;
          proc.$$is_lambda = true;
          proc.$$arity = self2.method.$$arity == null ? self2.method.length : self2.method.$$arity;
          proc.$$parameters = self2.method.$$parameters;
          return proc;
        });
        $def(self, "$inspect", function $$inspect() {
          var self2 = this;
          return "#<" + self2.$class() + ": " + self2.receiver.$class() + "#" + self2.name + " (defined in " + self2.owner + " in " + self2.$source_location().$join(":") + ")>";
        });
        $alias(self, "[]", "call");
        return $alias(self, "===", "call");
      })("::", null);
      return function($base, $super) {
        var self = $klass($base, $super, "UnboundMethod");
        var $proto = self.$$prototype;
        $proto.method = $proto.owner = $proto.name = $proto.source = nil;
        self.$attr_reader("source", "owner", "name");
        $def(self, "$initialize", function $$initialize(source, owner, method, name) {
          var self2 = this;
          self2.source = source;
          self2.owner = owner;
          self2.method = method;
          return self2.name = name;
        });
        $def(self, "$arity", function $$arity() {
          var self2 = this;
          return self2.method.$arity();
        });
        $def(self, "$parameters", function $$parameters() {
          var self2 = this;
          return self2.method.$$parameters;
        });
        $def(self, "$source_location", function $$source_location() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.method.$$source_location)) {
            return $ret_or_1;
          } else {
            return ["(eval)", 0];
          }
        });
        $def(self, "$comments", function $$comments() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.method.$$comments)) {
            return $ret_or_1;
          } else {
            return [];
          }
        });
        $def(self, "$bind", function $$bind(object) {
          var self2 = this;
          if (self2.owner.$$is_module || Opal2.is_a(object, self2.owner)) {
            return $$$("Method").$new(object, self2.owner, self2.method, self2.name);
          } else {
            $Kernel.$raise($$$("TypeError"), "can't bind singleton method to a different class (expected " + object + ".kind_of?(" + self2.owner + " to be true)");
          }
        });
        $def(self, "$bind_call", function $$bind_call(object, $a) {
          var block = $$bind_call.$$p || nil, $post_args, args, self2 = this;
          $$bind_call.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          return $send(self2.$bind(object), "call", $to_a(args), block.$to_proc());
        }, -2);
        return $def(self, "$inspect", function $$inspect() {
          var self2 = this;
          return "#<" + self2.$class() + ": " + self2.source + "#" + self2.name + " (defined in " + self2.owner + " in " + self2.$source_location().$join(":") + ")>";
        });
      }("::", null);
    };
    Opal.modules["corelib/variables"] = function(Opal2) {
      var $gvars = Opal2.gvars, $const_set = Opal2.const_set, $Object = Opal2.Object, $hash2 = Opal2.hash2, nil = Opal2.nil;
      Opal2.add_stubs("new");
      $gvars["&"] = $gvars["~"] = $gvars["`"] = $gvars["'"] = nil;
      $gvars.LOADED_FEATURES = $gvars['"'] = Opal2.loaded_features;
      $gvars.LOAD_PATH = $gvars[":"] = [];
      $gvars["/"] = "\n";
      $gvars[","] = nil;
      $const_set("::", "ARGV", []);
      $const_set("::", "ARGF", $Object.$new());
      $const_set("::", "ENV", $hash2([], {}));
      $gvars.VERBOSE = false;
      $gvars.DEBUG = false;
      return $gvars.SAFE = 0;
    };
    Opal.modules["corelib/io"] = function(Opal2) {
      var $klass = Opal2.klass, $const_set = Opal2.const_set, $not = Opal2.not, $truthy = Opal2.truthy, $def = Opal2.def, $return_ivar = Opal2.return_ivar, $return_val = Opal2.return_val, $slice = Opal2.slice, $Kernel = Opal2.Kernel, $gvars = Opal2.gvars, $send = Opal2.send, $to_a = Opal2.to_a, $rb_plus = Opal2.rb_plus, $neqeq = Opal2.neqeq, $range = Opal2.range, $hash2 = Opal2.hash2, $eqeq = Opal2.eqeq, $to_ary = Opal2.to_ary, $rb_gt = Opal2.rb_gt, $assign_ivar_val = Opal2.assign_ivar_val, $alias = Opal2.alias, $a, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=");
      (function($base, $super) {
        var self = $klass($base, $super, "IO");
        var $proto = self.$$prototype;
        $proto.read_buffer = $proto.closed = nil;
        $const_set(self, "SEEK_SET", 0);
        $const_set(self, "SEEK_CUR", 1);
        $const_set(self, "SEEK_END", 2);
        $const_set(self, "SEEK_DATA", 3);
        $const_set(self, "SEEK_HOLE", 4);
        $const_set(self, "READABLE", 1);
        $const_set(self, "WRITABLE", 4);
        self.$attr_reader("eof");
        self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
        $def(self, "$initialize", function $$initialize(fd, flags) {
          var self2 = this;
          if (flags == null)
            flags = "r";
          self2.fd = fd;
          self2.flags = flags;
          self2.eof = false;
          if ($truthy(flags["$include?"]("r")) && $not(flags["$match?"](/[wa+]/))) {
            return self2.closed = "write";
          } else if ($truthy(flags["$match?"](/[wa]/)) && $not(flags["$match?"](/[r+]/))) {
            return self2.closed = "read";
          } else {
            return nil;
          }
          ;
        }, -2);
        $def(self, "$fileno", $return_ivar("fd"));
        $def(self, "$tty?", function $IO_tty$ques$1() {
          var self2 = this;
          return self2.tty == true;
        });
        $def(self, "$write", function $$write(string) {
          var self2 = this;
          self2.write_proc(string);
          return string.$size();
        });
        $def(self, "$flush", $return_val(nil));
        $def(self, "$<<", function $IO_$lt$lt$2(string) {
          var self2 = this;
          self2.$write(string);
          return self2;
        });
        $def(self, "$print", function $$print($a2) {
          var $post_args, args, self2 = this;
          if ($gvars[","] == null)
            $gvars[","] = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          for (var i = 0, ii = args.length; i < ii; i++) {
            args[i] = $Kernel.$String(args[i]);
          }
          self2.$write(args.join($gvars[","]));
          ;
          return nil;
        }, -1);
        $def(self, "$puts", function $$puts($a2) {
          var $post_args, args, self2 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          var line;
          if (args.length === 0) {
            self2.$write("\n");
            return nil;
          } else {
            for (var i = 0, ii = args.length; i < ii; i++) {
              if (args[i].$$is_array) {
                var ary = args[i].$flatten();
                if (ary.length > 0)
                  $send(self2, "puts", $to_a(ary));
              } else {
                if (args[i].$$is_string) {
                  line = args[i].valueOf();
                } else {
                  line = $Kernel.$String(args[i]);
                }
                if (!line.endsWith("\n"))
                  line += "\n";
                self2.$write(line);
              }
            }
          }
          ;
          return nil;
        }, -1);
        $def(self, "$getc", function $$getc() {
          var self2 = this, $ret_or_1 = nil, parts = nil, ret = nil;
          self2.read_buffer = $truthy($ret_or_1 = self2.read_buffer) ? $ret_or_1 : "";
          parts = "";
          do {
            self2.read_buffer = $rb_plus(self2.read_buffer, parts);
            if ($neqeq(self2.read_buffer, "")) {
              ret = self2.read_buffer["$[]"](0);
              self2.read_buffer = self2.read_buffer["$[]"]($range(1, -1, false));
              return ret;
            }
            ;
          } while ($truthy(parts = self2.$sysread_noraise(1)));
          ;
          return nil;
        });
        $def(self, "$getbyte", function $$getbyte() {
          var $a2, self2 = this;
          return $a2 = self2.$getc(), $a2 === nil || $a2 == null ? nil : $a2.$ord();
        });
        $def(self, "$readbyte", function $$readbyte() {
          var self2 = this;
          return self2.$readchar().$ord();
        });
        $def(self, "$readchar", function $$readchar() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.$getc())) {
            return $ret_or_1;
          } else {
            return $Kernel.$raise($$$("EOFError"), "end of file reached");
          }
        });
        $def(self, "$readline", function $$readline($a2) {
          var $post_args, args, self2 = this, $ret_or_1 = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy($ret_or_1 = $send(self2, "gets", $to_a(args)))) {
            return $ret_or_1;
          } else {
            return $Kernel.$raise($$$("EOFError"), "end of file reached");
          }
          ;
        }, -1);
        $def(self, "$gets", function $$gets(sep, limit, opts) {
          var $a2, $b, self2 = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          if (sep == null)
            sep = false;
          if (limit == null)
            limit = nil;
          if (opts == null)
            opts = $hash2([], {});
          if ($truthy(sep.$$is_number) && $not(limit)) {
            $a2 = [false, sep, limit], sep = $a2[0], limit = $a2[1], opts = $a2[2], $a2;
          }
          ;
          if ($truthy(sep.$$is_hash) && $not(limit) && $eqeq(opts, $hash2([], {}))) {
            $a2 = [false, nil, sep], sep = $a2[0], limit = $a2[1], opts = $a2[2], $a2;
          } else if ($truthy(limit.$$is_hash) && $eqeq(opts, $hash2([], {}))) {
            $a2 = [sep, nil, limit], sep = $a2[0], limit = $a2[1], opts = $a2[2], $a2;
          }
          ;
          orig_sep = sep;
          if ($eqeq(sep, false)) {
            sep = $gvars["/"];
          }
          ;
          if ($eqeq(sep, "")) {
            sep = /\r?\n\r?\n/;
          }
          ;
          sep = $truthy($ret_or_1 = sep) ? $ret_or_1 : "";
          if (!$eqeq(orig_sep, "")) {
            sep = sep.$to_str();
          }
          ;
          seplen = $eqeq(orig_sep, "") ? 2 : sep.$length();
          if ($eqeq(sep, " ")) {
            sep = / /;
          }
          ;
          self2.read_buffer = $truthy($ret_or_1 = self2.read_buffer) ? $ret_or_1 : "";
          data = "";
          ret = nil;
          do {
            self2.read_buffer = $rb_plus(self2.read_buffer, data);
            if ($neqeq(sep, "") && $truthy($truthy(sep.$$is_regexp) ? self2.read_buffer["$match?"](sep) : self2.read_buffer["$include?"](sep))) {
              orig_buffer = self2.read_buffer;
              $b = self2.read_buffer.$split(sep, 2), $a2 = $to_ary($b), ret = $a2[0] == null ? nil : $a2[0], self2.read_buffer = $a2[1] == null ? nil : $a2[1], $b;
              if ($neqeq(ret, orig_buffer)) {
                ret = $rb_plus(ret, orig_buffer["$[]"](ret.$length(), seplen));
              }
              ;
              break;
            }
            ;
          } while ($truthy(data = self2.$sysread_noraise($eqeq(sep, "") ? 65536 : 1)));
          ;
          if (!$truthy(ret)) {
            $a2 = [$truthy($ret_or_1 = self2.read_buffer) ? $ret_or_1 : "", ""], ret = $a2[0], self2.read_buffer = $a2[1], $a2;
            if ($eqeq(ret, "")) {
              ret = nil;
            }
            ;
          }
          ;
          if ($truthy(ret)) {
            if ($truthy(limit)) {
              ret = ret["$[]"](Opal2.Range.$new(0, limit, true));
              self2.read_buffer = $rb_plus(ret["$[]"](Opal2.Range.$new(limit, -1, false)), self2.read_buffer);
            }
            ;
            if ($truthy(opts["$[]"]("chomp"))) {
              ret = ret.$sub(/\r?\n$/, "");
            }
            ;
            if ($eqeq(orig_sep, "")) {
              ret = ret.$sub(/^[\r\n]+/, "");
            }
            ;
          }
          ;
          if ($eqeq(orig_sep, false)) {
            $gvars._ = ret;
          }
          ;
          return ret;
        }, -1);
        $def(self, "$sysread", function $$sysread(integer) {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.read_proc(integer))) {
            return $ret_or_1;
          } else {
            self2.eof = true;
            return $Kernel.$raise($$$("EOFError"), "end of file reached");
          }
        });
        $def(self, "$sysread_noraise", function $$sysread_noraise(integer) {
          var self2 = this;
          try {
            return self2.$sysread(integer);
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("EOFError")])) {
              try {
                return nil;
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
        $def(self, "$readpartial", function $$readpartial(integer) {
          var $a2, self2 = this, $ret_or_1 = nil, part = nil, ret = nil;
          self2.read_buffer = $truthy($ret_or_1 = self2.read_buffer) ? $ret_or_1 : "";
          part = self2.$sysread(integer);
          $a2 = [$rb_plus(self2.read_buffer, $truthy($ret_or_1 = part) ? $ret_or_1 : ""), ""], ret = $a2[0], self2.read_buffer = $a2[1], $a2;
          if ($eqeq(ret, "")) {
            ret = nil;
          }
          ;
          return ret;
        });
        $def(self, "$read", function $$read(integer) {
          var $a2, self2 = this, $ret_or_1 = nil, parts = nil, ret = nil;
          if (integer == null)
            integer = nil;
          self2.read_buffer = $truthy($ret_or_1 = self2.read_buffer) ? $ret_or_1 : "";
          parts = "";
          ret = nil;
          do {
            self2.read_buffer = $rb_plus(self2.read_buffer, parts);
            if ($truthy(integer) && $truthy($rb_gt(self2.read_buffer.$length(), integer))) {
              $a2 = [self2.read_buffer["$[]"](Opal2.Range.$new(0, integer, true)), self2.read_buffer["$[]"](Opal2.Range.$new(integer, -1, false))], ret = $a2[0], self2.read_buffer = $a2[1], $a2;
              return ret;
            }
            ;
          } while ($truthy(parts = self2.$sysread_noraise($truthy($ret_or_1 = integer) ? $ret_or_1 : 65536)));
          ;
          $a2 = [self2.read_buffer, ""], ret = $a2[0], self2.read_buffer = $a2[1], $a2;
          return ret;
        }, -1);
        $def(self, "$readlines", function $$readlines(separator) {
          var self2 = this;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          if (separator == null)
            separator = $gvars["/"];
          return self2.$each_line(separator).$to_a();
        }, -1);
        $def(self, "$each", function $$each($a2, $b) {
          var block = $$each.$$p || nil, $post_args, sep, args, self2 = this, s = nil;
          if ($gvars["/"] == null)
            $gvars["/"] = nil;
          $$each.$$p = null;
          ;
          $post_args = $slice(arguments);
          if ($post_args.length > 0)
            sep = $post_args.shift();
          if (sep == null)
            sep = $gvars["/"];
          args = $post_args;
          if (!(block !== nil)) {
            return $send(self2, "enum_for", ["each", sep].concat($to_a(args)));
          }
          ;
          while ($truthy(s = $send(self2, "gets", [sep].concat($to_a(args))))) {
            Opal2.yield1(block, s);
          }
          ;
          return self2;
        }, -1);
        $def(self, "$each_byte", function $$each_byte() {
          var block = $$each_byte.$$p || nil, self2 = this, s = nil;
          $$each_byte.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("each_byte");
          }
          ;
          while ($truthy(s = self2.$getbyte())) {
            Opal2.yield1(block, s);
          }
          ;
          return self2;
        });
        $def(self, "$each_char", function $$each_char() {
          var block = $$each_char.$$p || nil, self2 = this, s = nil;
          $$each_char.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("each_char");
          }
          ;
          while ($truthy(s = self2.$getc())) {
            Opal2.yield1(block, s);
          }
          ;
          return self2;
        });
        $def(self, "$close", $assign_ivar_val("closed", "both"));
        $def(self, "$close_read", function $$close_read() {
          var self2 = this;
          if ($eqeq(self2.closed, "write")) {
            return self2.closed = "both";
          } else {
            return self2.closed = "read";
          }
        });
        $def(self, "$close_write", function $$close_write() {
          var self2 = this;
          if ($eqeq(self2.closed, "read")) {
            return self2.closed = "both";
          } else {
            return self2.closed = "write";
          }
        });
        $def(self, "$closed?", function $IO_closed$ques$3() {
          var self2 = this;
          return self2.closed["$=="]("both");
        });
        $def(self, "$closed_read?", function $IO_closed_read$ques$4() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.closed["$=="]("read"))) {
            return $ret_or_1;
          } else {
            return self2.closed["$=="]("both");
          }
        });
        $def(self, "$closed_write?", function $IO_closed_write$ques$5() {
          var self2 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self2.closed["$=="]("write"))) {
            return $ret_or_1;
          } else {
            return self2.closed["$=="]("both");
          }
        });
        $def(self, "$check_writable", function $$check_writable() {
          var self2 = this;
          if ($truthy(self2["$closed_write?"]())) {
            return $Kernel.$raise($$$("IOError"), "not opened for writing");
          } else {
            return nil;
          }
        });
        $def(self, "$check_readable", function $$check_readable() {
          var self2 = this;
          if ($truthy(self2["$closed_read?"]())) {
            return $Kernel.$raise($$$("IOError"), "not opened for reading");
          } else {
            return nil;
          }
        });
        $alias(self, "each_line", "each");
        return $alias(self, "eof?", "eof");
      })("::", null);
      $const_set("::", "STDIN", $gvars.stdin = $$$("IO").$new(0, "r"));
      $const_set("::", "STDOUT", $gvars.stdout = $$$("IO").$new(1, "w"));
      $const_set("::", "STDERR", $gvars.stderr = $$$("IO").$new(2, "w"));
      var console2 = Opal2.global.console;
      $$$("STDOUT")["$write_proc="](typeof process === "object" && typeof process.stdout === "object" ? function(s) {
        process.stdout.write(s);
      } : function(s) {
        console2.log(s);
      });
      $$$("STDERR")["$write_proc="](typeof process === "object" && typeof process.stderr === "object" ? function(s) {
        process.stderr.write(s);
      } : function(s) {
        console2.warn(s);
      });
      return $a = [function(s) {
        var p = prompt();
        if (p !== null)
          return p + "\n";
        return nil;
      }], $send($$$("STDIN"), "read_proc=", $a), $a[$a.length - 1];
    };
    Opal.modules["opal/regexp_anchors"] = function(Opal2) {
      var $module = Opal2.module, $const_set = Opal2.const_set, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("new");
      return function($base, $parent_nesting) {
        var self = $module($base, "Opal");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $const_set(self, "REGEXP_START", "^");
        $const_set(self, "REGEXP_END", "$");
        $const_set(self, "FORBIDDEN_STARTING_IDENTIFIER_CHARS", "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        $const_set(self, "FORBIDDEN_ENDING_IDENTIFIER_CHARS", "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        $const_set(self, "INLINE_IDENTIFIER_REGEXP", $$("Regexp").$new("[^" + $$$(self, "FORBIDDEN_STARTING_IDENTIFIER_CHARS") + "]*[^" + $$$(self, "FORBIDDEN_ENDING_IDENTIFIER_CHARS") + "]"));
        $const_set(self, "FORBIDDEN_CONST_NAME_CHARS", "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
        return $const_set(self, "CONST_NAME_REGEXP", $$("Regexp").$new("" + $$$(self, "REGEXP_START") + "(::)?[A-Z][^" + $$$(self, "FORBIDDEN_CONST_NAME_CHARS") + "]*" + $$$(self, "REGEXP_END")));
      }($nesting[0], $nesting);
    };
    Opal.modules["opal/mini"] = function(Opal2) {
      var $Object = Opal2.Object, nil = Opal2.nil;
      Opal2.add_stubs("require");
      $Object.$require("opal/base");
      $Object.$require("corelib/nil");
      $Object.$require("corelib/boolean");
      $Object.$require("corelib/string");
      $Object.$require("corelib/comparable");
      $Object.$require("corelib/enumerable");
      $Object.$require("corelib/enumerator");
      $Object.$require("corelib/array");
      $Object.$require("corelib/hash");
      $Object.$require("corelib/number");
      $Object.$require("corelib/range");
      $Object.$require("corelib/proc");
      $Object.$require("corelib/method");
      $Object.$require("corelib/regexp");
      $Object.$require("corelib/variables");
      $Object.$require("corelib/io");
      return $Object.$require("opal/regexp_anchors");
    };
    Opal.modules["corelib/kernel/format"] = function(Opal2) {
      var $coerce_to = Opal2.coerce_to, $module = Opal2.module, $slice = Opal2.slice, $truthy = Opal2.truthy, $eqeq = Opal2.eqeq, $Opal = Opal2.Opal, $Kernel = Opal2.Kernel, $gvars = Opal2.gvars, $def = Opal2.def, $alias = Opal2.alias, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format");
      return function($base) {
        var self = $module($base, "Kernel");
        $def(self, "$format", function $$format(format_string, $a) {
          var $post_args, args, ary = nil;
          if ($gvars.DEBUG == null)
            $gvars.DEBUG = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($eqeq(args.$length(), 1) && $truthy(args["$[]"](0)["$respond_to?"]("to_ary"))) {
            ary = $Opal["$coerce_to?"](args["$[]"](0), $$$("Array"), "to_ary");
            if (!$truthy(ary["$nil?"]())) {
              args = ary.$to_a();
            }
            ;
          }
          ;
          var result = "", begin_slice = 0, end_slice, i, len = format_string.length, arg, str, exponent, width, precision, tmp_num, hash_parameter_key, closing_brace_char, base_number, base_prefix, base_neg_zero_regex, base_neg_zero_digit, next_arg, seq_arg_num = 1, pos_arg_num = 0, flags, FNONE = 0, FSHARP = 1, FMINUS = 2, FPLUS = 4, FZERO = 8, FSPACE = 16, FWIDTH = 32, FPREC = 64, FPREC0 = 128;
          function CHECK_FOR_FLAGS() {
            if (flags & FWIDTH) {
              $Kernel.$raise($$$("ArgumentError"), "flag after width");
            }
            if (flags & FPREC0) {
              $Kernel.$raise($$$("ArgumentError"), "flag after precision");
            }
          }
          function CHECK_FOR_WIDTH() {
            if (flags & FWIDTH) {
              $Kernel.$raise($$$("ArgumentError"), "width given twice");
            }
            if (flags & FPREC0) {
              $Kernel.$raise($$$("ArgumentError"), "width after precision");
            }
          }
          function GET_NTH_ARG(num) {
            if (num >= args.length) {
              $Kernel.$raise($$$("ArgumentError"), "too few arguments");
            }
            return args[num];
          }
          function GET_NEXT_ARG() {
            switch (pos_arg_num) {
              case -1:
                $Kernel.$raise($$$("ArgumentError"), "unnumbered(" + seq_arg_num + ") mixed with numbered");
              case -2:
                $Kernel.$raise($$$("ArgumentError"), "unnumbered(" + seq_arg_num + ") mixed with named");
            }
            pos_arg_num = seq_arg_num++;
            return GET_NTH_ARG(pos_arg_num - 1);
          }
          function GET_POS_ARG(num) {
            if (pos_arg_num > 0) {
              $Kernel.$raise($$$("ArgumentError"), "numbered(" + num + ") after unnumbered(" + pos_arg_num + ")");
            }
            if (pos_arg_num === -2) {
              $Kernel.$raise($$$("ArgumentError"), "numbered(" + num + ") after named");
            }
            if (num < 1) {
              $Kernel.$raise($$$("ArgumentError"), "invalid index - " + num + "$");
            }
            pos_arg_num = -1;
            return GET_NTH_ARG(num - 1);
          }
          function GET_ARG() {
            return next_arg === void 0 ? GET_NEXT_ARG() : next_arg;
          }
          function READ_NUM(label) {
            var num, str2 = "";
            for (; ; i++) {
              if (i === len) {
                $Kernel.$raise($$$("ArgumentError"), "malformed format string - %*[0-9]");
              }
              if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
                i--;
                num = parseInt(str2, 10) || 0;
                if (num > 2147483647) {
                  $Kernel.$raise($$$("ArgumentError"), "" + label + " too big");
                }
                return num;
              }
              str2 += format_string.charAt(i);
            }
          }
          function READ_NUM_AFTER_ASTER(label) {
            var arg2, num = READ_NUM(label);
            if (format_string.charAt(i + 1) === "$") {
              i++;
              arg2 = GET_POS_ARG(num);
            } else {
              arg2 = GET_NEXT_ARG();
            }
            return arg2.$to_int();
          }
          for (i = format_string.indexOf("%"); i !== -1; i = format_string.indexOf("%", i)) {
            str = void 0;
            flags = FNONE;
            width = -1;
            precision = -1;
            next_arg = void 0;
            end_slice = i;
            i++;
            switch (format_string.charAt(i)) {
              case "%":
                begin_slice = i;
              case "":
              case "\n":
              case "\0":
                i++;
                continue;
            }
            format_sequence:
              for (; i < len; i++) {
                switch (format_string.charAt(i)) {
                  case " ":
                    CHECK_FOR_FLAGS();
                    flags |= FSPACE;
                    continue format_sequence;
                  case "#":
                    CHECK_FOR_FLAGS();
                    flags |= FSHARP;
                    continue format_sequence;
                  case "+":
                    CHECK_FOR_FLAGS();
                    flags |= FPLUS;
                    continue format_sequence;
                  case "-":
                    CHECK_FOR_FLAGS();
                    flags |= FMINUS;
                    continue format_sequence;
                  case "0":
                    CHECK_FOR_FLAGS();
                    flags |= FZERO;
                    continue format_sequence;
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                    tmp_num = READ_NUM("width");
                    if (format_string.charAt(i + 1) === "$") {
                      if (i + 2 === len) {
                        str = "%";
                        i++;
                        break format_sequence;
                      }
                      if (next_arg !== void 0) {
                        $Kernel.$raise($$$("ArgumentError"), "value given twice - %" + tmp_num + "$");
                      }
                      next_arg = GET_POS_ARG(tmp_num);
                      i++;
                    } else {
                      CHECK_FOR_WIDTH();
                      flags |= FWIDTH;
                      width = tmp_num;
                    }
                    continue format_sequence;
                  case "<":
                  case "{":
                    closing_brace_char = format_string.charAt(i) === "<" ? ">" : "}";
                    hash_parameter_key = "";
                    i++;
                    for (; ; i++) {
                      if (i === len) {
                        $Kernel.$raise($$$("ArgumentError"), "malformed name - unmatched parenthesis");
                      }
                      if (format_string.charAt(i) === closing_brace_char) {
                        if (pos_arg_num > 0) {
                          $Kernel.$raise($$$("ArgumentError"), "named " + hash_parameter_key + " after unnumbered(" + pos_arg_num + ")");
                        }
                        if (pos_arg_num === -1) {
                          $Kernel.$raise($$$("ArgumentError"), "named " + hash_parameter_key + " after numbered");
                        }
                        pos_arg_num = -2;
                        if (args[0] === void 0 || !args[0].$$is_hash) {
                          $Kernel.$raise($$$("ArgumentError"), "one hash required");
                        }
                        next_arg = args[0].$fetch(hash_parameter_key);
                        if (closing_brace_char === ">") {
                          continue format_sequence;
                        } else {
                          str = next_arg.toString();
                          if (precision !== -1) {
                            str = str.slice(0, precision);
                          }
                          if (flags & FMINUS) {
                            while (str.length < width) {
                              str = str + " ";
                            }
                          } else {
                            while (str.length < width) {
                              str = " " + str;
                            }
                          }
                          break format_sequence;
                        }
                      }
                      hash_parameter_key += format_string.charAt(i);
                    }
                  case "*":
                    i++;
                    CHECK_FOR_WIDTH();
                    flags |= FWIDTH;
                    width = READ_NUM_AFTER_ASTER("width");
                    if (width < 0) {
                      flags |= FMINUS;
                      width = -width;
                    }
                    continue format_sequence;
                  case ".":
                    if (flags & FPREC0) {
                      $Kernel.$raise($$$("ArgumentError"), "precision given twice");
                    }
                    flags |= FPREC | FPREC0;
                    precision = 0;
                    i++;
                    if (format_string.charAt(i) === "*") {
                      i++;
                      precision = READ_NUM_AFTER_ASTER("precision");
                      if (precision < 0) {
                        flags &= ~FPREC;
                      }
                      continue format_sequence;
                    }
                    precision = READ_NUM("precision");
                    continue format_sequence;
                  case "d":
                  case "i":
                  case "u":
                    arg = $Kernel.$Integer(GET_ARG());
                    if (arg >= 0) {
                      str = arg.toString();
                      while (str.length < precision) {
                        str = "0" + str;
                      }
                      if (flags & FMINUS) {
                        if (flags & FPLUS || flags & FSPACE) {
                          str = (flags & FPLUS ? "+" : " ") + str;
                        }
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        if (flags & FZERO && precision === -1) {
                          while (str.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0)) {
                            str = "0" + str;
                          }
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                        } else {
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                          while (str.length < width) {
                            str = " " + str;
                          }
                        }
                      }
                    } else {
                      str = (-arg).toString();
                      while (str.length < precision) {
                        str = "0" + str;
                      }
                      if (flags & FMINUS) {
                        str = "-" + str;
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        if (flags & FZERO && precision === -1) {
                          while (str.length < width - 1) {
                            str = "0" + str;
                          }
                          str = "-" + str;
                        } else {
                          str = "-" + str;
                          while (str.length < width) {
                            str = " " + str;
                          }
                        }
                      }
                    }
                    break format_sequence;
                  case "b":
                  case "B":
                  case "o":
                  case "x":
                  case "X":
                    switch (format_string.charAt(i)) {
                      case "b":
                      case "B":
                        base_number = 2;
                        base_prefix = "0b";
                        base_neg_zero_regex = /^1+/;
                        base_neg_zero_digit = "1";
                        break;
                      case "o":
                        base_number = 8;
                        base_prefix = "0";
                        base_neg_zero_regex = /^3?7+/;
                        base_neg_zero_digit = "7";
                        break;
                      case "x":
                      case "X":
                        base_number = 16;
                        base_prefix = "0x";
                        base_neg_zero_regex = /^f+/;
                        base_neg_zero_digit = "f";
                        break;
                    }
                    arg = $Kernel.$Integer(GET_ARG());
                    if (arg >= 0) {
                      str = arg.toString(base_number);
                      while (str.length < precision) {
                        str = "0" + str;
                      }
                      if (flags & FMINUS) {
                        if (flags & FPLUS || flags & FSPACE) {
                          str = (flags & FPLUS ? "+" : " ") + str;
                        }
                        if (flags & FSHARP && arg !== 0) {
                          str = base_prefix + str;
                        }
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        if (flags & FZERO && precision === -1) {
                          while (str.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0) - (flags & FSHARP && arg !== 0 ? base_prefix.length : 0)) {
                            str = "0" + str;
                          }
                          if (flags & FSHARP && arg !== 0) {
                            str = base_prefix + str;
                          }
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                        } else {
                          if (flags & FSHARP && arg !== 0) {
                            str = base_prefix + str;
                          }
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                          while (str.length < width) {
                            str = " " + str;
                          }
                        }
                      }
                    } else {
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (-arg).toString(base_number);
                        while (str.length < precision) {
                          str = "0" + str;
                        }
                        if (flags & FMINUS) {
                          if (flags & FSHARP) {
                            str = base_prefix + str;
                          }
                          str = "-" + str;
                          while (str.length < width) {
                            str = str + " ";
                          }
                        } else {
                          if (flags & FZERO && precision === -1) {
                            while (str.length < width - 1 - (flags & FSHARP ? 2 : 0)) {
                              str = "0" + str;
                            }
                            if (flags & FSHARP) {
                              str = base_prefix + str;
                            }
                            str = "-" + str;
                          } else {
                            if (flags & FSHARP) {
                              str = base_prefix + str;
                            }
                            str = "-" + str;
                            while (str.length < width) {
                              str = " " + str;
                            }
                          }
                        }
                      } else {
                        str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                        while (str.length < precision - 2) {
                          str = base_neg_zero_digit + str;
                        }
                        if (flags & FMINUS) {
                          str = ".." + str;
                          if (flags & FSHARP) {
                            str = base_prefix + str;
                          }
                          while (str.length < width) {
                            str = str + " ";
                          }
                        } else {
                          if (flags & FZERO && precision === -1) {
                            while (str.length < width - 2 - (flags & FSHARP ? base_prefix.length : 0)) {
                              str = base_neg_zero_digit + str;
                            }
                            str = ".." + str;
                            if (flags & FSHARP) {
                              str = base_prefix + str;
                            }
                          } else {
                            str = ".." + str;
                            if (flags & FSHARP) {
                              str = base_prefix + str;
                            }
                            while (str.length < width) {
                              str = " " + str;
                            }
                          }
                        }
                      }
                    }
                    if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
                      str = str.toUpperCase();
                    }
                    break format_sequence;
                  case "f":
                  case "e":
                  case "E":
                  case "g":
                  case "G":
                    arg = $Kernel.$Float(GET_ARG());
                    if (arg >= 0 || isNaN(arg)) {
                      if (arg === Infinity) {
                        str = "Inf";
                      } else {
                        switch (format_string.charAt(i)) {
                          case "f":
                            str = arg.toFixed(precision === -1 ? 6 : precision);
                            break;
                          case "e":
                          case "E":
                            str = arg.toExponential(precision === -1 ? 6 : precision);
                            break;
                          case "g":
                          case "G":
                            str = arg.toExponential();
                            exponent = parseInt(str.split("e")[1], 10);
                            if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                              str = arg.toPrecision(precision === -1 ? flags & FSHARP ? 6 : void 0 : precision);
                            }
                            break;
                        }
                      }
                      if (flags & FMINUS) {
                        if (flags & FPLUS || flags & FSPACE) {
                          str = (flags & FPLUS ? "+" : " ") + str;
                        }
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        if (flags & FZERO && arg !== Infinity && !isNaN(arg)) {
                          while (str.length < width - (flags & FPLUS || flags & FSPACE ? 1 : 0)) {
                            str = "0" + str;
                          }
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                        } else {
                          if (flags & FPLUS || flags & FSPACE) {
                            str = (flags & FPLUS ? "+" : " ") + str;
                          }
                          while (str.length < width) {
                            str = " " + str;
                          }
                        }
                      }
                    } else {
                      if (arg === -Infinity) {
                        str = "Inf";
                      } else {
                        switch (format_string.charAt(i)) {
                          case "f":
                            str = (-arg).toFixed(precision === -1 ? 6 : precision);
                            break;
                          case "e":
                          case "E":
                            str = (-arg).toExponential(precision === -1 ? 6 : precision);
                            break;
                          case "g":
                          case "G":
                            str = (-arg).toExponential();
                            exponent = parseInt(str.split("e")[1], 10);
                            if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                              str = (-arg).toPrecision(precision === -1 ? flags & FSHARP ? 6 : void 0 : precision);
                            }
                            break;
                        }
                      }
                      if (flags & FMINUS) {
                        str = "-" + str;
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        if (flags & FZERO && arg !== -Infinity) {
                          while (str.length < width - 1) {
                            str = "0" + str;
                          }
                          str = "-" + str;
                        } else {
                          str = "-" + str;
                          while (str.length < width) {
                            str = " " + str;
                          }
                        }
                      }
                    }
                    if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
                      str = str.toUpperCase();
                    }
                    str = str.replace(/([eE][-+]?)([0-9])$/, "$10$2");
                    break format_sequence;
                  case "a":
                  case "A":
                    $Kernel.$raise($$$("NotImplementedError"), "`A` and `a` format field types are not implemented in Opal yet");
                  case "c":
                    arg = GET_ARG();
                    if (arg["$respond_to?"]("to_ary")) {
                      arg = arg.$to_ary()[0];
                    }
                    if (arg["$respond_to?"]("to_str")) {
                      str = arg.$to_str();
                    } else {
                      str = String.fromCharCode($coerce_to(arg, $$$("Integer"), "to_int"));
                    }
                    if (str.length !== 1) {
                      $Kernel.$raise($$$("ArgumentError"), "%c requires a character");
                    }
                    if (flags & FMINUS) {
                      while (str.length < width) {
                        str = str + " ";
                      }
                    } else {
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                    break format_sequence;
                  case "p":
                    str = GET_ARG().$inspect();
                    if (precision !== -1) {
                      str = str.slice(0, precision);
                    }
                    if (flags & FMINUS) {
                      while (str.length < width) {
                        str = str + " ";
                      }
                    } else {
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                    break format_sequence;
                  case "s":
                    str = GET_ARG().$to_s();
                    if (precision !== -1) {
                      str = str.slice(0, precision);
                    }
                    if (flags & FMINUS) {
                      while (str.length < width) {
                        str = str + " ";
                      }
                    } else {
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                    break format_sequence;
                  default:
                    $Kernel.$raise($$$("ArgumentError"), "malformed format string - %" + format_string.charAt(i));
                }
              }
            if (str === void 0) {
              $Kernel.$raise($$$("ArgumentError"), "malformed format string - %");
            }
            result += format_string.slice(begin_slice, end_slice) + str;
            begin_slice = i + 1;
          }
          if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
            $Kernel.$raise($$$("ArgumentError"), "too many arguments for format string");
          }
          return result + format_string.slice(begin_slice);
          ;
        }, -2);
        return $alias(self, "sprintf", "format");
      }("::");
    };
    Opal.modules["corelib/string/encoding"] = function(Opal2) {
      var $klass = Opal2.klass, $hash2 = Opal2.hash2, $rb_plus = Opal2.rb_plus, $truthy = Opal2.truthy, $send = Opal2.send, $defs = Opal2.defs, $eqeq = Opal2.eqeq, $def = Opal2.def, $return_ivar = Opal2.return_ivar, $return_val = Opal2.return_val, $slice = Opal2.slice, $Kernel = Opal2.Kernel, $Opal = Opal2.Opal, $rb_lt = Opal2.rb_lt, $a, self = Opal2.top, $nesting = [], $$ = Opal2.$r($nesting), nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=");
      self.$require("corelib/string");
      (function($base, $super) {
        var self2 = $klass($base, $super, "Encoding");
        var $proto = self2.$$prototype;
        $proto.name = $proto.dummy = nil;
        $defs(self2, "$register", function $$register(name, options) {
          var block = $$register.$$p || nil, self3 = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;
          $$register.$$p = null;
          ;
          if (options == null)
            options = $hash2([], {});
          names = $rb_plus([name], $truthy($ret_or_1 = options["$[]"]("aliases")) ? $ret_or_1 : []);
          ascii = $truthy($ret_or_1 = options["$[]"]("ascii")) && $ret_or_1;
          dummy = $truthy($ret_or_1 = options["$[]"]("dummy")) && $ret_or_1;
          if ($truthy(options["$[]"]("inherits"))) {
            encoding = options["$[]"]("inherits").$clone();
            encoding.$initialize(name, names, ascii, dummy);
          } else {
            encoding = self3.$new(name, names, ascii, dummy);
          }
          ;
          if (block !== nil) {
            $send(encoding, "instance_eval", [], block.$to_proc());
          }
          ;
          register = Opal2.encodings;
          return $send(names, "each", [], function $$1(encoding_name) {
            var self4 = $$1.$$s == null ? this : $$1.$$s;
            if (encoding_name == null)
              encoding_name = nil;
            self4.$const_set(encoding_name.$tr("-", "_"), encoding);
            return register[encoding_name] = encoding;
          }, { $$s: self3 });
        }, -2);
        $defs(self2, "$find", function $$find(name) {
          var self3 = this;
          if ($eqeq(name, "default_external")) {
            return self3.$default_external();
          }
          ;
          return Opal2.find_encoding(name);
          ;
        });
        self2.$singleton_class().$attr_accessor("default_external");
        self2.$attr_reader("name", "names");
        $def(self2, "$initialize", function $$initialize(name, names, ascii, dummy) {
          var self3 = this;
          self3.name = name;
          self3.names = names;
          self3.ascii = ascii;
          return self3.dummy = dummy;
        });
        $def(self2, "$ascii_compatible?", $return_ivar("ascii"));
        $def(self2, "$dummy?", $return_ivar("dummy"));
        $def(self2, "$binary?", $return_val(false));
        $def(self2, "$to_s", $return_ivar("name"));
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          return "#<Encoding:" + self3.name + ($truthy(self3.dummy) ? " (dummy)" : nil) + ">";
        });
        $def(self2, "$charsize", function $$charsize(string) {
          var len = 0;
          for (var i = 0, length = string.length; i < length; i++) {
            var charcode = string.charCodeAt(i);
            if (!(charcode >= 55296 && charcode <= 56319)) {
              len++;
            }
          }
          return len;
        });
        $def(self2, "$each_char", function $$each_char(string) {
          var block = $$each_char.$$p || nil;
          $$each_char.$$p = null;
          ;
          var low_surrogate = "";
          for (var i = 0, length = string.length; i < length; i++) {
            var charcode = string.charCodeAt(i);
            var chr = string.charAt(i);
            if (charcode >= 56320 && charcode <= 57343) {
              low_surrogate = chr;
              continue;
            } else if (charcode >= 55296 && charcode <= 56319) {
              chr = low_surrogate + chr;
            }
            if (string.encoding.name != "UTF-8") {
              chr = new String(chr);
              chr.encoding = string.encoding;
            }
            Opal2.yield1(block, chr);
          }
          ;
        });
        $def(self2, "$each_byte", function $$each_byte($a2) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return $Kernel.$raise($$$("NotImplementedError"));
        }, -1);
        $def(self2, "$bytesize", function $$bytesize($a2) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return $Kernel.$raise($$$("NotImplementedError"));
        }, -1);
        $klass("::", $$$("StandardError"), "EncodingError");
        return $klass("::", $$$("EncodingError"), "CompatibilityError"), nil;
      })("::", null);
      $send($$$("Encoding"), "register", ["UTF-8", $hash2(["aliases", "ascii"], { "aliases": ["CP65001"], "ascii": true })], function $$2() {
        var self2 = $$2.$$s == null ? this : $$2.$$s;
        $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          var units = Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1) {
                    Opal2.yield1(block, 239);
                    Opal2.yield1(block, 191);
                    Opal2.yield1(block, 189);
                  }
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1) {
                    Opal2.yield1(block, 239);
                    Opal2.yield1(block, 191);
                    Opal2.yield1(block, 189);
                  }
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                  Opal2.yield1(block, 239);
                  Opal2.yield1(block, 191);
                  Opal2.yield1(block, 189);
                }
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1) {
                Opal2.yield1(block, 239);
                Opal2.yield1(block, 191);
                Opal2.yield1(block, 189);
              }
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0)
                break;
              Opal2.yield1(block, codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0)
                break;
              Opal2.yield1(block, codePoint >> 6 | 192);
              Opal2.yield1(block, codePoint & 63 | 128);
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0)
                break;
              Opal2.yield1(block, codePoint >> 12 | 224);
              Opal2.yield1(block, codePoint >> 6 & 63 | 128);
              Opal2.yield1(block, codePoint & 63 | 128);
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0)
                break;
              Opal2.yield1(block, codePoint >> 18 | 240);
              Opal2.yield1(block, codePoint >> 12 & 63 | 128);
              Opal2.yield1(block, codePoint >> 6 & 63 | 128);
              Opal2.yield1(block, codePoint & 63 | 128);
            } else {
            }
          }
          ;
        });
        return $def(self2, "$bytesize", function $$bytesize(string) {
          return string.$bytes().$length();
        });
      }, { $$s: self });
      $send($$$("Encoding"), "register", ["UTF-16LE"], function $$3() {
        var self2 = $$3.$$s == null ? this : $$3.$$s;
        $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal2.yield1(block, code & 255);
            Opal2.yield1(block, code >> 8);
          }
          ;
        });
        return $def(self2, "$bytesize", function $$bytesize(string) {
          return string.length * 2;
        });
      }, { $$s: self });
      $send($$$("Encoding"), "register", ["UTF-16BE", $hash2(["inherits"], { "inherits": $$$($$$("Encoding"), "UTF_16LE") })], function $$4() {
        var self2 = $$4.$$s == null ? this : $$4.$$s;
        return $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal2.yield1(block, code >> 8);
            Opal2.yield1(block, code & 255);
          }
          ;
        });
      }, { $$s: self });
      $send($$$("Encoding"), "register", ["UTF-32LE"], function $$5() {
        var self2 = $$5.$$s == null ? this : $$5.$$s;
        $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal2.yield1(block, code & 255);
            Opal2.yield1(block, code >> 8);
            Opal2.yield1(block, 0);
            Opal2.yield1(block, 0);
          }
          ;
        });
        return $def(self2, "$bytesize", function $$bytesize(string) {
          return string.length * 4;
        });
      }, { $$s: self });
      $send($$$("Encoding"), "register", ["UTF-32BE", $hash2(["inherits"], { "inherits": $$$($$$("Encoding"), "UTF_32LE") })], function $$6() {
        var self2 = $$6.$$s == null ? this : $$6.$$s;
        return $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal2.yield1(block, 0);
            Opal2.yield1(block, 0);
            Opal2.yield1(block, code >> 8);
            Opal2.yield1(block, code & 255);
          }
          ;
        });
      }, { $$s: self });
      $send($$$("Encoding"), "register", ["ASCII-8BIT", $hash2(["aliases", "ascii"], { "aliases": ["BINARY"], "ascii": true })], function $$7() {
        var self2 = $$7.$$s == null ? this : $$7.$$s;
        $def(self2, "$each_char", function $$each_char(string) {
          var block = $$each_char.$$p || nil;
          $$each_char.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var chr = new String(string.charAt(i));
            chr.encoding = string.encoding;
            Opal2.yield1(block, chr);
          }
          ;
        });
        $def(self2, "$charsize", function $$charsize(string) {
          return string.length;
        });
        $def(self2, "$each_byte", function $$each_byte(string) {
          var block = $$each_byte.$$p || nil;
          $$each_byte.$$p = null;
          ;
          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal2.yield1(block, code & 255);
          }
          ;
        });
        $def(self2, "$bytesize", function $$bytesize(string) {
          return string.length;
        });
        return $def(self2, "$binary?", $return_val(true));
      }, { $$s: self });
      $$$("Encoding").$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], { "aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$("Encoding"), "ASCII_8BIT") }));
      $$$("Encoding").$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], { "aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$("Encoding"), "ASCII_8BIT") }));
      (function($base, $super) {
        var self2 = $klass($base, $super, "String");
        var $proto = self2.$$prototype;
        $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
        self2.$attr_reader("encoding");
        self2.$attr_reader("internal_encoding");
        Opal2.prop(String.prototype, "bytes", nil);
        Opal2.prop(String.prototype, "encoding", $$$($$$("Encoding"), "UTF_8"));
        Opal2.prop(String.prototype, "internal_encoding", $$$($$$("Encoding"), "UTF_8"));
        $def(self2, "$b", function $$b() {
          var self3 = this;
          return self3.$dup().$force_encoding("binary");
        });
        $def(self2, "$bytesize", function $$bytesize() {
          var self3 = this;
          return self3.internal_encoding.$bytesize(self3);
        });
        $def(self2, "$each_byte", function $$each_byte() {
          var block = $$each_byte.$$p || nil, self3 = this;
          $$each_byte.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each_byte"], function $$8() {
              var self4 = $$8.$$s == null ? this : $$8.$$s;
              return self4.$bytesize();
            }, { $$s: self3 });
          }
          ;
          $send(self3.internal_encoding, "each_byte", [self3], block.$to_proc());
          return self3;
        });
        $def(self2, "$bytes", function $$bytes() {
          var self3 = this, $ret_or_1 = nil;
          if (typeof self3 === "string") {
            return new String(self3).$each_byte().$to_a();
          }
          ;
          self3.bytes = $truthy($ret_or_1 = self3.bytes) ? $ret_or_1 : self3.$each_byte().$to_a();
          return self3.bytes.$dup();
        });
        $def(self2, "$each_char", function $$each_char() {
          var block = $$each_char.$$p || nil, self3 = this;
          $$each_char.$$p = null;
          ;
          if (!(block !== nil)) {
            return $send(self3, "enum_for", ["each_char"], function $$9() {
              var self4 = $$9.$$s == null ? this : $$9.$$s;
              return self4.$length();
            }, { $$s: self3 });
          }
          ;
          $send(self3.encoding, "each_char", [self3], block.$to_proc());
          return self3;
        });
        $def(self2, "$chars", function $$chars() {
          var block = $$chars.$$p || nil, self3 = this;
          $$chars.$$p = null;
          ;
          if (!$truthy(block)) {
            return self3.$each_char().$to_a();
          }
          ;
          return $send(self3, "each_char", [], block.$to_proc());
        });
        $def(self2, "$each_codepoint", function $$each_codepoint() {
          var block = $$each_codepoint.$$p || nil, self3 = this;
          $$each_codepoint.$$p = null;
          ;
          if (!(block !== nil)) {
            return self3.$enum_for("each_codepoint");
          }
          ;
          for (var i = 0, length = self3.length; i < length; i++) {
            Opal2.yield1(block, self3.codePointAt(i));
          }
          ;
          return self3;
        });
        $def(self2, "$codepoints", function $$codepoints() {
          var block = $$codepoints.$$p || nil, self3 = this;
          $$codepoints.$$p = null;
          ;
          if (block !== nil) {
            return $send(self3, "each_codepoint", [], block.$to_proc());
          }
          ;
          return self3.$each_codepoint().$to_a();
        });
        $def(self2, "$encode", function $$encode(encoding) {
          var self3 = this;
          return Opal2.enc(self3, encoding);
        });
        $def(self2, "$force_encoding", function $$force_encoding(encoding) {
          var self3 = this;
          var str = self3;
          if (encoding === str.encoding) {
            return str;
          }
          encoding = $Opal["$coerce_to!"](encoding, $$$("String"), "to_s");
          encoding = $$$("Encoding").$find(encoding);
          if (encoding === str.encoding) {
            return str;
          }
          str = Opal2.set_encoding(str, encoding);
          return str;
        });
        $def(self2, "$getbyte", function $$getbyte(idx) {
          var self3 = this, string_bytes = nil;
          string_bytes = self3.$bytes();
          idx = $Opal["$coerce_to!"](idx, $$$("Integer"), "to_int");
          if ($truthy($rb_lt(string_bytes.$length(), idx))) {
            return nil;
          }
          ;
          return string_bytes["$[]"](idx);
        });
        $def(self2, "$initialize_copy", function $$initialize_copy(other) {
          return "\n      self.encoding = other.encoding;\n      self.internal_encoding = other.internal_encoding;\n    ";
        });
        return $def(self2, "$valid_encoding?", $return_val(true));
      })("::", null);
      return $a = [$$$($$("Encoding"), "UTF_8")], $send($$$("Encoding"), "default_external=", $a), $a[$a.length - 1];
    };
    Opal.modules["corelib/math"] = function(Opal2) {
      var $type_error = Opal2.type_error, $module = Opal2.module, $const_set = Opal2.const_set, $Class = Opal2.Class, $slice = Opal2.slice, $Kernel = Opal2.Kernel, $defs = Opal2.defs, $truthy = Opal2.truthy, $send = Opal2.send, $def = Opal2.def, $rb_minus = Opal2.rb_minus, $eqeqeq = Opal2.eqeqeq, $rb_divide = Opal2.rb_divide, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?");
      return function($base, $parent_nesting) {
        var self = $module($base, "Math");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        $const_set(self, "E", Math.E);
        $const_set(self, "PI", Math.PI);
        $const_set(self, "DomainError", $Class.$new($$$("StandardError")));
        $defs(self, "$checked", function $$checked(method, $a) {
          var $post_args, args;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if (isNaN(args[0]) || args.length == 2 && isNaN(args[1])) {
            return NaN;
          }
          var result = Math[method].apply(null, args);
          if (isNaN(result)) {
            $Kernel.$raise($$("DomainError"), 'Numerical argument is out of domain - "' + method + '"');
          }
          return result;
          ;
        }, -2);
        $defs(self, "$float!", function $Math_float$excl$1(value) {
          try {
            return $Kernel.$Float(value);
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("ArgumentError")])) {
              try {
                return $Kernel.$raise($type_error(value, $$$("Float")));
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
        $defs(self, "$integer!", function $Math_integer$excl$2(value) {
          try {
            return $Kernel.$Integer(value);
          } catch ($err) {
            if (Opal2.rescue($err, [$$$("ArgumentError")])) {
              try {
                return $Kernel.$raise($type_error(value, $$$("Integer")));
              } finally {
                Opal2.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        });
        self.$module_function();
        if (!$truthy(typeof Math.erf !== "undefined")) {
          Opal2.prop(Math, "erf", function(x) {
            var A1 = 0.254829592, A2 = -0.284496736, A3 = 1.421413741, A4 = -1.453152027, A5 = 1.061405429, P = 0.3275911;
            var sign = 1;
            if (x < 0) {
              sign = -1;
            }
            x = Math.abs(x);
            var t2 = 1 / (1 + P * x);
            var y = 1 - ((((A5 * t2 + A4) * t2 + A3) * t2 + A2) * t2 + A1) * t2 * Math.exp(-x * x);
            return sign * y;
          });
        }
        ;
        if (!$truthy(typeof Math.erfc !== "undefined")) {
          Opal2.prop(Math, "erfc", function(x) {
            var z = Math.abs(x), t2 = 1 / (0.5 * z + 1);
            var A1 = t2 * 0.17087277 + -0.82215223, A2 = t2 * A1 + 1.48851587, A3 = t2 * A2 + -1.13520398, A4 = t2 * A3 + 0.27886807, A5 = t2 * A4 + -0.18628806, A6 = t2 * A5 + 0.09678418, A7 = t2 * A6 + 0.37409196, A8 = t2 * A7 + 1.00002368, A9 = t2 * A8, A10 = -z * z - 1.26551223 + A9;
            var a = t2 * Math.exp(A10);
            if (x < 0) {
              return 2 - a;
            } else {
              return a;
            }
          });
        }
        ;
        $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], "each", [], function $Math$3(method) {
          var self2 = $Math$3.$$s == null ? this : $Math$3.$$s;
          if (method == null)
            method = nil;
          return $send(self2, "define_method", [method], function $$4(x) {
            if (x == null)
              x = nil;
            return $$$("Math").$checked(method, $$$("Math")["$float!"](x));
          });
        }, { $$s: self });
        $def(self, "$atan2", function $$atan2(y, x) {
          return $$$("Math").$checked("atan2", $$$("Math")["$float!"](y), $$$("Math")["$float!"](x));
        });
        $def(self, "$hypot", function $$hypot(x, y) {
          return $$$("Math").$checked("hypot", $$$("Math")["$float!"](x), $$$("Math")["$float!"](y));
        });
        $def(self, "$frexp", function $$frexp(x) {
          x = $$("Math")["$float!"](x);
          if (isNaN(x)) {
            return [NaN, 0];
          }
          var ex = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1, frac = x / Math.pow(2, ex);
          return [frac, ex];
          ;
        });
        $def(self, "$gamma", function $$gamma(n) {
          n = $$("Math")["$float!"](n);
          var i, t2, x, value, result, twoN, threeN, fourN, fiveN;
          var G = 4.7421875;
          var P = [
            0.9999999999999971,
            57.15623566586292,
            -59.59796035547549,
            14.136097974741746,
            -0.4919138160976202,
            3399464998481189e-20,
            4652362892704858e-20,
            -9837447530487956e-20,
            1580887032249125e-19,
            -21026444172410488e-20,
            21743961811521265e-20,
            -1643181065367639e-19,
            8441822398385275e-20,
            -26190838401581408e-21,
            36899182659531625e-22
          ];
          if (isNaN(n)) {
            return NaN;
          }
          if (n === 0 && 1 / n < 0) {
            return -Infinity;
          }
          if (n === -1 || n === -Infinity) {
            $Kernel.$raise($$("DomainError"), 'Numerical argument is out of domain - "gamma"');
          }
          if ($$("Integer")["$==="](n)) {
            if (n <= 0) {
              return isFinite(n) ? Infinity : NaN;
            }
            if (n > 171) {
              return Infinity;
            }
            value = n - 2;
            result = n - 1;
            while (value > 1) {
              result *= value;
              value--;
            }
            if (result == 0) {
              result = 1;
            }
            return result;
          }
          if (n < 0.5) {
            return Math.PI / (Math.sin(Math.PI * n) * $$$("Math").$gamma($rb_minus(1, n)));
          }
          if (n >= 171.35) {
            return Infinity;
          }
          if (n > 85) {
            twoN = n * n;
            threeN = twoN * n;
            fourN = threeN * n;
            fiveN = fourN * n;
            return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
          }
          n -= 1;
          x = P[0];
          for (i = 1; i < P.length; ++i) {
            x += P[i] / (n + i);
          }
          t2 = n + G + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t2, n + 0.5) * Math.exp(-t2) * x;
          ;
        });
        $def(self, "$ldexp", function $$ldexp(mantissa, exponent) {
          mantissa = $$("Math")["$float!"](mantissa);
          exponent = $$("Math")["$integer!"](exponent);
          if (isNaN(exponent)) {
            $Kernel.$raise($$$("RangeError"), "float NaN out of range of integer");
          }
          return mantissa * Math.pow(2, exponent);
          ;
        });
        $def(self, "$lgamma", function $$lgamma(n) {
          if (n == -1) {
            return [Infinity, 1];
          } else {
            return [Math.log(Math.abs($$$("Math").$gamma(n))), $$$("Math").$gamma(n) < 0 ? -1 : 1];
          }
        });
        $def(self, "$log", function $$log(x, base) {
          ;
          if ($eqeqeq($$$("String"), x)) {
            $Kernel.$raise($type_error(x, $$$("Float")));
          }
          ;
          if ($truthy(base == null)) {
            return $$$("Math").$checked("log", $$$("Math")["$float!"](x));
          } else {
            if ($eqeqeq($$$("String"), base)) {
              $Kernel.$raise($type_error(base, $$$("Float")));
            }
            ;
            return $rb_divide($$$("Math").$checked("log", $$$("Math")["$float!"](x)), $$$("Math").$checked("log", $$$("Math")["$float!"](base)));
          }
          ;
        }, -2);
        $def(self, "$log10", function $$log10(x) {
          if ($eqeqeq($$$("String"), x)) {
            $Kernel.$raise($type_error(x, $$$("Float")));
          }
          ;
          return $$$("Math").$checked("log10", $$$("Math")["$float!"](x));
        });
        $def(self, "$log2", function $$log2(x) {
          if ($eqeqeq($$$("String"), x)) {
            $Kernel.$raise($type_error(x, $$$("Float")));
          }
          ;
          return $$$("Math").$checked("log2", $$$("Math")["$float!"](x));
        });
        return $def(self, "$tan", function $$tan(x) {
          x = $$$("Math")["$float!"](x);
          if ($truthy(x["$infinite?"]())) {
            return $$$($$$("Float"), "NAN");
          }
          ;
          return $$$("Math").$checked("tan", $$$("Math")["$float!"](x));
        });
      }("::", $nesting);
    };
    Opal.modules["corelib/complex/base"] = function(Opal2) {
      var $module = Opal2.module, $truthy = Opal2.truthy, $def = Opal2.def, $klass = Opal2.klass, $nesting = [], nil = Opal2.nil;
      Opal2.add_stubs("new,from_string");
      (function($base, $parent_nesting) {
        var self = $module($base, "Kernel");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        return $def(self, "$Complex", function $$Complex(real, imag) {
          if (imag == null)
            imag = nil;
          if ($truthy(imag)) {
            return $$("Complex").$new(real, imag);
          } else {
            return $$("Complex").$new(real, 0);
          }
          ;
        }, -2);
      })("::", $nesting);
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "String");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        return $def(self, "$to_c", function $$to_c() {
          var self2 = this;
          return $$("Complex").$from_string(self2);
        });
      }("::", null, $nesting);
    };
    Opal.modules["corelib/complex"] = function(Opal2) {
      var $klass = Opal2.klass, $truthy = Opal2.truthy, $eqeqeq = Opal2.eqeqeq, $Kernel = Opal2.Kernel, $defs = Opal2.defs, $rb_times = Opal2.rb_times, $def = Opal2.def, $rb_plus = Opal2.rb_plus, $rb_minus = Opal2.rb_minus, $rb_divide = Opal2.rb_divide, $eqeq = Opal2.eqeq, $to_ary = Opal2.to_ary, $rb_gt = Opal2.rb_gt, $neqeq = Opal2.neqeq, $return_val = Opal2.return_val, $const_set = Opal2.const_set, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle");
      self.$require("corelib/numeric");
      self.$require("corelib/complex/base");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Complex");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2), $proto = self2.$$prototype;
        $proto.real = $proto.imag = nil;
        $defs(self2, "$rect", function $$rect(real, imag) {
          var self3 = this;
          if (imag == null)
            imag = 0;
          if (!($eqeqeq($$$("Numeric"), real) && $truthy(real["$real?"]()) && $eqeqeq($$$("Numeric"), imag) && $truthy(imag["$real?"]()))) {
            $Kernel.$raise($$$("TypeError"), "not a real");
          }
          ;
          return self3.$new(real, imag);
        }, -2);
        $defs(self2, "$polar", function $$polar(r, theta) {
          var self3 = this;
          if (theta == null)
            theta = 0;
          if (!($eqeqeq($$$("Numeric"), r) && $truthy(r["$real?"]()) && $eqeqeq($$$("Numeric"), theta) && $truthy(theta["$real?"]()))) {
            $Kernel.$raise($$$("TypeError"), "not a real");
          }
          ;
          return self3.$new($rb_times(r, $$$("Math").$cos(theta)), $rb_times(r, $$$("Math").$sin(theta)));
        }, -2);
        self2.$attr_reader("real", "imag");
        $def(self2, "$initialize", function $$initialize(real, imag) {
          var self3 = this;
          if (imag == null)
            imag = 0;
          self3.real = real;
          self3.imag = imag;
          return self3.$freeze();
        }, -2);
        $def(self2, "$coerce", function $$coerce(other) {
          var self3 = this;
          if ($eqeqeq($$$("Complex"), other)) {
            return [other, self3];
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            return [$$$("Complex").$new(other, 0), self3];
          } else {
            return $Kernel.$raise($$$("TypeError"), "" + other.$class() + " can't be coerced into Complex");
          }
        });
        $def(self2, "$==", function $Complex_$eq_eq$1(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($eqeqeq($$$("Complex"), other)) {
            if ($truthy($ret_or_1 = self3.real["$=="](other.$real()))) {
              return self3.imag["$=="](other.$imag());
            } else {
              return $ret_or_1;
            }
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            if ($truthy($ret_or_1 = self3.real["$=="](other))) {
              return self3.imag["$=="](0);
            } else {
              return $ret_or_1;
            }
          } else {
            return other["$=="](self3);
          }
        });
        $def(self2, "$-@", function $Complex_$minus$$2() {
          var self3 = this;
          return $Kernel.$Complex(self3.real["$-@"](), self3.imag["$-@"]());
        });
        $def(self2, "$+", function $Complex_$plus$3(other) {
          var self3 = this;
          if ($eqeqeq($$$("Complex"), other)) {
            return $Kernel.$Complex($rb_plus(self3.real, other.$real()), $rb_plus(self3.imag, other.$imag()));
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            return $Kernel.$Complex($rb_plus(self3.real, other), self3.imag);
          } else {
            return self3.$__coerced__("+", other);
          }
        });
        $def(self2, "$-", function $Complex_$minus$4(other) {
          var self3 = this;
          if ($eqeqeq($$$("Complex"), other)) {
            return $Kernel.$Complex($rb_minus(self3.real, other.$real()), $rb_minus(self3.imag, other.$imag()));
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            return $Kernel.$Complex($rb_minus(self3.real, other), self3.imag);
          } else {
            return self3.$__coerced__("-", other);
          }
        });
        $def(self2, "$*", function $Complex_$$5(other) {
          var self3 = this;
          if ($eqeqeq($$$("Complex"), other)) {
            return $Kernel.$Complex($rb_minus($rb_times(self3.real, other.$real()), $rb_times(self3.imag, other.$imag())), $rb_plus($rb_times(self3.real, other.$imag()), $rb_times(self3.imag, other.$real())));
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            return $Kernel.$Complex($rb_times(self3.real, other), $rb_times(self3.imag, other));
          } else {
            return self3.$__coerced__("*", other);
          }
        });
        $def(self2, "$/", function $Complex_$slash$6(other) {
          var self3 = this;
          if ($eqeqeq($$$("Complex"), other)) {
            if ($eqeqeq($$$("Number"), self3.real) && $truthy(self3.real["$nan?"]()) || $eqeqeq($$$("Number"), self3.imag) && $truthy(self3.imag["$nan?"]()) || $eqeqeq($$$("Number"), other.$real()) && $truthy(other.$real()["$nan?"]()) || $eqeqeq($$$("Number"), other.$imag()) && $truthy(other.$imag()["$nan?"]())) {
              return $$$("Complex").$new($$$($$$("Float"), "NAN"), $$$($$$("Float"), "NAN"));
            } else {
              return $rb_divide($rb_times(self3, other.$conj()), other.$abs2());
            }
          } else if ($eqeqeq($$$("Numeric"), other) && $truthy(other["$real?"]())) {
            return $Kernel.$Complex(self3.real.$quo(other), self3.imag.$quo(other));
          } else {
            return self3.$__coerced__("/", other);
          }
        });
        $def(self2, "$**", function $Complex_$$$7(other) {
          var $a, $b, self3 = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;
          if ($eqeq(other, 0)) {
            return $$$("Complex").$new(1, 0);
          }
          ;
          if ($eqeqeq($$$("Complex"), other)) {
            $b = self3.$polar(), $a = $to_ary($b), r = $a[0] == null ? nil : $a[0], theta = $a[1] == null ? nil : $a[1], $b;
            ore = other.$real();
            oim = other.$imag();
            nr = $$$("Math").$exp($rb_minus($rb_times(ore, $$$("Math").$log(r)), $rb_times(oim, theta)));
            ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$("Math").$log(r)));
            return $$$("Complex").$polar(nr, ntheta);
          } else if ($eqeqeq($$$("Integer"), other)) {
            if ($truthy($rb_gt(other, 0))) {
              x = self3;
              z = x;
              n = $rb_minus(other, 1);
              while ($neqeq(n, 0)) {
                $b = n.$divmod(2), $a = $to_ary($b), div = $a[0] == null ? nil : $a[0], mod = $a[1] == null ? nil : $a[1], $b;
                while ($eqeq(mod, 0)) {
                  x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
                  n = div;
                  $b = n.$divmod(2), $a = $to_ary($b), div = $a[0] == null ? nil : $a[0], mod = $a[1] == null ? nil : $a[1], $b;
                }
                ;
                z = $rb_times(z, x);
                n = $rb_minus(n, 1);
              }
              ;
              return z;
            } else {
              return $rb_divide($$$("Rational").$new(1, 1), self3)["$**"](other["$-@"]());
            }
          } else if ($eqeqeq($$$("Float"), other) || $eqeqeq($$$("Rational"), other)) {
            $b = self3.$polar(), $a = $to_ary($b), r = $a[0] == null ? nil : $a[0], theta = $a[1] == null ? nil : $a[1], $b;
            return $$$("Complex").$polar(r["$**"](other), $rb_times(theta, other));
          } else {
            return self3.$__coerced__("**", other);
          }
          ;
        });
        $def(self2, "$abs", function $$abs() {
          var self3 = this;
          return $$$("Math").$hypot(self3.real, self3.imag);
        });
        $def(self2, "$abs2", function $$abs2() {
          var self3 = this;
          return $rb_plus($rb_times(self3.real, self3.real), $rb_times(self3.imag, self3.imag));
        });
        $def(self2, "$angle", function $$angle() {
          var self3 = this;
          return $$$("Math").$atan2(self3.imag, self3.real);
        });
        $def(self2, "$conj", function $$conj() {
          var self3 = this;
          return $Kernel.$Complex(self3.real, self3.imag["$-@"]());
        });
        $def(self2, "$denominator", function $$denominator() {
          var self3 = this;
          return self3.real.$denominator().$lcm(self3.imag.$denominator());
        });
        $def(self2, "$eql?", function $Complex_eql$ques$8(other) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($truthy($ret_or_1 = $truthy($ret_or_2 = $$("Complex")["$==="](other)) ? self3.real.$class()["$=="](self3.imag.$class()) : $ret_or_2)) {
            return self3["$=="](other);
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$fdiv", function $$fdiv(other) {
          var self3 = this;
          if (!$eqeqeq($$$("Numeric"), other)) {
            $Kernel.$raise($$$("TypeError"), "" + other.$class() + " can't be coerced into Complex");
          }
          ;
          return $rb_divide(self3, other);
        });
        $def(self2, "$finite?", function $Complex_finite$ques$9() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.real["$finite?"]())) {
            return self3.imag["$finite?"]();
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return "Complex:" + self3.real + ":" + self3.imag;
        });
        $def(self2, "$infinite?", function $Complex_infinite$ques$10() {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = self3.real["$infinite?"]())) {
            return $ret_or_1;
          } else {
            return self3.imag["$infinite?"]();
          }
        });
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          return "(" + self3 + ")";
        });
        $def(self2, "$numerator", function $$numerator() {
          var self3 = this, d = nil;
          d = self3.$denominator();
          return $Kernel.$Complex($rb_times(self3.real.$numerator(), $rb_divide(d, self3.real.$denominator())), $rb_times(self3.imag.$numerator(), $rb_divide(d, self3.imag.$denominator())));
        });
        $def(self2, "$polar", function $$polar() {
          var self3 = this;
          return [self3.$abs(), self3.$arg()];
        });
        $def(self2, "$rationalize", function $$rationalize(eps) {
          var self3 = this;
          ;
          if (arguments.length > 1) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " for 0..1)");
          }
          ;
          if ($neqeq(self3.imag, 0)) {
            $Kernel.$raise($$$("RangeError"), "can't convert " + self3 + " into Rational");
          }
          ;
          return self3.$real().$rationalize(eps);
        }, -1);
        $def(self2, "$real?", $return_val(false));
        $def(self2, "$rect", function $$rect() {
          var self3 = this;
          return [self3.real, self3.imag];
        });
        $def(self2, "$to_f", function $$to_f() {
          var self3 = this;
          if (!$eqeq(self3.imag, 0)) {
            $Kernel.$raise($$$("RangeError"), "can't convert " + self3 + " into Float");
          }
          ;
          return self3.real.$to_f();
        });
        $def(self2, "$to_i", function $$to_i() {
          var self3 = this;
          if (!$eqeq(self3.imag, 0)) {
            $Kernel.$raise($$$("RangeError"), "can't convert " + self3 + " into Integer");
          }
          ;
          return self3.real.$to_i();
        });
        $def(self2, "$to_r", function $$to_r() {
          var self3 = this;
          if (!$eqeq(self3.imag, 0)) {
            $Kernel.$raise($$$("RangeError"), "can't convert " + self3 + " into Rational");
          }
          ;
          return self3.real.$to_r();
        });
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this, result = nil;
          result = self3.real.$inspect();
          result = $rb_plus(result, $eqeqeq($$$("Number"), self3.imag) && $truthy(self3.imag["$nan?"]()) || $truthy(self3.imag["$positive?"]()) || $truthy(self3.imag["$zero?"]()) ? "+" : "-");
          result = $rb_plus(result, self3.imag.$abs().$inspect());
          if ($eqeqeq($$$("Number"), self3.imag) && ($truthy(self3.imag["$nan?"]()) || $truthy(self3.imag["$infinite?"]()))) {
            result = $rb_plus(result, "*");
          }
          ;
          return $rb_plus(result, "i");
        });
        $const_set($nesting2[0], "I", self2.$new(0, 1));
        $defs(self2, "$from_string", function $$from_string(str) {
          var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/, match = str.match(re), real, imag, denominator;
          function isFloat() {
            return re.test(str);
          }
          function cutFloat() {
            var match2 = str.match(re);
            var number = match2[0];
            str = str.slice(number.length);
            return number.replace(/_/g, "");
          }
          function cutNumber() {
            if (isFloat()) {
              var numerator = parseFloat(cutFloat());
              if (str[0] === "/") {
                str = str.slice(1);
                if (isFloat()) {
                  var denominator2 = parseFloat(cutFloat());
                  return $Kernel.$Rational(numerator, denominator2);
                } else {
                  str = "/" + str;
                  return numerator;
                }
              } else {
                return numerator;
              }
            } else {
              return null;
            }
          }
          real = cutNumber();
          if (!real) {
            if (str[0] === "i") {
              return $Kernel.$Complex(0, 1);
            }
            if (str[0] === "-" && str[1] === "i") {
              return $Kernel.$Complex(0, -1);
            }
            if (str[0] === "+" && str[1] === "i") {
              return $Kernel.$Complex(0, 1);
            }
            return $Kernel.$Complex(0, 0);
          }
          imag = cutNumber();
          if (!imag) {
            if (str[0] === "i") {
              return $Kernel.$Complex(0, real);
            } else {
              return $Kernel.$Complex(real, 0);
            }
          } else {
            return $Kernel.$Complex(real, imag);
          }
        });
        (function(self3, $parent_nesting2) {
          return $alias(self3, "rectangular", "rect");
        })(Opal2.get_singleton_class(self2), $nesting2);
        $alias(self2, "arg", "angle");
        $alias(self2, "conjugate", "conj");
        $alias(self2, "divide", "/");
        $alias(self2, "imaginary", "imag");
        $alias(self2, "magnitude", "abs");
        $alias(self2, "phase", "arg");
        $alias(self2, "quo", "/");
        $alias(self2, "rectangular", "rect");
        Opal2.udef(self2, "$negative?");
        ;
        Opal2.udef(self2, "$positive?");
        ;
        Opal2.udef(self2, "$step");
        ;
        return nil;
        ;
      }("::", $$$("Numeric"), $nesting);
    };
    Opal.modules["corelib/rational/base"] = function(Opal2) {
      var $module = Opal2.module, $def = Opal2.def, $klass = Opal2.klass, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("convert,from_string");
      (function($base) {
        var self = $module($base, "Kernel");
        return $def(self, "$Rational", function $$Rational(numerator, denominator) {
          if (denominator == null)
            denominator = 1;
          return $$$("Rational").$convert(numerator, denominator);
        }, -2);
      })("::");
      return function($base, $super) {
        var self = $klass($base, $super, "String");
        return $def(self, "$to_r", function $$to_r() {
          var self2 = this;
          return $$$("Rational").$from_string(self2);
        });
      }("::", null);
    };
    Opal.modules["corelib/rational"] = function(Opal2) {
      var $klass = Opal2.klass, $eqeq = Opal2.eqeq, $Kernel = Opal2.Kernel, $truthy = Opal2.truthy, $rb_lt = Opal2.rb_lt, $rb_divide = Opal2.rb_divide, $defs = Opal2.defs, $eqeqeq = Opal2.eqeqeq, $not = Opal2.not, $Opal = Opal2.Opal, $def = Opal2.def, $return_ivar = Opal2.return_ivar, $rb_minus = Opal2.rb_minus, $rb_times = Opal2.rb_times, $rb_plus = Opal2.rb_plus, $rb_gt = Opal2.rb_gt, $rb_le = Opal2.rb_le, $return_self = Opal2.return_self, $alias = Opal2.alias, self = Opal2.top, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send");
      self.$require("corelib/numeric");
      self.$require("corelib/rational/base");
      return function($base, $super) {
        var self2 = $klass($base, $super, "Rational");
        var $proto = self2.$$prototype;
        $proto.num = $proto.den = nil;
        $defs(self2, "$reduce", function $$reduce(num, den) {
          var self3 = this, gcd = nil;
          num = num.$to_i();
          den = den.$to_i();
          if ($eqeq(den, 0)) {
            $Kernel.$raise($$$("ZeroDivisionError"), "divided by 0");
          } else if ($truthy($rb_lt(den, 0))) {
            num = num["$-@"]();
            den = den["$-@"]();
          } else if ($eqeq(den, 1)) {
            return self3.$new(num, den);
          }
          ;
          gcd = num.$gcd(den);
          return self3.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
        });
        $defs(self2, "$convert", function $$convert(num, den) {
          var self3 = this;
          if ($truthy(num["$nil?"]()) || $truthy(den["$nil?"]())) {
            $Kernel.$raise($$$("TypeError"), "cannot convert nil into Rational");
          }
          ;
          if ($eqeqeq($$$("Integer"), num) && $eqeqeq($$$("Integer"), den)) {
            return self3.$reduce(num, den);
          }
          ;
          if ($eqeqeq($$$("Float"), num) || $eqeqeq($$$("String"), num) || $eqeqeq($$$("Complex"), num)) {
            num = num.$to_r();
          }
          ;
          if ($eqeqeq($$$("Float"), den) || $eqeqeq($$$("String"), den) || $eqeqeq($$$("Complex"), den)) {
            den = den.$to_r();
          }
          ;
          if ($truthy(den["$equal?"](1)) && $not($$$("Integer")["$==="](num))) {
            return $Opal["$coerce_to!"](num, $$$("Rational"), "to_r");
          } else if ($eqeqeq($$$("Numeric"), num) && $eqeqeq($$$("Numeric"), den)) {
            return $rb_divide(num, den);
          } else {
            return self3.$reduce(num, den);
          }
          ;
        });
        $def(self2, "$initialize", function $$initialize(num, den) {
          var self3 = this;
          self3.num = num;
          self3.den = den;
          return self3.$freeze();
        });
        $def(self2, "$numerator", $return_ivar("num"));
        $def(self2, "$denominator", $return_ivar("den"));
        $def(self2, "$coerce", function $$coerce(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            return [other, self3];
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            return [other.$to_r(), self3];
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return [other, self3.$to_f()];
          } else {
            return nil;
          }
        });
        $def(self2, "$==", function $Rational_$eq_eq$1(other) {
          var self3 = this, $ret_or_1 = nil, $ret_or_2 = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            if ($truthy($ret_or_2 = self3.num["$=="](other.$numerator()))) {
              return self3.den["$=="](other.$denominator());
            } else {
              return $ret_or_2;
            }
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            if ($truthy($ret_or_2 = self3.num["$=="](other))) {
              return self3.den["$=="](1);
            } else {
              return $ret_or_2;
            }
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return self3.$to_f()["$=="](other);
          } else {
            return other["$=="](self3);
          }
        });
        $def(self2, "$<=>", function $Rational_$lt_eq_gt$2(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            return $rb_minus($rb_times(self3.num, other.$denominator()), $rb_times(self3.den, other.$numerator()))["$<=>"](0);
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            return $rb_minus(self3.num, $rb_times(self3.den, other))["$<=>"](0);
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return self3.$to_f()["$<=>"](other);
          } else {
            return self3.$__coerced__("<=>", other);
          }
        });
        $def(self2, "$+", function $Rational_$plus$3(other) {
          var self3 = this, $ret_or_1 = nil, num = nil, den = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            num = $rb_plus($rb_times(self3.num, other.$denominator()), $rb_times(self3.den, other.$numerator()));
            den = $rb_times(self3.den, other.$denominator());
            return $Kernel.$Rational(num, den);
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            return $Kernel.$Rational($rb_plus(self3.num, $rb_times(other, self3.den)), self3.den);
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return $rb_plus(self3.$to_f(), other);
          } else {
            return self3.$__coerced__("+", other);
          }
        });
        $def(self2, "$-", function $Rational_$minus$4(other) {
          var self3 = this, $ret_or_1 = nil, num = nil, den = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            num = $rb_minus($rb_times(self3.num, other.$denominator()), $rb_times(self3.den, other.$numerator()));
            den = $rb_times(self3.den, other.$denominator());
            return $Kernel.$Rational(num, den);
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            return $Kernel.$Rational($rb_minus(self3.num, $rb_times(other, self3.den)), self3.den);
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return $rb_minus(self3.$to_f(), other);
          } else {
            return self3.$__coerced__("-", other);
          }
        });
        $def(self2, "$*", function $Rational_$$5(other) {
          var self3 = this, $ret_or_1 = nil, num = nil, den = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            num = $rb_times(self3.num, other.$numerator());
            den = $rb_times(self3.den, other.$denominator());
            return $Kernel.$Rational(num, den);
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            return $Kernel.$Rational($rb_times(self3.num, other), self3.den);
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return $rb_times(self3.$to_f(), other);
          } else {
            return self3.$__coerced__("*", other);
          }
        });
        $def(self2, "$/", function $Rational_$slash$6(other) {
          var self3 = this, $ret_or_1 = nil, num = nil, den = nil;
          if ($eqeqeq($$$("Rational"), $ret_or_1 = other)) {
            num = $rb_times(self3.num, other.$denominator());
            den = $rb_times(self3.den, other.$numerator());
            return $Kernel.$Rational(num, den);
          } else if ($eqeqeq($$$("Integer"), $ret_or_1)) {
            if ($eqeq(other, 0)) {
              return $rb_divide(self3.$to_f(), 0);
            } else {
              return $Kernel.$Rational(self3.num, $rb_times(self3.den, other));
            }
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return $rb_divide(self3.$to_f(), other);
          } else {
            return self3.$__coerced__("/", other);
          }
        });
        $def(self2, "$**", function $Rational_$$$7(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($eqeqeq($$$("Integer"), $ret_or_1 = other)) {
            if ($eqeq(self3, 0) && $truthy($rb_lt(other, 0))) {
              return $$$($$$("Float"), "INFINITY");
            } else if ($truthy($rb_gt(other, 0))) {
              return $Kernel.$Rational(self3.num["$**"](other), self3.den["$**"](other));
            } else if ($truthy($rb_lt(other, 0))) {
              return $Kernel.$Rational(self3.den["$**"](other["$-@"]()), self3.num["$**"](other["$-@"]()));
            } else {
              return $Kernel.$Rational(1, 1);
            }
          } else if ($eqeqeq($$$("Float"), $ret_or_1)) {
            return self3.$to_f()["$**"](other);
          } else if ($eqeqeq($$$("Rational"), $ret_or_1)) {
            if ($eqeq(other, 0)) {
              return $Kernel.$Rational(1, 1);
            } else if ($eqeq(other.$denominator(), 1)) {
              if ($truthy($rb_lt(other, 0))) {
                return $Kernel.$Rational(self3.den["$**"](other.$numerator().$abs()), self3.num["$**"](other.$numerator().$abs()));
              } else {
                return $Kernel.$Rational(self3.num["$**"](other.$numerator()), self3.den["$**"](other.$numerator()));
              }
            } else if ($eqeq(self3, 0) && $truthy($rb_lt(other, 0))) {
              return $Kernel.$raise($$$("ZeroDivisionError"), "divided by 0");
            } else {
              return self3.$to_f()["$**"](other);
            }
          } else {
            return self3.$__coerced__("**", other);
          }
        });
        $def(self2, "$abs", function $$abs() {
          var self3 = this;
          return $Kernel.$Rational(self3.num.$abs(), self3.den.$abs());
        });
        $def(self2, "$ceil", function $$ceil(precision) {
          var self3 = this;
          if (precision == null)
            precision = 0;
          if ($eqeq(precision, 0)) {
            return $rb_divide(self3.num["$-@"](), self3.den)["$-@"]().$ceil();
          } else {
            return self3.$with_precision("ceil", precision);
          }
          ;
        }, -1);
        $def(self2, "$floor", function $$floor(precision) {
          var self3 = this;
          if (precision == null)
            precision = 0;
          if ($eqeq(precision, 0)) {
            return $rb_divide(self3.num["$-@"](), self3.den)["$-@"]().$floor();
          } else {
            return self3.$with_precision("floor", precision);
          }
          ;
        }, -1);
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return "Rational:" + self3.num + ":" + self3.den;
        });
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          return "(" + self3 + ")";
        });
        $def(self2, "$rationalize", function $$rationalize(eps) {
          var self3 = this;
          ;
          if (arguments.length > 1) {
            $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (" + arguments.length + " for 0..1)");
          }
          if (eps == null) {
            return self3;
          }
          var e = eps.$abs(), a = $rb_minus(self3, e), b = $rb_plus(self3, e);
          var p0 = 0, p1 = 1, q0 = 1, q1 = 0, p2, q2;
          var c, k, t2;
          while (true) {
            c = a.$ceil();
            if ($rb_le(c, b)) {
              break;
            }
            k = c - 1;
            p2 = k * p1 + p0;
            q2 = k * q1 + q0;
            t2 = $rb_divide(1, $rb_minus(b, k));
            b = $rb_divide(1, $rb_minus(a, k));
            a = t2;
            p0 = p1;
            q0 = q1;
            p1 = p2;
            q1 = q2;
          }
          return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
          ;
        }, -1);
        $def(self2, "$round", function $$round(precision) {
          var self3 = this, num = nil, den = nil, approx = nil;
          if (precision == null)
            precision = 0;
          if (!$eqeq(precision, 0)) {
            return self3.$with_precision("round", precision);
          }
          ;
          if ($eqeq(self3.num, 0)) {
            return 0;
          }
          ;
          if ($eqeq(self3.den, 1)) {
            return self3.num;
          }
          ;
          num = $rb_plus($rb_times(self3.num.$abs(), 2), self3.den);
          den = $rb_times(self3.den, 2);
          approx = $rb_divide(num, den).$truncate();
          if ($truthy($rb_lt(self3.num, 0))) {
            return approx["$-@"]();
          } else {
            return approx;
          }
          ;
        }, -1);
        $def(self2, "$to_f", function $$to_f() {
          var self3 = this;
          return $rb_divide(self3.num, self3.den);
        });
        $def(self2, "$to_i", function $$to_i() {
          var self3 = this;
          return self3.$truncate();
        });
        $def(self2, "$to_r", $return_self);
        $def(self2, "$to_s", function $$to_s() {
          var self3 = this;
          return "" + self3.num + "/" + self3.den;
        });
        $def(self2, "$truncate", function $$truncate(precision) {
          var self3 = this;
          if (precision == null)
            precision = 0;
          if ($eqeq(precision, 0)) {
            if ($truthy($rb_lt(self3.num, 0))) {
              return self3.$ceil();
            } else {
              return self3.$floor();
            }
          } else {
            return self3.$with_precision("truncate", precision);
          }
          ;
        }, -1);
        $def(self2, "$with_precision", function $$with_precision(method, precision) {
          var self3 = this, p = nil, s = nil;
          if (!$eqeqeq($$$("Integer"), precision)) {
            $Kernel.$raise($$$("TypeError"), "not an Integer");
          }
          ;
          p = 10["$**"](precision);
          s = $rb_times(self3, p);
          if ($truthy($rb_lt(precision, 1))) {
            return $rb_divide(s.$send(method), p).$to_i();
          } else {
            return $Kernel.$Rational(s.$send(method), p);
          }
          ;
        });
        $defs(self2, "$from_string", function $$from_string(string) {
          var str = string.trimLeft(), re = /^[+-]?[\d_]+(\.[\d_]+)?/, match = str.match(re), numerator, denominator;
          function isFloat() {
            return re.test(str);
          }
          function cutFloat() {
            var match2 = str.match(re);
            var number = match2[0];
            str = str.slice(number.length);
            return number.replace(/_/g, "");
          }
          if (isFloat()) {
            numerator = parseFloat(cutFloat());
            if (str[0] === "/") {
              str = str.slice(1);
              if (isFloat()) {
                denominator = parseFloat(cutFloat());
                return $Kernel.$Rational(numerator, denominator);
              } else {
                return $Kernel.$Rational(numerator, 1);
              }
            } else {
              return $Kernel.$Rational(numerator, 1);
            }
          } else {
            return $Kernel.$Rational(0, 1);
          }
        });
        $alias(self2, "divide", "/");
        return $alias(self2, "quo", "/");
      }("::", $$$("Numeric"));
    };
    Opal.modules["corelib/time"] = function(Opal2) {
      var $slice = Opal2.slice, $deny_frozen_access = Opal2.deny_frozen_access, $klass = Opal2.klass, $Kernel = Opal2.Kernel, $Opal = Opal2.Opal, $defs = Opal2.defs, $eqeqeq = Opal2.eqeqeq, $def = Opal2.def, $truthy = Opal2.truthy, $rb_gt = Opal2.rb_gt, $rb_lt = Opal2.rb_lt, $send = Opal2.send, $rb_plus = Opal2.rb_plus, $rb_divide = Opal2.rb_divide, $rb_minus = Opal2.rb_minus, $range = Opal2.range, $neqeq = Opal2.neqeq, $rb_le = Opal2.rb_le, $eqeq = Opal2.eqeq, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?");
      self.$require("corelib/comparable");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Time");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        self2.$include($$$("Comparable"));
        var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], short_days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], long_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        ;
        $defs(self2, "$at", function $$at(seconds, frac) {
          ;
          var result;
          if ($$$("Time")["$==="](seconds)) {
            if (frac !== void 0) {
              $Kernel.$raise($$$("TypeError"), "can't convert Time into an exact number");
            }
            result = new Date(seconds.getTime());
            result.timezone = seconds.timezone;
            return result;
          }
          if (!seconds.$$is_number) {
            seconds = $Opal["$coerce_to!"](seconds, $$$("Integer"), "to_int");
          }
          if (frac === void 0) {
            return new Date(seconds * 1e3);
          }
          if (!frac.$$is_number) {
            frac = $Opal["$coerce_to!"](frac, $$$("Integer"), "to_int");
          }
          return new Date(seconds * 1e3 + frac / 1e3);
          ;
        }, -2);
        function time_params(year, month, day, hour, min, sec) {
          if (year.$$is_string) {
            year = parseInt(year, 10);
          } else {
            year = $Opal["$coerce_to!"](year, $$$("Integer"), "to_int");
          }
          if (month === nil) {
            month = 1;
          } else if (!month.$$is_number) {
            if (month["$respond_to?"]("to_str")) {
              month = month.$to_str();
              switch (month.toLowerCase()) {
                case "jan":
                  month = 1;
                  break;
                case "feb":
                  month = 2;
                  break;
                case "mar":
                  month = 3;
                  break;
                case "apr":
                  month = 4;
                  break;
                case "may":
                  month = 5;
                  break;
                case "jun":
                  month = 6;
                  break;
                case "jul":
                  month = 7;
                  break;
                case "aug":
                  month = 8;
                  break;
                case "sep":
                  month = 9;
                  break;
                case "oct":
                  month = 10;
                  break;
                case "nov":
                  month = 11;
                  break;
                case "dec":
                  month = 12;
                  break;
                default:
                  month = month.$to_i();
              }
            } else {
              month = $Opal["$coerce_to!"](month, $$$("Integer"), "to_int");
            }
          }
          if (month < 1 || month > 12) {
            $Kernel.$raise($$$("ArgumentError"), "month out of range: " + month);
          }
          month = month - 1;
          if (day === nil) {
            day = 1;
          } else if (day.$$is_string) {
            day = parseInt(day, 10);
          } else {
            day = $Opal["$coerce_to!"](day, $$$("Integer"), "to_int");
          }
          if (day < 1 || day > 31) {
            $Kernel.$raise($$$("ArgumentError"), "day out of range: " + day);
          }
          if (hour === nil) {
            hour = 0;
          } else if (hour.$$is_string) {
            hour = parseInt(hour, 10);
          } else {
            hour = $Opal["$coerce_to!"](hour, $$$("Integer"), "to_int");
          }
          if (hour < 0 || hour > 24) {
            $Kernel.$raise($$$("ArgumentError"), "hour out of range: " + hour);
          }
          if (min === nil) {
            min = 0;
          } else if (min.$$is_string) {
            min = parseInt(min, 10);
          } else {
            min = $Opal["$coerce_to!"](min, $$$("Integer"), "to_int");
          }
          if (min < 0 || min > 59) {
            $Kernel.$raise($$$("ArgumentError"), "min out of range: " + min);
          }
          if (sec === nil) {
            sec = 0;
          } else if (!sec.$$is_number) {
            if (sec.$$is_string) {
              sec = parseInt(sec, 10);
            } else {
              sec = $Opal["$coerce_to!"](sec, $$$("Integer"), "to_int");
            }
          }
          if (sec < 0 || sec > 60) {
            $Kernel.$raise($$$("ArgumentError"), "sec out of range: " + sec);
          }
          return [year, month, day, hour, min, sec];
        }
        ;
        $defs(self2, "$new", function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
          var self3 = this;
          ;
          if (month == null)
            month = nil;
          if (day == null)
            day = nil;
          if (hour == null)
            hour = nil;
          if (min == null)
            min = nil;
          if (sec == null)
            sec = nil;
          if (utc_offset == null)
            utc_offset = nil;
          var args, result, timezone, utc_date;
          if (year === void 0) {
            return new Date();
          }
          args = time_params(year, month, day, hour, min, sec);
          year = args[0];
          month = args[1];
          day = args[2];
          hour = args[3];
          min = args[4];
          sec = args[5];
          if (utc_offset === nil) {
            result = new Date(year, month, day, hour, min, 0, sec * 1e3);
            if (year < 100) {
              result.setFullYear(year);
            }
            return result;
          }
          timezone = self3.$_parse_offset(utc_offset);
          utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1e3));
          if (year < 100) {
            utc_date.setUTCFullYear(year);
          }
          result = new Date(utc_date.getTime() - timezone * 36e5);
          result.timezone = timezone;
          return result;
          ;
        }, -1);
        $defs(self2, "$_parse_offset", function $$_parse_offset(utc_offset) {
          var timezone;
          if (utc_offset.$$is_string) {
            if (utc_offset == "UTC") {
              timezone = 0;
            } else if (/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
              var sign, hours, minutes;
              sign = utc_offset[0];
              hours = +(utc_offset[1] + utc_offset[2]);
              minutes = +(utc_offset[4] + utc_offset[5]);
              timezone = (sign == "-" ? -1 : 1) * (hours + minutes / 60);
            } else {
              $Kernel.$raise($$$("ArgumentError"), '"+HH:MM", "-HH:MM", "UTC" expected for utc_offset: ' + utc_offset);
            }
          } else if (utc_offset.$$is_number) {
            timezone = utc_offset / 3600;
          } else {
            $Kernel.$raise($$$("ArgumentError"), "Opal doesn't support other types for a timezone argument than Integer and String");
          }
          return timezone;
        });
        $defs(self2, "$local", function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
          if (month == null)
            month = nil;
          if (day == null)
            day = nil;
          if (hour == null)
            hour = nil;
          if (min == null)
            min = nil;
          if (sec == null)
            sec = nil;
          if (millisecond == null)
            millisecond = nil;
          if (_dummy1 == null)
            _dummy1 = nil;
          if (_dummy2 == null)
            _dummy2 = nil;
          if (_dummy3 == null)
            _dummy3 = nil;
          var args, result;
          if (arguments.length === 10) {
            args = $slice(arguments);
            year = args[5];
            month = args[4];
            day = args[3];
            hour = args[2];
            min = args[1];
            sec = args[0];
          }
          args = time_params(year, month, day, hour, min, sec);
          year = args[0];
          month = args[1];
          day = args[2];
          hour = args[3];
          min = args[4];
          sec = args[5];
          result = new Date(year, month, day, hour, min, 0, sec * 1e3);
          if (year < 100) {
            result.setFullYear(year);
          }
          return result;
          ;
        }, -2);
        $defs(self2, "$gm", function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
          if (month == null)
            month = nil;
          if (day == null)
            day = nil;
          if (hour == null)
            hour = nil;
          if (min == null)
            min = nil;
          if (sec == null)
            sec = nil;
          if (millisecond == null)
            millisecond = nil;
          if (_dummy1 == null)
            _dummy1 = nil;
          if (_dummy2 == null)
            _dummy2 = nil;
          if (_dummy3 == null)
            _dummy3 = nil;
          var args, result;
          if (arguments.length === 10) {
            args = $slice(arguments);
            year = args[5];
            month = args[4];
            day = args[3];
            hour = args[2];
            min = args[1];
            sec = args[0];
          }
          args = time_params(year, month, day, hour, min, sec);
          year = args[0];
          month = args[1];
          day = args[2];
          hour = args[3];
          min = args[4];
          sec = args[5];
          result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1e3));
          if (year < 100) {
            result.setUTCFullYear(year);
          }
          result.timezone = 0;
          return result;
          ;
        }, -2);
        $defs(self2, "$now", function $$now() {
          var self3 = this;
          return self3.$new();
        });
        $def(self2, "$+", function $Time_$plus$2(other) {
          var self3 = this;
          if ($eqeqeq($$$("Time"), other)) {
            $Kernel.$raise($$$("TypeError"), "time + time?");
          }
          ;
          if (!other.$$is_number) {
            other = $Opal["$coerce_to!"](other, $$$("Integer"), "to_int");
          }
          var result = new Date(self3.getTime() + other * 1e3);
          result.timezone = self3.timezone;
          return result;
          ;
        });
        $def(self2, "$-", function $Time_$minus$3(other) {
          var self3 = this;
          if ($eqeqeq($$$("Time"), other)) {
            return (self3.getTime() - other.getTime()) / 1e3;
          }
          ;
          if (!other.$$is_number) {
            other = $Opal["$coerce_to!"](other, $$$("Integer"), "to_int");
          }
          var result = new Date(self3.getTime() - other * 1e3);
          result.timezone = self3.timezone;
          return result;
          ;
        });
        $def(self2, "$<=>", function $Time_$lt_eq_gt$4(other) {
          var self3 = this, r = nil;
          if ($eqeqeq($$$("Time"), other)) {
            return self3.$to_f()["$<=>"](other.$to_f());
          } else {
            r = other["$<=>"](self3);
            if ($truthy(r["$nil?"]())) {
              return nil;
            } else if ($truthy($rb_gt(r, 0))) {
              return -1;
            } else if ($truthy($rb_lt(r, 0))) {
              return 1;
            } else {
              return 0;
            }
            ;
          }
        });
        $def(self2, "$==", function $Time_$eq_eq$5(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = $$$("Time")["$==="](other))) {
            return self3.$to_f() === other.$to_f();
          } else {
            return $ret_or_1;
          }
        });
        $def(self2, "$asctime", function $$asctime() {
          var self3 = this;
          return self3.$strftime("%a %b %e %H:%M:%S %Y");
        });
        $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], "each", [], function $Time$6(method, getter, utcgetter, difference) {
          var self3 = $Time$6.$$s == null ? this : $Time$6.$$s;
          if (method == null)
            method = nil;
          if (getter == null)
            getter = nil;
          if (utcgetter == null)
            utcgetter = nil;
          if (difference == null)
            difference = 0;
          return $send(self3, "define_method", [method], function $$7() {
            var self4 = $$7.$$s == null ? this : $$7.$$s;
            return difference + (self4.timezone != null ? new Date(self4.getTime() + self4.timezone * 36e5)[utcgetter]() : self4[getter]());
          }, { $$s: self3 });
        }, { $$arity: -4, $$s: self2 });
        $def(self2, "$yday", function $$yday() {
          var self3 = this, start_of_year = nil, start_of_day = nil, one_day = nil;
          start_of_year = $$("Time").$new(self3.$year()).$to_i();
          start_of_day = $$("Time").$new(self3.$year(), self3.$month(), self3.$day()).$to_i();
          one_day = 86400;
          return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
        });
        $def(self2, "$isdst", function $$isdst() {
          var self3 = this;
          var jan = new Date(self3.getFullYear(), 0, 1), jul = new Date(self3.getFullYear(), 6, 1);
          return self3.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        });
        $def(self2, "$dup", function $$dup() {
          var self3 = this, copy = nil;
          copy = new Date(self3.getTime());
          copy.$copy_instance_variables(self3);
          copy.$initialize_dup(self3);
          return copy;
        });
        $def(self2, "$eql?", function $Time_eql$ques$8(other) {
          var self3 = this, $ret_or_1 = nil;
          if ($truthy($ret_or_1 = other["$is_a?"]($$$("Time")))) {
            return self3["$<=>"](other)["$zero?"]();
          } else {
            return $ret_or_1;
          }
        });
        $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], "each", [], function $Time$9(method, weekday) {
          var self3 = $Time$9.$$s == null ? this : $Time$9.$$s;
          if (method == null)
            method = nil;
          if (weekday == null)
            weekday = nil;
          return $send(self3, "define_method", [method], function $$10() {
            var self4 = $$10.$$s == null ? this : $$10.$$s;
            return self4.$wday() === weekday;
          }, { $$s: self3 });
        }, { $$s: self2 });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return "Time:" + self3.getTime();
        });
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this;
          if ($truthy(self3["$utc?"]())) {
            return self3.$strftime("%Y-%m-%d %H:%M:%S UTC");
          } else {
            return self3.$strftime("%Y-%m-%d %H:%M:%S %z");
          }
        });
        $def(self2, "$succ", function $$succ() {
          var self3 = this;
          var result = new Date(self3.getTime() + 1e3);
          result.timezone = self3.timezone;
          return result;
        });
        $def(self2, "$usec", function $$usec() {
          var self3 = this;
          return self3.getMilliseconds() * 1e3;
        });
        $def(self2, "$zone", function $$zone() {
          var self3 = this;
          if (self3.timezone === 0)
            return "UTC";
          else if (self3.timezone != null)
            return nil;
          var string = self3.toString(), result;
          if (string.indexOf("(") == -1) {
            result = string.match(/[A-Z]{3,4}/)[0];
          } else {
            result = string.match(/\((.+)\)(?:\s|$)/)[1];
          }
          if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
            return RegExp.$1;
          } else {
            return result;
          }
        });
        $def(self2, "$getgm", function $$getgm() {
          var self3 = this;
          var result = new Date(self3.getTime());
          result.timezone = 0;
          return result;
        });
        $def(self2, "$gmtime", function $$gmtime() {
          var self3 = this;
          if (self3.timezone !== 0) {
            $deny_frozen_access(self3);
            self3.timezone = 0;
          }
          return self3;
        });
        $def(self2, "$gmt?", function $Time_gmt$ques$11() {
          var self3 = this;
          return self3.timezone === 0;
        });
        $def(self2, "$gmt_offset", function $$gmt_offset() {
          var self3 = this;
          return self3.timezone != null ? self3.timezone * 60 : -self3.getTimezoneOffset() * 60;
        });
        $def(self2, "$strftime", function $$strftime(format) {
          var self3 = this;
          return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
            var result = "", jd, c, s, zero = flags.indexOf("0") !== -1, pad = flags.indexOf("-") === -1, blank = flags.indexOf("_") !== -1, upcase = flags.indexOf("^") !== -1, invert = flags.indexOf("#") !== -1, colons = (flags.match(":") || []).length;
            width = parseInt(width, 10);
            if (zero && blank) {
              if (flags.indexOf("0") < flags.indexOf("_")) {
                zero = false;
              } else {
                blank = false;
              }
            }
            switch (conv) {
              case "Y":
                result += self3.$year();
                break;
              case "C":
                zero = !blank;
                result += Math.round(self3.$year() / 100);
                break;
              case "y":
                zero = !blank;
                result += self3.$year() % 100;
                break;
              case "m":
                zero = !blank;
                result += self3.$mon();
                break;
              case "B":
                result += long_months[self3.$mon() - 1];
                break;
              case "b":
              case "h":
                blank = !zero;
                result += short_months[self3.$mon() - 1];
                break;
              case "d":
                zero = !blank;
                result += self3.$day();
                break;
              case "e":
                blank = !zero;
                result += self3.$day();
                break;
              case "j":
                zero = !blank;
                width = isNaN(width) ? 3 : width;
                result += self3.$yday();
                break;
              case "H":
                zero = !blank;
                result += self3.$hour();
                break;
              case "k":
                blank = !zero;
                result += self3.$hour();
                break;
              case "I":
                zero = !blank;
                result += self3.$hour() % 12 || 12;
                break;
              case "l":
                blank = !zero;
                result += self3.$hour() % 12 || 12;
                break;
              case "P":
                result += self3.$hour() >= 12 ? "pm" : "am";
                break;
              case "p":
                result += self3.$hour() >= 12 ? "PM" : "AM";
                break;
              case "M":
                zero = !blank;
                result += self3.$min();
                break;
              case "S":
                zero = !blank;
                result += self3.$sec();
                break;
              case "L":
                zero = !blank;
                width = isNaN(width) ? 3 : width;
                result += self3.getMilliseconds();
                break;
              case "N":
                width = isNaN(width) ? 9 : width;
                result += self3.getMilliseconds().toString().$rjust(3, "0");
                result = result.$ljust(width, "0");
                break;
              case "z":
                var offset = self3.timezone == null ? self3.getTimezoneOffset() : -self3.timezone * 60, hours = Math.floor(Math.abs(offset) / 60), minutes = Math.abs(offset) % 60;
                result += offset < 0 ? "+" : "-";
                result += hours < 10 ? "0" : "";
                result += hours;
                if (colons > 0) {
                  result += ":";
                }
                result += minutes < 10 ? "0" : "";
                result += minutes;
                if (colons > 1) {
                  result += ":00";
                }
                break;
              case "Z":
                result += self3.$zone();
                break;
              case "A":
                result += days_of_week[self3.$wday()];
                break;
              case "a":
                result += short_days[self3.$wday()];
                break;
              case "u":
                result += self3.$wday() + 1;
                break;
              case "w":
                result += self3.$wday();
                break;
              case "V":
                result += self3.$cweek_cyear()["$[]"](0).$to_s().$rjust(2, "0");
                break;
              case "G":
                result += self3.$cweek_cyear()["$[]"](1);
                break;
              case "g":
                result += self3.$cweek_cyear()["$[]"](1)["$[]"]($range(-2, -1, false));
                break;
              case "s":
                result += self3.$to_i();
                break;
              case "n":
                result += "\n";
                break;
              case "t":
                result += "	";
                break;
              case "%":
                result += "%";
                break;
              case "c":
                result += self3.$strftime("%a %b %e %T %Y");
                break;
              case "D":
              case "x":
                result += self3.$strftime("%m/%d/%y");
                break;
              case "F":
                result += self3.$strftime("%Y-%m-%d");
                break;
              case "v":
                result += self3.$strftime("%e-%^b-%4Y");
                break;
              case "r":
                result += self3.$strftime("%I:%M:%S %p");
                break;
              case "R":
                result += self3.$strftime("%H:%M");
                break;
              case "T":
              case "X":
                result += self3.$strftime("%H:%M:%S");
                break;
              case "J":
                jd = self3.$to_date().$jd();
                if (jd < 2405160) {
                  result += self3.$strftime("%Y-%m-%d");
                  break;
                } else if (jd < 2419614)
                  c = "M", s = 1867;
                else if (jd < 2424875)
                  c = "T", s = 1911;
                else if (jd < 2447535)
                  c = "S", s = 1925;
                else if (jd < 2458605)
                  c = "H", s = 1988;
                else
                  c = "R", s = 2018;
                result += self3.$format("%c%02d", c, $rb_minus(self3.$year(), s));
                result += self3.$strftime("-%m-%d");
                break;
              default:
                return full;
            }
            if (upcase) {
              result = result.toUpperCase();
            }
            if (invert) {
              result = result.replace(/[A-Z]/, function(c2) {
                c2.toLowerCase();
              }).replace(/[a-z]/, function(c2) {
                c2.toUpperCase();
              });
            }
            if (pad && (zero || blank)) {
              result = result.$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
            }
            return result;
          });
        });
        $def(self2, "$to_a", function $$to_a() {
          var self3 = this;
          return [self3.$sec(), self3.$min(), self3.$hour(), self3.$day(), self3.$month(), self3.$year(), self3.$wday(), self3.$yday(), self3.$isdst(), self3.$zone()];
        });
        $def(self2, "$to_f", function $$to_f() {
          var self3 = this;
          return self3.getTime() / 1e3;
        });
        $def(self2, "$to_i", function $$to_i() {
          var self3 = this;
          return parseInt(self3.getTime() / 1e3, 10);
        });
        $def(self2, "$cweek_cyear", function $$cweek_cyear() {
          var self3 = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;
          jan01 = $$$("Time").$new(self3.$year(), 1, 1);
          jan01_wday = jan01.$wday();
          first_monday = 0;
          year = self3.$year();
          if ($truthy($rb_le(jan01_wday, 4)) && $neqeq(jan01_wday, 0)) {
            offset = $rb_minus(jan01_wday, 1);
          } else {
            offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
            if ($eqeq(offset, -8)) {
              offset = -1;
            }
            ;
          }
          ;
          week = $rb_divide($rb_plus(self3.$yday(), offset), 7).$ceil();
          if ($truthy($rb_le(week, 0))) {
            return $$$("Time").$new($rb_minus(self3.$year(), 1), 12, 31).$cweek_cyear();
          } else if ($eqeq(week, 53)) {
            dec31 = $$$("Time").$new(self3.$year(), 12, 31);
            dec31_wday = dec31.$wday();
            if ($truthy($rb_le(dec31_wday, 3)) && $neqeq(dec31_wday, 0)) {
              week = 1;
              year = $rb_plus(year, 1);
            }
            ;
          }
          ;
          return [week, year];
        });
        (function(self3, $parent_nesting2) {
          $alias(self3, "mktime", "local");
          return $alias(self3, "utc", "gm");
        })(Opal2.get_singleton_class(self2), $nesting2);
        $alias(self2, "ctime", "asctime");
        $alias(self2, "dst?", "isdst");
        $alias(self2, "getutc", "getgm");
        $alias(self2, "gmtoff", "gmt_offset");
        $alias(self2, "mday", "day");
        $alias(self2, "month", "mon");
        $alias(self2, "to_s", "inspect");
        $alias(self2, "tv_sec", "to_i");
        $alias(self2, "tv_usec", "usec");
        $alias(self2, "utc", "gmtime");
        $alias(self2, "utc?", "gmt?");
        return $alias(self2, "utc_offset", "gmt_offset");
      }("::", Date, $nesting);
    };
    Opal.modules["corelib/struct"] = function(Opal2) {
      var $klass = Opal2.klass, $slice = Opal2.slice, $extract_kwargs = Opal2.extract_kwargs, $ensure_kwargs = Opal2.ensure_kwargs, $truthy = Opal2.truthy, $neqeq = Opal2.neqeq, $eqeq = Opal2.eqeq, $Opal = Opal2.Opal, $send = Opal2.send, $Class = Opal2.Class, $to_a = Opal2.to_a, $def = Opal2.def, $defs = Opal2.defs, $Kernel = Opal2.Kernel, $hash2 = Opal2.hash2, $rb_gt = Opal2.rb_gt, $rb_minus = Opal2.rb_minus, $eqeqeq = Opal2.eqeqeq, $rb_lt = Opal2.rb_lt, $rb_ge = Opal2.rb_ge, $rb_plus = Opal2.rb_plus, $alias = Opal2.alias, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig");
      self.$require("corelib/enumerable");
      return function($base, $super, $parent_nesting) {
        var self2 = $klass($base, $super, "Struct");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        self2.$include($$$("Enumerable"));
        $defs(self2, "$new", function $Struct_new$1(const_name, $a, $b) {
          var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self3 = this, klass = nil;
          $Struct_new$1.$$p = null;
          ;
          $post_args = $slice(arguments, 1);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          args = $post_args;
          keyword_init = $kwargs.$$smap["keyword_init"];
          if (keyword_init == null)
            keyword_init = false;
          if ($truthy(const_name)) {
            if ($eqeq(const_name.$class(), $$$("String")) && $neqeq(const_name["$[]"](0).$upcase(), const_name["$[]"](0))) {
              args.$unshift(const_name);
              const_name = nil;
            } else {
              try {
                const_name = $Opal["$const_name!"](const_name);
              } catch ($err) {
                if (Opal2.rescue($err, [$$$("TypeError"), $$$("NameError")])) {
                  try {
                    args.$unshift(const_name);
                    const_name = nil;
                  } finally {
                    Opal2.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
              ;
            }
          }
          ;
          $send(args, "map", [], function $$2(arg) {
            if (arg == null)
              arg = nil;
            return $Opal["$coerce_to!"](arg, $$$("String"), "to_str");
          });
          klass = $send($Class, "new", [self3], function $$3() {
            var self4 = $$3.$$s == null ? this : $$3.$$s;
            $send(args, "each", [], function $$4(arg) {
              var self5 = $$4.$$s == null ? this : $$4.$$s;
              if (arg == null)
                arg = nil;
              return self5.$define_struct_attribute(arg);
            }, { $$s: self4 });
            return function(self5, $parent_nesting2) {
              $def(self5, "$new", function $new$5($a2) {
                var $post_args2, args2, self6 = this, instance = nil;
                $post_args2 = $slice(arguments);
                args2 = $post_args2;
                instance = self6.$allocate();
                instance.$$data = {};
                $send(instance, "initialize", $to_a(args2));
                return instance;
              }, -1);
              return self5.$alias_method("[]", "new");
            }(Opal2.get_singleton_class(self4), $nesting2);
          }, { $$s: self3 });
          if ($truthy(block)) {
            $send(klass, "module_eval", [], block.$to_proc());
          }
          ;
          klass.$$keyword_init = keyword_init;
          if ($truthy(const_name)) {
            $$$("Struct").$const_set(const_name, klass);
          }
          ;
          return klass;
        }, -2);
        $defs(self2, "$define_struct_attribute", function $$define_struct_attribute(name) {
          var self3 = this;
          if ($eqeq(self3, $$$("Struct"))) {
            $Kernel.$raise($$$("ArgumentError"), "you cannot define attributes to the Struct class");
          }
          ;
          self3.$members()["$<<"](name);
          $send(self3, "define_method", [name], function $$6() {
            var self4 = $$6.$$s == null ? this : $$6.$$s;
            return self4.$$data[name];
          }, { $$s: self3 });
          return $send(self3, "define_method", ["" + name + "="], function $$7(value) {
            var self4 = $$7.$$s == null ? this : $$7.$$s;
            if (value == null)
              value = nil;
            return self4.$$data[name] = value;
            ;
          }, { $$s: self3 });
        });
        $defs(self2, "$members", function $$members() {
          var self3 = this, $ret_or_1 = nil;
          if (self3.members == null)
            self3.members = nil;
          if ($eqeq(self3, $$$("Struct"))) {
            $Kernel.$raise($$$("ArgumentError"), "the Struct class has no members");
          }
          ;
          return self3.members = $truthy($ret_or_1 = self3.members) ? $ret_or_1 : [];
        });
        $defs(self2, "$inherited", function $$inherited(klass) {
          var self3 = this, members = nil;
          if (self3.members == null)
            self3.members = nil;
          members = self3.members;
          return $send(klass, "instance_eval", [], function $$8() {
            var self4 = $$8.$$s == null ? this : $$8.$$s;
            return self4.members = members;
          }, { $$s: self3 });
        });
        $def(self2, "$initialize", function $$initialize($a) {
          var $post_args, args, self3 = this, kwargs = nil, $ret_or_1 = nil, extra = nil;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($truthy(self3.$class().$$keyword_init)) {
            kwargs = $truthy($ret_or_1 = args.$last()) ? $ret_or_1 : $hash2([], {});
            if ($truthy($rb_gt(args.$length(), 1)) || $truthy(args.length === 1 && !kwargs.$$is_hash)) {
              $Kernel.$raise($$$("ArgumentError"), "wrong number of arguments (given " + args.$length() + ", expected 0)");
            }
            ;
            extra = $rb_minus(kwargs.$keys(), self3.$class().$members());
            if ($truthy(extra["$any?"]())) {
              $Kernel.$raise($$$("ArgumentError"), "unknown keywords: " + extra.$join(", "));
            }
            ;
            return $send(self3.$class().$members(), "each", [], function $$9(name) {
              var $b, self4 = $$9.$$s == null ? this : $$9.$$s;
              if (name == null)
                name = nil;
              return $b = [name, kwargs["$[]"](name)], $send(self4, "[]=", $b), $b[$b.length - 1];
            }, { $$s: self3 });
          } else {
            if ($truthy($rb_gt(args.$length(), self3.$class().$members().$length()))) {
              $Kernel.$raise($$$("ArgumentError"), "struct size differs");
            }
            ;
            return $send(self3.$class().$members(), "each_with_index", [], function $$10(name, index) {
              var $b, self4 = $$10.$$s == null ? this : $$10.$$s;
              if (name == null)
                name = nil;
              if (index == null)
                index = nil;
              return $b = [name, args["$[]"](index)], $send(self4, "[]=", $b), $b[$b.length - 1];
            }, { $$s: self3 });
          }
          ;
        }, -1);
        $def(self2, "$initialize_copy", function $$initialize_copy(from) {
          var self3 = this;
          self3.$$data = {};
          var keys = Object.keys(from.$$data), i, max, name;
          for (i = 0, max = keys.length; i < max; i++) {
            name = keys[i];
            self3.$$data[name] = from.$$data[name];
          }
        });
        $defs(self2, "$keyword_init?", function $Struct_keyword_init$ques$11() {
          var self3 = this;
          return self3.$$keyword_init;
        });
        $def(self2, "$members", function $$members() {
          var self3 = this;
          return self3.$class().$members();
        });
        $def(self2, "$hash", function $$hash() {
          var self3 = this;
          return $$("Hash").$new(self3.$$data).$hash();
        });
        $def(self2, "$[]", function $Struct_$$$12(name) {
          var self3 = this;
          if ($eqeqeq($$$("Integer"), name)) {
            if ($truthy($rb_lt(name, self3.$class().$members().$size()["$-@"]()))) {
              $Kernel.$raise($$$("IndexError"), "offset " + name + " too small for struct(size:" + self3.$class().$members().$size() + ")");
            }
            ;
            if ($truthy($rb_ge(name, self3.$class().$members().$size()))) {
              $Kernel.$raise($$$("IndexError"), "offset " + name + " too large for struct(size:" + self3.$class().$members().$size() + ")");
            }
            ;
            name = self3.$class().$members()["$[]"](name);
          } else if ($eqeqeq($$$("String"), name)) {
            if (!self3.$$data.hasOwnProperty(name)) {
              $Kernel.$raise($$$("NameError").$new("no member '" + name + "' in struct", name));
            }
          } else {
            $Kernel.$raise($$$("TypeError"), "no implicit conversion of " + name.$class() + " into Integer");
          }
          ;
          name = $Opal["$coerce_to!"](name, $$$("String"), "to_str");
          return self3.$$data[name];
          ;
        });
        $def(self2, "$[]=", function $Struct_$$$eq$13(name, value) {
          var self3 = this;
          if ($eqeqeq($$$("Integer"), name)) {
            if ($truthy($rb_lt(name, self3.$class().$members().$size()["$-@"]()))) {
              $Kernel.$raise($$$("IndexError"), "offset " + name + " too small for struct(size:" + self3.$class().$members().$size() + ")");
            }
            ;
            if ($truthy($rb_ge(name, self3.$class().$members().$size()))) {
              $Kernel.$raise($$$("IndexError"), "offset " + name + " too large for struct(size:" + self3.$class().$members().$size() + ")");
            }
            ;
            name = self3.$class().$members()["$[]"](name);
          } else if ($eqeqeq($$$("String"), name)) {
            if (!$truthy(self3.$class().$members()["$include?"](name.$to_sym()))) {
              $Kernel.$raise($$$("NameError").$new("no member '" + name + "' in struct", name));
            }
          } else {
            $Kernel.$raise($$$("TypeError"), "no implicit conversion of " + name.$class() + " into Integer");
          }
          ;
          name = $Opal["$coerce_to!"](name, $$$("String"), "to_str");
          return self3.$$data[name] = value;
          ;
        });
        $def(self2, "$==", function $Struct_$eq_eq$14(other) {
          var self3 = this;
          if (!$truthy(other["$instance_of?"](self3.$class()))) {
            return false;
          }
          ;
          var recursed1 = {}, recursed2 = {};
          function _eqeq(struct, other2) {
            var key, a, b;
            recursed1[struct.$__id__()] = true;
            recursed2[other2.$__id__()] = true;
            for (key in struct.$$data) {
              a = struct.$$data[key];
              b = other2.$$data[key];
              if ($$$("Struct")["$==="](a)) {
                if (!recursed1.hasOwnProperty(a.$__id__()) || !recursed2.hasOwnProperty(b.$__id__())) {
                  if (!_eqeq(a, b)) {
                    return false;
                  }
                }
              } else {
                if (!a["$=="](b)) {
                  return false;
                }
              }
            }
            return true;
          }
          return _eqeq(self3, other);
          ;
        });
        $def(self2, "$eql?", function $Struct_eql$ques$15(other) {
          var self3 = this;
          if (!$truthy(other["$instance_of?"](self3.$class()))) {
            return false;
          }
          ;
          var recursed1 = {}, recursed2 = {};
          function _eqeq(struct, other2) {
            var key, a, b;
            recursed1[struct.$__id__()] = true;
            recursed2[other2.$__id__()] = true;
            for (key in struct.$$data) {
              a = struct.$$data[key];
              b = other2.$$data[key];
              if ($$$("Struct")["$==="](a)) {
                if (!recursed1.hasOwnProperty(a.$__id__()) || !recursed2.hasOwnProperty(b.$__id__())) {
                  if (!_eqeq(a, b)) {
                    return false;
                  }
                }
              } else {
                if (!a["$eql?"](b)) {
                  return false;
                }
              }
            }
            return true;
          }
          return _eqeq(self3, other);
          ;
        });
        $def(self2, "$each", function $$each() {
          var $yield = $$each.$$p || nil, self3 = this;
          $$each.$$p = null;
          if (!($yield !== nil)) {
            return $send(self3, "enum_for", ["each"], function $$16() {
              var self4 = $$16.$$s == null ? this : $$16.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $send(self3.$class().$members(), "each", [], function $$17(name) {
            var self4 = $$17.$$s == null ? this : $$17.$$s;
            if (name == null)
              name = nil;
            return Opal2.yield1($yield, self4["$[]"](name));
            ;
          }, { $$s: self3 });
          return self3;
        });
        $def(self2, "$each_pair", function $$each_pair() {
          var $yield = $$each_pair.$$p || nil, self3 = this;
          $$each_pair.$$p = null;
          if (!($yield !== nil)) {
            return $send(self3, "enum_for", ["each_pair"], function $$18() {
              var self4 = $$18.$$s == null ? this : $$18.$$s;
              return self4.$size();
            }, { $$s: self3 });
          }
          ;
          $send(self3.$class().$members(), "each", [], function $$19(name) {
            var self4 = $$19.$$s == null ? this : $$19.$$s;
            if (name == null)
              name = nil;
            return Opal2.yield1($yield, [name, self4["$[]"](name)]);
            ;
          }, { $$s: self3 });
          return self3;
        });
        $def(self2, "$length", function $$length() {
          var self3 = this;
          return self3.$class().$members().$length();
        });
        $def(self2, "$to_a", function $$to_a() {
          var self3 = this;
          return $send(self3.$class().$members(), "map", [], function $$20(name) {
            var self4 = $$20.$$s == null ? this : $$20.$$s;
            if (name == null)
              name = nil;
            return self4["$[]"](name);
          }, { $$s: self3 });
        });
        var inspect_stack = [];
        $def(self2, "$inspect", function $$inspect() {
          var self3 = this, result = nil, pushed = nil;
          return function() {
            try {
              result = "#<struct ";
              if ($truthy(inspect_stack["$include?"](self3.$__id__()))) {
                return $rb_plus(result, ":...>");
              } else {
                inspect_stack["$<<"](self3.$__id__());
                pushed = true;
                if ($eqeqeq($$$("Struct"), self3) && $truthy(self3.$class().$name())) {
                  result = $rb_plus(result, "" + self3.$class() + " ");
                }
                ;
                result = $rb_plus(result, $send(self3.$each_pair(), "map", [], function $$21(name, value) {
                  if (name == null)
                    name = nil;
                  if (value == null)
                    value = nil;
                  return "" + name + "=" + $$("Opal").$inspect(value);
                }).$join(", "));
                result = $rb_plus(result, ">");
                return result;
              }
              ;
            } finally {
              $truthy(pushed) ? inspect_stack.pop() : nil;
            }
            ;
          }();
        });
        $def(self2, "$to_h", function $$to_h() {
          var block = $$to_h.$$p || nil, self3 = this;
          $$to_h.$$p = null;
          ;
          if (block !== nil) {
            return $send($send(self3, "map", [], block.$to_proc()), "to_h", $to_a(self3.$args()));
          }
          ;
          return $send(self3.$class().$members(), "each_with_object", [$hash2([], {})], function $$22(name, h) {
            var $a, self4 = $$22.$$s == null ? this : $$22.$$s;
            if (name == null)
              name = nil;
            if (h == null)
              h = nil;
            return $a = [name, self4["$[]"](name)], $send(h, "[]=", $a), $a[$a.length - 1];
          }, { $$s: self3 });
        });
        $def(self2, "$values_at", function $$values_at($a) {
          var $post_args, args, self3 = this;
          $post_args = $slice(arguments);
          args = $post_args;
          args = $send(args, "map", [], function $$23(arg) {
            if (arg == null)
              arg = nil;
            return arg.$$is_range ? arg.$to_a() : arg;
          }).$flatten();
          var result = [];
          for (var i = 0, len = args.length; i < len; i++) {
            if (!args[i].$$is_number) {
              $Kernel.$raise($$$("TypeError"), "no implicit conversion of " + args[i].$class() + " into Integer");
            }
            result.push(self3["$[]"](args[i]));
          }
          return result;
          ;
        }, -1);
        $def(self2, "$dig", function $$dig(key, $a) {
          var $post_args, keys, self3 = this, item = nil;
          $post_args = $slice(arguments, 1);
          keys = $post_args;
          item = $truthy(key.$$is_string && self3.$$data.hasOwnProperty(key)) ? self3.$$data[key] || nil : nil;
          if (item === nil || keys.length === 0) {
            return item;
          }
          ;
          if (!$truthy(item["$respond_to?"]("dig"))) {
            $Kernel.$raise($$$("TypeError"), "" + item.$class() + " does not have #dig method");
          }
          ;
          return $send(item, "dig", $to_a(keys));
        }, -2);
        $alias(self2, "size", "length");
        $alias(self2, "to_s", "inspect");
        return $alias(self2, "values", "to_a");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/set"] = function(Opal2) {
      var $freeze = Opal2.freeze, $klass = Opal2.klass, $slice = Opal2.slice, $defs = Opal2.defs, $hash2 = Opal2.hash2, $truthy = Opal2.truthy, $eqeqeq = Opal2.eqeqeq, $Kernel = Opal2.Kernel, $send = Opal2.send, $def = Opal2.def, $eqeq = Opal2.eqeq, $rb_lt = Opal2.rb_lt, $rb_le = Opal2.rb_le, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("include,new,nil?,===,raise,each,add,merge,class,respond_to?,subtract,dup,join,to_a,equal?,instance_of?,==,instance_variable_get,size,is_a?,all?,include?,[]=,enum_for,[],<<,replace,compare_by_identity,name,compare_by_identity?,delete,select,frozen?,freeze,reject,delete_if,to_proc,keep_if,each_key,empty?,eql?,instance_eval,clear,<,<=,any?,!,intersect?,keys,|,proper_subset?,subset?,proper_superset?,superset?,-,select!,collect!");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Set");
        var $nesting2 = [self].concat($parent_nesting), $$ = Opal2.$r($nesting2), $ret_or_1 = nil, $proto = self.$$prototype;
        $proto.hash = nil;
        self.$include($$$("Enumerable"));
        $defs(self, "$[]", function $Set_$$$1($a) {
          var $post_args, ary, self2 = this;
          $post_args = $slice(arguments);
          ary = $post_args;
          return self2.$new(ary);
        }, -1);
        $def(self, "$initialize", function $$initialize(enum$) {
          var block = $$initialize.$$p || nil, self2 = this;
          $$initialize.$$p = null;
          ;
          if (enum$ == null)
            enum$ = nil;
          self2.hash = $hash2([], {});
          if ($truthy(enum$["$nil?"]())) {
            return nil;
          }
          ;
          if (!$eqeqeq($$$("Enumerable"), enum$)) {
            $Kernel.$raise($$$("ArgumentError"), "value must be enumerable");
          }
          ;
          if ($truthy(block)) {
            return $send(enum$, "each", [], function $$2(item) {
              var self3 = $$2.$$s == null ? this : $$2.$$s;
              if (item == null)
                item = nil;
              return self3.$add(Opal2.yield1(block, item));
            }, { $$s: self2 });
          } else {
            return self2.$merge(enum$);
          }
          ;
        }, -1);
        $def(self, "$dup", function $$dup() {
          var self2 = this, result = nil;
          result = self2.$class().$new();
          return result.$merge(self2);
        });
        $def(self, "$-", function $Set_$minus$3(enum$) {
          var self2 = this;
          if (!$truthy(enum$["$respond_to?"]("each"))) {
            $Kernel.$raise($$$("ArgumentError"), "value must be enumerable");
          }
          ;
          return self2.$dup().$subtract(enum$);
        });
        $def(self, "$inspect", function $$inspect() {
          var self2 = this;
          return "#<Set: {" + self2.$to_a().$join(",") + "}>";
        });
        $def(self, "$==", function $Set_$eq_eq$4(other) {
          var self2 = this;
          if ($truthy(self2["$equal?"](other))) {
            return true;
          } else if ($truthy(other["$instance_of?"](self2.$class()))) {
            return self2.hash["$=="](other.$instance_variable_get("@hash"));
          } else if ($truthy(other["$is_a?"]($$$("Set"))) && $eqeq(self2.$size(), other.$size())) {
            return $send(other, "all?", [], function $$5(o) {
              var self3 = $$5.$$s == null ? this : $$5.$$s;
              if (self3.hash == null)
                self3.hash = nil;
              if (o == null)
                o = nil;
              return self3.hash["$include?"](o);
            }, { $$s: self2 });
          } else {
            return false;
          }
        });
        $def(self, "$add", function $$add(o) {
          var self2 = this;
          self2.hash["$[]="](o, true);
          return self2;
        });
        $def(self, "$classify", function $$classify() {
          var block = $$classify.$$p || nil, self2 = this, result = nil;
          $$classify.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("classify");
          }
          ;
          result = $send($$$("Hash"), "new", [], function $$6(h, k) {
            var $a, self3 = $$6.$$s == null ? this : $$6.$$s;
            if (h == null)
              h = nil;
            if (k == null)
              k = nil;
            return $a = [k, self3.$class().$new()], $send(h, "[]=", $a), $a[$a.length - 1];
          }, { $$s: self2 });
          $send(self2, "each", [], function $$7(item) {
            if (item == null)
              item = nil;
            return result["$[]"](Opal2.yield1(block, item)).$add(item);
          });
          return result;
        });
        $def(self, "$collect!", function $Set_collect$excl$8() {
          var block = $Set_collect$excl$8.$$p || nil, self2 = this, result = nil;
          $Set_collect$excl$8.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("collect!");
          }
          ;
          result = self2.$class().$new();
          $send(self2, "each", [], function $$9(item) {
            if (item == null)
              item = nil;
            return result["$<<"](Opal2.yield1(block, item));
          });
          return self2.$replace(result);
        });
        $def(self, "$compare_by_identity", function $$compare_by_identity() {
          var self2 = this;
          if ($truthy(self2.hash["$respond_to?"]("compare_by_identity"))) {
            self2.hash.$compare_by_identity();
            return self2;
          } else {
            return self2.$raise($$("NotImplementedError"), "" + self2.$class().$name() + "#compare_by_identity is not implemented");
          }
        });
        $def(self, "$compare_by_identity?", function $Set_compare_by_identity$ques$10() {
          var self2 = this, $ret_or_12 = nil;
          if ($truthy($ret_or_12 = self2.hash["$respond_to?"]("compare_by_identity?"))) {
            return self2.hash["$compare_by_identity?"]();
          } else {
            return $ret_or_12;
          }
        });
        $def(self, "$delete", function $Set_delete$11(o) {
          var self2 = this;
          self2.hash.$delete(o);
          return self2;
        });
        $def(self, "$delete?", function $Set_delete$ques$12(o) {
          var self2 = this;
          if ($truthy(self2["$include?"](o))) {
            self2.$delete(o);
            return self2;
          } else {
            return nil;
          }
        });
        $def(self, "$delete_if", function $$delete_if() {
          var $yield = $$delete_if.$$p || nil, self2 = this;
          $$delete_if.$$p = null;
          if (!($yield !== nil)) {
            return self2.$enum_for("delete_if");
          }
          ;
          $send($send(self2, "select", [], function $$13(o) {
            if (o == null)
              o = nil;
            return Opal2.yield1($yield, o);
            ;
          }), "each", [], function $$14(o) {
            var self3 = $$14.$$s == null ? this : $$14.$$s;
            if (self3.hash == null)
              self3.hash = nil;
            if (o == null)
              o = nil;
            return self3.hash.$delete(o);
          }, { $$s: self2 });
          return self2;
        });
        $def(self, "$freeze", function $$freeze() {
          var self2 = this;
          if ($truthy(self2["$frozen?"]())) {
            return self2;
          }
          ;
          self2.hash.$freeze();
          return $freeze(self2);
          ;
        });
        $def(self, "$keep_if", function $$keep_if() {
          var $yield = $$keep_if.$$p || nil, self2 = this;
          $$keep_if.$$p = null;
          if (!($yield !== nil)) {
            return self2.$enum_for("keep_if");
          }
          ;
          $send($send(self2, "reject", [], function $$15(o) {
            if (o == null)
              o = nil;
            return Opal2.yield1($yield, o);
            ;
          }), "each", [], function $$16(o) {
            var self3 = $$16.$$s == null ? this : $$16.$$s;
            if (self3.hash == null)
              self3.hash = nil;
            if (o == null)
              o = nil;
            return self3.hash.$delete(o);
          }, { $$s: self2 });
          return self2;
        });
        $def(self, "$reject!", function $Set_reject$excl$17() {
          var block = $Set_reject$excl$17.$$p || nil, self2 = this, before = nil;
          $Set_reject$excl$17.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("reject!");
          }
          ;
          before = self2.$size();
          $send(self2, "delete_if", [], block.$to_proc());
          if ($eqeq(self2.$size(), before)) {
            return nil;
          } else {
            return self2;
          }
          ;
        });
        $def(self, "$select!", function $Set_select$excl$18() {
          var block = $Set_select$excl$18.$$p || nil, self2 = this, before = nil;
          $Set_select$excl$18.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("select!");
          }
          ;
          before = self2.$size();
          $send(self2, "keep_if", [], block.$to_proc());
          if ($eqeq(self2.$size(), before)) {
            return nil;
          } else {
            return self2;
          }
          ;
        });
        $def(self, "$add?", function $Set_add$ques$19(o) {
          var self2 = this;
          if ($truthy(self2["$include?"](o))) {
            return nil;
          } else {
            return self2.$add(o);
          }
        });
        $def(self, "$each", function $$each() {
          var block = $$each.$$p || nil, self2 = this;
          $$each.$$p = null;
          ;
          if (!(block !== nil)) {
            return self2.$enum_for("each");
          }
          ;
          $send(self2.hash, "each_key", [], block.$to_proc());
          return self2;
        });
        $def(self, "$empty?", function $Set_empty$ques$20() {
          var self2 = this;
          return self2.hash["$empty?"]();
        });
        $def(self, "$eql?", function $Set_eql$ques$21(other) {
          var self2 = this;
          return self2.hash["$eql?"]($send(other, "instance_eval", [], function $$22() {
            var self3 = $$22.$$s == null ? this : $$22.$$s;
            if (self3.hash == null)
              self3.hash = nil;
            return self3.hash;
          }, { $$s: self2 }));
        });
        $def(self, "$clear", function $$clear() {
          var self2 = this;
          self2.hash.$clear();
          return self2;
        });
        $def(self, "$include?", function $Set_include$ques$23(o) {
          var self2 = this;
          return self2.hash["$include?"](o);
        });
        $def(self, "$merge", function $$merge(enum$) {
          var self2 = this;
          $send(enum$, "each", [], function $$24(item) {
            var self3 = $$24.$$s == null ? this : $$24.$$s;
            if (item == null)
              item = nil;
            return self3.$add(item);
          }, { $$s: self2 });
          return self2;
        });
        $def(self, "$replace", function $$replace(enum$) {
          var self2 = this;
          self2.$clear();
          self2.$merge(enum$);
          return self2;
        });
        $def(self, "$size", function $$size() {
          var self2 = this;
          return self2.hash.$size();
        });
        $def(self, "$subtract", function $$subtract(enum$) {
          var self2 = this;
          $send(enum$, "each", [], function $$25(item) {
            var self3 = $$25.$$s == null ? this : $$25.$$s;
            if (item == null)
              item = nil;
            return self3.$delete(item);
          }, { $$s: self2 });
          return self2;
        });
        $def(self, "$|", function $Set_$$26(enum$) {
          var self2 = this;
          if (!$truthy(enum$["$respond_to?"]("each"))) {
            $Kernel.$raise($$$("ArgumentError"), "value must be enumerable");
          }
          ;
          return self2.$dup().$merge(enum$);
        });
        function is_set(set) {
          $truthy($ret_or_1 = set["$is_a?"]($$$("Set"))) ? $ret_or_1 : $Kernel.$raise($$$("ArgumentError"), "value must be a set");
        }
        ;
        $def(self, "$superset?", function $Set_superset$ques$27(set) {
          var self2 = this;
          is_set(set);
          if ($truthy($rb_lt(self2.$size(), set.$size()))) {
            return false;
          }
          ;
          return $send(set, "all?", [], function $$28(o) {
            var self3 = $$28.$$s == null ? this : $$28.$$s;
            if (o == null)
              o = nil;
            return self3["$include?"](o);
          }, { $$s: self2 });
        });
        $def(self, "$proper_superset?", function $Set_proper_superset$ques$29(set) {
          var self2 = this;
          is_set(set);
          if ($truthy($rb_le(self2.$size(), set.$size()))) {
            return false;
          }
          ;
          return $send(set, "all?", [], function $$30(o) {
            var self3 = $$30.$$s == null ? this : $$30.$$s;
            if (o == null)
              o = nil;
            return self3["$include?"](o);
          }, { $$s: self2 });
        });
        $def(self, "$subset?", function $Set_subset$ques$31(set) {
          var self2 = this;
          is_set(set);
          if ($truthy($rb_lt(set.$size(), self2.$size()))) {
            return false;
          }
          ;
          return $send(self2, "all?", [], function $$32(o) {
            if (o == null)
              o = nil;
            return set["$include?"](o);
          });
        });
        $def(self, "$proper_subset?", function $Set_proper_subset$ques$33(set) {
          var self2 = this;
          is_set(set);
          if ($truthy($rb_le(set.$size(), self2.$size()))) {
            return false;
          }
          ;
          return $send(self2, "all?", [], function $$34(o) {
            if (o == null)
              o = nil;
            return set["$include?"](o);
          });
        });
        $def(self, "$intersect?", function $Set_intersect$ques$35(set) {
          var self2 = this;
          is_set(set);
          if ($truthy($rb_lt(self2.$size(), set.$size()))) {
            return $send(self2, "any?", [], function $$36(o) {
              if (o == null)
                o = nil;
              return set["$include?"](o);
            });
          } else {
            return $send(set, "any?", [], function $$37(o) {
              var self3 = $$37.$$s == null ? this : $$37.$$s;
              if (o == null)
                o = nil;
              return self3["$include?"](o);
            }, { $$s: self2 });
          }
          ;
        });
        $def(self, "$disjoint?", function $Set_disjoint$ques$38(set) {
          var self2 = this;
          return self2["$intersect?"](set)["$!"]();
        });
        $def(self, "$to_a", function $$to_a() {
          var self2 = this;
          return self2.hash.$keys();
        });
        $alias(self, "+", "|");
        $alias(self, "<", "proper_subset?");
        $alias(self, "<<", "add");
        $alias(self, "<=", "subset?");
        $alias(self, ">", "proper_superset?");
        $alias(self, ">=", "superset?");
        $alias(self, "difference", "-");
        $alias(self, "filter!", "select!");
        $alias(self, "length", "size");
        $alias(self, "map!", "collect!");
        $alias(self, "member?", "include?");
        return $alias(self, "union", "|");
      }("::", null, $nesting);
    };
    Opal.modules["corelib/dir"] = function(Opal2) {
      var $klass = Opal2.klass, $def = Opal2.def, $truthy = Opal2.truthy, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("[],pwd");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Dir");
        var $nesting2 = [self].concat($parent_nesting);
        return function(self2, $parent_nesting2) {
          $def(self2, "$chdir", function $$chdir(dir) {
            var $yield = $$chdir.$$p || nil, prev_cwd = nil;
            $$chdir.$$p = null;
            return function() {
              try {
                prev_cwd = Opal2.current_dir;
                Opal2.current_dir = dir;
                return Opal2.yieldX($yield, []);
                ;
              } finally {
                Opal2.current_dir = prev_cwd;
              }
              ;
            }();
          });
          $def(self2, "$pwd", function $$pwd() {
            return Opal2.current_dir || ".";
          });
          $def(self2, "$home", function $$home() {
            var $ret_or_1 = nil;
            if ($truthy($ret_or_1 = $$$("ENV")["$[]"]("HOME"))) {
              return $ret_or_1;
            } else {
              return ".";
            }
          });
          return $alias(self2, "getwd", "pwd");
        }(Opal2.get_singleton_class(self), $nesting2);
      }("::", null, $nesting);
    };
    Opal.modules["corelib/file"] = function(Opal2) {
      var $truthy = Opal2.truthy, $klass = Opal2.klass, $const_set = Opal2.const_set, $Opal = Opal2.Opal, $regexp = Opal2.regexp, $rb_plus = Opal2.rb_plus, $def = Opal2.def, $Kernel = Opal2.Kernel, $eqeq = Opal2.eqeq, $rb_lt = Opal2.rb_lt, $rb_minus = Opal2.rb_minus, $range = Opal2.range, $send = Opal2.send, $slice = Opal2.slice, $alias = Opal2.alias, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "File");
        var $nesting2 = [self].concat($parent_nesting), windows_root_rx = nil;
        $const_set($nesting2[0], "Separator", $const_set($nesting2[0], "SEPARATOR", "/"));
        $const_set($nesting2[0], "ALT_SEPARATOR", nil);
        $const_set($nesting2[0], "PATH_SEPARATOR", ":");
        $const_set($nesting2[0], "FNM_SYSCASE", 0);
        windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
        return function(self2, $parent_nesting2) {
          var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
          $def(self2, "$absolute_path", function $$absolute_path(path, basedir) {
            var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;
            if (basedir == null)
              basedir = nil;
            sep = $$("SEPARATOR");
            sep_chars = $sep_chars();
            new_parts = [];
            path = $truthy(path["$respond_to?"]("to_path")) ? path.$to_path() : path;
            path = $Opal["$coerce_to!"](path, $$$("String"), "to_str");
            basedir = $truthy($ret_or_1 = basedir) ? $ret_or_1 : $$$("Dir").$pwd();
            path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
            basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
            if ($truthy(path_abs)) {
              parts = path.$split($regexp(["[", sep_chars, "]"]));
              leading_sep = windows_root_rx.test(path) ? "" : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
              abs = true;
            } else {
              parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
              leading_sep = windows_root_rx.test(basedir) ? "" : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
              abs = basedir_abs;
            }
            ;
            var part;
            for (var i = 0, ii = parts.length; i < ii; i++) {
              part = parts[i];
              if (part === nil || part === "" && (new_parts.length === 0 || abs) || part === "." && (new_parts.length === 0 || abs)) {
                continue;
              }
              if (part === "..") {
                new_parts.pop();
              } else {
                new_parts.push(part);
              }
            }
            if (!abs && parts[0] !== ".") {
              new_parts.$unshift(".");
            }
            ;
            new_path = new_parts.$join(sep);
            if ($truthy(abs)) {
              new_path = $rb_plus(leading_sep, new_path);
            }
            ;
            return new_path;
          }, -2);
          $def(self2, "$expand_path", function $$expand_path(path, basedir) {
            var self3 = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;
            if (basedir == null)
              basedir = nil;
            sep = $$("SEPARATOR");
            sep_chars = $sep_chars();
            if ($truthy(path[0] === "~" || basedir && basedir[0] === "~")) {
              home = $$("Dir").$home();
              if (!$truthy(home)) {
                $Kernel.$raise($$$("ArgumentError"), "couldn't find HOME environment -- expanding `~'");
              }
              ;
              leading_sep = windows_root_rx.test(home) ? "" : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
              if (!$truthy(home["$start_with?"](leading_sep))) {
                $Kernel.$raise($$$("ArgumentError"), "non-absolute home");
              }
              ;
              home = $rb_plus(home, sep);
              home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
              path = path.$sub(home_path_regexp, home);
              if ($truthy(basedir)) {
                basedir = basedir.$sub(home_path_regexp, home);
              }
              ;
            }
            ;
            return self3.$absolute_path(path, basedir);
          }, -2);
          function $coerce_to_path(path) {
            if ($truthy(path["$respond_to?"]("to_path"))) {
              path = path.$to_path();
            }
            path = $Opal["$coerce_to!"](path, $$$("String"), "to_str");
            return path;
          }
          function $sep_chars() {
            if ($$("ALT_SEPARATOR") === nil) {
              return Opal2.escape_regexp($$("SEPARATOR"));
            } else {
              return Opal2.escape_regexp($rb_plus($$("SEPARATOR"), $$("ALT_SEPARATOR")));
            }
          }
          ;
          $def(self2, "$dirname", function $$dirname(path, level) {
            var self3 = this, sep_chars = nil;
            if (level == null)
              level = 1;
            if ($eqeq(level, 0)) {
              return path;
            }
            ;
            if ($truthy($rb_lt(level, 0))) {
              $Kernel.$raise($$$("ArgumentError"), "level can't be negative");
            }
            ;
            sep_chars = $sep_chars();
            path = $coerce_to_path(path);
            var absolute = path.match(new RegExp("^[" + sep_chars + "]")), out;
            path = path.replace(new RegExp("[" + sep_chars + "]+$"), "");
            path = path.replace(new RegExp("[^" + sep_chars + "]+$"), "");
            path = path.replace(new RegExp("[" + sep_chars + "]+$"), "");
            if (path === "") {
              out = absolute ? "/" : ".";
            } else {
              out = path;
            }
            if (level == 1) {
              return out;
            } else {
              return self3.$dirname(out, $rb_minus(level, 1));
            }
            ;
          }, -2);
          $def(self2, "$basename", function $$basename(name, suffix) {
            var sep_chars = nil;
            if (suffix == null)
              suffix = nil;
            sep_chars = $sep_chars();
            name = $coerce_to_path(name);
            if (name.length == 0) {
              return name;
            }
            if (suffix !== nil) {
              suffix = $Opal["$coerce_to!"](suffix, $$$("String"), "to_str");
            } else {
              suffix = null;
            }
            name = name.replace(new RegExp("(.)[" + sep_chars + "]*$"), "$1");
            name = name.replace(new RegExp("^(?:.*[" + sep_chars + "])?([^" + sep_chars + "]+)$"), "$1");
            if (suffix === ".*") {
              name = name.replace(/\.[^\.]+$/, "");
            } else if (suffix !== null) {
              suffix = Opal2.escape_regexp(suffix);
              name = name.replace(new RegExp("" + suffix + "$"), "");
            }
            return name;
            ;
          }, -2);
          $def(self2, "$extname", function $$extname(path) {
            var self3 = this, filename = nil, last_dot_idx = nil;
            path = $coerce_to_path(path);
            filename = self3.$basename(path);
            if ($truthy(filename["$empty?"]())) {
              return "";
            }
            ;
            last_dot_idx = filename["$[]"]($range(1, -1, false)).$rindex(".");
            if ($truthy(last_dot_idx["$nil?"]()) || $eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))) {
              return "";
            } else {
              return filename["$[]"](Opal2.Range.$new($rb_plus(last_dot_idx, 1), -1, false));
            }
            ;
          });
          $def(self2, "$exist?", function $exist$ques$1(path) {
            return Opal2.modules[path] != null;
          });
          $def(self2, "$directory?", function $directory$ques$2(path) {
            var files = nil;
            files = [];
            for (var key in Opal2.modules) {
              files.push(key);
            }
            ;
            path = path.$gsub($regexp(["(^.", $$("SEPARATOR"), "+|", $$("SEPARATOR"), "+$)"]));
            return $send(files, "find", [], function $$3(f) {
              if (f == null)
                f = nil;
              return f["$=~"]($regexp(["^", path]));
            });
          });
          $def(self2, "$join", function $$join($a) {
            var $post_args, paths, result = nil;
            $post_args = $slice(arguments);
            paths = $post_args;
            if ($truthy(paths["$empty?"]())) {
              return "";
            }
            ;
            result = "";
            paths = $send(paths.$flatten().$each_with_index(), "map", [], function $$4(item, index) {
              if (item == null)
                item = nil;
              if (index == null)
                index = nil;
              if ($eqeq(index, 0) && $truthy(item["$empty?"]())) {
                return $$("SEPARATOR");
              } else if ($eqeq(paths.$length(), $rb_plus(index, 1)) && $truthy(item["$empty?"]())) {
                return $$("SEPARATOR");
              } else {
                return item;
              }
              ;
            });
            paths = $send(paths, "reject", [], "empty?".$to_proc());
            $send(paths, "each_with_index", [], function $$5(item, index) {
              var next_item = nil;
              if (item == null)
                item = nil;
              if (index == null)
                index = nil;
              next_item = paths["$[]"]($rb_plus(index, 1));
              if ($truthy(next_item["$nil?"]())) {
                return result = "" + result + item;
              } else {
                if ($truthy(item["$end_with?"]($$("SEPARATOR"))) && $truthy(next_item["$start_with?"]($$("SEPARATOR")))) {
                  item = item.$sub($regexp([$$("SEPARATOR"), "+$"]), "");
                }
                ;
                return result = $truthy(item["$end_with?"]($$("SEPARATOR"))) || $truthy(next_item["$start_with?"]($$("SEPARATOR"))) ? "" + result + item : "" + result + item + $$("SEPARATOR");
              }
              ;
            });
            return result;
          }, -1);
          $def(self2, "$split", function $$split(path) {
            return path.$split($$("SEPARATOR"));
          });
          $alias(self2, "realpath", "expand_path");
          return $alias(self2, "exists?", "exist?");
        }(Opal2.get_singleton_class(self), $nesting2);
      }("::", $$$("IO"), $nesting);
    };
    Opal.modules["corelib/process/base"] = function(Opal2) {
      var $klass = Opal2.klass, $slice = Opal2.slice, $defs = Opal2.defs, $return_val = Opal2.return_val, nil = Opal2.nil;
      (function($base, $super) {
        var self = $klass($base, $super, "Signal");
        return $defs(self, "$trap", function $$trap($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
      })("::", null);
      return function($base, $super) {
        var self = $klass($base, $super, "GC");
        return $defs(self, "$start", $return_val(nil));
      }("::", null);
    };
    Opal.modules["corelib/process"] = function(Opal2) {
      var $module = Opal2.module, $defs = Opal2.defs, $truthy = Opal2.truthy, $return_val = Opal2.return_val, $Kernel = Opal2.Kernel, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("const_set,size,<<,__register_clock__,to_f,now,new,[],raise");
      return function($base) {
        var self = $module($base, "Process");
        var monotonic = nil;
        self.__clocks__ = [];
        $defs(self, "$__register_clock__", function $$__register_clock__(name, func) {
          var self2 = this;
          if (self2.__clocks__ == null)
            self2.__clocks__ = nil;
          self2.$const_set(name, self2.__clocks__.$size());
          return self2.__clocks__["$<<"](func);
        });
        self.$__register_clock__("CLOCK_REALTIME", function() {
          return Date.now();
        });
        monotonic = false;
        if (Opal2.global.performance) {
          monotonic = function() {
            return performance.now();
          };
        } else if (Opal2.global.process && process.hrtime) {
          var hrtime_base = process.hrtime();
          monotonic = function() {
            var hrtime = process.hrtime(hrtime_base);
            var us = hrtime[1] / 1e3 | 0;
            return hrtime[0] * 1e3 + us / 1e3;
          };
        }
        ;
        if ($truthy(monotonic)) {
          self.$__register_clock__("CLOCK_MONOTONIC", monotonic);
        }
        ;
        $defs(self, "$pid", $return_val(0));
        $defs(self, "$times", function $$times() {
          var t2 = nil;
          t2 = $$$("Time").$now().$to_f();
          return $$$($$$("Benchmark"), "Tms").$new(t2, t2, t2, t2, t2);
        });
        return $defs(self, "$clock_gettime", function $$clock_gettime(clock_id, unit) {
          var self2 = this, $ret_or_1 = nil, clock = nil;
          if (self2.__clocks__ == null)
            self2.__clocks__ = nil;
          if (unit == null)
            unit = "float_second";
          if ($truthy($ret_or_1 = clock = self2.__clocks__["$[]"](clock_id))) {
            $ret_or_1;
          } else {
            $Kernel.$raise($$$($$$("Errno"), "EINVAL"), "clock_gettime(" + clock_id + ") " + self2.__clocks__["$[]"](clock_id));
          }
          ;
          var ms = clock();
          switch (unit) {
            case "float_second":
              return ms / 1e3;
            case "float_millisecond":
              return ms / 1;
            case "float_microsecond":
              return ms * 1e3;
            case "second":
              return ms / 1e3 | 0;
            case "millisecond":
              return ms / 1 | 0;
            case "microsecond":
              return ms * 1e3 | 0;
            case "nanosecond":
              return ms * 1e6 | 0;
            default:
              $Kernel.$raise($$$("ArgumentError"), "unexpected unit: " + unit);
          }
          ;
        }, -2);
      }("::");
    };
    Opal.modules["corelib/random/formatter"] = function(Opal2) {
      var $klass = Opal2.klass, $module = Opal2.module, $def = Opal2.def, $range = Opal2.range, $send = Opal2.send, $rb_divide = Opal2.rb_divide, $Kernel = Opal2.Kernel, $Opal = Opal2.Opal, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend");
      return function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "Random");
        var $nesting2 = [self].concat($parent_nesting);
        (function($base2, $parent_nesting2) {
          var self2 = $module($base2, "Formatter");
          var $nesting3 = [self2].concat($parent_nesting2), $$ = Opal2.$r($nesting3);
          $def(self2, "$hex", function $$hex(count) {
            var self3 = this;
            if (count == null)
              count = nil;
            count = $$$("Random").$_verify_count(count);
            var bytes = self3.$bytes(count);
            var out = "";
            for (var i = 0; i < count; i++) {
              out += bytes.charCodeAt(i).toString(16).padStart(2, "0");
            }
            return out.$encode("US-ASCII");
            ;
          }, -1);
          $def(self2, "$random_bytes", function $$random_bytes(count) {
            var self3 = this;
            if (count == null)
              count = nil;
            return self3.$bytes(count);
          }, -1);
          $def(self2, "$base64", function $$base64(count) {
            var self3 = this;
            if (count == null)
              count = nil;
            return $$$("Base64").$strict_encode64(self3.$random_bytes(count)).$encode("US-ASCII");
          }, -1);
          $def(self2, "$urlsafe_base64", function $$urlsafe_base64(count, padding) {
            var self3 = this;
            if (count == null)
              count = nil;
            if (padding == null)
              padding = false;
            return $$$("Base64").$urlsafe_encode64(self3.$random_bytes(count), padding).$encode("US-ASCII");
          }, -1);
          $def(self2, "$uuid", function $$uuid() {
            var self3 = this, str = nil;
            str = self3.$hex(16).$split("");
            str["$[]="](12, "4");
            str["$[]="](16, (parseInt(str["$[]"](16), 16) & 3 | 8).toString(16));
            str = [str["$[]"]($range(0, 8, true)), str["$[]"]($range(8, 12, true)), str["$[]"]($range(12, 16, true)), str["$[]"]($range(16, 20, true)), str["$[]"]($range(20, 32, true))];
            str = $send(str, "map", [], "join".$to_proc());
            return str.$join("-");
          });
          $def(self2, "$random_float", function $$random_float() {
            var self3 = this, bs = nil, num = nil;
            bs = self3.$bytes(4);
            num = 0;
            $send(4, "times", [], function $$1(i) {
              if (i == null)
                i = nil;
              num = num["$<<"](8);
              return num = num["$|"](bs["$[]"](i).$ord());
            });
            return $rb_divide(num.$abs(), 2147483647);
          });
          $def(self2, "$random_number", function $$random_number(limit) {
            var self3 = this;
            ;
            function randomFloat() {
              return self3.$random_float();
            }
            function randomInt(max) {
              return Math.floor(randomFloat() * max);
            }
            function randomRange() {
              var min = limit.begin, max = limit.end;
              if (min === nil || max === nil) {
                return nil;
              }
              var length = max - min;
              if (length < 0) {
                return nil;
              }
              if (length === 0) {
                return min;
              }
              if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
                length++;
              }
              return randomInt(length) + min;
            }
            if (limit == null) {
              return randomFloat();
            } else if (limit.$$is_range) {
              return randomRange();
            } else if (limit.$$is_number) {
              if (limit <= 0) {
                $Kernel.$raise($$$("ArgumentError"), "invalid argument - " + limit);
              }
              if (limit % 1 === 0) {
                return randomInt(limit);
              } else {
                return randomFloat() * limit;
              }
            } else {
              limit = $Opal["$coerce_to!"](limit, $$$("Integer"), "to_int");
              if (limit <= 0) {
                $Kernel.$raise($$$("ArgumentError"), "invalid argument - " + limit);
              }
              return randomInt(limit);
            }
            ;
          }, -1);
          return $def(self2, "$alphanumeric", function $$alphanumeric(count) {
            var self3 = this, map = nil;
            if (count == null)
              count = nil;
            count = $$("Random").$_verify_count(count);
            map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], "map", [], "to_a".$to_proc()).$flatten();
            return $send($$$("Array"), "new", [count], function $$2(i) {
              var self4 = $$2.$$s == null ? this : $$2.$$s;
              if (i == null)
                i = nil;
              return map["$[]"](self4.$random_number(map.$length()));
            }, { $$s: self3 }).$join();
          }, -1);
        })(self, $nesting2);
        self.$include($$$($$$("Random"), "Formatter"));
        return self.$extend($$$($$$("Random"), "Formatter"));
      }("::", null, $nesting);
    };
    Opal.modules["corelib/random/mersenne_twister"] = function(Opal2) {
      var $klass = Opal2.klass, $const_set = Opal2.const_set, $send = Opal2.send, nil = Opal2.nil, $$$ = Opal2.$$$, mersenne_twister = nil;
      Opal2.add_stubs("generator=");
      mersenne_twister = function() {
        var N = 624;
        var M = 397;
        var MATRIX_A = 2567483615;
        var UMASK = 2147483648;
        var LMASK = 2147483647;
        var MIXBITS = function(u, v) {
          return u & UMASK | v & LMASK;
        };
        var TWIST = function(u, v) {
          return MIXBITS(u, v) >>> 1 ^ (v & 1 ? MATRIX_A : 0);
        };
        function init(s) {
          var mt = { left: 0, next: N, state: new Array(N) };
          init_genrand(mt, s);
          return mt;
        }
        function init_genrand(mt, s) {
          var j, i;
          mt.state[0] = s >>> 0;
          for (j = 1; j < N; j++) {
            mt.state[j] = 1812433253 * (mt.state[j - 1] ^ mt.state[j - 1] >> 30 >>> 0) + j;
            mt.state[j] &= 4294967295;
          }
          mt.left = 1;
          mt.next = N;
        }
        function next_state(mt) {
          var p = 0, _p = mt.state;
          var j;
          mt.left = N;
          mt.next = 0;
          for (j = N - M + 1; --j; p++)
            _p[p] = _p[p + M] ^ TWIST(_p[p + 0], _p[p + 1]);
          for (j = M; --j; p++)
            _p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[p + 1]);
          _p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[0]);
        }
        function genrand_int32(mt) {
          var y;
          if (--mt.left <= 0)
            next_state(mt);
          y = mt.state[mt.next++];
          y ^= y >>> 11;
          y ^= y << 7 & 2636928640;
          y ^= y << 15 & 4022730752;
          y ^= y >>> 18;
          return y >>> 0;
        }
        function int_pair_to_real_exclusive(a, b) {
          a >>>= 5;
          b >>>= 6;
          return (a * 67108864 + b) * (1 / 9007199254740992);
        }
        function genrand_real(mt) {
          var a = genrand_int32(mt), b = genrand_int32(mt);
          return int_pair_to_real_exclusive(a, b);
        }
        return { genrand_real, init };
      }();
      return function($base, $super) {
        var self = $klass($base, $super, "Random");
        var $a;
        var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
        $const_set(self, "MERSENNE_TWISTER_GENERATOR", {
          new_seed: function() {
            return Math.round(Math.random() * MAX_INT);
          },
          reseed: function(seed) {
            return mersenne_twister.init(seed);
          },
          rand: function(mt) {
            return mersenne_twister.genrand_real(mt);
          }
        });
        return $a = [$$$(self, "MERSENNE_TWISTER_GENERATOR")], $send(self, "generator=", $a), $a[$a.length - 1];
      }("::", null);
    };
    Opal.modules["corelib/random"] = function(Opal2) {
      var $truthy = Opal2.truthy, $klass = Opal2.klass, $Kernel = Opal2.Kernel, $defs = Opal2.defs, $Opal = Opal2.Opal, $def = Opal2.def, $eqeqeq = Opal2.eqeqeq, $send = Opal2.send, self = Opal2.top, nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set");
      self.$require("corelib/random/formatter");
      (function($base, $super) {
        var self2 = $klass($base, $super, "Random");
        self2.$attr_reader("seed", "state");
        $defs(self2, "$_verify_count", function $$_verify_count(count) {
          if (!$truthy(count))
            count = 16;
          if (typeof count !== "number")
            count = count.$to_int();
          if (count < 0)
            $Kernel.$raise($$$("ArgumentError"), "negative string size (or size too big)");
          count = Math.floor(count);
          return count;
        });
        $def(self2, "$initialize", function $$initialize(seed) {
          var self3 = this;
          if (seed == null)
            seed = $$$("Random").$new_seed();
          seed = $Opal["$coerce_to!"](seed, $$$("Integer"), "to_int");
          self3.state = seed;
          return self3.$reseed(seed);
        }, -1);
        $def(self2, "$reseed", function $$reseed(seed) {
          var self3 = this;
          self3.seed = seed;
          return self3.$rng = Opal2.$$rand.reseed(seed);
          ;
        });
        $defs(self2, "$new_seed", function $$new_seed() {
          return Opal2.$$rand.new_seed();
        });
        $defs(self2, "$rand", function $$rand(limit) {
          var self3 = this;
          ;
          return $$$(self3, "DEFAULT").$rand(limit);
        }, -1);
        $defs(self2, "$srand", function $$srand(n) {
          var self3 = this, previous_seed = nil;
          if (n == null)
            n = $$$("Random").$new_seed();
          n = $Opal["$coerce_to!"](n, $$$("Integer"), "to_int");
          previous_seed = $$$(self3, "DEFAULT").$seed();
          $$$(self3, "DEFAULT").$reseed(n);
          return previous_seed;
        }, -1);
        $defs(self2, "$urandom", function $$urandom(size) {
          return $$$("SecureRandom").$bytes(size);
        });
        $def(self2, "$==", function $Random_$eq_eq$1(other) {
          var self3 = this, $ret_or_1 = nil;
          if (!$eqeqeq($$$("Random"), other)) {
            return false;
          }
          ;
          if ($truthy($ret_or_1 = self3.$seed()["$=="](other.$seed()))) {
            return self3.$state()["$=="](other.$state());
          } else {
            return $ret_or_1;
          }
          ;
        });
        $def(self2, "$bytes", function $$bytes(length) {
          var self3 = this;
          length = $$$("Random").$_verify_count(length);
          return $send($$$("Array"), "new", [length], function $$2() {
            var self4 = $$2.$$s == null ? this : $$2.$$s;
            return self4.$rand(255).$chr();
          }, { $$s: self3 }).$join().$encode("ASCII-8BIT");
        });
        $defs(self2, "$bytes", function $$bytes(length) {
          var self3 = this;
          return $$$(self3, "DEFAULT").$bytes(length);
        });
        $def(self2, "$rand", function $$rand(limit) {
          var self3 = this;
          ;
          return self3.$random_number(limit);
        }, -1);
        $def(self2, "$random_float", function $$random_float() {
          var self3 = this;
          self3.state++;
          return Opal2.$$rand.rand(self3.$rng);
        });
        $defs(self2, "$random_float", function $$random_float() {
          var self3 = this;
          return $$$(self3, "DEFAULT").$random_float();
        });
        return $defs(self2, "$generator=", function $Random_generator$eq$3(generator) {
          var self3 = this;
          Opal2.$$rand = generator;
          if ($truthy(self3["$const_defined?"]("DEFAULT"))) {
            return $$$(self3, "DEFAULT").$reseed();
          } else {
            return self3.$const_set("DEFAULT", self3.$new(self3.$new_seed()));
          }
          ;
        });
      })("::", null);
      return self.$require("corelib/random/mersenne_twister");
    };
    Opal.modules["corelib/unsupported"] = function(Opal2) {
      var $Kernel = Opal2.Kernel, $klass = Opal2.klass, $send = Opal2.send, $slice = Opal2.slice, $module = Opal2.module, $def = Opal2.def, $return_val = Opal2.return_val, $alias = Opal2.alias, $defs = Opal2.defs, self = Opal2.top, $nesting = [], nil = Opal2.nil, $$$ = Opal2.$$$;
      Opal2.add_stubs("raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods");
      var warnings = {};
      function handle_unsupported_feature(message) {
        switch (Opal2.config.unsupported_features_severity) {
          case "error":
            $Kernel.$raise($$$("NotImplementedError"), message);
            break;
          case "warning":
            warn(message);
            break;
          default:
        }
      }
      function warn(string) {
        if (warnings[string]) {
          return;
        }
        warnings[string] = true;
        self.$warn(string);
      }
      ;
      (function($base, $super) {
        var self2 = $klass($base, $super, "String");
        var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
        return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], "each", [], function $String$1(method_name) {
          var self3 = $String$1.$$s == null ? this : $String$1.$$s;
          if (method_name == null)
            method_name = nil;
          return $send(self3, "define_method", [method_name], function $$2($a) {
            var $post_args, $fwd_rest;
            $post_args = $slice(arguments);
            $fwd_rest = $post_args;
            return $Kernel.$raise($$$("NotImplementedError"), ERROR["$%"](method_name));
          }, -1);
        }, { $$s: self2 });
      })("::", null);
      (function($base) {
        var self2 = $module($base, "Kernel");
        var ERROR = "Object tainting is not supported by Opal";
        $def(self2, "$taint", function $$taint() {
          var self3 = this;
          handle_unsupported_feature(ERROR);
          return self3;
        });
        $def(self2, "$untaint", function $$untaint() {
          var self3 = this;
          handle_unsupported_feature(ERROR);
          return self3;
        });
        return $def(self2, "$tainted?", function $Kernel_tainted$ques$3() {
          handle_unsupported_feature(ERROR);
          return false;
        });
      })("::");
      (function($base, $super) {
        var self2 = $klass($base, $super, "Module");
        $def(self2, "$public", function $Module_public$4($a) {
          var $post_args, methods, self3 = this;
          $post_args = $slice(arguments);
          methods = $post_args;
          if (methods.length === 0) {
            self3.$$module_function = false;
            return nil;
          }
          return methods.length === 1 ? methods[0] : methods;
          ;
        }, -1);
        $def(self2, "$private_class_method", function $$private_class_method($a) {
          var $post_args, methods;
          $post_args = $slice(arguments);
          methods = $post_args;
          return methods.length === 1 ? methods[0] : methods;
          ;
        }, -1);
        $def(self2, "$private_method_defined?", $return_val(false));
        $def(self2, "$private_constant", function $$private_constant($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        $alias(self2, "nesting", "public");
        $alias(self2, "private", "public");
        $alias(self2, "protected", "public");
        $alias(self2, "protected_method_defined?", "private_method_defined?");
        $alias(self2, "public_class_method", "private_class_method");
        $alias(self2, "public_instance_method", "instance_method");
        $alias(self2, "public_instance_methods", "instance_methods");
        return $alias(self2, "public_method_defined?", "method_defined?");
      })("::", null);
      (function($base) {
        var self2 = $module($base, "Kernel");
        $def(self2, "$private_methods", function $$private_methods($a) {
          var $post_args, methods;
          $post_args = $slice(arguments);
          methods = $post_args;
          return [];
        }, -1);
        $alias(self2, "protected_methods", "private_methods");
        $alias(self2, "private_instance_methods", "private_methods");
        return $alias(self2, "protected_instance_methods", "private_methods");
      })("::");
      (function($base, $parent_nesting) {
        var self2 = $module($base, "Kernel");
        var $nesting2 = [self2].concat($parent_nesting), $$ = Opal2.$r($nesting2);
        return $def(self2, "$eval", function $Kernel_eval$5($a) {
          var $post_args, $fwd_rest;
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return $Kernel.$raise($$$("NotImplementedError"), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + $$("RUBY_ENGINE_VERSION") + "/docs/opal_parser.md for details."));
        }, -1);
      })("::", $nesting);
      $defs(self, "$public", function $public$6($a) {
        var $post_args, methods;
        $post_args = $slice(arguments);
        methods = $post_args;
        return methods.length === 1 ? methods[0] : methods;
        ;
      }, -1);
      return $defs(self, "$private", function $private$7($a) {
        var $post_args, methods;
        $post_args = $slice(arguments);
        methods = $post_args;
        return methods.length === 1 ? methods[0] : methods;
        ;
      }, -1);
    };
    Opal.queue(function(Opal2) {
      var $Object = Opal2.Object, nil = Opal2.nil;
      Opal2.add_stubs("require,autoload");
      $Object.$require("opal/base");
      $Object.$require("opal/mini");
      $Object.$require("corelib/kernel/format");
      $Object.$require("corelib/string/encoding");
      $Object.$autoload("Math", "corelib/math");
      $Object.$require("corelib/complex/base");
      $Object.$autoload("Complex", "corelib/complex");
      $Object.$require("corelib/rational/base");
      $Object.$autoload("Rational", "corelib/rational");
      $Object.$require("corelib/time");
      $Object.$autoload("Struct", "corelib/struct");
      $Object.$autoload("Set", "corelib/set");
      $Object.$autoload("Dir", "corelib/dir");
      $Object.$autoload("File", "corelib/file");
      $Object.$require("corelib/process/base");
      $Object.$autoload("Process", "corelib/process");
      $Object.$autoload("Random", "corelib/random");
      return $Object.$require("corelib/unsupported");
    });
  }
});

// node_modules/asciidoctor/index.js
var require_asciidoctor = __commonJS({
  "node_modules/asciidoctor/index.js"(exports, module2) {
    module2.exports = (init_asciidoctor(), __toCommonJS(asciidoctor_exports));
  }
});

// node_modules/mark.js/dist/mark.js
var require_mark = __commonJS({
  "node_modules/mark.js/dist/mark.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Mark = factory();
    })(exports, function() {
      "use strict";
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var DOMIterator = function() {
        function DOMIterator2(ctx) {
          var iframes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var exclude = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var iframesTimeout = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5e3;
          classCallCheck(this, DOMIterator2);
          this.ctx = ctx;
          this.iframes = iframes;
          this.exclude = exclude;
          this.iframesTimeout = iframesTimeout;
        }
        createClass(DOMIterator2, [{
          key: "getContexts",
          value: function getContexts() {
            var ctx = void 0, filteredCtx = [];
            if (typeof this.ctx === "undefined" || !this.ctx) {
              ctx = [];
            } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {
              ctx = Array.prototype.slice.call(this.ctx);
            } else if (Array.isArray(this.ctx)) {
              ctx = this.ctx;
            } else if (typeof this.ctx === "string") {
              ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));
            } else {
              ctx = [this.ctx];
            }
            ctx.forEach(function(ctx2) {
              var isDescendant = filteredCtx.filter(function(contexts) {
                return contexts.contains(ctx2);
              }).length > 0;
              if (filteredCtx.indexOf(ctx2) === -1 && !isDescendant) {
                filteredCtx.push(ctx2);
              }
            });
            return filteredCtx;
          }
        }, {
          key: "getIframeContents",
          value: function getIframeContents(ifr, successFn) {
            var errorFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
            };
            var doc = void 0;
            try {
              var ifrWin = ifr.contentWindow;
              doc = ifrWin.document;
              if (!ifrWin || !doc) {
                throw new Error("iframe inaccessible");
              }
            } catch (e) {
              errorFn();
            }
            if (doc) {
              successFn(doc);
            }
          }
        }, {
          key: "isIframeBlank",
          value: function isIframeBlank(ifr) {
            var bl = "about:blank", src = ifr.getAttribute("src").trim(), href = ifr.contentWindow.location.href;
            return href === bl && src !== bl && src;
          }
        }, {
          key: "observeIframeLoad",
          value: function observeIframeLoad(ifr, successFn, errorFn) {
            var _this = this;
            var called = false, tout = null;
            var listener = function listener2() {
              if (called) {
                return;
              }
              called = true;
              clearTimeout(tout);
              try {
                if (!_this.isIframeBlank(ifr)) {
                  ifr.removeEventListener("load", listener2);
                  _this.getIframeContents(ifr, successFn, errorFn);
                }
              } catch (e) {
                errorFn();
              }
            };
            ifr.addEventListener("load", listener);
            tout = setTimeout(listener, this.iframesTimeout);
          }
        }, {
          key: "onIframeReady",
          value: function onIframeReady(ifr, successFn, errorFn) {
            try {
              if (ifr.contentWindow.document.readyState === "complete") {
                if (this.isIframeBlank(ifr)) {
                  this.observeIframeLoad(ifr, successFn, errorFn);
                } else {
                  this.getIframeContents(ifr, successFn, errorFn);
                }
              } else {
                this.observeIframeLoad(ifr, successFn, errorFn);
              }
            } catch (e) {
              errorFn();
            }
          }
        }, {
          key: "waitForIframes",
          value: function waitForIframes(ctx, done) {
            var _this2 = this;
            var eachCalled = 0;
            this.forEachIframe(ctx, function() {
              return true;
            }, function(ifr) {
              eachCalled++;
              _this2.waitForIframes(ifr.querySelector("html"), function() {
                if (!--eachCalled) {
                  done();
                }
              });
            }, function(handled) {
              if (!handled) {
                done();
              }
            });
          }
        }, {
          key: "forEachIframe",
          value: function forEachIframe(ctx, filter, each) {
            var _this3 = this;
            var end = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var ifr = ctx.querySelectorAll("iframe"), open = ifr.length, handled = 0;
            ifr = Array.prototype.slice.call(ifr);
            var checkEnd = function checkEnd2() {
              if (--open <= 0) {
                end(handled);
              }
            };
            if (!open) {
              checkEnd();
            }
            ifr.forEach(function(ifr2) {
              if (DOMIterator2.matches(ifr2, _this3.exclude)) {
                checkEnd();
              } else {
                _this3.onIframeReady(ifr2, function(con) {
                  if (filter(ifr2)) {
                    handled++;
                    each(con);
                  }
                  checkEnd();
                }, checkEnd);
              }
            });
          }
        }, {
          key: "createIterator",
          value: function createIterator(ctx, whatToShow, filter) {
            return document.createNodeIterator(ctx, whatToShow, filter, false);
          }
        }, {
          key: "createInstanceOnIframe",
          value: function createInstanceOnIframe(contents) {
            return new DOMIterator2(contents.querySelector("html"), this.iframes);
          }
        }, {
          key: "compareNodeIframe",
          value: function compareNodeIframe(node, prevNode, ifr) {
            var compCurr = node.compareDocumentPosition(ifr), prev = Node.DOCUMENT_POSITION_PRECEDING;
            if (compCurr & prev) {
              if (prevNode !== null) {
                var compPrev = prevNode.compareDocumentPosition(ifr), after = Node.DOCUMENT_POSITION_FOLLOWING;
                if (compPrev & after) {
                  return true;
                }
              } else {
                return true;
              }
            }
            return false;
          }
        }, {
          key: "getIteratorNode",
          value: function getIteratorNode(itr) {
            var prevNode = itr.previousNode();
            var node = void 0;
            if (prevNode === null) {
              node = itr.nextNode();
            } else {
              node = itr.nextNode() && itr.nextNode();
            }
            return {
              prevNode,
              node
            };
          }
        }, {
          key: "checkIframeFilter",
          value: function checkIframeFilter(node, prevNode, currIfr, ifr) {
            var key = false, handled = false;
            ifr.forEach(function(ifrDict, i) {
              if (ifrDict.val === currIfr) {
                key = i;
                handled = ifrDict.handled;
              }
            });
            if (this.compareNodeIframe(node, prevNode, currIfr)) {
              if (key === false && !handled) {
                ifr.push({
                  val: currIfr,
                  handled: true
                });
              } else if (key !== false && !handled) {
                ifr[key].handled = true;
              }
              return true;
            }
            if (key === false) {
              ifr.push({
                val: currIfr,
                handled: false
              });
            }
            return false;
          }
        }, {
          key: "handleOpenIframes",
          value: function handleOpenIframes(ifr, whatToShow, eCb, fCb) {
            var _this4 = this;
            ifr.forEach(function(ifrDict) {
              if (!ifrDict.handled) {
                _this4.getIframeContents(ifrDict.val, function(con) {
                  _this4.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);
                });
              }
            });
          }
        }, {
          key: "iterateThroughNodes",
          value: function iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {
            var _this5 = this;
            var itr = this.createIterator(ctx, whatToShow, filterCb);
            var ifr = [], elements = [], node = void 0, prevNode = void 0, retrieveNodes = function retrieveNodes2() {
              var _getIteratorNode = _this5.getIteratorNode(itr);
              prevNode = _getIteratorNode.prevNode;
              node = _getIteratorNode.node;
              return node;
            };
            while (retrieveNodes()) {
              if (this.iframes) {
                this.forEachIframe(ctx, function(currIfr) {
                  return _this5.checkIframeFilter(node, prevNode, currIfr, ifr);
                }, function(con) {
                  _this5.createInstanceOnIframe(con).forEachNode(whatToShow, function(ifrNode) {
                    return elements.push(ifrNode);
                  }, filterCb);
                });
              }
              elements.push(node);
            }
            elements.forEach(function(node2) {
              eachCb(node2);
            });
            if (this.iframes) {
              this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);
            }
            doneCb();
          }
        }, {
          key: "forEachNode",
          value: function forEachNode(whatToShow, each, filter) {
            var _this6 = this;
            var done = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
            };
            var contexts = this.getContexts();
            var open = contexts.length;
            if (!open) {
              done();
            }
            contexts.forEach(function(ctx) {
              var ready = function ready2() {
                _this6.iterateThroughNodes(whatToShow, ctx, each, filter, function() {
                  if (--open <= 0) {
                    done();
                  }
                });
              };
              if (_this6.iframes) {
                _this6.waitForIframes(ctx, ready);
              } else {
                ready();
              }
            });
          }
        }], [{
          key: "matches",
          value: function matches(element, selector) {
            var selectors = typeof selector === "string" ? [selector] : selector, fn = element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector;
            if (fn) {
              var match = false;
              selectors.every(function(sel) {
                if (fn.call(element, sel)) {
                  match = true;
                  return false;
                }
                return true;
              });
              return match;
            } else {
              return false;
            }
          }
        }]);
        return DOMIterator2;
      }();
      var Mark$1 = function() {
        function Mark3(ctx) {
          classCallCheck(this, Mark3);
          this.ctx = ctx;
          this.ie = false;
          var ua = window.navigator.userAgent;
          if (ua.indexOf("MSIE") > -1 || ua.indexOf("Trident") > -1) {
            this.ie = true;
          }
        }
        createClass(Mark3, [{
          key: "log",
          value: function log(msg) {
            var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "debug";
            var log2 = this.opt.log;
            if (!this.opt.debug) {
              return;
            }
            if ((typeof log2 === "undefined" ? "undefined" : _typeof(log2)) === "object" && typeof log2[level] === "function") {
              log2[level]("mark.js: " + msg);
            }
          }
        }, {
          key: "escapeStr",
          value: function escapeStr(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }, {
          key: "createRegExp",
          value: function createRegExp(str) {
            if (this.opt.wildcards !== "disabled") {
              str = this.setupWildcardsRegExp(str);
            }
            str = this.escapeStr(str);
            if (Object.keys(this.opt.synonyms).length) {
              str = this.createSynonymsRegExp(str);
            }
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.setupIgnoreJoinersRegExp(str);
            }
            if (this.opt.diacritics) {
              str = this.createDiacriticsRegExp(str);
            }
            str = this.createMergedBlanksRegExp(str);
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.createJoinersRegExp(str);
            }
            if (this.opt.wildcards !== "disabled") {
              str = this.createWildcardsRegExp(str);
            }
            str = this.createAccuracyRegExp(str);
            return str;
          }
        }, {
          key: "createSynonymsRegExp",
          value: function createSynonymsRegExp(str) {
            var syn = this.opt.synonyms, sens = this.opt.caseSensitive ? "" : "i", joinerPlaceholder = this.opt.ignoreJoiners || this.opt.ignorePunctuation.length ? "\0" : "";
            for (var index in syn) {
              if (syn.hasOwnProperty(index)) {
                var value = syn[index], k1 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(index) : this.escapeStr(index), k2 = this.opt.wildcards !== "disabled" ? this.setupWildcardsRegExp(value) : this.escapeStr(value);
                if (k1 !== "" && k2 !== "") {
                  str = str.replace(new RegExp("(" + this.escapeStr(k1) + "|" + this.escapeStr(k2) + ")", "gm" + sens), joinerPlaceholder + ("(" + this.processSynomyms(k1) + "|") + (this.processSynomyms(k2) + ")") + joinerPlaceholder);
                }
              }
            }
            return str;
          }
        }, {
          key: "processSynomyms",
          value: function processSynomyms(str) {
            if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {
              str = this.setupIgnoreJoinersRegExp(str);
            }
            return str;
          }
        }, {
          key: "setupWildcardsRegExp",
          value: function setupWildcardsRegExp(str) {
            str = str.replace(/(?:\\)*\?/g, function(val) {
              return val.charAt(0) === "\\" ? "?" : "";
            });
            return str.replace(/(?:\\)*\*/g, function(val) {
              return val.charAt(0) === "\\" ? "*" : "";
            });
          }
        }, {
          key: "createWildcardsRegExp",
          value: function createWildcardsRegExp(str) {
            var spaces = this.opt.wildcards === "withSpaces";
            return str.replace(/\u0001/g, spaces ? "[\\S\\s]?" : "\\S?").replace(/\u0002/g, spaces ? "[\\S\\s]*?" : "\\S*");
          }
        }, {
          key: "setupIgnoreJoinersRegExp",
          value: function setupIgnoreJoinersRegExp(str) {
            return str.replace(/[^(|)\\]/g, function(val, indx, original) {
              var nextChar = original.charAt(indx + 1);
              if (/[(|)\\]/.test(nextChar) || nextChar === "") {
                return val;
              } else {
                return val + "\0";
              }
            });
          }
        }, {
          key: "createJoinersRegExp",
          value: function createJoinersRegExp(str) {
            var joiner = [];
            var ignorePunctuation = this.opt.ignorePunctuation;
            if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {
              joiner.push(this.escapeStr(ignorePunctuation.join("")));
            }
            if (this.opt.ignoreJoiners) {
              joiner.push("\\u00ad\\u200b\\u200c\\u200d");
            }
            return joiner.length ? str.split(/\u0000+/).join("[" + joiner.join("") + "]*") : str;
          }
        }, {
          key: "createDiacriticsRegExp",
          value: function createDiacriticsRegExp(str) {
            var sens = this.opt.caseSensitive ? "" : "i", dct = this.opt.caseSensitive ? ["a\xE0\xE1\u1EA3\xE3\u1EA1\u0103\u1EB1\u1EAF\u1EB3\u1EB5\u1EB7\xE2\u1EA7\u1EA5\u1EA9\u1EAB\u1EAD\xE4\xE5\u0101\u0105", "A\xC0\xC1\u1EA2\xC3\u1EA0\u0102\u1EB0\u1EAE\u1EB2\u1EB4\u1EB6\xC2\u1EA6\u1EA4\u1EA8\u1EAA\u1EAC\xC4\xC5\u0100\u0104", "c\xE7\u0107\u010D", "C\xC7\u0106\u010C", "d\u0111\u010F", "D\u0110\u010E", "e\xE8\xE9\u1EBB\u1EBD\u1EB9\xEA\u1EC1\u1EBF\u1EC3\u1EC5\u1EC7\xEB\u011B\u0113\u0119", "E\xC8\xC9\u1EBA\u1EBC\u1EB8\xCA\u1EC0\u1EBE\u1EC2\u1EC4\u1EC6\xCB\u011A\u0112\u0118", "i\xEC\xED\u1EC9\u0129\u1ECB\xEE\xEF\u012B", "I\xCC\xCD\u1EC8\u0128\u1ECA\xCE\xCF\u012A", "l\u0142", "L\u0141", "n\xF1\u0148\u0144", "N\xD1\u0147\u0143", "o\xF2\xF3\u1ECF\xF5\u1ECD\xF4\u1ED3\u1ED1\u1ED5\u1ED7\u1ED9\u01A1\u1EDF\u1EE1\u1EDB\u1EDD\u1EE3\xF6\xF8\u014D", "O\xD2\xD3\u1ECE\xD5\u1ECC\xD4\u1ED2\u1ED0\u1ED4\u1ED6\u1ED8\u01A0\u1EDE\u1EE0\u1EDA\u1EDC\u1EE2\xD6\xD8\u014C", "r\u0159", "R\u0158", "s\u0161\u015B\u0219\u015F", "S\u0160\u015A\u0218\u015E", "t\u0165\u021B\u0163", "T\u0164\u021A\u0162", "u\xF9\xFA\u1EE7\u0169\u1EE5\u01B0\u1EEB\u1EE9\u1EED\u1EEF\u1EF1\xFB\xFC\u016F\u016B", "U\xD9\xDA\u1EE6\u0168\u1EE4\u01AF\u1EEA\u1EE8\u1EEC\u1EEE\u1EF0\xDB\xDC\u016E\u016A", "y\xFD\u1EF3\u1EF7\u1EF9\u1EF5\xFF", "Y\xDD\u1EF2\u1EF6\u1EF8\u1EF4\u0178", "z\u017E\u017C\u017A", "Z\u017D\u017B\u0179"] : ["a\xE0\xE1\u1EA3\xE3\u1EA1\u0103\u1EB1\u1EAF\u1EB3\u1EB5\u1EB7\xE2\u1EA7\u1EA5\u1EA9\u1EAB\u1EAD\xE4\xE5\u0101\u0105A\xC0\xC1\u1EA2\xC3\u1EA0\u0102\u1EB0\u1EAE\u1EB2\u1EB4\u1EB6\xC2\u1EA6\u1EA4\u1EA8\u1EAA\u1EAC\xC4\xC5\u0100\u0104", "c\xE7\u0107\u010DC\xC7\u0106\u010C", "d\u0111\u010FD\u0110\u010E", "e\xE8\xE9\u1EBB\u1EBD\u1EB9\xEA\u1EC1\u1EBF\u1EC3\u1EC5\u1EC7\xEB\u011B\u0113\u0119E\xC8\xC9\u1EBA\u1EBC\u1EB8\xCA\u1EC0\u1EBE\u1EC2\u1EC4\u1EC6\xCB\u011A\u0112\u0118", "i\xEC\xED\u1EC9\u0129\u1ECB\xEE\xEF\u012BI\xCC\xCD\u1EC8\u0128\u1ECA\xCE\xCF\u012A", "l\u0142L\u0141", "n\xF1\u0148\u0144N\xD1\u0147\u0143", "o\xF2\xF3\u1ECF\xF5\u1ECD\xF4\u1ED3\u1ED1\u1ED5\u1ED7\u1ED9\u01A1\u1EDF\u1EE1\u1EDB\u1EDD\u1EE3\xF6\xF8\u014DO\xD2\xD3\u1ECE\xD5\u1ECC\xD4\u1ED2\u1ED0\u1ED4\u1ED6\u1ED8\u01A0\u1EDE\u1EE0\u1EDA\u1EDC\u1EE2\xD6\xD8\u014C", "r\u0159R\u0158", "s\u0161\u015B\u0219\u015FS\u0160\u015A\u0218\u015E", "t\u0165\u021B\u0163T\u0164\u021A\u0162", "u\xF9\xFA\u1EE7\u0169\u1EE5\u01B0\u1EEB\u1EE9\u1EED\u1EEF\u1EF1\xFB\xFC\u016F\u016BU\xD9\xDA\u1EE6\u0168\u1EE4\u01AF\u1EEA\u1EE8\u1EEC\u1EEE\u1EF0\xDB\xDC\u016E\u016A", "y\xFD\u1EF3\u1EF7\u1EF9\u1EF5\xFFY\xDD\u1EF2\u1EF6\u1EF8\u1EF4\u0178", "z\u017E\u017C\u017AZ\u017D\u017B\u0179"];
            var handled = [];
            str.split("").forEach(function(ch) {
              dct.every(function(dct2) {
                if (dct2.indexOf(ch) !== -1) {
                  if (handled.indexOf(dct2) > -1) {
                    return false;
                  }
                  str = str.replace(new RegExp("[" + dct2 + "]", "gm" + sens), "[" + dct2 + "]");
                  handled.push(dct2);
                }
                return true;
              });
            });
            return str;
          }
        }, {
          key: "createMergedBlanksRegExp",
          value: function createMergedBlanksRegExp(str) {
            return str.replace(/[\s]+/gmi, "[\\s]+");
          }
        }, {
          key: "createAccuracyRegExp",
          value: function createAccuracyRegExp(str) {
            var _this = this;
            var chars = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\xA1\xBF";
            var acc = this.opt.accuracy, val = typeof acc === "string" ? acc : acc.value, ls = typeof acc === "string" ? [] : acc.limiters, lsJoin = "";
            ls.forEach(function(limiter) {
              lsJoin += "|" + _this.escapeStr(limiter);
            });
            switch (val) {
              case "partially":
              default:
                return "()(" + str + ")";
              case "complementary":
                lsJoin = "\\s" + (lsJoin ? lsJoin : this.escapeStr(chars));
                return "()([^" + lsJoin + "]*" + str + "[^" + lsJoin + "]*)";
              case "exactly":
                return "(^|\\s" + lsJoin + ")(" + str + ")(?=$|\\s" + lsJoin + ")";
            }
          }
        }, {
          key: "getSeparatedKeywords",
          value: function getSeparatedKeywords(sv) {
            var _this2 = this;
            var stack = [];
            sv.forEach(function(kw) {
              if (!_this2.opt.separateWordSearch) {
                if (kw.trim() && stack.indexOf(kw) === -1) {
                  stack.push(kw);
                }
              } else {
                kw.split(" ").forEach(function(kwSplitted) {
                  if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {
                    stack.push(kwSplitted);
                  }
                });
              }
            });
            return {
              "keywords": stack.sort(function(a, b) {
                return b.length - a.length;
              }),
              "length": stack.length
            };
          }
        }, {
          key: "isNumeric",
          value: function isNumeric(value) {
            return Number(parseFloat(value)) == value;
          }
        }, {
          key: "checkRanges",
          value: function checkRanges(array) {
            var _this3 = this;
            if (!Array.isArray(array) || Object.prototype.toString.call(array[0]) !== "[object Object]") {
              this.log("markRanges() will only accept an array of objects");
              this.opt.noMatch(array);
              return [];
            }
            var stack = [];
            var last = 0;
            array.sort(function(a, b) {
              return a.start - b.start;
            }).forEach(function(item) {
              var _callNoMatchOnInvalid = _this3.callNoMatchOnInvalidRanges(item, last), start = _callNoMatchOnInvalid.start, end = _callNoMatchOnInvalid.end, valid = _callNoMatchOnInvalid.valid;
              if (valid) {
                item.start = start;
                item.length = end - start;
                stack.push(item);
                last = end;
              }
            });
            return stack;
          }
        }, {
          key: "callNoMatchOnInvalidRanges",
          value: function callNoMatchOnInvalidRanges(range, last) {
            var start = void 0, end = void 0, valid = false;
            if (range && typeof range.start !== "undefined") {
              start = parseInt(range.start, 10);
              end = start + parseInt(range.length, 10);
              if (this.isNumeric(range.start) && this.isNumeric(range.length) && end - last > 0 && end - start > 0) {
                valid = true;
              } else {
                this.log("Ignoring invalid or overlapping range: " + ("" + JSON.stringify(range)));
                this.opt.noMatch(range);
              }
            } else {
              this.log("Ignoring invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start,
              end,
              valid
            };
          }
        }, {
          key: "checkWhitespaceRanges",
          value: function checkWhitespaceRanges(range, originalLength, string) {
            var end = void 0, valid = true, max = string.length, offset = originalLength - max, start = parseInt(range.start, 10) - offset;
            start = start > max ? max : start;
            end = start + parseInt(range.length, 10);
            if (end > max) {
              end = max;
              this.log("End range automatically set to the max value of " + max);
            }
            if (start < 0 || end - start < 0 || start > max || end > max) {
              valid = false;
              this.log("Invalid range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            } else if (string.substring(start, end).replace(/\s+/g, "") === "") {
              valid = false;
              this.log("Skipping whitespace only range: " + JSON.stringify(range));
              this.opt.noMatch(range);
            }
            return {
              start,
              end,
              valid
            };
          }
        }, {
          key: "getTextNodes",
          value: function getTextNodes(cb) {
            var _this4 = this;
            var val = "", nodes = [];
            this.iterator.forEachNode(NodeFilter.SHOW_TEXT, function(node) {
              nodes.push({
                start: val.length,
                end: (val += node.textContent).length,
                node
              });
            }, function(node) {
              if (_this4.matchesExclude(node.parentNode)) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, function() {
              cb({
                value: val,
                nodes
              });
            });
          }
        }, {
          key: "matchesExclude",
          value: function matchesExclude(el) {
            return DOMIterator.matches(el, this.opt.exclude.concat(["script", "style", "title", "head", "html"]));
          }
        }, {
          key: "wrapRangeInTextNode",
          value: function wrapRangeInTextNode(node, start, end) {
            var hEl = !this.opt.element ? "mark" : this.opt.element, startNode = node.splitText(start), ret = startNode.splitText(end - start);
            var repl = document.createElement(hEl);
            repl.setAttribute("data-markjs", "true");
            if (this.opt.className) {
              repl.setAttribute("class", this.opt.className);
            }
            repl.textContent = startNode.textContent;
            startNode.parentNode.replaceChild(repl, startNode);
            return ret;
          }
        }, {
          key: "wrapRangeInMappedTextNode",
          value: function wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {
            var _this5 = this;
            dict.nodes.every(function(n, i) {
              var sibl = dict.nodes[i + 1];
              if (typeof sibl === "undefined" || sibl.start > start) {
                if (!filterCb(n.node)) {
                  return false;
                }
                var s = start - n.start, e = (end > n.end ? n.end : end) - n.start, startStr = dict.value.substr(0, n.start), endStr = dict.value.substr(e + n.start);
                n.node = _this5.wrapRangeInTextNode(n.node, s, e);
                dict.value = startStr + endStr;
                dict.nodes.forEach(function(k, j) {
                  if (j >= i) {
                    if (dict.nodes[j].start > 0 && j !== i) {
                      dict.nodes[j].start -= e;
                    }
                    dict.nodes[j].end -= e;
                  }
                });
                end -= e;
                eachCb(n.node.previousSibling, n.start);
                if (end > n.end) {
                  start = n.end;
                } else {
                  return false;
                }
              }
              return true;
            });
          }
        }, {
          key: "wrapMatches",
          value: function wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this6 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              dict.nodes.forEach(function(node) {
                node = node.node;
                var match = void 0;
                while ((match = regex.exec(node.textContent)) !== null && match[matchIdx] !== "") {
                  if (!filterCb(match[matchIdx], node)) {
                    continue;
                  }
                  var pos = match.index;
                  if (matchIdx !== 0) {
                    for (var i = 1; i < matchIdx; i++) {
                      pos += match[i].length;
                    }
                  }
                  node = _this6.wrapRangeInTextNode(node, pos, pos + match[matchIdx].length);
                  eachCb(node.previousSibling);
                  regex.lastIndex = 0;
                }
              });
              endCb();
            });
          }
        }, {
          key: "wrapMatchesAcrossElements",
          value: function wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {
            var _this7 = this;
            var matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;
            this.getTextNodes(function(dict) {
              var match = void 0;
              while ((match = regex.exec(dict.value)) !== null && match[matchIdx] !== "") {
                var start = match.index;
                if (matchIdx !== 0) {
                  for (var i = 1; i < matchIdx; i++) {
                    start += match[i].length;
                  }
                }
                var end = start + match[matchIdx].length;
                _this7.wrapRangeInMappedTextNode(dict, start, end, function(node) {
                  return filterCb(match[matchIdx], node);
                }, function(node, lastIndex) {
                  regex.lastIndex = lastIndex;
                  eachCb(node);
                });
              }
              endCb();
            });
          }
        }, {
          key: "wrapRangeFromIndex",
          value: function wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {
            var _this8 = this;
            this.getTextNodes(function(dict) {
              var originalLength = dict.value.length;
              ranges.forEach(function(range, counter) {
                var _checkWhitespaceRange = _this8.checkWhitespaceRanges(range, originalLength, dict.value), start = _checkWhitespaceRange.start, end = _checkWhitespaceRange.end, valid = _checkWhitespaceRange.valid;
                if (valid) {
                  _this8.wrapRangeInMappedTextNode(dict, start, end, function(node) {
                    return filterCb(node, range, dict.value.substring(start, end), counter);
                  }, function(node) {
                    eachCb(node, range);
                  });
                }
              });
              endCb();
            });
          }
        }, {
          key: "unwrapMatches",
          value: function unwrapMatches(node) {
            var parent = node.parentNode;
            var docFrag = document.createDocumentFragment();
            while (node.firstChild) {
              docFrag.appendChild(node.removeChild(node.firstChild));
            }
            parent.replaceChild(docFrag, node);
            if (!this.ie) {
              parent.normalize();
            } else {
              this.normalizeTextNode(parent);
            }
          }
        }, {
          key: "normalizeTextNode",
          value: function normalizeTextNode(node) {
            if (!node) {
              return;
            }
            if (node.nodeType === 3) {
              while (node.nextSibling && node.nextSibling.nodeType === 3) {
                node.nodeValue += node.nextSibling.nodeValue;
                node.parentNode.removeChild(node.nextSibling);
              }
            } else {
              this.normalizeTextNode(node.firstChild);
            }
            this.normalizeTextNode(node.nextSibling);
          }
        }, {
          key: "markRegExp",
          value: function markRegExp(regexp, opt) {
            var _this9 = this;
            this.opt = opt;
            this.log('Searching with expression "' + regexp + '"');
            var totalMatches = 0, fn = "wrapMatches";
            var eachCb = function eachCb2(element) {
              totalMatches++;
              _this9.opt.each(element);
            };
            if (this.opt.acrossElements) {
              fn = "wrapMatchesAcrossElements";
            }
            this[fn](regexp, this.opt.ignoreGroups, function(match, node) {
              return _this9.opt.filter(node, match, totalMatches);
            }, eachCb, function() {
              if (totalMatches === 0) {
                _this9.opt.noMatch(regexp);
              }
              _this9.opt.done(totalMatches);
            });
          }
        }, {
          key: "mark",
          value: function mark(sv, opt) {
            var _this10 = this;
            this.opt = opt;
            var totalMatches = 0, fn = "wrapMatches";
            var _getSeparatedKeywords = this.getSeparatedKeywords(typeof sv === "string" ? [sv] : sv), kwArr = _getSeparatedKeywords.keywords, kwArrLen = _getSeparatedKeywords.length, sens = this.opt.caseSensitive ? "" : "i", handler = function handler2(kw) {
              var regex = new RegExp(_this10.createRegExp(kw), "gm" + sens), matches = 0;
              _this10.log('Searching with expression "' + regex + '"');
              _this10[fn](regex, 1, function(term, node) {
                return _this10.opt.filter(node, kw, totalMatches, matches);
              }, function(element) {
                matches++;
                totalMatches++;
                _this10.opt.each(element);
              }, function() {
                if (matches === 0) {
                  _this10.opt.noMatch(kw);
                }
                if (kwArr[kwArrLen - 1] === kw) {
                  _this10.opt.done(totalMatches);
                } else {
                  handler2(kwArr[kwArr.indexOf(kw) + 1]);
                }
              });
            };
            if (this.opt.acrossElements) {
              fn = "wrapMatchesAcrossElements";
            }
            if (kwArrLen === 0) {
              this.opt.done(totalMatches);
            } else {
              handler(kwArr[0]);
            }
          }
        }, {
          key: "markRanges",
          value: function markRanges(rawRanges, opt) {
            var _this11 = this;
            this.opt = opt;
            var totalMatches = 0, ranges = this.checkRanges(rawRanges);
            if (ranges && ranges.length) {
              this.log("Starting to mark with the following ranges: " + JSON.stringify(ranges));
              this.wrapRangeFromIndex(ranges, function(node, range, match, counter) {
                return _this11.opt.filter(node, range, match, counter);
              }, function(element, range) {
                totalMatches++;
                _this11.opt.each(element, range);
              }, function() {
                _this11.opt.done(totalMatches);
              });
            } else {
              this.opt.done(totalMatches);
            }
          }
        }, {
          key: "unmark",
          value: function unmark(opt) {
            var _this12 = this;
            this.opt = opt;
            var sel = this.opt.element ? this.opt.element : "*";
            sel += "[data-markjs]";
            if (this.opt.className) {
              sel += "." + this.opt.className;
            }
            this.log('Removal selector "' + sel + '"');
            this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, function(node) {
              _this12.unwrapMatches(node);
            }, function(node) {
              var matchesSel = DOMIterator.matches(node, sel), matchesExclude = _this12.matchesExclude(node);
              if (!matchesSel || matchesExclude) {
                return NodeFilter.FILTER_REJECT;
              } else {
                return NodeFilter.FILTER_ACCEPT;
              }
            }, this.opt.done);
          }
        }, {
          key: "opt",
          set: function set$$1(val) {
            this._opt = _extends({}, {
              "element": "",
              "className": "",
              "exclude": [],
              "iframes": false,
              "iframesTimeout": 5e3,
              "separateWordSearch": true,
              "diacritics": true,
              "synonyms": {},
              "accuracy": "partially",
              "acrossElements": false,
              "caseSensitive": false,
              "ignoreJoiners": false,
              "ignoreGroups": 0,
              "ignorePunctuation": [],
              "wildcards": "disabled",
              "each": function each() {
              },
              "noMatch": function noMatch() {
              },
              "filter": function filter() {
                return true;
              },
              "done": function done() {
              },
              "debug": false,
              "log": window.console
            }, val);
          },
          get: function get$$1() {
            return this._opt;
          }
        }, {
          key: "iterator",
          get: function get$$1() {
            return new DOMIterator(this.ctx, this.opt.iframes, this.opt.exclude, this.opt.iframesTimeout);
          }
        }]);
        return Mark3;
      }();
      function Mark2(ctx) {
        var _this = this;
        var instance = new Mark$1(ctx);
        this.mark = function(sv, opt) {
          instance.mark(sv, opt);
          return _this;
        };
        this.markRegExp = function(sv, opt) {
          instance.markRegExp(sv, opt);
          return _this;
        };
        this.markRanges = function(sv, opt) {
          instance.markRanges(sv, opt);
          return _this;
        };
        this.unmark = function(opt) {
          instance.unmark(opt);
          return _this;
        };
        return this;
      }
      return Mark2;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AsciidocPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/adocNewFileModal.ts
var import_obsidian = require("obsidian");
var AdocNewFileModal = class extends import_obsidian.Modal {
  constructor(plugin, parent) {
    super(plugin.app);
    this.plugin = plugin;
    this.fileName = "new_name";
    this.ext = "adoc";
    this.parent = parent != null ? parent : this.plugin.app.vault.getRoot();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("new-adoc-modal");
    const pathInput = new import_obsidian.TextComponent(contentEl);
    pathInput.inputEl.addClass("modal_input");
    pathInput.setValue(this.fileName);
    pathInput.inputEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        this.complete();
      }
    });
    pathInput.onChange((value) => this.fileName = value);
    const submitButton = new import_obsidian.ButtonComponent(contentEl);
    submitButton.setCta();
    submitButton.setButtonText("Create");
    submitButton.onClick(() => this.complete());
    pathInput.inputEl.focus();
  }
  async complete() {
    this.close();
    const parent = this.parent instanceof import_obsidian.TFile ? this.parent.parent : this.parent;
    if (parent instanceof import_obsidian.TFolder) {
      const newPath = `${parent.path}/${this.fileName}.${this.ext}`;
      const existingFile = this.app.vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(newPath));
      if (existingFile && existingFile instanceof import_obsidian.TFile) {
        new import_obsidian.Notice("File already exists");
        const leaf2 = this.app.workspace.getLeaf(true);
        leaf2.openFile(existingFile);
        return;
      }
      const newFile = await this.app.vault.create(
        newPath,
        "",
        {}
      );
      const leaf = this.app.workspace.getLeaf(true);
      leaf.openFile(newFile);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/asciidocView.ts
var import_obsidian3 = require("obsidian");
var import_obsidian4 = require("obsidian");
var import_asciidoctor = __toESM(require_asciidoctor());
var import_search2 = require("@codemirror/search");
var import_language3 = require("@codemirror/language");
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
var import_language4 = require("@codemirror/language");
var import_stream_parser = require("@codemirror/stream-parser");

// src/codemirror.ts
var import_commands = require("@codemirror/commands");
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_autocomplete = require("@codemirror/autocomplete");
var import_search = require("@codemirror/search");
var import_lint = require("@codemirror/lint");
var import_language2 = require("@codemirror/language");
var import_highlight = require("@lezer/highlight");
var codemirrorConfig = {
  name: "obsidian",
  dark: false,
  background: "var(--background-primary)",
  foreground: "var(--text-normal)",
  selection: "var(--text-selection)",
  cursor: "var(--text-normal)",
  dropdownBackground: "var(--background-primary)",
  dropdownBorder: "var(--background-modifier-border)",
  activeLine: "var(--background-primary)",
  matchingBracket: "var(--background-modifier-accent)",
  keyword: "#d73a49",
  storage: "#d73a49",
  variable: "var(--text-normal)",
  parameter: "var(--text-accent-hover)",
  function: "var(--text-accent-hover)",
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  type: "var(--text-accent-hover)",
  class: "#6f42c1",
  number: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)",
  regexp: "#032f62"
};
var obsidianTheme = import_view.EditorView.theme(
  {
    "&": {
      color: codemirrorConfig.foreground,
      backgroundColor: codemirrorConfig.background
    },
    ".cm-content": { caretColor: codemirrorConfig.cursor },
    "&.cm-focused .cm-cursor": { borderLeftColor: codemirrorConfig.cursor },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, & ::selection": {
      backgroundColor: codemirrorConfig.selection
    },
    ".cm-panels": {
      backgroundColor: codemirrorConfig.dropdownBackground,
      color: codemirrorConfig.foreground
    },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: codemirrorConfig.dropdownBackground,
      outline: `1px solid ${codemirrorConfig.dropdownBorder}`
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: codemirrorConfig.selection
    },
    ".cm-activeLine": { backgroundColor: codemirrorConfig.activeLine },
    ".cm-activeLineGutter": {
      backgroundColor: codemirrorConfig.background
    },
    ".cm-selectionMatch": { backgroundColor: codemirrorConfig.selection },
    ".cm-matchingBracket, .cm-nonmatchingBracket": {
      backgroundColor: codemirrorConfig.matchingBracket,
      outline: "none"
    },
    ".cm-gutters": {
      backgroundColor: codemirrorConfig.background,
      color: codemirrorConfig.comment,
      borderRight: "1px solid var(--background-modifier-border)"
    },
    ".cm-lineNumbers, .cm-gutterElement": { color: "inherit" },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: codemirrorConfig.foreground
    },
    ".cm-tooltip": {
      border: `1px solid ${codemirrorConfig.dropdownBorder}`,
      backgroundColor: codemirrorConfig.dropdownBackground,
      color: codemirrorConfig.foreground
    },
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        background: codemirrorConfig.selection,
        color: codemirrorConfig.foreground
      }
    }
  },
  { dark: codemirrorConfig.dark }
);
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: import_highlight.tags.keyword, color: codemirrorConfig.keyword },
  {
    tag: [import_highlight.tags.name, import_highlight.tags.deleted, import_highlight.tags.character, import_highlight.tags.macroName],
    color: codemirrorConfig.variable
  },
  { tag: [import_highlight.tags.propertyName], color: codemirrorConfig.function },
  {
    tag: [
      import_highlight.tags.processingInstruction,
      import_highlight.tags.string,
      import_highlight.tags.inserted,
      import_highlight.tags.special(import_highlight.tags.string)
    ],
    color: codemirrorConfig.string
  },
  {
    tag: [import_highlight.tags.function(import_highlight.tags.variableName), import_highlight.tags.labelName],
    color: codemirrorConfig.function
  },
  {
    tag: [import_highlight.tags.color, import_highlight.tags.constant(import_highlight.tags.name), import_highlight.tags.standard(import_highlight.tags.name)],
    color: codemirrorConfig.constant
  },
  {
    tag: [import_highlight.tags.definition(import_highlight.tags.name), import_highlight.tags.separator],
    color: codemirrorConfig.variable
  },
  { tag: [import_highlight.tags.className], color: codemirrorConfig.class },
  {
    tag: [
      import_highlight.tags.number,
      import_highlight.tags.changed,
      import_highlight.tags.annotation,
      import_highlight.tags.modifier,
      import_highlight.tags.self,
      import_highlight.tags.namespace
    ],
    color: codemirrorConfig.number
  },
  {
    tag: [import_highlight.tags.typeName],
    color: codemirrorConfig.type,
    fontStyle: codemirrorConfig.type
  },
  { tag: [import_highlight.tags.operator, import_highlight.tags.operatorKeyword], color: codemirrorConfig.keyword },
  {
    tag: [import_highlight.tags.url, import_highlight.tags.escape, import_highlight.tags.regexp, import_highlight.tags.link],
    color: codemirrorConfig.regexp
  },
  { tag: [import_highlight.tags.meta, import_highlight.tags.comment], color: codemirrorConfig.comment },
  {
    tag: [import_highlight.tags.atom, import_highlight.tags.bool, import_highlight.tags.special(import_highlight.tags.variableName)],
    color: codemirrorConfig.variable
  },
  { tag: import_highlight.tags.invalid, color: codemirrorConfig.invalid }
]);
var basicExtensions = [
  (0, import_commands.history)(),
  (0, import_language.foldGutter)(),
  (0, import_view.dropCursor)(),
  import_state.EditorState.allowMultipleSelections.of(true),
  (0, import_language.indentOnInput)(),
  import_view.EditorView.lineWrapping,
  (0, import_language.bracketMatching)(),
  (0, import_autocomplete.closeBrackets)(),
  (0, import_search.highlightSelectionMatches)(),
  obsidianTheme,
  //syntaxHighlighting(obsidianHighlightStyle),
  import_view.keymap.of([
    ...import_autocomplete.closeBracketsKeymap,
    ...import_commands.defaultKeymap,
    ...import_search.searchKeymap,
    ...import_commands.historyKeymap,
    import_commands.indentWithTab,
    ...import_language.foldKeymap,
    ...import_autocomplete.completionKeymap,
    ...import_lint.lintKeymap
  ])
];
var language = new import_state.Compartment();

// src/searchCtx.ts
var import_mark = __toESM(require_mark());
var SearchCtx = class {
  constructor(rootDiv, searchContainer) {
    this.root = rootDiv;
    this.mark = new import_mark.default(rootDiv);
    this.isSearchActive = false;
    this.resultOffset = 0;
    this.searchBox = null;
    this.searchContainer = searchContainer;
  }
  render() {
    this.isSearchActive = true;
    let searchBox = createEl("div", { cls: "CodeMirror-dialog CodeMirror-dialog-top" });
    searchBox.createEl("span", {
      cls: "CodeMirror-search-label",
      text: "Search:"
    });
    searchBox.createEl("input", {
      type: "text",
      cls: "CodeMirror-search-field"
    });
    searchBox.createEl("span", { cls: "CodeMirror-search-hint" });
    this.searchContainer.insertBefore(searchBox, this.searchContainer.children[0]);
    let collection = searchBox.getElementsByTagName("input");
    collection[0].addEventListener("keyup", (e) => {
      if (e.keyCode == 13) {
        this.search(collection[0].value);
      }
    }, true);
    collection[0].focus();
    this.searchBox = searchBox;
  }
  search(s) {
    if (!this.isSearchActive) {
      this.resultOffset = 0;
    }
    this.isSearchActive = true;
    this.mark.unmark();
    this.mark.mark(s, { separateWordSearch: false });
    let elements = this.root.getElementsByTagName("mark");
    if (elements.length != 0) {
      if (this.resultOffset >= elements.length)
        this.resultOffset = 0;
      elements[this.resultOffset].scrollIntoView();
      this.resultOffset += 1;
    }
  }
  focus() {
    if (this.isSearchActive && this.searchBox) {
      let collection = this.searchBox.getElementsByTagName("input");
      if (collection.length)
        collection[0].focus();
      return;
    } else {
      this.render();
    }
  }
  resetSearch() {
    if (this.isSearchActive && this.searchBox) {
      this.searchBox.remove();
    }
    this.isSearchActive = false;
  }
};

// node_modules/codemirror-asciidoc/lib/asciidoc.js
var HighlightRules = function() {
  var identifierRe = "[a-zA-Z\xA1-\uFFFF]+\\b";
  this.$rules = {
    "start": [
      { token: "empty", regex: /$/ },
      { token: "literal", regex: /^\.{4,}\s*$/, next: "listingBlock" },
      { token: "literal", regex: /^-{4,}\s*$/, next: "literalBlock" },
      { token: "literal", regex: /^\+{4,}\s*$/, next: "passthroughBlock" },
      { token: "keyword", regex: /^={4,}\s*$/ },
      { token: "text", regex: /^\s*$/ },
      // immediately return to the start mode without matching anything
      { token: "empty", regex: "", next: "dissallowDelimitedBlock" }
    ],
    "dissallowDelimitedBlock": [
      { include: "paragraphEnd" },
      { token: "comment", regex: "^//.+$" },
      { token: "keyword", regex: "^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\\s" },
      { include: "listStart" },
      { token: "literal", regex: /^\s+.+$/, next: "indentedBlock" },
      { token: "empty", regex: "", next: "text" }
    ],
    "paragraphEnd": [
      { token: "doc.comment", regex: /^\/{4,}\s*$/, next: "commentBlock" },
      { token: "tableBlock", regex: /^\s*[|!]=+\s*$/, next: "tableBlock" },
      // open block, ruler
      { token: "keyword", regex: /^(?:--|''')\s*$/, next: "start" },
      { token: "option", regex: /^\[.*\]\s*$/, next: "start" },
      { token: "pageBreak", regex: /^>{3,}$/, next: "start" },
      { token: "literal", regex: /^\.{4,}\s*$/, next: "listingBlock" },
      { token: "titleUnderline", regex: /^(?:={2,}|-{2,}|~{2,}|\^{2,}|\+{2,})\s*$/, next: "start" },
      { token: "singleLineTitle", regex: /^={1,6}\s+\S.*$/, next: "start" },
      { token: "otherBlock", regex: /^(?:\*{2,}|_{2,})\s*$/, next: "start" },
      // .optional title
      { token: "optionalTitle", regex: /^\.[^.\s].+$/, next: "start" }
    ],
    "listStart": [
      {
        token: "keyword",
        regex: /^\s*(?:\d+\.|[a-zA-Z]\.|[ixvmIXVM]+\)|\*{1,5}|-|\.{1,5})\s/,
        next: "listText"
      },
      { token: "meta.tag", regex: /^.+(?::{2,4}|;;)(?: |$)/, next: "listText" },
      // continuation
      { token: "keyword", regex: /^\+\s*$/, next: "start" }
    ],
    "text": [
      {
        token: ["link", "link"],
        regex: /((?:https?:\/\/|ftp:\/\/|file:\/\/|mailto:|callto:)[^\s\[]+)(\[.*?\])/
      },
      { token: ["link", "link"], regex: /(?:https?:\/\/|ftp:\/\/|file:\/\/|mailto:|callto:)[^\s\[]+/ },
      { token: "link", regex: /\b[\w\.\/\-]+@[\w\.\/\-]+\b/ },
      { include: "macros" },
      { include: "paragraphEnd" },
      { token: "literal", regex: /\+{3,}/, next: "smallPassthrough" },
      {
        token: "escape",
        regex: /\((?:C|TM|R)\)|\.{3}|->|<-|=>|<=|&#(?:\d+|x[a-fA-F\d]+);|(?: |^)--(?=\s+\S)/
      },
      { token: "escape", regex: /\\[_*'`+#]|\\{2}[_*'`+#]{2}/ },
      { token: "keyword", regex: /\s\+$/ },
      // any word
      { token: "text", regex: identifierRe },
      {
        token: ["keyword", "string", "keyword"],
        regex: /(<<[\w\d\-$]+,)(.*?)(>>|$)/
      },
      { token: "keyword", regex: /<<[\w\d\-$]+,?|>>/ },
      { token: "constant.character", regex: /\({2,3}.*?\){2,3}/ },
      // List of callouts
      { token: "support.function.list.callout", regex: /^(?:<\d+>|\d+>|>) /, next: "text" },
      // Anchor
      { token: "keyword", regex: /\[\[.+?\]\]/ },
      // bibliography
      { token: "support", regex: /^\[{3}[\w\d =\-]+\]{3}/ },
      { include: "quotes" },
      // text block end
      { token: "empty", regex: /^\s*$/, next: "start" }
    ],
    "listText": [
      { include: "listStart" },
      { include: "text" }
    ],
    "indentedBlock": [
      { token: "literal", regex: /^[\s\w].+$/, next: "indentedBlock" },
      { token: "literal", regex: "", next: "start" }
    ],
    "listingBlock": [
      { token: "literal", regex: /^\.{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "constant.numeric", regex: "<\\d+>" },
      { token: "literal", regex: "[^<]+" },
      { token: "literal", regex: "<" }
    ],
    "literalBlock": [
      { token: "literal", regex: /^-{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "constant.numeric", regex: "<\\d+>" },
      { token: "literal", regex: "[^<]+" },
      { token: "literal", regex: "<" }
    ],
    "passthroughBlock": [
      { token: "literal", regex: /^\+{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: identifierRe + "|\\d+" },
      { include: "macros" },
      { token: "literal", regex: "." }
    ],
    "smallPassthrough": [
      { token: "literal", regex: /[+]{3,}/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: /^\s*$/, next: "dissallowDelimitedBlock" },
      { token: "literal", regex: identifierRe + "|\\d+" },
      { include: "macros" }
    ],
    "commentBlock": [
      { token: "doc.comment", regex: /^\/{4,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "doc.comment", regex: "^.*$" }
    ],
    "tableBlock": [
      { token: "tableBlock", regex: /^\s*\|={3,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "tableBlock", regex: /^\s*!={3,}\s*$/, next: "innerTableBlock" },
      { token: "tableBlock", regex: /\|/ },
      { include: "text", noEscape: true }
    ],
    "innerTableBlock": [
      { token: "tableBlock", regex: /^\s*!={3,}\s*$/, next: "tableBlock" },
      { token: "tableBlock", regex: /^\s*|={3,}\s*$/, next: "dissallowDelimitedBlock" },
      { token: "tableBlock", regex: /\!/ }
    ],
    "macros": [
      { token: "macro", regex: /{[\w\-$]+}/ },
      {
        token: ["text", "string", "text", "constant.character", "text"],
        regex: /({)([\w\-$]+)(:)?(.+)?(})/
      },
      {
        token: ["text", "markup.list.macro", "keyword", "string"],
        regex: /(\w+)(footnote(?:ref)?::?)([^\s\[]+)?(\[.*?\])?/
      },
      {
        token: ["markup.list.macro", "keyword", "string"],
        regex: /([a-zA-Z\-][\w\.\/\-]*::?)([^\s\[]+)(\[.*?\])?/
      },
      { token: ["markup.list.macro", "keyword"], regex: /([a-zA-Z\-][\w\.\/\-]+::?)(\[.*?\])/ },
      { token: "keyword", regex: /^:.+?:(?= |$)/ }
    ],
    "quotes": [
      { token: "string.italic", regex: /__[^_\s].*?__/ },
      { token: "string.italic", regex: quoteRule("_") },
      { token: "keyword.bold", regex: /\*\*[^*\s].*?\*\*/ },
      { token: "keyword.bold", regex: quoteRule("\\*") },
      { token: "literal", regex: /\+\+[^+\s].*?\+\+/ },
      { token: "literal", regex: quoteRule("\\+") },
      { token: "literal", regex: /\$\$.+?\$\$/ },
      { token: "literal", regex: quoteRule("\\$") },
      { token: "literal", regex: /``[^`\s].*?``/ },
      { token: "literal", regex: quoteRule("`") },
      { token: "keyword", regex: /\^[^\^].*?\^/ },
      { token: "keyword", regex: quoteRule("\\^") },
      { token: "keyword", regex: /~[^~].*?~/ },
      { token: "keyword", regex: quoteRule("~") },
      { token: "keyword", regex: /##?/ },
      { token: "keyword", regex: /(?:\B|^)``|\b''/ }
    ]
  };
  function quoteRule(ch) {
    var prefix = /\w/.test(ch) ? "\\b" : "(?:\\B|^)";
    return prefix + ch + "[^" + ch + "].*?" + ch + "(?![\\w*])";
  }
  var tokenMap = {
    macro: "constant.character",
    tableBlock: "doc.comment",
    titleUnderline: "markup.heading",
    singleLineTitle: "markup.heading",
    pageBreak: "string",
    option: "string.regexp",
    otherBlock: "markup.list",
    literal: "support.function",
    optionalTitle: "constant.numeric",
    escape: "constant.language.escape",
    link: "markup.underline.list"
  };
  for (var state in this.$rules) {
    var stateRules = this.$rules[state];
    for (var i = stateRules.length; i--; ) {
      var rule = stateRules[i];
      if (rule.include || typeof rule == "string") {
        var args = [i, 1].concat(this.$rules[rule.include || rule]);
        if (rule.noEscape) {
          args = args.filter(function(x) {
            return !x.next;
          });
        }
        stateRules.splice.apply(stateRules, args);
      } else if (rule.token in tokenMap) {
        rule.token = tokenMap[rule.token];
      }
    }
  }
};
var MAX_TOKEN_COUNT = 1e3;
var Tokenizer = function(rules) {
  this.states = rules;
  this.regExps = {};
  this.matchMappings = {};
  for (var key in this.states) {
    var state = this.states[key];
    var ruleRegExps = [];
    var matchTotal = 0;
    var mapping = this.matchMappings[key] = { defaultToken: "text" };
    var flag = "g";
    var splitterRurles = [];
    for (var i = 0; i < state.length; i++) {
      var rule = state[i];
      if (rule.defaultToken)
        mapping.defaultToken = rule.defaultToken;
      if (rule.caseInsensitive)
        flag = "gi";
      if (rule.regex == null)
        continue;
      if (rule.regex instanceof RegExp)
        rule.regex = rule.regex.toString().slice(1, -1);
      var adjustedregex = rule.regex;
      var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
      if (Array.isArray(rule.token)) {
        if (rule.token.length == 1 || matchcount == 1) {
          rule.token = rule.token[0];
        } else if (matchcount - 1 != rule.token.length) {
          throw new Error("number of classes and regexp groups in '" + rule.token + "'\n'" + rule.regex + "' doesn't match\n" + (matchcount - 1) + "!=" + rule.token.length);
        } else {
          rule.tokenArray = rule.token;
          rule.token = null;
          rule.onMatch = this.$arrayTokens;
        }
      } else if (typeof rule.token == "function" && !rule.onMatch) {
        if (matchcount > 1)
          rule.onMatch = this.$applyToken;
        else
          rule.onMatch = rule.token;
      }
      if (matchcount > 1) {
        if (/\\\d/.test(rule.regex)) {
          adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
          });
        } else {
          matchcount = 1;
          adjustedregex = this.removeCapturingGroups(rule.regex);
        }
        if (!rule.splitRegex && typeof rule.token != "string")
          splitterRurles.push(rule);
      }
      mapping[matchTotal] = i;
      matchTotal += matchcount;
      ruleRegExps.push(adjustedregex);
      if (!rule.onMatch)
        rule.onMatch = null;
    }
    splitterRurles.forEach(function(rule2) {
      rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
    }, this);
    this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
  }
};
(function() {
  this.$setMaxTokenCount = function(m) {
    MAX_TOKEN_COUNT = m | 0;
  };
  this.$applyToken = function(str) {
    var values = this.splitRegex.exec(str).slice(1);
    var types = this.token.apply(this, values);
    if (typeof types === "string")
      return [{ type: types, value: str }];
    var tokens = [];
    for (var i = 0, l = types.length; i < l; i++) {
      if (values[i])
        tokens[tokens.length] = {
          type: types[i],
          value: values[i]
        };
    }
    return tokens;
  }, this.$arrayTokens = function(str) {
    if (!str)
      return [];
    var values = this.splitRegex.exec(str);
    if (!values)
      return "text";
    var tokens = [];
    var types = this.tokenArray;
    for (var i = 0, l = types.length; i < l; i++) {
      if (values[i + 1])
        tokens[tokens.length] = {
          type: types[i],
          value: values[i + 1]
        };
    }
    return tokens;
  };
  this.removeCapturingGroups = function(src) {
    var r = src.replace(
      /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
      function(x, y) {
        return y ? "(?:" : x;
      }
    );
    return r;
  };
  this.createSplitterRegexp = function(src, flag) {
    if (src.indexOf("(?=") != -1) {
      var stack = 0;
      var inChClass = false;
      var lastCapture = {};
      src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
        if (inChClass) {
          inChClass = square != "]";
        } else if (square) {
          inChClass = true;
        } else if (parenClose) {
          if (stack == lastCapture.stack) {
            lastCapture.end = index + 1;
            lastCapture.stack = -1;
          }
          stack--;
        } else if (parenOpen) {
          stack++;
          if (parenOpen.length != 1) {
            lastCapture.stack = stack;
            lastCapture.start = index;
          }
        }
        return m;
      });
      if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
        src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
    }
    return new RegExp(src, (flag || "").replace("g", ""));
  };
  this.getLineTokens = function(line, startState) {
    if (startState && typeof startState != "string") {
      var stack = startState.slice(0);
      startState = stack[0];
    } else
      var stack = [];
    var currentState = startState || "start";
    var state = this.states[currentState];
    if (!state) {
      currentState = "start";
      state = this.states[currentState];
    }
    var mapping = this.matchMappings[currentState];
    var re = this.regExps[currentState];
    re.lastIndex = 0;
    var match, tokens = [];
    var lastIndex = 0;
    var token = { type: null, value: "" };
    while (match = re.exec(line)) {
      var type = mapping.defaultToken;
      var rule = null;
      var value = match[0];
      var index = re.lastIndex;
      if (index - value.length > lastIndex) {
        var skipped = line.substring(lastIndex, index - value.length);
        if (token.type == type) {
          token.value += skipped;
        } else {
          if (token.type)
            tokens.push(token);
          token = { type, value: skipped };
        }
      }
      for (var i = 0; i < match.length - 2; i++) {
        if (match[i + 1] === void 0)
          continue;
        rule = state[mapping[i]];
        if (rule.onMatch)
          type = rule.onMatch(value, currentState, stack);
        else
          type = rule.token;
        if (rule.next) {
          if (typeof rule.next == "string")
            currentState = rule.next;
          else
            currentState = rule.next(currentState, stack);
          state = this.states[currentState];
          if (!state) {
            window.console && console.error && console.error(currentState, "doesn't exist");
            currentState = "start";
            state = this.states[currentState];
          }
          mapping = this.matchMappings[currentState];
          lastIndex = index;
          re = this.regExps[currentState];
          re.lastIndex = index;
        }
        break;
      }
      if (value) {
        if (typeof type == "string") {
          if ((!rule || rule.merge !== false) && token.type === type) {
            token.value += value;
          } else {
            if (token.type)
              tokens.push(token);
            token = { type, value };
          }
        } else if (type) {
          if (token.type)
            tokens.push(token);
          token = { type: null, value: "" };
          for (var i = 0; i < type.length; i++)
            tokens.push(type[i]);
        }
      }
      if (lastIndex == line.length)
        break;
      lastIndex = index;
      if (tokens.length > MAX_TOKEN_COUNT) {
        while (lastIndex < line.length) {
          if (token.type)
            tokens.push(token);
          token = {
            value: line.substring(lastIndex, lastIndex += 2e3),
            type: "overflow"
          };
        }
        currentState = "start";
        stack = [];
        break;
      }
    }
    if (token.type)
      tokens.push(token);
    if (stack.length > 1) {
      if (stack[0] !== currentState)
        stack.unshift(currentState);
    }
    return {
      tokens,
      state: stack.length ? stack : currentState
    };
  };
}).call(Tokenizer.prototype);
var tokenFromAceToken = {
  empty: null,
  text: null,
  // Keyword
  keyword: "keyword",
  control: "keyword",
  operator: "operator",
  // Constants
  constant: "atom",
  numeric: "number",
  character: "atom",
  escape: "atom",
  // Variables
  variable: "variable",
  parameter: "variable-3",
  language: "variable-2",
  // Python's `self` uses that.
  // Comments
  comment: "comment",
  line: "comment",
  "double-slash": "comment",
  "double-dash": "comment",
  "number-sign": "comment",
  percentage: "comment",
  block: "comment",
  doc: "comment",
  // String
  string: "string",
  quoted: "string",
  single: "string",
  double: "string",
  triple: "string",
  unquoted: "string",
  interpolated: "string",
  regexp: "string-2",
  meta: "keyword",
  literal: "qualifier",
  support: "builtin",
  // Markup
  markup: "tag",
  underline: "link",
  link: "link",
  strong: "strong",
  heading: "header",
  em: "em",
  list: "variable-2",
  numbered: "variable-2",
  unnumbered: "variable-2",
  quote: "quote",
  raw: "variable-2",
  // Markdown's raw block uses that.
  // Invalid
  invalid: "error",
  illegal: "invalidchar",
  deprecated: "error"
};
var cmTokenFromAceTokens = function(tokens) {
  var token = null;
  for (var i = 0; i < tokens.length; i++) {
    if (tokenFromAceToken[tokens[i]] !== void 0) {
      token = tokenFromAceToken[tokens[i]];
    }
  }
  return token;
};
var consumeToken = function(stream, state) {
  var plannedToken = state.plannedTokens.shift();
  if (plannedToken === void 0) {
    return null;
  }
  stream.match(plannedToken.value);
  var tokens = plannedToken.type.split(".");
  return cmTokenFromAceTokens(tokens);
};
var matchToken = function(stream, state) {
  if (state.plannedTokens.length > 0) {
    return consumeToken(stream, state);
  }
  var currentState = state.current;
  var currentLine = stream.match(/.*$/, false)[0];
  var tokenized = tokenizer.getLineTokens(currentLine, currentState);
  state.plannedTokens = tokenized.tokens;
  state.current = tokenized.state;
  return consumeToken(stream, state);
};
var aceHighlightRules = new HighlightRules();
var tokenizer = new Tokenizer(aceHighlightRules.$rules);
var asciidoc = {
  startState: function() {
    return {
      current: "start",
      // List of {value, type}, with type being an Ace token string.
      plannedTokens: []
    };
  },
  blankLine: function(state) {
    matchToken("", state);
  },
  token: matchToken
};

// src/keyboardCallbacks.ts
var KeyInfo = class {
  constructor(keyName, isShift = false, isCtrl = false, isAlt = false) {
    this.keyName = keyName;
    if (this.keyName.length == 1)
      this.keyName = "Key" + this.keyName.toUpperCase();
    this.mask = this.modifiersToMask(isShift, isCtrl, isAlt);
  }
  modifiersToMask(isShift = false, isCtrl = false, isAlt = false) {
    let modifiers = 0;
    if (isShift)
      modifiers |= 1;
    if (isCtrl)
      modifiers |= 2;
    if (isAlt)
      modifiers |= 4;
    return modifiers;
  }
  static fromHotkey(hk) {
    let keyName = hk.key;
    let checkModifier = (modName) => hk.modifiers.includes(modName);
    return new KeyInfo(keyName, checkModifier("Shift"), checkModifier("Mod"), checkModifier("Alt"));
  }
  matchEventModifiers(event) {
    let mask = this.modifiersToMask(event.shiftKey, event.ctrlKey, event.altKey);
    if ((this.mask & mask) == this.mask)
      return true;
    return false;
  }
};
var KeyboardCallbacks = class {
  constructor() {
    this.keyMap = /* @__PURE__ */ new Map();
    this.callbacks = /* @__PURE__ */ new Map();
  }
  registerKey(ki, callback) {
    this.keyMap.set(ki.keyName, ki);
    this.callbacks.set(ki.keyName, callback);
  }
  registerObsidianHotkey(hk, defaultKey, callback) {
    let ki;
    if (hk) {
      ki = KeyInfo.fromHotkey(hk);
    } else {
      ki = defaultKey;
    }
    this.registerKey(ki, callback);
  }
  handleKeyboardEvent(event) {
    let ki = this.keyMap.get(event.code);
    if (!ki)
      return;
    if (ki.matchEventModifiers(event)) {
      const cb = this.callbacks.get(ki.keyName);
      if (cb)
        cb();
    }
  }
};

// src/util.ts
var import_obsidian2 = require("obsidian");
var adocSpecificTypes = ["important", "caution"];
var admotionIcons = /* @__PURE__ */ new Map([
  ["danger", "zap"],
  ["note", "pencil"],
  ["tip", "flame"],
  ["warning", "alert-triangle"]
]);
function patchAdmonitionBlock(item) {
  let abType = item.className.replace("admonitionblock ", "");
  if (adocSpecificTypes.includes(abType)) {
    abType = "danger";
  }
  const iconElement = item.getElementsByClassName("icon");
  item.setAttribute("data-callout", abType);
  item.className = "callout";
  let calloutTitle = createEl("div", { cls: "callout-title" });
  let iconName = admotionIcons.get(abType);
  if (iconName == void 0)
    iconName = "pencil";
  const calloutIcon = calloutTitle.createEl("div", { cls: "callout-icon" });
  (0, import_obsidian2.setIcon)(calloutIcon, iconName);
  if (iconElement.length > 0 && iconElement[0]) {
    calloutTitle.appendChild(iconElement[0]);
    item.insertBefore(calloutTitle, item.firstChild);
  }
}

// src/asciidocView.ts
var ASCIIDOC_EDITOR_VIEW = "asciidoc-editor-view";
CodeMirror.defineMode("asciidoc", asciidoc);
CodeMirror.defineMIME("text/asciidoc", "asciidoc");
(0, import_obsidian4.loadPrism)().then((_) => {
});
(0, import_obsidian4.loadMermaid)().then((_) => {
});
async function mermaidDraw(htmlItem) {
  if (!htmlItem.lastChild)
    return;
  let firstChild = htmlItem.children[0];
  if (!(firstChild instanceof HTMLElement)) {
    return;
  }
  const txt = firstChild.innerText;
  htmlItem.removeChild(htmlItem.lastChild);
  let randId = "Z" + Math.random().toString(36).substring(2, 16);
  let tmp = await mermaid.render(randId, txt);
  const parser = new DOMParser();
  let diagramDoc = parser.parseFromString(tmp.svg, "application/xml");
  let svg;
  if (diagramDoc) {
    for (let child of diagramDoc.childNodes) {
      if (child.tagName != "svg")
        continue;
      svg = child;
      break;
    }
  }
  htmlItem.appendChild(svg);
}
var tokenInfoPropId = import_stream_parser.tokenClassNodeProp.id;
function getHighlighters(state) {
  return [import_language3.defaultHighlightStyle];
}
var TreeHighlighterEx = class {
  constructor(view) {
    this.tree = (0, import_language4.syntaxTree)(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
    this.tokenCache = /* @__PURE__ */ Object.create(null);
  }
  update(update) {
    let tree = (0, import_language4.syntaxTree)(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return import_view3.Decoration.none;
    let builder = new import_state3.RangeSetBuilder();
    for (let rangeIter of view.visibleRanges) {
      let treeHandler = function(n) {
        try {
          let nm = n.type.props[tokenInfoPropId];
          if (!nm)
            return;
          let cachedEntry;
          if (!(cachedEntry = _this.tokenCache[nm])) {
            let m = {
              class: nm.split(" ").map((item) => "cm-" + item).join(" "),
              attributes: {
                spellcheck: "false"
              }
            };
            cachedEntry = _this.tokenCache[nm] = import_view3.Decoration.mark(m);
          }
          builder.add(n.from, n.to, cachedEntry);
        } catch (err) {
          console.log(err);
        }
      };
      let _this = this;
      this.tree.iterate({
        from: rangeIter.from,
        to: rangeIter.to,
        enter: treeHandler
      });
    }
    return builder.finish();
  }
};
var treeHighlighterEx = import_state3.Prec.high(import_view3.ViewPlugin.fromClass(TreeHighlighterEx, {
  decorations: (v) => v.decorations
}));
function isValidUrl(str) {
  let url;
  try {
    url = new URL(str);
  } catch (_) {
    return false;
  }
  return true;
}
function deleteChildNodes(el) {
  while (el.hasChildNodes())
    el.removeChild(el.children[0]);
}
var isEditMode = true;
function mermaidBlockProcessor() {
  this.block(function() {
    const self = this;
    self.named("mermaid");
    self.onContext(["listing"]);
    self.process(function(parent, reader) {
      const diagramText = reader.read();
      return this.createPassBlock(parent, `<pre class='highlight'><code class='language-mermaid'>${diagramText}</code></pre>`);
    });
  });
}
var AsciidocView = class extends import_obsidian3.TextFileView {
  constructor(plugin, leaf) {
    super(leaf);
    this.getViewData = () => {
      return this.editorView.state.doc.toString();
    };
    this.setViewData = (data, clear) => {
      this.pageData = data;
      this.editorView.dispatch({
        changes: {
          from: 0,
          to: this.editorView.state.doc.length,
          insert: data
        }
      });
      if (clear) {
        if (!isEditMode) {
          this.renderViewerMode(this.div);
        }
      }
    };
    this.clear = () => {
      this.editorView.dispatch({
        changes: {
          from: 0,
          to: this.editorView.state.doc.length,
          insert: ""
        }
      });
    };
    this.keyHandle = (event) => {
      if (this.app.workspace.activeLeaf != this.leaf)
        return;
      this.keyMap.handleKeyboardEvent(event);
    };
    this.plugin = plugin;
    this.div = this.contentEl.createEl("div", { cls: "adoc-view" });
    this.isEditMode = isEditMode;
    this.adoc = (0, import_asciidoctor.default)();
    this.adoc.Extensions.register(mermaidBlockProcessor);
    this.keyMap = new KeyboardCallbacks();
    let editorState = import_state2.EditorState.create({
      extensions: [
        basicExtensions,
        (0, import_view2.lineNumbers)(),
        treeHighlighterEx,
        (0, import_view2.highlightActiveLine)(),
        import_language3.StreamLanguage.define(asciidoc),
        // TODO: Figure out how to nicely set language modes.
        import_view2.EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            this.save(false);
          }
        })
      ]
    });
    this.editorView = new import_view2.EditorView({
      state: editorState
      //parent: this.contentEl,
    });
    this.actionElem = this.addAction("book-open", "preview/editor mode", (_) => {
      this.changeViewMode();
    });
    this.setModeIcon();
  }
  setModeIcon() {
    if (this.isEditMode) {
      (0, import_obsidian4.setIcon)(this.actionElem, "book-open");
      this.actionElem.setAttribute("aria-label", "Current view: editing\nclick to read");
    } else {
      (0, import_obsidian4.setIcon)(this.actionElem, "edit-3");
      this.actionElem.setAttribute("aria-label", "Current view: reading\nclick to edit");
    }
  }
  changeViewMode() {
    isEditMode = this.isEditMode = !this.isEditMode;
    this.setModeIcon();
    this.renderCurrentMode();
  }
  renderCurrentMode() {
    if (!this.div) {
      console.log("No target div, SHOULD NOT REACH");
      return;
    }
    if (isEditMode) {
      this.div.replaceChildren(this.editorView.dom);
    } else {
      this.renderViewerMode(this.div);
    }
  }
  getViewerOptions() {
    let attributes = {
      "showtitle": true,
      "outfilesuffix": ".adoc"
    };
    return {
      standalone: false,
      safe: "safe",
      attributes
    };
  }
  renderViewerMode(parentEl) {
    const contents = this.editorView.state.doc.toString();
    const htmlStr = this.adoc.convert(contents, this.getViewerOptions());
    const parser = new window.DOMParser();
    let root = document.createElement("div");
    const dataEl = root.createEl("div", { cls: "markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-properties adoc-preview" });
    const parsedDoc = parser.parseFromString(htmlStr, "text/html");
    if (parsedDoc.body && parsedDoc.body.childNodes.length > 0) {
      let chldArr = parsedDoc.body.childNodes;
      for (let i = 0; i < chldArr.length; i++) {
        dataEl.appendChild(chldArr[i]);
      }
    }
    try {
      let collection = dataEl.getElementsByTagName("a");
      for (let item of collection) {
        let txt = item.getAttribute("href").trim();
        item.className = "internal-link";
        const menu = new import_obsidian3.Menu();
        if (!txt.startsWith("app://") && isValidUrl(txt)) {
          item.className = "external-link";
        } else {
          item.onclick = (evt) => {
            this.app.workspace.openLinkText(txt, "", false);
            evt.preventDefault();
          };
          menu.addItem(
            (item2) => item2.setTitle("Open").onClick(() => this.app.workspace.openLinkText(txt, "", false))
          );
        }
        menu.addItem((item2) => item2.setTitle("Copy URL").setIcon("documents").onClick(() => {
          new import_obsidian3.Notice("Copied");
          navigator.clipboard.writeText(txt);
        }));
        item.addEventListener(
          "contextmenu",
          (ev) => menu.showAtMouseEvent(ev),
          false
        );
        item.setAttribute("rel", "noopener");
        item.setAttribute("target", "_blank");
      }
      collection = dataEl.getElementsByTagName("pre");
      for (let item of collection) {
        if (item.className == "highlight" && item.children.length == 1) {
          let className = item.children[0].className;
          if (className == "language-diagram") {
            let html = Buffer.from(item.children[0].innerText, "base64").toString("utf8");
            const parser2 = new DOMParser();
            let diagramDoc = parser2.parseFromString(html, "application/xml");
            let svg;
            if (diagramDoc) {
              for (let child of diagramDoc.childNodes) {
                if (child.tagName != "svg")
                  continue;
                svg = child;
                break;
              }
            }
            if (svg) {
              for (let child of svg.children) {
                if (child.tagName && child.tagName.toLowerCase() == "script")
                  svg.removeChild(child);
              }
              item.replaceChild(svg, item.lastChild);
            }
          } else if (className.startsWith("language-mermaid")) {
            mermaidDraw(item);
          } else if (className.startsWith("language-")) {
            item.className = className;
            Prism.highlightElement(item);
          }
        }
      }
      collection = dataEl.getElementsByTagName("img");
      for (let item of collection) {
        let path = item.src;
        let commonPrefix = "app://obsidian.md/";
        if (path.startsWith(commonPrefix)) {
          path = path.substr(commonPrefix.length);
        }
        path = unescape(path);
        let file = this.app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian3.TFile) {
          item.src = this.app.vault.getResourcePath(file);
        }
      }
      collection = dataEl.getElementsByClassName("admonitionblock");
      while (collection.length > 0) {
        patchAdmonitionBlock(collection[0]);
      }
    } catch (err) {
      console.log(err);
    }
    this.sctx = new SearchCtx(dataEl, root);
    parentEl.replaceChildren(root);
  }
  async onOpen() {
    await super.onOpen();
  }
  async onLoadFile(file) {
    this.renderCurrentMode();
    this.addKeyEvents();
    await super.onLoadFile(file);
  }
  async onUnloadFile(file) {
    window.removeEventListener("keydown", this.keyHandle, true);
    await super.onUnloadFile(file);
    deleteChildNodes(this.div);
  }
  async onClose() {
    await super.onClose();
  }
  onResize() {
  }
  getContext(file) {
    var _a, _b;
    return (_b = file == null ? void 0 : file.path) != null ? _b : (_a = this.file) == null ? void 0 : _a.path;
  }
  getViewType() {
    return ASCIIDOC_EDITOR_VIEW;
  }
  addKeyEvents() {
    let getHotkey = (nm) => {
      if (this.app.hotkeyManager) {
        let tmp = this.app.hotkeyManager.customKeys[nm];
        if (tmp && tmp.length)
          return tmp[0];
      }
      let command = this.app.commands.findCommand(nm);
      if (command.hotkeys && command.hotkeys.length > 0) {
        return command.hotkeys[0];
      }
      return void 0;
    };
    this.keyMap.registerObsidianHotkey(
      getHotkey("markdown:toggle-preview"),
      new KeyInfo("E", false, true, false),
      () => {
        this.changeViewMode();
      }
    );
    this.keyMap.registerObsidianHotkey(
      getHotkey("editor:open-search"),
      new KeyInfo("F", false, true, false),
      () => {
        this.commandFind();
      }
    );
    this.keyMap.registerKey(new KeyInfo("Escape"), () => {
      this.commandEsc();
    });
    window.addEventListener("keydown", this.keyHandle, true);
  }
  commandFind() {
    if (isEditMode) {
      (0, import_search2.openSearchPanel)(this.editorView);
    } else {
      this.sctx.focus();
    }
  }
  commandEsc() {
    if (isEditMode)
      return;
    this.sctx.resetSearch();
  }
};

// src/main.ts
var AsciidocPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    this.registerExtensions(["adoc", "asciidoc"], ASCIIDOC_EDITOR_VIEW);
    this.registerView(ASCIIDOC_EDITOR_VIEW, (leaf) => new AsciidocView(this, leaf));
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("New asciidoc file").setIcon("scroll-text").onClick(async () => {
            new AdocNewFileModal(this, file).open();
          });
        });
      })
    );
    this.addRibbonIcon("scroll-text", "New asciidoc file", () => {
      new AdocNewFileModal(this).open();
    });
    this.addCommand({
      id: "create-adoc",
      name: "create new Asciidoc file",
      callback: () => {
        new AdocNewFileModal(this).open();
      }
    });
  }
  updateEditorExtensions() {
    this.app.workspace.updateOptions();
  }
};
/*! Bundled license information:

@asciidoctor/core/dist/browser/asciidoctor.js:
  (**
   * @license Asciidoctor.js 3.0.4 | MIT | https://github.com/asciidoctor/asciidoctor.js
   *)

mark.js/dist/mark.js:
  (*!***************************************************
  * mark.js v8.11.1
  * https://markjs.io/
  * Copyright (c) 2014–2018, Julian Kühnel
  * Released under the MIT license https://git.io/vwTVl
  *****************************************************)
*/

/* nosourcemap */